,text
0,"#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;//#include &lt;string.h&gt;// strlen() : 문자열의 길이를 구하는 함수//배열을 받으려면 포인터를 사용해야한다.//배열을 매개변수로 받는 함수는 배열의 크기를 같이 받는다.//문자열의 끝은 널 문자(Null CHaracter =&gt; 따라서 배열의 크기를 알지 않아도 끝을 알 수 있다.)//매개변수 1개 =&gt; 문자열을 저장하기 위한 객체 =&gt; pointer to charint strlen(const char* str){    /* arr : pointer to int     어떻게 문자열의 길이를 구할 수 있을까?    1. str은 문자열이다.    2. 문자열의 끝은 널 문자다.    */    }    ///strchr() : 문자열에서 특정 문자의 위치를 찾는 것    //    1. 문자가 있는 경우=&gt; 그 문자의 위치    //    2. 문자가 없는 경우=&gt; NULL/    //    char* pos = strchr(&quot;Hello, 'l&quot;);//char* str = &quot;asdasdasdasd&quot;; =&gt; a =131313113213113 s=2465465131313 d= 341363132132//char ch = 'd';char* strchr(const char* str , const char ch) { while (*str != '\0') {    if (*str == ch)    {        return str;    }    ++str;}return NULL;}int main(void){    int arr10;    sizeof arr;char asd123 = &quot;asdasdasdasd&quot;;printf(&quot;%p&quot;, strchr(asd, 'd'));printf(&quot;%c&quot;, toupper('A'));return 0;}int toupper(char num) {    if ('a'&lt;= num &amp;&amp; num &gt;= 'z') {        num = num - 32;    }    else {        num;    }    return num;};//void Swap(int* a, int* b)//{// // a : 0x1234 -&gt; 0xabcd   // b : 0x5678 -&gt; 0x5780//    int temp = *a;//    *a = *b;//    *b = temp;//}//int main()//{//    int a = 10, b = 20;//    Swap(&amp;a, &amp;b);//    printf(&quot;%d %d&quot;, a, b);//    return 0;////    int islower(char ch)//    {//        if ('a' &lt;= ch &amp;&amp; ch &lt;= 'Z')//        {//            return 1;//        }//        else//        {//            return 0;//        }//    }////    isupper()//    int isupper(char ch)//    {//        if ('A' &lt;= ch &amp;&amp; ch &lt;= 'z')//        {//        return 1;//        }//        else//        {//            return 0;//        }//    }////    char tolower(char ch)//    {//        if ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z')//        {//            return ch + 32;//        }//        else//        {//            return ch;//        }//    }////    ////    char toupper(char ch123)//    {////        if ('a' &lt;= ch123 &amp;&amp; ch123 &lt;= 'z')//        {//            return ch - 32;//        }//        else//        {//            return ch;//        }//    }// tolower(대문자에서 소문자로) / toupper(소문자에서 대문자로)//islower() : 한개의 문자를 받아 소문자인지 판별한다.// //char word128 = &quot;Hello, String!&quot;;//    //Hello,String =&gt; Drnken Jaesung//strcpy(word, &quot;Drunken Jaesung&quot;);//char word3;//strcpy(word2, word3);//puts(word)/*long long sum(int* a, int n){    long long result = 0LL;    for (int i = 0; i &lt; n; ++i)    {        result += ai;    }    return result;}*///swap() : 2개의 정수를 받아 서로 데이터를 교환/// &lt;summary&gt;    /*배열에 모든 원소를 더한다.    &lt;/summary&gt;    &lt;param name&gt;*//*포인터는 다른 타입의 객체를 참조할 수 있는 타입이다.Pointer : 데이터를 메모리 주소값으로 해석Type* Identifier;int num = 10; int* P = &amp;num;int* P2 = NULL;p를 통해서 null에 접근pointer dereference *p = 20; 왜? 포인터를 사용해야 하는가? 다른 범위에 있는 메모리에 접근하기 위해int* p =&gt; pointer to int int** p3; //pointer to pointer to intint *** p4 = &amp;p3; // pointer to pointer to pointer to int메모리에 접근하는 방법은 2가지가 있다.1. 직접 참조(Direct Regerence/ Direct Access) : 메모리 주소에 직접 접근하는 것간접 참조(indirect Reference/ Indirect Access) : 메모리 주소를 포인터를 통해서 접근하는 것Scope : 프로그램이 식별자를 찾을 수 있는 영역Block scope =&gt; 지역변수 local variableFile Scope : 파일 내에서 접근  =&gt; 전역변수 Global VariablePointer Type 크기는 얼마인가?Pointer Type :데이터를 메모리 주소값으로 해석한다.x84 :4bytex64 : 8byte//+ - : 메모리 주소를 가리키고 있는 타입의 크기만큼 옮긴다.//++ / --// Address Operation : 주소 연산char *pch  // pointer to characterpch +1; // 1 바이트만큼 뒤로pch -1; // 1 바이트만큼 앞으로ab =&gt; *(a+b);*p++;*++p;//주의 : 역참조 연산자와 증감 연산자를 결합할 때 연산 순서를 유의해야 한다.void* p; // pointer to void (int, double.\, function, ~~)//Dereference : 매개변수(parameter)함수에서 사용되는 변수. 함수 외부에서 입력값을 받기 위해 사용.함수를 사용한다는 것은 코드를 재사용하기 위함이다.함수를 호출한다. 호출한 사람을 호출자(caller), 호출된 함수를 피호출자(calle)// 호출자에게 내가 계산한 결과를 '반환'해줄 수 있다.반환은 return문을 사용함. 반환 값은 반환 타입과 일치해야 함.반환해줄 것이 없다면 void 타입을 사용.// () : Call Operater//3개의 입력을 받아 모든 입력값을 더해서 반환하는 함수 sum3()을 만들어라.int sum3(int x,int y,int z) { return x+y+z; } long long sum(int* a, int n)int a = sum(); //인자 (Argument) : 매개변수의 초깃값*///입력 : 단어를 입력받는다.//처리 : 알파벳 위치를 찾는다.//// 입력 : 반복 횟수와 문자열을 입력받는다./*그룹 단어 인지 */// 입력 ://처리 : 점수 계산// 1. 0일 때 점수가 늘어감// 2. 그 문제까지 연속된 0의 개수만큼 점수가 늘어남.// 1. 현재 문제를 맞췄는가?// 1-1, 맞았다면 연속적으로 맞춘만큼 점수를 부여한다.//2. 1번으로 돌아가 문자열의 끝을 만날 때까지 반복한다.//1. 현재 문제를 맞췄는가?//Emty String//pointer Type : 메모리 주소값으로 해석하는 타입// 배열은 포인터 타입으로 암시적 변환 가능-&gt; 포인터로 퇴행(decay) 했다.//Buffer Overrun"
1,"///////////////// 1157 : 단어 공부 (전지윤)#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main(){   char text1000003 = &quot;&quot;; // 단어를 입력 받기 위한 객체   scanf(&quot;%1000000s&quot;, text);   // 처리 : 가장 많이 사용된 알파벳이 무엇인지 알아내야 함.   // 각 알파벳이 몇 개나 사용됐는지 세야 함. =&gt; 객체가 필요하다.   int counts26 = { 0 };   // Index를 알파벳과 대응 =&gt; 어떻게 알파벳과 index를 대응시킬지 =&gt; 모든 문자를 대문자로 바꿔준다.   // a, A =&gt; 0   // b, B =&gt; 1   // c, C =&gt; 2   // d, D =&gt; 3   int maxCount = 0; // 1. 최댓값은 무엇인지?   char maxAlphabet = '\0'; // 2. 그에 대응하는 알파벳은 무엇인지?   const int SPEED_OF_LIGHT = 299792458;   for (int i = 0; texti != '\0'; i++)   // null문자 전까지만 돌아가도록   {      /const int DIFFERNECE_BETWEEN_UPPER_AND_LOWER = 32;      if (texti &gt;= 'a')      {         texti -= DIFFERNECE_BETWEEN_UPPER_AND_LOWER;      }/      texti = toupper(texti);  int alphabetIndex = texti - 'A';  countsalphabetIndex += 1;  if (countsalphabetIndex == maxCount)   //최대 알파벳 개수 판단  {     maxAlphabet = '?';  }  else if (countsalphabetIndex &gt; maxCount)  {     maxCount = countsalphabetIndex;     maxAlphabet = texti;  }   }   // 출력 :   printf(&quot;%c&quot;, maxAlphabet);}///////////////////// 다이얼 : 안중재#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;int main(){   // 입력 : 알파벳 대문자로 이뤄진 단어   char words16 = &quot;&quot;;   scanf(&quot;%s&quot;, &amp;words);   // 처리   // 1. 시간을 구하려면 숫자를 알아야 함.   // 2. 숫자를 알려면 알파벳을 대응하는 숫자로 변환.   // WA -&gt; 92 -&gt; 10 + 3 -&gt; 13   // ABC DEF GHI JKL MNO PQRS TUV WXYZ   //  2   3   4   5   6   7    8   9 (0,1은 왜 안눌러요..)   // 1. 알파벳을 대응하는 숫자로 바꾼다.    // 알파벳 변수를 만들고 변수의 순서가 알파벳 순서라 가정, 대응하는 숫자를 입력한다.   // alphabet0 == A   int alphabetToDigit26 = {      2,2,2, 3,3,3, 4,4,4, 5,5,5, 6,6,6,      7,7,7,7, 8,8,8, 9,9,9,9   };   // 2. 숫자와 대응하는 시간을 더한다.   int time = 0;   for (int i = 0; wordsi != '\0'; ++i)   {      int digit = alphabetToDigitwordsi - 'A';      time += (digit + 1);   }   // 출력 : 그 다이얼을 걸기 위해 필요한 최소 시간   printf(&quot;%d&quot;, time);}@@@@@@@@@@@1@@@@@@@@@@@@#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;string.h&gt;void Swap(int* a, int* b){   // a : 0x1234 -&gt; 0xabcd   // b : 0x5678 -&gt; 0x5780   int temp = *a;   *a = *b;   *b = temp;}int main(void){   char input = &quot;A bird came down the walk&quot;;   // Pointer : 데이터를 메모리 주소값으로 해석   // Type* Identifier;   // int* p; =&gt; pointer to int   int a = 10; // a : 0x1234   int b = 20; // b : 0x5678   // a &lt;-&gt; b   Swap(&amp;a, &amp;b);   printf(&quot;%d %d&quot;, a, b);   int num = 10;   int* p2 = NULL;   int* p = &amp;num   int* * p3 = &amp;p // pointer to pointer to int   **p3 = 30;   int* p4 = &amp;p3 // pointer to pointer to pointer to int   *p4 = 50;   *p = 20;   // 왜? 포인터를 사용해야 하는가   // 메모리에 접근하는 방법은 2가지가 있다.   // 직접 참조(Direct Reference / Direct Access) : 메모리 주소에 직접 접근하는 것   // num = 20;   // 간접 참조(Indirect Reference / Indirect Access) : 메모리 주소를 포인터를 통해서 접근하는 것   // *p = 20;   a;   // Scope : 프로그램이 식별자를 찾을 수 있는 영역   // Block Scope =&gt; Local Variable   // File Scope =&gt; Global Variable   puts(&quot;&quot;);}@@@@@@@@@@2@@@@@@@@@@  // Pointer Type 크기는 얼마인가?   // Pointer Type : 데이터를 메모리 주소값으로 해석한다.   // x86 : 4byte   // x64 : 8byte   // + - : 메모리 주소를 가리키고 있는 타입의 크기만큼 옮긴다.   // ++ / --   // Address Operation : 주소 연산   int arr2 = { 10, 20 };   p = arr; // arr의 첫 번째 원소의 주소를 가리키게 된다.   p = p + 1; // &amp;arr1   p = p - 1; // &amp;arr0   ++p;   --p;   p++;   p--;   char* pch; // pointer to character   pch + 1; // 1 바이트만큼 뒤로   pch - 1; // 1 바이트만큼 앞으로   // ab =&gt; *(a + b);   p = arr;   // 주의 : 역참조 연산자와 증감 연산자를 결합할 때 연산 순서를 유의해야 한다.   int num2 = p++;   num2 = *++p;   num2 = ++(p);   printf(&quot;\n%d&quot;, sizeof p);  @@@@@@@@@3@@@@@@@@@ // 123    //        pint n = *p++; // n = 1// *p : 역참조를 한 후// p++ : 포인터의 주소값을 증가시킨다.int n = *++p; // n = 3// ++p : 포인터의 주소값을 증가시킨 후// *p : 역참조한다.int n = ++(*p); // n = 4// *p : 역참조한 후  3// ++ : 역참조한 값을 증가시킨다.@@@@@@@@@@4@@@@@@@@@@#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;string.h&gt;// return-type identifier(parameter-list) =&gt; Header// complicated statement =&gt; Body// 매개변수(Parameter)// 함수에서 사용되는 변수. 함수 외부에서 입력값을 받기 위해 사용.// 함수를 사용한다는 것은 코드를 재사용하기 위함이다.// 함수를 호출한다. 호출한 사람을 호출자(Caller), 호출된 함수를 피호출자(Callee)// 호출자에게 내가 계산한 결과를 '반환' 해줄 수 있다.// 반환은 return문을 사용함. 반환 값은 반환 타입과 일치해야 함.// 반환해줄 것이 없다면 void 타입을 사용.int sum(int x, int y){    return x + y;}void foo(){    if (1)    {        // 반환 타입이 void인 경우에도 return문을 사용할 수 있으며        // 함수를 중간에 끝낼 때 사용한다.        return;    }}// 3개의 입력을 받아 모든 입력값을 더해서 반환하는 함수 sum3()을 만들어라.int sum3(int x, int y, int z){    return x + y + z;}// Swap() : 2개의 정수를 받아 서로 데이터를 교환void Swap(int* a, int* b){    int temp = *a;    *a = *b;    *b = temp;}// islower() : 한 개의 문자를 받아 소문자인지 판별한다.int islower(char ch){    if ('a' &lt;= ch &amp;&amp; ch &lt;= 'z')    {        return 1;    }    else    {        return 0;    }}// isupper()int isupper(char ch){    if ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z')    {        return 1;    }    else    {        return 0;    }}// tolower() / toupper()char tolower(char ch){    if ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z')    {        return ch + 32;    }    else    {        return ch;    }}char toupper(char ch){    if ('a' &lt;= ch &amp;&amp; ch &lt;= 'z')    {        return ch - 32;    }    else    {        return ch;    }}int main(void){    printf(&quot;%c\n&quot;, tolower('G'));    printf(&quot;%c\n&quot;, tolower('!'));    printf(&quot;%c\n&quot;, toupper('a'));    printf(&quot;%c\n&quot;, toupper('?'));return 0;}@@@@@@5@@@@@@// strchr() : 문자열에서 특정 문자의 위치를 찾는 것// 입력 : 문자열(const char), 내가 찾을 문자(const char)// 처리 : 입력된 문자열에서 그 문자가 나온 위치(메모리 주소)를 찾는다.// 출력 : 문자의 위치 =&gt; 그 문자가 있는 메모리 주소값(char)// 1. 문자가 있는 경우 =&gt; 그 문자의 위치// 2. 문자가 없는 경우 =&gt; NULL// char* pos = strchr(&quot;Hello, 'l');// &quot;Hello&quot;//    ↑// 1. 문제 정의 =&gt; 입력, 처리, 출력. 문제를 충분히 해결할 수 있을 정도로 계속해서 작은 단위로 쪼개서 생각해야 함.// 2. 작은 문제로 쪼갰다면 그 문제를 해결할 절차를 기술.// 3. 문제를 해결하기 위해 어떤 데이터가 필요한가? =&gt; 즉, 어떤 데이터를 저장해야 하는가?char* strchr(const char* str, const char ch){   while (str != '\0')   {      if (*str == ch)      {         return (char)str;      }  ++str;   }   return NULL;}strcpy()strcat()strlen()strcmp()strchr()strrchr()strstr()"
2,"@@@@ OX문제 문자열 @@@@#include &lt;stdio.h&gt;int main(void){   int T;   scanf(&quot;%d&quot;, &amp;T);   while (T--)   {      // 입력 : OX 퀴즈의 결과를 입력받는다.      char oxResult80 = &quot;&quot;;      scanf(&quot;%79s&quot;, oxResult);  // 처리 : 점수 계산  // 1. O일 때 점수가 늘어남.  // 2. 그 문제까지 연속된 O의 개수만큼 점수가 늘어남.  // 2. 1번으로 돌아가 문자열의 끝을 만날 때까지 반복한다.  int score = 0;  int consecutiveCorrectAnswerCount = 0;  for (int i = 0; oxResulti != '\0'; ++i)  {     // 1. 현재 문제를 맞췄는가?     if (oxResulti == 'O')     {        // 1-1. 맞았다면 연속적으로 맞춘만큼 점수를 부여한다.        ++consecutiveCorrectAnswerCount;        score += consecutiveCorrectAnswerCount;     }     else     {        consecutiveCorrectAnswerCount = 0;     }  }  // 출력 : 점수 출력  printf(&quot;%d\n&quot;, score);   }   return 0;}@@@@EOF문제 @@@@#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;char word1000001;int main(void){   int count = 0;   while (1)   {      if (EOF == scanf(&quot;%s&quot;, word))      {         break;      }  ++count;   }   printf(&quot;%d&quot;, count);   return 0;}@@@@ 알파벳 위치 @@@@#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;int main(){   // 입력 : 단어를 입력받는다.   char S101 = &quot;&quot;;   scanf(&quot;%s&quot;, S);   // 처리 : 알파벳 위치를 찾는다.   int count26;   for (int i = 0; i &lt; 26; ++i)   {      counti = -1;   }   for (int i = 0; Si != '\0'; ++i)   {      int index = Si - 'a';  if (countindex == -1)  {     countindex = i;  }   }   // 출력 : 알파벳 위치를 출력한다.   for (int i = 0; i &lt; 26; i++)   {      printf(&quot;%d &quot;, counti);   }   return 0;}@@@@ 그룹단어 @@@@#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;int main(void){   int N;   scanf(&quot;%d&quot;, &amp;N);   int count = 0; // 그룹 단어 개수를 저장할 객체   for (int i = 0; i &lt; N; ++i)   {      // 단어 입력 받음      char word101 = &quot;&quot;;      scanf(&quot;%100s&quot;, word);  // 그룹단어인지 확인  // 그룹단어 : 같은 문자가 연속적으로 나오는 단어  int isGroupWord = 1; // 그룹단어인지 확인하기 위한 객체  int isAlreadyExist26 = { 0 }; // 이전에 해당 문자가 나왔는지 저장하기 위한 객체  //   char prevCharacter = '\0'; // 문자가 연속적으로 잘 나오고 있는지 저장하기 위한 객체  for (int i = 0; wordi != '\0'; ++i)  {     if (prevCharacter != wordi)     {        int alphabet = wordi - 'a';        if (isAlreadyExistalphabet)        {           isGroupWord = 0;           break;        }        isAlreadyExistalphabet = 1;     }     prevCharacter = wordi;  }  // 그룹 단어라면 센다.  if (isGroupWord)  {     ++count;  }   }   printf(&quot;%d&quot;, count);   return 0;}"
3,"//함수 : 일련의 코드에 이름을 붙인 것    // API    Application Programming         interface =&gt; 함수 하나를 일컫는 단어.    Standard 플랫폼에 독립적이다.    Library : 유용한 API의 모음 alt + 화살표ctrl + d  복붙alt + shift + 화살표 &gt; 도배 최적화ctrl + rr 이름바꾸기@입력// Case#1 : 10, 20 ,30sanf(&quot;Case#%d : %d %d %d , &amp;caseNum &quot;)출력//연산//할당++a; // 1이 증가된 a의 데이터a++; // 증가가 되지 않은 이전의 a 데이터int a = 0x24;//0010 0100a * 2;a &lt;&lt; 1; = &gt; 빠른 곱셈// 0100 1000//증감분기문if / swich반복문for / while / do-whilefor 반복횟수가 정해져 있을 때while 반복 횟수가 정해져 있지 않을 때do-while 조건식 평가가 나중에 일어나야 할 때배열같은 성질의 여러 데이터를 한번에 다루기 위한 것.//입력부..입력 : 두개의 정수를 입력받는다.int A, B;sanf(%d %d , &amp;A , &amp;B);//처리부int result = A+ B//출력부printf(&quot;%d&quot;, result);오븐시계//입력시각 (시와 분)을 입력 받는다.요리하는데 필요한 시간도 입력 받는다.int A, B, C;scanf(&quot;%d %d %d&quot;, &amp;A, &amp;B, &amp;C);//처리 //오븐구이가 끝나는 시각을 계산한다.//현재 시각 : 시와 분요리하는데 얼마나 필요한지(분단위)1시간 = 60분단위를 분으로 통일한다.int totalMinute =A *60 + B;요리 시간을 더해준다.시와 분으로 분할한다.//입력N과 X를 입력받는다.int N, X;scanf (&quot;%d %d&quot;)함수 : 일련의 과정에 이름을 붙인 것왜 이름을 붙였을까?재사용하려고/두 수 를 입력 받아 그 결과값을 출력하는 함수를 만들기로 했다.int Add(int a, int b){    int result = a + b;    return result; }int re = Add(1, 2);int re2 = Add(2, 3);int re3 = Add(4, 5);int main() Caller call to Callee//Caller//CalleeAdd()// Argumentparameter can be initialized by an argumentprocedural Programming // 맨 뒤에 널문자가 포함된다는 사실을 잊지 말기char str = &quot;Hello World&quot;;char if(strcmp(&quot;Apple, &quot;Hello&quot;) &lt; 0){put main const char str try not do stchr strrchr strstr 문자열 복습을 철저하게 하면 된다"
4,"백준 반복문 마지막 문제 &lt;더하기 사이클&gt;int N;scanf(&quot;%d&quot;, &amp;N)int cycle = 0;int result = N;do{int firstDigit = result % 10;int secondDigit = result / 10;int newNumber = secoundDight + firstDigit;}result = firstDigit * 10 + newNumber % 10;++cycle;} while (result != N);printf(&quot;%d&quot;, cycle);}수가 10보다 작은가?1-1. 작다면, 수에 10을 곱한다.1-2 크다면 각 자리수를 구한다.1-2-1. 각 자리수를 더한다.1-2-2. 일의 자리수 * 10 + 새로운 수의 일의 자리//처음과 일치할 때까지이해안되고 실행도 안해봄 1차원 배열 3단계문제 &lt;숫자의 개수&gt; arr  // 10 * 10 int arr23 ={ 00        01        02 {1,        2,            3}, 10  11        12 {4,    5,            6    } } 각 자리수에 위치한 숫자가 몇 번 등장했는지 확인각 자리수 (digit)은 result % 10을 해서 알 수 있다.countForDigitdigit += 1;result /= 10; result = 0 모든 자리수를 확인할 때까지 result == 0"
5,"컴퓨터는 어떤 말을 사용할까?언어는 정보를 소통하기 위해 만들어졌다. 프로그래머는 컴퓨터에게 명령을 내리는 사람이다. 사람이 컴퓨터의 말을 배워서 컴퓨터에게 명령을 내린다.언어란 무엇인가모든 언어의 뜻은 기호들의 집합으로 인코딩된다. 언어가 제대로 동작을 하려면 의사소통하는 당사자들이 모두 같은 문맥을 공유해서 같은 기호에 같은 뜻을 부여해야 된다.문자 언어문자언어는 기호를 나열한 것이다. 기호를 정해진 순서대로 나열하여 단어를 만들 수 있다.비트자연어에서는 문자라고 부르는 것을 컴퓨터에서는 비트라고 부른다. 비트는 2진법의 바이너리와 숫자의 디지트가 합쳐진 말이다. 비트는 2진법을 사용한다 모스부호의 점과 선처럼 두가지 기호중 하나만 담을 수 있다.논리 연산비트 사용법 중 하나는 예/아니오 질문에 대답하는 것이다. '예'는 참 으로, '아니오'는 거짓으로 부른다. 다른 비트들이 표현하는 내용으로 부터 새로운 비트를 만들어내는 동작을 논리 연산이라 한다.불리언 대수조지 불이 만들어낸 불리언 대수도 비트의 연산 규칙 집합이다. 불리언 연산자는 NOT, AND, OR, XOR 이 있다.드모르간의 법칙드모르간은 불리언 대수에 적용할 수있는 법칙을 추가로 발견했다. a AND b 연산은 NOT(NOT a or NOT b)와 같다는 법칙이다.정수를 비트로 표현하는 방법양의 정수 표현10진수 체계에서는 10가지 기호인 숫자를 상자에 담을 수 있다. 이 체계는 지수를 적용할 밑으로 10을 사용하기 때문에 밑이 10인 시스템이라고 부른다.2진수에서 가장 오른쪽의 비트를 가장 작은 유효 비트(least significant bit - LSB)라 하고, 가장 왼쪽의 비트를 가장 큰 유효비트(most significant bit - MSB)라고 한다.2진수 덧셈2진수의 덧셈은 각 비트를 LSB에서 MSB로 더하며 결과가 1보다 크면 1을 다음 자리로 올린다.덧셈의 결과가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어나면 오버플로가 발생한다. 오버플로우는 MSB에서 올림이 발생했다는 뜻이다.음수 표현부호와 크기음수와 양수를 구별하기 위해 부호를 사용한다. MSB를 부호에 사용한다. 부호비트가 0이면 양수이고, 부호비트가 1이면 음수로 취급한다. 한 비트를 부호에 사용하고 나머지를 크기로 사용하는 방식을 부호와 크기 표현법이라 한다. 해당 표현법은 XOR과 AND를 통한 계산이 불가능하다 +1 과 -1을 더하려할때-2라는 결과값을 얻게 되는데 -2는 +1과 -1의 더한 값이 아니다.1의 보수음수를 표현하기 위해 양수의 모든 비트를 뒤집는 방법이 있다. 이런 방법을 1의 보수표현법 이라 한다. 1의 보수에서 덧셈을 하기 위해서는 MSB쪽에서 올림이 발생한 경우에 LSB로 올림을 전달해야한다. 이를 순환올림라고 한다.2의 보수4비트 수를 예시로 +1을 더했을 때 0이되는 비트 패턴은 1111 이다. 1111을 -1로 표현하는 비트 패턴을 2의 보수표현법이라 한다. 어떤 양수의 비트를 뒤집고(NOT을 취하고) 1을 추가하면 음수값을 얻을 수 있다. 이때 MSB에서 올림이 발생하면 이값은 버려진다. +1 즉 0001의 비트를 뒤집으면 1110 이고 여기에 1을 더하면 1111이 되며 이값이 -1을 표현한다실수를 표현하는 방법고정 소수점 표현법소수점의 비트위치가 항상 일정하게 고정되어 표현하는 것을 고정 소수점 표현법 이라 한다. 1/2, 1/4 등 2의 거듭제곱을 분모로 사용한다.부동 소수점 표현법과학적 표기법을 2진수에 적용한다. 과학적 표기법에서는 10진 소수점이 왼쪽 한 자리 뿐인 소수(가수)에 10을 몇번(지수) 거듭 제곱한 값을 곱하는 방식으로 소수를 표현한다. IEEE 부동소수점 수 표준IEEE는 미국 전자 전기 공학회의 약자이다. 같은 비트를 사용하더라도 정밀도을 높이기 위해 정규화 방식이 사용된다. 정규화 방식은 가수부분은 맨 앞으로 이동시키는 방식이다. 32비트는 7비트 정밀도로 표현가능하고 64비트는 15비트 정밀도로 표현할 수 있다.2진 코드화한 10진수 시스템2진 코드화 한 10진수는 4비트를 사용해 10진 숫자 하나를 표현한다. 그러나 더많은 비트를 사용하기에 비효율적 이여서 점점 사용이 줄어들었다.2진수를 다루는 쉬운 방법8진 표현법은 8진수로 표현하는 기법이다. 비트들을 3개씩 그룹으로 묶어 표현한다. 그러나 이젠 널리 쓰이지 않는다.16진 표현법8진 표현법 대신 16진 표현법이 널리 쓰이고 있다. 0~9 다음 10부터 15를 표현하기 위해 ABCDEF라는 기호를 추가하였다. 비트를 4개씩 그룹으로 나누어 표시하는 방식이다.프로그래밍 언어의 진법 표기법여러 프로그래밍 언어에서는 각 진법별 표기법을 다음과 같이 따르도록 하였다.0부터 시작하는 숫자는 8진 숫자이다. 017은 8진수이며 10진수로 15이다.1부터 9사이 숫자로 시작하는 숫자는 10진수이다.0x가 앞에 붙은 숫자는 167진수이다. 0x12F는 16진수이며 10진수로 303이다.비트 그룹의 이름세계적으로 8비트 덩어리가 기본 단위로 널리 쓰이기 시작했고 이를 바이트라고 부른다.4비트 = 니블8비트 = 바이트16비트 = 하프 워드32비트 = 워드64비트 = 더블 워드텍스트 표현아스키 코드정보교환을 위한 미국 표준 코드이다. 아스키 코드에는 글자를 출력하는데 쓰이지 않고 장치를 제어하기 위해 사용되는 제어 문자가 있다.다른 표준의 진화국제 표준화 기구에서 ISO-646과 ISO-8859를 도입하여 영어외 언어를 지원하였다. 그리고 비트의 가격이 떨어짐에 따라 유니코드라는 새로운 표준이 만들어졌고, 문자에 16비트 코드를 부여하였다. 현재는 21비트까지 확장되었다.유니코드 변환 형식의 8비트유니코드 변환 형식 8비트(UTF-8)라는 인코딩 방법이 하위 호환성과 효율성 때문에 가장 널리쓰이고 있다.문자를 사용한 수 표현출력 가능하게 변경한 인코딩은 쿼티드 프린터블 인코딩, QP 인코딩이라고 하는데, 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신 하기 위한 인코딩 방법이다. QP인코딩은 전자우편 첨부를 처리하기 위해 만들어졌다.베이스64 인코딩3바이트 데이터를 4문자로 표현한다. 3바이트의 24비트를 네 개의 6비트 덩어리로 나누고 6비트값에 출력 가능한 문자를 할당해 표현한다.URL 인코딩 퍼센트 인코딩이라고도 부르는데, % 뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 인코딩한다.2장 - 전자 회로의 조합 논리2.0. 전자 회로의 조합 논리컴퓨터는 2진법을 적용한 비트를 내부 언어로 사용함.컴퓨터는 비트를 기반으로 새로운 비트를 표현하고 연산하는 불리언대수 또는 조합논리(combinatorial logic)을 통해 구현한 기능을 통해 동작함.2.1. 논리 게이트1960년대 개발된 논리 연산을 수행하는 회로. 간단하게 게이트라고도 함.앞서 1장에서 다루었던 기본적인 부울대수의 연산을 수행하며, 이들의 결합으로 더욱 복합적인 기능을 구현할 수 있음.2.2. 게이트를 조합한 회로가산기 adder덧셈연산을 하는 논리회로종류반가산기무언가 빠진 부분이 있어서 가산기에 '반'이라는 접두사가 붙었다. 두 비트를 더할 때는 반가산기만으로도 충분하고, 올림 처리하려면 세번째 입력이 필요하다. 전가산기리플 자리올림 가산기자리올림이 아래쪽 비트로부터 바로 위쪽 비트로 물결이 퍼져나가는 것처럼 전달되기 때문에 붙은 이름.올림 예측 가산기디코더 decoder디코더는 인코딩된 수를 개별 비트의 집합으로 만들어준다.인코딩된 수를 비트의 집합으로 변환하는 회로.디멀티플렉서 demultiplexer (dmux)하나의 입력을 받아 몇가지의 출력 중 한 곳으로 전달하는 회로 디먹스라고 줄여서 부르는 경우가 많다.실렉터 selector (multiplexer)여러 입력 중 하나의 입력을 선택하는 회로이다."
6,"https://docs.google.com/document/d/1pTQ2cg7jq36qksTc5IRbD86jXhDA6vpIgkhbzS9uyrk/edit#heading=h.gsigcbwr8ux4%c : 단일 문자%s : 문자열%d : 정수%f :ASCII : Graphical , Non-grapical\n : 개행문자 (Line Feed)\t : 탭 (Horizontal Tap)// (int)0 =&gt; 0.0//float , double, long double//소수점 밑의 자리가 9개까지 같아야 함.// float : 6개// double : 9개// long double : 12개//10bit//0100 0000 0000//(signed char)1024;// char =&gt; 1 byte =&gt; 8 bit//오류의 종류//compile Error : 문법을 잘 못 쓴것//link Error : 연결을 잘못한 것// -함수를 선언만하고 정의하지 않았다거나// 이미 정의된 식별자를 다시 재정의한다거나// 범위 밖의 식별자를 사용했다거나// Runtime Error : 프로그램 실행 중에 오류 발생// 버그 =&gt; 논리 오류/*default 예외 처리  int A;  int B;  scanf(&quot;%d %d&quot;, &amp;A, &amp;B);# 1. 기본 개념식별자(identifier) : 여러 요소를 구분짓는 이름. 최대한 구체적으로 적는다.숫자로 시작할 수 없다.대소문자를 구분한다.키워드를 사용할 수 없다.범위(Scope), 이름 공간(Name Space), 연결(Linkage)선언(Declaration) : 프로그램에게 식별자가 어떤 의미인지, 어떤 속성을 갖는지 알려주는 것정의(Definition) : 식별자에 대한 모든 정보를 제공하는 선언구문(Statement) : 컴퓨터에게 명령하는 것. 세미콜론으로 구문을 구분.복합 구문(Compound Statement) : 블록(Block).식 구문(Expression Statement) : 계산을 할 수 있는 구문으로 연산자와 피연산자의 시퀀스. 평가(Evaluation)분기문(Selection Statement) : 식의 결과에 따라서 선택지를 제공하는 구문. if / switch반복문(Iteration Statement) : 어떤 구문을 반복하는 구문. for / while / do-while점프문(Jump Statement) : 조건에 관계없이 어떤 곳으로 이동하는 구문. break / continue / goto주석(Comment) : 사용자에게 정보를 제공하는 것. 코드의 의미(코드를 이렇게 작성한 이유)를 설명할 때 사용. #2 객체객체(Object) : 메모리. 데이터를 조작하는 영역크기(Size) : 데이터를 저장하기 위한 바이트 수정렬 요건(Alignment Requirement) : 데이터를 저장하기 필요한 연속적인 바이트 수기억 존속 시간(Storage Duration) : 데이터가 얼마나 오래 사용할 수 있는지.(데이터 유효성)값(Value) : 데이터수명(Lifetime) : 객체가 살아있는 시간. 기억 존속 시간이랑 같음.타입(Type) : 데이터를 해석하는 방법식별자(Identifier) : 객체를 구분짓는 이름타입Integer : int, signed char, short, long, long longFloating-point : float, double, long doubleCharacter : charConversion : 데이터를 다른 타입으로 해석하는 것.Implicit / Explicit(Casting)변수(Variable) : 여러 데이터를 저장할 수 있는 객체상수(Constant) : 데이터가 변하지 않는 객체. const #3 분기문분기문 : 프로그램에게 여러 흐름을 제공하는 구문if / switch"
7,"컴퓨터는 3가지메모리, IO, CPU Memory : 데이터 저장 공간 little endian . big endian비트엔디안리틀 엔디안 빅 엔디안cpu 는 레지스터랑만 논다입력 : 컴퓨터한데 데이터를 주는거ALU : 계산한다제어장치 : 제어한다컴퓨터 아키텍처운영체제 : 하드웨어 자원을 관리해준다프로세스 :힙 스택코드 데이터 ; 정적 데이터쓰레드가 프로세스 작업함메인 쓰레드computational thinkingType 비트를 해석하는 방법 + 그에 적용할 수 있는 연산Primitive TypeBuilt-in Type User-defined Typestruct Account {//이름 string Name;//계좌번호 int AccountNumber;//잔액int Balance;//이율 float Interest}Control Statement Conditional Statement (조건문)if / else / switch Iteration Statementfor / while / do while// c, c++, c# for (int i = 0; i &lt; 5; ++i)Function정의역에 있는 어떤 값을 대입시켰을 때, 그에 대응되는 공역의 값이 나오는 거다.f(x) = xCore 언어의 핵심 -&gt; 문법변수, 조건문, 반복문, 함수, 구조체, 열거형, 배열, 포인터, 공용체, 매크로, 타입 재정의 Library함수의 모음 #1 컴퓨터 동작 원리Memory / IO / CPUMemory : 데이터 저장 공간Little Endian / Big EndianMemory HierarchyIO : Input and OutputInput : User -&gt; ComputerOutput : Computer -&gt; UserCPU : 계산ALU : 계산Register : 메모리Control Unit : 나머지 부품 제어Computer ArchitectureHavard / Von 노이만OS : 컴퓨터 자원을 관리Process / ThreadCode / Data / Heap / StackOSI 7 LayerApplication : 프로그램 간 데이터 통신Presentation : 데이터 암호화 / 복호화Session : 세션 연결 및 해제Transport : 데이터 전송Network : 컴퓨터 식별Data Link : 경로 식별Physical : 비트 전송 방식#2 프로그래밍 언어내 생각을 컴퓨터에게 전할 수 있는 도구 =&gt; 프로그래밍 언어Type / Control Statement / FunctionCore / LibraryComputational ThinkingType비트를 해석하는 방법 + 그에 적용할 수 있는 연산Primitive TypeBuilt-in TypeUser-defined TypeControl StatementConditional Statementif / else / switchIteration Statementfor / while / do whileFunction정의역에 있는 어떤 값을 대입시켰을 때, 그에 대응되는 공역의 값이 나오는 거죠.Core언어의 핵심 =&gt; 문법변수, 조건문, 반복문, 함수, 구조체, 열거형, 배열, 포인터, 공용체, 매크로, 타입 재정의Library함수의 모음"
8,"자리 바꾸면 cd Gitpractice git config --local user.name &quot;minwoo&quot;git config --local user.email &quot;1124mw@naver.com&quot;sourcetree 다운로드하고 사용타입범위: 제목본문꼬릿말타입커밋 타입은 아래와 같다. 범위에는 관련된 기능을 적을 수도 있고, 이슈 ID를 적을 수도 있다.Feat: 새로운 기능의 추가Fix: 버그 수정Docs: 문서 수정Style: 스타일 관련 기능(코드 포맷팅, 세미콜론 누락, 코드 자체의 변경이 없는 경우)Refactor: 코드 리펙토링Chore: 빌드 업무 수정, 패키지 매니저 수정 등 잡다한 일(ex .gitignore 수정 같은 경우)main 브랜치에서 기능 관련 브랜치를 만들고 체크아웃한다.​기능을 개발할 때마다 커밋하면서 푸시를 한다.2-1. 개발 및 커밋하기 전 git fetch를 통해서 원격 저장소를 항상 최신화한다.2-2. main에 새로운 기능이 추가되었다면 내 브랜치로 병합한다. 이 과정에서 충돌이 발생했을 시 충돌을 해결한다.2-3. 커밋하기 전 항상 내 코드를 스스로 리뷰한다.​기능 개발이 끝났다면 Pull Request를 연다.3-1. Pull Request 도중 충돌이 발생했을 경우 로컬에서 충돌 해결한 다음 푸시한다.​다른 사람들한테 Pull Request를 열었다고 알려준다.​해당 팀원의 코드를 리뷰한다.​리뷰가 끝났다면 병합한다.​병합이 끝나면 원격 브랜치를 삭제한다.2main 직접 푸시하는 경우 있음. =&gt; 꼭 브랜치 만들기​fetch 하세요.​Merge Pull Request 대신에 Close Pull Request​Push != Pull Request. Push를 한다고 Pull Request가 되는 건 아님​Pull Request를 병합한 뒤에 Delete Branch를 하는데 이거는 Remote Branch만 삭제함. Local Branch X​Pull Request는 브랜치 하나 당 하나만 열 수 있음. 새로운 Pull Request를 열고 싶다면 이전 Pull Request를 닫거나 병합해야 함.git init : 래포 생성git status : 래포 상태 확인git add : 스테이싱git restore : Unstage or Discardgit commit : 커밋하는 거git branch : 브랜치 만드는 거git merge : 병합하는 거git reset : 되돌아 가는거git revert : 반대되는 커밋git fetch : 원격 가져오기git pull : fetch + mergegit push : 원격으로 보내기git clone : 로컬로 복제github flowmain에서 새 브랜치 만들기작업하면서 커밋 푸시작업 끝나면 pr코드리뷰리뷰끝나면 main으로 merge코드 리뷰리뷰 끝나면 main으로 merge충돌처리"
9,"#1 원격 명령어원격 저장소에 있는 것을 로컬로 불러오는 데 특정 위치를 지정할 수 있고, 반대로도 할 수 있다.git push / pull /fetch  git push   : 브랜치 이름 colon refspce 으로 source:destination  git bash   #2 이외의 명령어unixcd :Change Directorymkdir : Make Directorytouch : Make a filevi-i를 누르면 편집 모드:wq로 write &amp; quitESC키를 누르면 명령어 입력 모드git config : 설정 configure repositorygit add : 스테이징 영역 추가 add fill to staging areagit restore : 변경사항 폐기 Delete a version or Unstage filesgit log : 그래프를 보여줌 Show historygit status : 레포지토리 상태를 확인 Show current status of current repositorygit init : 레포지토리 생성 Initialize repository#3 Git의 동작- HEAD : 어떤 브랜치를 가리키는지의 대한 내용이 담겨있음 커밋이나 브랜치에 대한 내용이 담겨 있음- ref/heads 에 브랜치에 대한 파일이 있다. &gt; - 해당 파일의 이름은 브랜치의 이름&gt; - 그 파일에는 커밋 ID가 있었다. (해시값)ref/tags 에 태그에 대한 파일 있다.&gt; - 해당 파일의 이름은 태그의 이름&gt; - 그 파일에는 해시값이 있다.- objects에는 변경 사항이 저장되어 있음. =&gt; 각 커밋의 내용#4 vi 사용법- 명령어 모드랑 편집 모드&gt; - 편집하고 싶을 땐 i키를 누름&gt; - ESC키를 누르면 명령어 모드- 파일을 저장하고 나가려면 :wq git add temp.txtgit commit -m &quot;&quot;"
10,#1 버전관리 시스템버전관리 : 파일의 변화를 기록하는 것로컬 / 중앙집중형 / 분산형로컬 : 내컴퓨터에서만 버전 관리중앙집중형 : 서버에서만 버전 관리분산형 : 내 컴퓨터 + 서버에서 버전관리git은 분산형 버전 관리 시스템 (distributed version control system)#2 Git -Git은 스냅샷을 이용해서 버전 관리함.-Committed / Modified / StagedCommitted / Modified / StagedCommitted : 버전 관리를 한 상태modified : 수정이 일어난 상태Staged : 커밋하겠다고 한 상태#3 명령어-git commit : 커밋하는 것-git branch : 브랜치를 만드는 것브랜치 : 특정 커밋에 대한 참조-f : 브랜치를 강제로 옮기는 것-git checkout : 특정 버전(커밋)을 불러오는 것? -b : 브랜치를 만들고 체크아웃-git merge : 서로 다른 두 개의 커밋을 합쳐서 새로운 커밋을 생성-git rebase : 커밋을 복사해 다른 커밋으로 붙여넣는 것-i  : 인터랙티브 리베이스git cherry-pick : 원하는 커밋을 복사해 붙여넣는 것-상대 참조(relative reference)HEAD : 현재 작업 중인 버전^ : 특정 커밋의 부모\2 : 두번쨰 부모~ : 특정 커밋으로부터 어떤 수만큼 떨어진 부모git tag : 특정 커밋에다가 어떤 내용을 남기는 것git clone : 원격 저장소를 복제하는 것git fetch : 원격 저장소의 내용을 로컬로 가져오는 것로컬에 없는 커밋을 다운로드원격 브랜치를 업데이트원격 브랜치 : 원격 저장소의 브랜치를 추적 git pull : git fetch + git mergegit push : 로컬 저장소의 내용을 원격으로 보내는 것원격에 없는 커밋을 업로드원격 브랜치 없데이트 1.원격저장소를 만드는 명령어 -&gt; git clone2. 원격 브랜치 : 원격 저장소를 추적하는 특수한 브랜치(remote name/branch name)3.git fetch : 원격 저장소의 내용을 로컬에도 동기화로컬에 없는 커밋을 다운로드원격 브랜치를 업데이트4.git pull : git fetch -&gt; git merge5. git push : 로컬 저장소의 내용을 원격에 동기화 원격에 없는 커밋을 업로드원격 브랜치를 업데이트클론 원격 브랜치패치fetch
11,"두 정수를 입력받은 후 두 정수의 사칙연산 + 나머지(%) 결과를 출력하기최소값과 최대값을 입력받은 후 두 수 사이의 랜덤한 숫자 1개 출력하기13사이의 숫자를 입력받은 후 입력받은 숫자에 따라 다른 인삿말이 나오도록 하기(출력 예시 : 숫자를 입력하시오(13) : 3 좋은 하루입니다.)1부터 100까지의 숫자를 차례대로 출력하기출력되는 숫자의 옆에 홀수이면 홀수, 짝수이면 짝수라고 표시하기출력되는 숫자의 옆에 3의 배수이면 3의 배수라고, 5의 배수는 5의 배수라고 표시하기(출력 예시 1 홀수 2 짝수 3 홀수 3의 배수 4 짝수 5 홀수 5의 배수 6 짝수 . . . 100 짝수 5의 배수)​1~100 사이의 임의의 숫자를 맞추는 게임오답을 입력하면 컴퓨터가 정답이 오답보다 큰지 작은지 알려주고다섯 번 안에 못맞추면 게임 오버​숫자 대신 알파벳 중 하나를 입력받고 컴퓨터가 생각하는 알파벳과 같은 값을 찾는게임 만들기.기본 규칙은 5번과 비슷(틀렸을 때 입력한 문자보다 앞에 있는지, 뒤에 있는지 알려주고 5번까지 기회를 준다)​몬스터라는 구조체를 만들고 5개를 선언하시오. 5개의 이름은 cin으로 입력받게 하고몬스터의 공격력, 방어력은 랜덤으로 설정되도록 하시오.그 후 1~5 사이의 숫자를 입력하면 번호에 해당하는 몬스터의 이름, 공격력, 방어력을출력하시오."
12,"#include #include &lt;conio.h&gt;using namespace std;struct tile{    string fore;    string swa;    string fla;};struct player {};int main(){//실습.//    10*10 크기의 맵을 구상.//    플레이어(시작지점(0,0))가 존재//    탈출지점이 존재한다.//    WASD 키입력을 통해 플레이어를 이동시킨다.//    탈출지점은 (0,0)을 제외하고 랜덤 설정//    O(플레이어)가 E(탈출구)에 도달하면 &quot;탈출에 성공했습니다.&quot; 프로그램 종료//    system(&quot;cls&quot;); // 화면 지우는 명령어//맵 초기화    srand(time(NULL));    char map1010;    int player_x = 0;    int player_y = 0;    int    exit_x = rand() % 9 + 1;    int    exit_y = rand() % 9 + 1;    int tile_x = rand() % 9 + 1;    int tile_y = rand() % 9 + 1;    int chance = 20;//맵 구성    //플레이어for (int i = 0; i &lt; 10; i++){    for (int j = 0; j &lt; 10; j++)    {        mapij = '#';    }}for (int i = 0; i &lt; 20; i++){    tile_x = rand() % 9 + 1;    tile_y = rand() % 9 + 1;    maptile_xtile_y = '$';}    mapexit_xexit_y = 'E';    //맵 속성    /*tile map1;*///map1: rand() % 2 + 1;//    map1.fore = &quot; 숲&quot;;//    map1.fla = &quot;평지&quot;;//    map1.swa = &quot;늪&quot;;    //탈출 지점과 플레이어 지점 비교    while (1)    {        mapplayer_xplayer_y = 'P';        system(&quot;cls&quot;);        for (int i = 0; i &lt; 10; i++)        {            for (int j = 0; j &lt; 10; j++)            {                cout &lt;&lt; mapij;            } cout &lt;&lt; endl;        }        cout &lt;&lt; &quot;플레이어 좌표 : &quot; &lt;&lt; player_x &lt;&lt; player_y &lt;&lt; endl;        cout &lt;&lt; &quot;탈출구 좌표&quot; &lt;&lt; exit_x &lt;&lt; exit_y &lt;&lt; endl;        cout &lt;&lt; &quot;피로도&quot; &lt;&lt; chance &lt;&lt; endl;        if (player_x == exit_x &amp;&amp; player_y == exit_y) // 탈출지점        {            cout &lt;&lt; &quot;종료되었습니다.&quot;;            break;        }        //탈출구        // 키 움직임        switch (_getch())        {        case 'w':            mapplayer_xplayer_y = '#';            player_x -= 1;            if (player_x &lt; 0)            {                player_x = 0;            }            break;        case 'a':            mapplayer_xplayer_y = '#';            player_y -= 1;            if (player_y &lt; 0)            {                player_y = 0;            }            break;        case 's':            mapplayer_xplayer_y = '#';            player_x += 1;            if (player_x &gt; 9)            {                player_x = 9;            }            break;        case 'd':            mapplayer_xplayer_y = '#';            player_y += 1;            if (player_y &gt; 9)            {                player_y = 9;            }            break;        default:            break;        }        if (chance == 0)        {            cout &lt;&lt; &quot;피로가 쌓였습니다.&quot;;            break;        }    }}"
13,"#include #include using namespace std;//여기에다가 구조체를 정의 struct score{    int kor;    int eng;    int math;};struct student{    string name; // 클래스도 쓸 수 있고    int age; //기본 자료형도 쓸 수 있고    string homeTown;    int pride;    int monthlyScore12; //배열도 넣을 수 있고    struct score myScore;// 앞에서 정의한 구조체도 넣을 수 있다.}seoyeon,jaehyuk; //중괄호의 끝과 세미콜론 사이에다 student의 변수를 미리 선언해 줄 수도 있다.// name; age; korScore; rank;가 하위 변수int main() // 이놈이 지금 우리가 쓰고 있는 유일한 함수{/** 프로그래밍 기초 (메모리, cpu, 디스크)getch()   구조체절차적구조적객체 지향적추상화c언어에서 코드를 추상화 하는 데 사용되는 삼총사 : 배열 구조체 함수추상화??? 실제 세계(현상)를 간락화/기호화/보편화 해서 표현한 것코드에서 추상화가 필요한 이유 : 결국 코드는 사람이 짜는 것이기 때문에다른 사람이 코드를 해석하기 편리해야 하고다른사람이 인수인계 받아서 유지보수하기 편리해야 하고다른 사람들과 함께 공동으로 코드를 만들기 편리해야 하고배열 : 속성이 동일한 여러 개의 데이터를 같은 이름과 순서를 지정한 연속된 번호로 서로 연관되어 있음을 표시함으로써 추상화함구조체 : 데이터(자료형)을 실제로 쓰이는 데이터끼리 묶이서 추상화함수 : 프로세스 (코드)를 특정 기능 단위로 묶어서 추상화최악의 추상화 -&gt; 추상화 단계를 상승시키는 과정구조체란?변수를 모아 놓은 집합체특정 변수들이 무언가의 하위 개념으로 묶일 수 있을 때studentName10, studentAge10, studentScore10 ...'학생'의 'XXX'이름, 나이, 국어점수 , 석차 등등을 '학생'이라는 구조체로 묶어서 사용구조체를 정의하는 위치 : 구조체가 사용되는 함수의 앞에 정의한다.(해당 함수의 바깥쪽 앞 (위))구조체 정의의 방법struct 구조체 변수명{구조체 안에 들어갈 하위 변수들(위의 예시에 따르면 이름, 나이, 국어점수 , 석차같은 애들이 하위 변수이다. )};구조체는 일종의 우리가 새롭게 만든 데어터형구조체 안에 들어갈 수 있는 하위 변수는 무엇이 있을까?당연히 int/bool/float 같은 기본 자료형들은 모두 사용 가능string &lt;- 클래스도 쓸 수 있다.구조체의 선언과 초기화기본적으로 구조체 변수의 개념은 배열 변수의 개념과 동일 int a3 = (50,60,70);구조체 변수도 다음과 같이 선언과 같이 동시에 가능하다player.hp = player.hp - monstern.dmg;&lt;- 주석 없이 코드를 배우지 않은 사람에게도 어느 정도의 가독성이 확보된다./student minseop; //구조체 변수의 선언minseop.name = &quot;신민섭&quot;; //minseop.name = &quot;신민섭&quot;이다minseop.age = 34;minseop.homeTown = &quot;인천&quot;;minseop.pride = 100;cout &lt;&lt; minseop.name &lt;&lt; endl;//초간단 실습 : student 구조체를 사용해서 자기 자신의 정보를 입력하고 확인해보자.student minwoo;minwoo.age = 26;minwoo.homeTown = &quot;seoul&quot;;minwoo.pride = 100;minwoo.name = &quot;이민우&quot;;minwoo.myScore.eng = 99;minwoo.monthlyScore0 = 89;minwoo.monthlyScore1 = 95;score myScore = { 50, 80, 90 };// 배열을 초기화 하듯 구조체 변수도 초기화 할 수 있다.// monster a = {&quot;고블린&quot;, 70, 55, 12f, true, 100};cout &lt;&lt; myScore.kor &lt;&lt; myScore.eng &lt;&lt; myScore.math &lt;&lt; endl;cout &lt;&lt; minwoo.age &lt;&lt; endl;/* 과제 : 미궁탈출 게임의 업데이트사용할 수 있는 모든 요소에 구조체를 활용해서 소스 코드를 개선해 보세요.tile : 지형 정보를 넣고 (숲, 늪, 평지)player : 피로도를 넣고플레이어가 어느 지형에 있는지, 플레이어의 피로도가 얼마인지 (숲 -1, 늪 -3, 평지 0)표시되도록 수정해 봅시다.*///string a, b, c;    //최악의 추상화//    string a3; // 위에 것보다는 좀 낫다//    string name1, name2, name3; // 아님 아런 식으로든지//    string studentName3; // 위의 것보다 의도가 명료하게 드러나기 때문에 좋은 추상화    1. 두 정수를 입력받은 후 두 정수의 사칙연산 + 나머지(%) 결과를 출력하기    2. 최소값과 최대값을 입력받은 후 두 수 사이의 랜덤한 숫자 1개 출력하기    3. 1~3사이의 숫자를 입력받은 후 입력받은 숫자에 따라 다른 인삿말이 나오도록 하기    (출력 예시 : 숫자를 입력하시오(1~3) : 3        좋은 하루입니다.)    4. 1부터 100까지의 숫자를 차례대로 출력하기    출력되는 숫자의 옆에 홀수이면 홀수, 짝수이면 짝수라고 표시하기    출력되는 숫자의 옆에 3의 배수이면 3의 배수라고, 5의 배수는 5의 배수라고 표시하기    (출력 예시        1 홀수        2 짝수        3 홀수 3의 배수        4 짝수        5 홀수 5의 배수        6 짝수        .        .        .        100 짝수 5의 배수)    ​    5. 1~100 사이의 임의의 숫자를 맞추는 게임    오답을 입력하면 컴퓨터가 정답이 오답보다 큰지 작은지 알려주고    다섯 번 안에 못맞추면 게임 오버    ​    6. 숫자 대신 알파벳 중 하나를 입력받고 컴퓨터가 생각하는 알파벳과 같은 값을 찾는    게임 만들기.기본 규칙은 5번과 비슷    (틀렸을 때 입력한 문자보다 앞에 있는지, 뒤에 있는지 알려주고 5번까지 기회를 준다)    ​    7. 몬스터라는 구조체를 만들고 5개를 선언하시오. 5개의 이름은 cin으로 입력받게 하고    몬스터의 공격력, 방어력은 랜덤으로 설정되도록 하시오.    그 후 1~5 사이의 숫자를 입력하면 번호에 해당하는 몬스터의 이름, 공격력, 방어력을    출력하시오.}"
14,"#include #include &lt;conio.h&gt;using namespace std;int main(){//실습.//    10*10 크기의 맵을 구상.//    플레이어(시작지점(0,0))가 존재//    탈출지점이 존재한다.//    WASD 키입력을 통해 플레이어를 이동시킨다.//    탈출지점은 (0,0)을 제외하고 랜덤 설정//    O(플레이어)가 E(탈출구)에 도달하면 &quot;탈출에 성공헀습니다.&quot; 프로그램 종료//    system(&quot;cls&quot;); // 화면 지우는 명령어//맵 초기화    srand(time(NULL));    char map10103;    int player_x = 0;    int player_y = 0;    int    exit_x = rand() % 9 + 1;    int    exit_y = rand() % 9 + 1;//맵 구성    //플레이어while (1){    system(&quot;cls&quot;);    for (int i = 0; i &lt; 10; i++)    {        for (int j = 0; j &lt; 10; j++)        {            mapij = '#';        }    }    //탈출 지점과 플레이어 지점 비교    mapplayer_xplayer_y = 'P';    mapexit_xexit_y = 'E';    for (int i = 0; i &lt; 10; i++)    {        for (int j = 0; j &lt; 10; j++)        {            cout &lt;&lt; mapij;        } cout &lt;&lt; endl;    }    cout &lt;&lt; &quot;플레이어 좌표 : &quot; &lt;&lt; player_x &lt;&lt; player_y &lt;&lt; endl;    cout &lt;&lt; &quot;탈출구 좌표&quot; &lt;&lt; exit_x &lt;&lt; exit_y &lt;&lt; endl;    if (player_x == exit_x &amp;&amp; player_y == exit_y) // 탈출지점    {        cout &lt;&lt; &quot;종료되었습니다.&quot;;        break;    }    //탈출구    // 키 움직임    switch (_getch())    {    case 'w':        player_x -= 1;        if (player_x &lt; 0)        {            player_x = 0;        }        break;    case 'a':        player_y -= 1;        if (player_y &lt; 0)        {            player_y = 0;        }        break;    case 's':        player_x += 1;        if (player_x &gt; 9)        {            player_x = 9;        }        break;    case 'd':        player_y += 1;        if (player_y &gt; 9)        {            player_y = 9;        }        break;    default:        break;    }}return 0;}"
15,"#include #include &lt;conio.h&gt;using namespace std;int main(){/*    실습.    A ~ Z 키 중에 하나를 정답으로 설정한다.    유저는 한 개의 키를 입력해서 설정된 값을 맞춘다.    유저가 입력한 키와 설정된 값이 맞으면 승리, 프로그램 종료    틀리면 남은 기회를 보여주고 5번 틀리면 정답을 알려주고 게임오버    +틀릴 때마다 정답 알파벳이 입력된 알파벡 앞에 있는지, 뒤에 있는지 힌트를 준다.    +입력된 값이 대소문자 구분 없이 처리될 수 있도록 수정해보자.*/    srand(time(NULL));    char input; //입력값    char random_num = rand() % 26 + 65;    int chance;     // 최댓값- 최소값 +1 더하기 최소값    cout &lt;&lt; random_num &lt;&lt; endl;    while (1)    {        for (chance = 0; chance &lt; 5; chance++)         {        cout &lt;&lt; &quot;알파벳을 맞추시오&quot; &lt;&lt; endl;        input = _getch();            if (input == random_num)            {                cout &lt;&lt; &quot;정답입니다&quot; &lt;&lt; endl;                break;            }            if (96 &lt; input &lt; 123 )             {                input -= 32;            }            else if (input != random_num)            {                cout &lt;&lt; &quot;오답입니다&quot; &lt;&lt; endl;                cout &lt;&lt; &quot;기회가&quot; &lt;&lt; 4 - chance &lt;&lt; &quot;번 남았습니다. &quot; &lt;&lt; endl;                if(input &gt; random_num)                {                    cout &lt;&lt; &quot;입력한 값이 정답보다 큽니다&quot; &lt;&lt; endl;                }                else if (input &lt; random_num)                {                    cout &lt;&lt; &quot;입력한 값이 정답보다 작습니다&quot; &lt;&lt; endl;                }            }            else            {                if (chance == 0)               {                   cout &lt;&lt; &quot;정답은 &quot; &lt;&lt; random_num &lt;&lt; &quot;입니다.&quot;;                       break;                }           }            } if (input == random_num)            break;        if (chance == 0)            break;    }                //실습.                //    10*10 크기의 맵을 구상.                //    플레이어(시작지점(0,0))가 존재                //    탈출지점이 존재한다.                //    WASD 키입력을 통해 플레이어를 이동시킨다.                //    탈출지점은 (0,0)을 제외하고 랜덤 설정                //    O(플레이어)가 E(탈출구)에 도달하면 &quot;탈출에 성공헀습니다.&quot; 프로그램 종료                //    system(&quot;cls&quot;); // 화면 지우는 명령어       맵 초기화       int Px = rand() &amp; 10;       int py = rand() &amp; 10;       int end_x = rand() &amp; 10;       int end_y = rand() &amp; 10;    char map1010;        for (int i = 0; i &lt; 10; i++)        {            for (int j = 0; j &lt; 10; j++)            {                mapij = '#';            }        }        for (int i = 0; i &lt; 10; i++)        {            for (int j = 0; j &lt; 10; j++)            {                cout &lt;&lt; mapij;            } cout &lt;&lt; endl;          }   mapPxpy = 'p';           mapend_xend_y = 'E';       //탈출 위치 지정       //플레이어 위치 초기값       //화면 초기화        //입력값에 의한 이동         //위로 이동         //왼쪽으로 이동        //아래로 이동        //오른쪽으로 이동        //탈출 성공 후처리 : 플레이어가 출구로 나간것을 표시"
16,"/*    boolean 타입    bool is_alive =  5 &gt; 3; /숫자상으로 1출력     bool is_alive = false;     /true or /1byte   배열 (자료구조)   같은 데이터타입의 여러 변수를 하나의 묶음으로 나타낸 것.   배열의 데이터타입에 대한 동일한 크기로 메모리상에 연속된 공간이 할당된다.   배열명이 메모리 시작 주소이다.   0이 시작이다.형변환: 데이터타입을 변환한다. 묵시적 형변환명시적 형변환실습.A~Z 키 중에 하나를 정답으로 설정한다.유저는 한 개의 키를 입력해서 설정된 값을 맞춘다.유저가 입력한 키와 설정된 값이 맞으면 승리, 프로그램 종료틀리면 남은 기회를 보여주고, 5번 틀리면 정답을 알려주고 게임오버+ 틀릴 때마다 정답 알파벳이 입력된 알파벳 앞에 있는지, 뒤에 있는지 힌트를 준다.+ 입력된 값이 대소문자 구분없이 처리될 수 있도록 수정 해보자.콘솔용 탈출게임10 * 10 크기의 맵을 구성한다. (2차원 배열)플레이어(0, 0)가 존재한다.탈출지점이 존재한다.WASD 키입력을 통해 플레이어를 이동시킨다.탈출지점은 (0, 0)을 제외하고 랜덤 설정0가 E에 도달하면 &quot;탈출에 성공했습니다.&quot; 프로그램 종료#0##########################################################################E#######################system (&quot;cls&quot;);   */#include #include &lt;conio.h&gt;using namespace std;int main(){    ////int input_key = _getch();    //char input_key = _getch();    //cout &lt;&lt; (int)input_key &lt;&lt; endl;    //    //명시적 형변환    //float test_float =(float)5.4;//f를 안붙이면 더블로 출력해서 짤림 , 형변환    //float test_float = 5.4f;//int nums10 = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 };//cout &lt;&lt; nums &lt;&lt; endl;////cout &lt;&lt; &amp;(nums0) &lt;&lt; endl; /같은 값을 출력 /잘못된 메모리 주소로 들어가면 런타임에러가 뜬다.//for (int i = 0; i &lt; 10; i++)//    cout &lt;&lt; &amp;(numsi) &lt;&lt; endl;/*cout &lt;&lt; &amp;(nums1) &lt;&lt; endl;cout &lt;&lt; &amp;(nums2) &lt;&lt; endl;cout &lt;&lt; &amp;(nums3) &lt;&lt; endl;*//*실습1. string형 배열변수 5개짜리를 선언하고반복문을 통해 학생의 이름을 입력받는다.학생이름 5개 저장입력을 다 받고나서 1~5 사이의 값을 입력하면 해당학생의 이름이 출력된다.예시) 1번째 학생의 이름을 입력하세요 : _    2번째 학생의 이름을 입력하세요 : _    3번째 학생의 이름을 입력하세요 : _    4번째 학생의 이름을 입력하세요 : _    5번째 학생의 이름을 입력하세요 : _    1~5 사이의 번호를 입력하세요 : _3    3번째 학생의 이름은 ... 입니다.    2차원배열 및 다차원배열    배열이 (개념적으로) 2중으로, 다중으로 구성되어 있는 것. 실제로는 일차원이라는 것    1차원 배열 :  int student_nums5; // 5개의 int    -&gt; 5명의 학생이 있다.    2차원 배열 : int student_nums35; // 15개의 int    -&gt; 3개 반에 각각 5명의 학생이 있다.    3차원 배열 : int student_nums435; // 60개의 int    -&gt; 4개 학년에 각각 3개 반이 존재, 각 반에 5명의 학생이 있다.    실습.    구구단의 결과를 저장하는 2차원 배열을 하나 선언하고,    2 * 1 = 2    이중 for문을 이용해서 배열 변수에 구구단의 결과값을 저장하고,     두 수를 입력받아서 적합한 결과값을 출력해보자.    예시)     (결과 저장 완료)    몇 단을 볼까요? : _4    몇을 곱할까요? : _7    4 * 7 + 28*//*string name5;int num;for (int i = 0; i &lt; 5; i++) {    cout &lt;&lt; i+1 &lt;&lt; &quot;번째 학생의 이름을 입력하세요 : &quot;;    cin &gt;&gt; namei;}cout &lt;&lt; &quot;1~5 사이의 번호를 입력하세요 : &quot;;cin &gt;&gt; num;cout &lt;&lt; num &lt;&lt; &quot;번째 학생의 이름은&quot; &lt;&lt; namenum-1 &lt;&lt;  &quot;입니다.&quot; &lt;&lt; endl;*///string a, b, c, d, e;    /*cout &lt;&lt; &amp;(numsi) &lt;&lt; endl;cout &lt;&lt; &quot;1번째 학생의 이름을 입력하세요&quot; &lt;&lt; endl;cin &gt;&gt; a &gt;&gt;endl;cout &lt;&lt; &quot;2번째 학생의 이름을 입력하세요&quot; &lt;&lt; endl;cin &gt;&gt; b &gt;&gt;endl;cout &lt;&lt; &quot;3번째 학생의 이름을 입력하세요&quot; &lt;&lt; endl;cin &gt;&gt; c &gt;&gt;endl;*///int student_num35 ={    { 1, 2, 3, 4, 5 },//                            { 6, 7, 8, 9, 10 },//                            { 11, 12, 13, 14, 15 } };////순서대로 출력하는 코드//for (int j = 0; j &lt; 3; j++)//{//    for (int i = 0; i &lt; 5; i++)//    {//        cout &lt;&lt; student_numji &lt;&lt; endl;//        //cout &lt;&lt; student_num05 &lt;&lt; endl; // 10s 정상적인 사용방법 x//    }//}/*(엔터 없이) 문자 하나를 입력하는 방법_getch():*//*int gugu89;int inputdan;int inputsu;for (int j = 0; j &lt; 8; j++) {    for (int i = 0; i &lt; 9; i++)    {        guguji = (j + 2) * (i + 1);    }}for (int j = 0; j &lt; 8; j++) {    for (int i = 0; i &lt; 9; i++)    {        cout &lt;&lt; guguji &lt;&lt; endl;    } cout &lt;&lt; endl;}cout &lt;&lt; &quot;결과 저장 완료&quot; &lt;&lt; endl;cout &lt;&lt; &quot;몇단을 볼까요&quot;;cin &gt;&gt; inputdan; cout &lt;&lt; &quot;몇을 곱할까요&quot;;cin &gt;&gt; inputsu; cout &lt;&lt; inputdan &lt;&lt; &quot; * &quot; &lt;&lt; inputsu &lt;&lt; &quot; = &quot; &lt;&lt; guguinputdan-2inputsu-1 &lt;&lt; endl;*/    /*gugu00 = 2 * 1;    gugu01 = 2 * 2;    gugu02 = 2 * 3;*/// *&amp;*&amp;&amp;*&amp;*&amp;*&amp;*&amp; 하다가 도전실패한 것 //        int input_key = _getch();////        cout &lt;&lt; (int)input_key &lt;&lt; endl;//        srand(time(NULL))//            int num = rand() % 26 + 65; // 최댓값+ 최소값 +1 더하기 최소값//        cout &lt;&lt; rand_num &lt;&lt; endl;////        int input;//        if ()//        rand()////        cout &lt;&lt; &quot; 알파벳을 맞추시오&quot; &lt;&lt; endl;//        cin &gt;&gt; input;//for (int chance = 0; chance &lt; 5; chance++) {////            }//        if (input == rand()) //        {//            cout &lt;&lt; &quot;정답입니다&quot; &lt;&lt; endl;//        }//        else if (input )int player;int map1010;for (map = 0; map &lt; 10; map++) {    cout &lt;&lt; &quot;#&quot; &lt;&lt; endl;}}"
17,/*  5)            *     // 5           *    // 456          ***   // 34567         ***  // 2345678        ***** //123456789        /    for (int i = 0; i &lt; 5; i++)    {        for (int k = 5; k &gt; i + 1; k--)        {            cout &lt;&lt; &quot; &quot;;        }        for (int s = 0; s &lt; 2 * i + 1; s++)        {            cout &lt;&lt; &quot;&quot;;        }        for (int k = 5; k &gt; i + 1; k--)        {            cout &lt;&lt; &quot; &quot;;        }        cout &lt;&lt; endl;    }    cout &lt;&lt; endl;         /*   6)        *****         ***          ***           *            *        /                for (int i = 0; i &lt; 5; i++)                {                    for (int j = 0; j &lt; i; j++)                    {                        cout &lt;&lt; &quot; &quot;;                    }                    for (int s = 10; s &gt; 2 * i + 1; s--)                    {                        cout &lt;&lt; &quot;&quot;;                    }                    for (int j = 0; j &lt; i; j++)                    {                        cout &lt;&lt; &quot; &quot;;                    }                    cout &lt;&lt; endl;                }                cout &lt;&lt; endl;
18,"/* 제어문 데이터(타입) / 연산자 / &lt;제어구조&gt;조건문 : 특정 조건에 따라서 실행문을 실행할지 안할지 제어 : if / switch반복문 : 특정 조건에 따라서 실행문을 일정 횟수만큼 반복 실행 제어 : while  / for조건문1_1. if 문if (조건식) 결과가 참 또는 거짓{실행문1;}else if (조건식2){실행문3;}else{실행문2;}조건문 실습1.정수를 하나 입력 받아서입력 받은 숫자가 10보다 크면 &quot;입력된 숫자가 10보다 큽니다.&quot; 출력10 이하 9초과 이면 &quot;9보다 큽니다.&quot; 출력9 이하 6 초과 이면 &quot;6보다 큽니다.&quot; 출력그 이외에는 &quot;6보다 작거나 같습니다.&quot; 출력1_2. switch 문switch (정수형 변수){case 정수1:     실행문1;break;case 정수2:     실행문2;break;case -3:     실행문3;break;default;    //해당하는 정수값이 없을 때    실행문4;break;}실습2. switch문 실습.당신의 고향은 어디입니까?서울   2. 양평   3.광주   4.대전    5.제주도_1안녕하세요. 당신의 고향은 서울이군요.안녕하수꽝. 혼저옵서예.default는 5개 중에 선택해 주세요.반복문2_1. while문 (조건식){//초기식실행문;조건식을 바꾸는 실행문; // while문을 중단시키는 첫번째 방법if (조건식){break;  //while문을 중단시키는 두번째 방법}do-while문do{    실행문;}    while (조건식);     do-while문은 한번은 실행하고 while 문은 한번도 실행 x 할 수 있다.    }    2_2 for문    for ((1)초기식; (2)조건식 ; (3)증감식)    {    (4)실행문;    }    (1) -&gt; (2) -&gt; (4) -&gt; (3) -&gt; (2) -&gt; (4) -&gt; (3) -&gt; ... 조건식의 결과값이 0 이 나올 때까지 / //입력 정수를 하나 입력 받는다. 변수를 선언 /*int input_num; cin &gt;&gt; input_num;/ //처리 //출력 /*if (input_num &gt; 10) { cout &lt;&lt; &quot;입력된 숫자가 10보다 큽니다.&quot; &lt;&lt; endl; } else if (input_num &gt; 9) {  cout &lt;&lt; &quot;9보다 큽니다.&quot; &lt;&lt; endl; } else if (input_num &gt; 6) { cout &lt;&lt; &quot;6보다 큽니다.&quot; &lt;&lt; endl; } else {  cout &lt;&lt; &quot;6보다 작거나 같습니다.&quot; &lt;&lt; endl; }*///입력/*  int hometown_num;  cout &lt;&lt; &quot;당신의 고향은 어디입니까?&quot; &lt;&lt; endl;  cout &lt;&lt; &quot;1. 서울   2. 양평   3.광주   4.대전    5.제주도&quot; &lt;&lt; endl;  cin &gt;&gt; hometown_num;  //처리  //출력  switch (hometown_num)  {   case 1:   cout &lt;&lt; &quot;안녕하세요.당신의 고향은 서울이군요.&quot; &lt;&lt; endl;   break;   case 2:   cout &lt;&lt; &quot;안녕하세요.당신의 고향은 양평이군요.&quot; &lt;&lt; endl;   break;   case 3:   cout &lt;&lt; &quot;안녕하세요.당신의 고향은 광주이군요.&quot; &lt;&lt; endl;   break;   case 4:   cout &lt;&lt; &quot;안녕하세요.당신의 고향은 대전이군요.&quot; &lt;&lt; endl;   break;   case 5:   cout &lt;&lt; &quot;안녕하세요.당신의 고향은 제주도이군요.&quot; &lt;&lt; endl;   break;   default:   cout &lt;&lt; &quot;5개 중에 하나를 선택해 주세요.&quot; &lt;&lt; endl;   break;  }*/  //int hometown;  //cout &lt;&lt; &quot;당신의 고향은 어디입니까?&quot; &lt;&lt; endl;  //cout &lt;&lt; &quot;1. 서울   2. 양평   3.광주   4.대전    5.제주도&quot; &lt;&lt; endl;  //cin &gt;&gt; hometown;  ////처리  ////출력  //if (hometown == 1)  //{  //    cout &lt;&lt; &quot;안녕하세요.당신의 고향은 서울이군요.&quot; &lt;&lt; endl;  //}  //else if (hometown == 2)  //{  //    cout &lt;&lt; &quot;안녕하세요.당신의 고향은 양평이군요.&quot; &lt;&lt; endl;  //}  //else if (hometown == 3)  //{  //    cout &lt;&lt; &quot;안녕하세요.당신의 고향은 광주이군요.&quot; &lt;&lt; endl;  //}  //else if (hometown = 4)  //{  //    cout &lt;&lt; &quot;안녕하세요.당신의 고향은 대전이군요.&quot; &lt;&lt; endl;  //}  //else if (hometown = 5)  //{  //    cout &lt;&lt; &quot;안녕하세요.당신의 고향은 제주도이군요.&quot; &lt;&lt; endl;  //}  //else   //{  //    cout &lt;&lt; &quot;5개 중에 하나를 선택해 주세요.&quot; &lt;&lt; endl;  //}/*실습2.switch문 실습. 당신의 고향은 어디입니까?서울   2. 양평   3.광주   4.대전    5.제주도_1안녕하세요. 당신의 고향은 서울이군요.안녕하수꽝. 혼저옵서예.default는 5개 중에 선택해 주세요.*//*int num;cin &gt;&gt; num;if (num &gt; 10){    cout &lt;&lt; &quot;입력된 숫자가 10보다 큽니다.&quot;;}else if (num &lt;= 10 &amp;&amp; num &gt; 9){    cout &lt;&lt; &quot;9보다 큽니다.&quot;;}else if (num &lt;= 9 &amp;&amp; num &gt; 6){    cout &lt;&lt; &quot;6보다 큽니다.&quot;;}else{cout &lt;&lt; &quot;6보다 작거나 같습니다.&quot;;}*/// hello world를 5번 출력하는 프로그램,  조건식을 바꾸고 싶으면 변수를 쓴다./*//int repeat_count = 0;    while (1)    {        cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;        repeat_count++;        if (repeat_count &gt;= 5)        {            break;        }    }    while (count &lt; 5)    {        cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;        repeat_count++;    }    repeat_count = 0;    do    {        cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;        repeat_count++;    } while (repeat_count &lt; 5);*/    //실습 4 // while문을 써서 정답을 맞출 때까지 반복되는 프로그램으로 수정해보자.    //처리    //cout &lt;&lt; &quot;미리보는 정답&quot; &lt;&lt; correct_num &lt;&lt; endl;    ////입력    //int input_quiz_number;    //cin &gt;&gt; input_quiz_number;    ////출력 : true or false    //(input_quiz_number == correct_num) ? cout &lt;&lt; &quot;true&quot; &lt;&lt; endl : cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;   /* srand(time(NULL));    int correct_num = rand() % 9 + 1;    int input_num;    while (1)    {        cout &lt;&lt; &quot;1 ~ 9 사이의 숫자 맞추기! &quot;;        cin &gt;&gt; input_num;        if (correct_num == input_num)        {            cout &lt;&lt; &quot;정답입니다&quot;;            break;        }        cout &lt;&lt; &quot;다시 시도해보세요&quot; &lt;&lt; endl;    }*/    //처리//int correct_num = rand() % 9 + 1;//cout &lt;&lt; &quot;미리보는 정답&quot; &lt;&lt; correct_num &lt;&lt; endl;//     //입력//    int input_quiz_number = -1; //초기식//    while (input_quiz_number != correct_num) // 조건식을 수정한다.//        cout &lt;&lt; &quot;숫자를 맞춰보세요&quot;;//    cin &gt;&gt; input_quiz_number; //출력 : true or false   /* (input_quiz_number == correct_num) ? cout &lt;&lt; &quot;true&quot; &lt;&lt; endl :            cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;/            // break 조건을 추가       / if (input_quiz_number == correct_num)        {            break;        }*/    //for (int i = 0; i &lt; 5; i++)    //{    //    cout &lt;&lt; &quot;hello world &lt;&lt; &quot; &lt;&lt; endl;    //}    //for (int i = 0; i &lt; 5; i += 1 )// 증감식 뒤에는 세미콜론 x    //{    //    cout &lt;&lt; &quot;hello world &lt;&lt; &quot; &lt;&lt; endl;    //}  /*  for문 실습1.  10부터 1까지 차례대로 출력되는 코드를 작성해 보자.  10  9  8  7  ...  1  실습2.  100미만의 3의 배수를 차례대로 출력되는 코드를 작성해 보자.  3  6  9  12  15  ...  96  99  실습3.  1000미만의 2의 승수를 차례대로 출력되는 코드를 작성해보자.  1  2  4  8  16  32  64  128  256  512  */  // for문 실습1. 10부터 1까지 차례대로 출력되는 코드를 작성해 보자.      //for (int i = 10; i &gt; 0 ; i--)      //{      //    cout &lt;&lt; i &lt;&lt; endl;      //}      //for (int i = 3; i &lt; 100; i += 3)      //{      //    cout &lt;&lt; i &lt;&lt; endl;      //}      ////실습3. 1000미만의 2의 승수를 차례대로 출력되는 코드를 작성해보자.      //for (int i = 1; i &lt; 1000; i *= 2)      //{      //    cout &lt;&lt; i &lt;&lt; endl;      //}      /*실습4.      구구단을 출력해보자      4_1. 구구단을 2단을 차례대로 출력해보자       2 * 1 = 2       2 * 2 = 4       2 * 3 = 6       2 * 4 = 8       2 * 5 = 10       2 * 6 = 12       2 * 7 = 14       2 * 8 = 16       2 * 9 = 18       4_2. 구구단 2단 ~9단을 차례대로 출력해보자       2단       3단       4단       4_3. 구구단 2~9단을 다음과 같은 형태로 출력해보자.       2단 3단 4단       5단 6단 7단       8단 9단      2 * 1 = 2   3 * 1 = 3   4 * 1 = 4      2 * 2 = 2      */      /*for (int i = 1; i &lt;= 9 ; i++)      {          cout &lt;&lt; &quot;2x&quot; &lt;&lt; i &lt;&lt; &quot;=&quot; &lt;&lt; 2 * i &lt;&lt; endl;      }      for (int i = 2; i &lt; 10; i++) {          for (int j = 1; j &lt; 10; j++) {              cout &lt;&lt; i &lt;&lt; &quot;*&quot; &lt;&lt; j &lt;&lt; &quot;=&quot; &lt;&lt; i * j &lt;&lt; endl;              }          cout &lt;&lt; endl;          }      별 찍기      1)      *      **      ***      ****      *****      2)  */  //교수님이랑 같이 한 1번 ,2번      //for (int i = 1; i &lt;= 9 ; i++)  //    cout &lt;&lt; &quot;2 * &quot; &lt;&lt; i &lt;&lt; &quot; = &quot; &lt;&lt; 2 * i &lt;&lt; endl;  //         //    for (int gugu_dan = 2; gugu_dan &lt; 10; gugu_dan++) {  //  //        for (int gugu_su = 1; gugu_su &lt; 10; gugu_su++) {  //  //          //            cout &lt;&lt; gugu_dan &lt;&lt; &quot;*&quot; &lt;&lt; gugu_su &lt;&lt; &quot; = &quot; &lt;&lt; gugu_dan * gugu_su &lt;&lt; endl;  //        }  //        cout &lt;&lt; endl;  //    }  //  //    for (int i = 1; i &lt;= 9; i++)  //        cout &lt;&lt; &quot;2 * &quot; &lt;&lt; i &lt;&lt; &quot; = &quot; &lt;&lt; 2 * i  //        cout &lt;&lt; &quot;*&quot;  //  //    //구구단 3단씩 출력되는 코드  //    for (int i = 2; i &lt; 10; i += 3)  //    {  //        for (int j = 1; j &lt; 10; ++j)  //        {  //            for (int k = 0; k &lt; 3; ++k)  //            {     //                if (i + k == 10)  //                    break;  //  //                cout &lt;&lt; i + k &lt;&lt; &quot;x&quot; &lt;&lt; j &lt;&lt; &quot;=&quot; &lt;&lt; (i + k) * j &lt;&lt; &quot;\t&quot;;  //            }  //            cout &lt;&lt; endl;  //        }  //        cout &lt;&lt; endl;  //    }  //    return 0;"
19,"#include using namespace std;int main(){//실습 1. 3 ~ 7 사이의 랜덤한 숫자를 출력하는 프로그램을 작성하자.    srand(time(NULL));    int randNumber;// 0 ~ 7    randNumber = rand() % 5 + 3;    //(randNumber &lt;= 2) ? randNumber += 3 : randNumber;    cout &lt;&lt; randNumber &lt;&lt; endl; // 1    // 실습2  가장 작은 값과 큰 값을 입력 받아서, 그 사이의 임의의 값을 출력하는 프로그램을 작성하자.    int max;    int min;    cout &lt;&lt; &quot;가장 작은 값 입력&quot;;    cin &gt;&gt; min;    cout &lt;&lt; &quot;가장 큰 값 입력&quot;;    cin &gt;&gt; max;    cout &lt;&lt; rand() % (max - min + 1) + min &lt;&lt; endl;    //실습3.프로그램을 실행하면 내부적으로 1 ~9사이의 숫자가 정답으로 정해진다.유저가 1 ~9 사이의 숫자를 입력하면 맞으면 true, 틀리면 false    int answer = rand() % 9 + 1;    int input;    cout &lt;&lt; &quot; 1~9 사이에 숫자 맞추기 &quot; &lt;&lt; endl;    cin &gt;&gt; input;    cout &lt;&lt; boolalpha &lt;&lt; (answer == input) &lt;&lt; endl;    //(answer == input) ? cout &lt;&lt; &quot;true&quot; : cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;    //과제 rand 값의 데이터 타입은 ?  범위는 0 ~ 32767이다 4byte// 교수님과 함께함@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 다음건#include &lt;iostream&gt;using namespace std;int main(){    /*실습1. 3 ~7 사이의 랜덤한 숫자를 출력하는 프로그램을 작성하자.        (3, 7 포함)        실습2.가장 작은 값과 큰 값을 입력 받아서, 그 사이의 임의의 값을 출력하는 프로그램을 작성하자.        실습3.프로그램을 실행하면 내부적으로 1 ~9 사이의 숫자가 정답으로 정해진다.유저가 1 ~9 사이의 숫자를 입력하면 맞으면 true, 틀리면 false*/        int rand_num;        // 입력         // 처리        srand(time(NULL));            //rand(); // 0 ~ 32767 % 5        rand_num = 3 + rand() % 5;        //3 + 0, 3 + 1, 3 + 2, 3 + 3, 3 + 4; //7-3 + 1        // 출력 - 숫자 하나 출력        cout &lt;&lt; rand_num &lt;&lt; endl;        //실습 2.         //입력        int input_min_number;        int input_max_number;        cout &lt;&lt; &quot;최소값을 입력하세요 : &quot;;        cin &gt;&gt; input_min_number;        cout &lt;&lt; &quot;최대값을 입력하세요 : &quot;;        cin &gt;&gt; input_max_number;        //처리        rand_num = input_min_number + rand() % (input_max_number - input_min_number + 1);                                                        //7-3 + 1        //출력        cout &lt;&lt;&quot;실습2 &quot; &lt;&lt; rand_num &lt;&lt; endl;        //실습 3.        //처리        int correct_num = rand() % 9 + 1;        cout &lt;&lt;&quot;미리보는 정답&quot; &lt;&lt; correct_num &lt;&lt; endl;        //입력        int input_quiz_number;        cin &gt;&gt; input_quiz_number;        //출력 : true or false        (input_quiz_number == correct_num) ? cout &lt;&lt; &quot;true&quot; &lt;&lt; endl : cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;}"
20,"출처: 인프런 김영한님 스프링 웹 MVC 1편스프링에서 응답 데이터를 만드는 방법은 크게 3가지이다.1. 정적 리소스예) 웹 브라우저에 정적인 HTML, css, js을 직접 제공할 때 사용스프링 부트의 경우, 클래스패스의 다음 디렉토리에 있는 정적 리소스를 제공/static , /public , /resources , /META-INF/resourcessrc/main/resources 는 리소스를 보관하는 곳이고, 또 클래스패스의 시작 경로이다.따라서 다음 디렉토리에 리소스를 넣어두면 스프링 부트가 정적 리소스로 서비스를 제공한다.정적 리소스 경로src/main/resources/static다음 경로에 파일이 들어있으면src/main/resources/static/basic/my-form.html웹 브라우저에서 다음과 같이 실행하면 된다.http://localhost:8080/basic/my-form.html정적 리소스는 해당 파일을 변경 없이 그대로 서비스한다.2. 뷰 템플릿 사용예) 웹 브라우저에 동적인 HTML을 제공할 때는 뷰 템플릿을 사용한다.스프링 부트의 경우, 타임리프 템플릿 엔진을 사용하여 뷰 템플릿을  작성할 수 있다.3. HTTP 메시지 사용HTTP API를 제공하는 경우에는 HTML이 아니라 데이터를 전달해야 하므로, HTTP 메시지 바디에JSON 등의 형식으로 데이터를 실어 보낸다.요즘 가장 많이 사용하는 방식추가로..PRG 패턴HTTP API를 사용하지 않는 경우에, PRG 패턴을 많이 사용한다.PRG 패턴이란 Post/Redirect/Get 패턴으로, Post 요청 이후 새로고침 시 같은 Post 요청이 또 반복해서 일어나는 문제를 보완하기 위한 패턴이다. 따라서 Post 요청을 처리한 후 Redirect를 통해 다른 페이지를 Get하여 화면에 보여준다. 이 패턴을 많이 사용한다고 강사님께서 말씀해주셨는데 토이 프로젝트를 하면서 쓴 적이 없고 또 생소했기 때문에 더 찾아보았다. 그 결과 HTTP API를 사용하지 않는 경우에 많이 사용한다고 결론지을 수 있었다. 요즘 REST API로 개발이 많이 이루어지기 때문에, 이렇게 API 통신을 할 경우엔 PRG 패턴이 필요하지 않다."
21,"출처 : 인프런 스프링 MVC 1편 김영한님 강의HTTP 요청 메시지를 통해 클라이언트에서 서버로 데이터를 전달하는 방법에는 크게 3가지 종류가 있다.1. GET - 쿼리 파라미터/url?username=sue&amp;age=20위처럼 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달한다. 검색, 필터, 페이징등에서 많이 사용하는 방식이다.실제로 토이 프로젝트 진행 시 API 설계를 위해 프로그래머스 사이트에서 채용 조건 검색하는 부분을 참고해 보았는데, 쿼리 파라미터로 기술 스택을 검색/필터링하는 것을 확인할 수 있었다.이 사진에서 request URL이 https://programmers.co.kr/api/tags/auto_complete?term=pyth 임을 알 수 있다. term으로 pyth를 포함하는 모든 기술 스택을 검색하는 것 같다.2. POST - HTML Form이 경우에는 content-type: application/x-www-form-urlencoded메시지 바디에 1번의 경우처럼 쿼리 파리미터 형식으로 전달한다. 예) username=sue&amp;age=20예) 회원 가입, 상품 주문, HTML Form 사용여기서 내가 잘 몰랐던 부분은 Form Data로 요청할 경우는 GET, POST만 가능하다는 점이다. 토이 프로젝트 당시 HTML Form으로 구현되어 넘어오는 데이터를 PUT으로 기존 데이터를 수정하려고 API를 작성하는 중에, 이 강의 내용을 듣게 되어 알 수 있었다. 검색하니 정말 HTML 스펙 상 PUT, PATCH, DELETE 등의 요청은 불가능하다고 한다. (참고 블로그 : https://mangkyu.tistory.com/218) 3. HTTP message body에 데이터를 직접 담아서 요청요즘 가장 많이 사용하는 형식으로, HTTP API에서 주로 사용한다.JSON, XML, TEXT 형식을 지원한다.데이터 형식은 주로 JSON을 사용한다.POST, PUT, PATCH 등의 여러 메소드를 지원한다."
22,"들어가며장고를 이용해서 프로젝트를 진행했을 때, 웹 서버로 nginx를 이용하여 배포한 경험이 있다. 찾아보니 기본적으로 nginx는 동시 요청을 처리하기 위해 멀티 프로세스, 싱글 스레드 방식을 이용한다고 한다. 이후, 프로세스와 스레드의 개념과 스프링 부트에 내장되어 있는 톰캣에서는 동시 요청을 어떻게 처리하는지 궁금했다.프로세스 (Process)프로그램이 실행되어 돌아가고 있는 상태.컴퓨터로 한 번에 단 하나의 작업만 할 수 있으면 안 됨. ex) 메일을 전송하는 동안 검색을 할 수 없고 화면이 멈춰버린다면?그렇기 때문에 컴퓨터(CPU(프로세서))는 여러 프로세스를 함께 실행시킨다. 작업 관리자에 들어가보면 얼마나 많은 프로세스들이 동시에 진행되는지 볼 수 있음. 여러 프로세스를 함께 돌리는 방법은 동시성, 병렬성, 또는 두 성질을 함께 이용하는 방식으로 이루어짐.  동시성 (Concurrency)조금씩 여러 작업을 돌아가면서 진행하는 방법. 사람은 느낄 수 없는 속도로 Context Switching(진행중인 작업을 바꾸는 것)이 일어나 마치 동시에 일어나는 것처럼 느껴짐. Context Switching 하는 다양한 방법과 알고리즘이 있다.병렬성 (Parallelism)프로세서 하나에 코어 여러 개가 달려서 각각 동시에 작업들을 수행하는 것. (ex 듀얼 코어 쿼드코어 옥타코어 등 멀티코어 프로세서가 달린 컴퓨터에서 가능)프로세스의 메모리 구조스레드 (Thread)그런데 이런 멀티 프로세스 방식도 충분하지 않다! 웹 브라우저도 하나의 프로그램이기 때문에, 브라우저를 이용하는 동안 다운로드, 영상 시청, 웹 서핑 등의 다양한 작업을 동시에 할 수 있어야 함. ⇒ 한 프로세스 안에서도 여러 작업들이 동시에 진행되어야 함. ⇒ 멀티 스레드프로세스들은 컴퓨터의 자원을 분할해서 쓰지만 스레드는 프로세스마다 주어진 전체 자원을 함께 사용. → 속도 굿. 효율 굿.but, 공유 자원에 스레드 여러 개가 동시에 접근하면 에러! Thread-safe(여러 스레드로부터 동시 접근이 발생해도 프로그램 실행에 문제가 없는 것) 하도록 주의하자.Spring Boot 내장 Tomcat 웹 서버는?멀티 스레드 방식.일반적으로는 client 요청을 받으면 스레드를 생성하여 요청을 처리하지만, client가 많아질 수록 스레드 생성, 제거하는 비용 문제와 오버헤드가 발생따라서 톰캣은 Thread Pool 방식 이용. 미리 특정 갯수의 스레드를 스레드 풀에 만들어 두고, 가져다 씀. 클라이언트 요청이 풀에 있는 스레드 개수보다 많아지면 그 때 새로 스레드 생성. 스레드 재사용 가능하다는 장점. 적절한 Pool 개수가 중요.스프링은?기본적으로는 Thread-safe 하지 않다. 코드를 어떻게 짜느냐에 따라 다른 것이다!하지만 스프링 빈은 무상태로 설계하는 관행, 스프링 빈의 전역 변수에는 불변 객체를 사용하는 관행이 있다. 그렇기 때문에 Thread-safe해진 것.참고 영상https://www.youtube.com/watch?v=iks_Xb9DtTMhttps://www.youtube.com/watch?v=LLiV5Yz1AWg"
23,"스프링 입문 강의를 듣던 중, 웹 서버와 웹 어플리케이션 서버에 대한 개념이 부족한 것 같아 정리해보았다. 내용은 예전에 공부했던 네이버 부스트코스의 웹 프로그래밍 풀스택 강의 필기 내용을 참고했다.1. 웹 서버 (Web Server)웹 서버는 보통 소프트웨어를 말하지만, 웹 서버 소프트웨어가 동작하는 컴퓨터를 말하기도 한다.웹 서버의 가장 중요한 기능은 클라이언트가 요청하는 HTML 문서나 각종 리소스를 전달하는 것이다.리소스가 존재하지 않거나 문제가 발생하면 에러 메시지를 보낸다.웹 브라우저나 웹 크롤러가 요청하는 리소스는 컴퓨터에 저장되어 있는 정적인 데이터거나 동적인 결과가 될 수 있다.정적인 데이터: 이미지, HTML 파일, CSS 파일, JS 파일 등동적인 데이터: 웹 서버에 의해서 실행되는 프로그램을 통해서 만들어진 결과물웹 크롤러: 네이버 등의 검색 사이트에서 다른 웹 사이트 정보를 읽어갈 때 사용하는 소프트웨어1) 웹 브라우저와 웹 서버웹 브라우저가 웹 페이지를 요청하면 웹 서버는 웹 페이지를 응답한다.2) 웹 서버 소프트웨어의 종류가장 많이 사용하는 웹 서버는 Apache, Nginx, Microsoft, Google 웹 서버이다.Apache 웹 서버는 Apache Software Foundation에서 개발한 웹서버로, 오픈소스 SW이며 거의 대부분의 운영체제에서 설치 및 사용이 가능하다.Nginx는 차세대 웹 서버로 불리며 더 적은 자원으로 더 빠르게 데이터를 서비스하는 것을 목적으로 만들어진 오픈소스 SW이다.3) 클라이언트/서버 구조클라이언트는 서비스를 제공하는 서버에게 정보를 요청하여 응답 받은 결과를 사용한다.4) DBMSDatabase Management System다수의 사용자들이 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어DBMS는 주로 서버처럼 동작한다. → 때문에 DBMS에 접속해서 동작하는 클라이언트 프로그램이 한때 많이 생겼다. → 클라이언트 무거워지고 보안의 문제, 로직 변경시 매번 클라이언트 재배포 해야 하는 문제 등 여러 문제 발생 → 미들웨어 등장.5) 미들웨어 (MiddleWare)클라이언트 쪽에 비즈니스 로직이 많을 경우, 클라이언트 관리 (배포 등)로 인해 비용이 많이 발생하는 문제가 발생한다.비즈니스 로직을 클라이언트와 DBMS 사이의 미들웨어 서버에서 동작하도록 함으로써 클라이언트는 입력과 출력만 담당하도록 하였다.미들웨어: 클라이언트와 DBMS 사이에 또 다른 서버를 두는 방식.2. WAS (Web Application Server)WAS는 일종의 미들웨어로 웹 클라이언트 (보통 웹 브라우저)의 요청 중 보통 웹 애플리케이션이 동작하도록 지원하는 목적을 가진다.웹은 처음엔 정적인 컨텐츠만 보여줬다. 웹이 동적 컨텐츠도 보여줄 수 있도록 많은 기능을 요구받으면서 웹과 DBMS 사이의 미들웨어가 필요해졌는데 이런 미들웨어가 바로 WAS이다.WAS의 기본 기능 3가지프로그램 실행 환경과 DB 접속 기능을 제공여러개의 트랜잭션(논리적인 작업단위)을 관리한다.업무를 처리하는 비즈니스 로직을 수행한다.웹서버의 기능도 제공.3. 웹 서버 vs WASWAS도 보통 자체적으로 웹 서버 기능을 내장하고 있다.현재는 WAS가 가지고 있는 웹 서버도 정적인 컨텐츠를 처리하는데 있어서 성능 상 큰 차이가 없다.규모가 커질 수록 웹 서버와 WAS를 분리한다. 그 목적은 장애 극복 기능인 경우가 많다.주로 웹 서버는 정적 컨텐츠, WAS는 동적 컨텐츠를 웹 브라우저에게 전송웹 서버는 상대적으로 WAS보다 간단하게 구성되어있다. 앞단에 웹 서버를 두면 장애 극복 기능 UP참고웹 서버 vs. 애플리케이션 서버"
24,"스프링부트 입문 강의를 듣다 maven, gradle에 대한 내용이 짧게 언급되었다. (요즘엔 거의 gradle을 쓰면 된다는 내용) maven은 학교 수업에서 언젠가 과제할 때 본 적 있었고 gradle은 안드로이드 스튜디오에서 쓴 적 있었다. 하지만 둘의 역할이 무엇인지, 차이점이 무엇인지 잘 몰랐기 때문에 간단하게나마 알기 위해 찾아보았다.찾아보다가 보니, 기존에 python으로만 사이드 프로젝트 백엔드 개발을 해보았을 때 사용했던 python에서 venv, poetry 등과도 비슷하게 여겨졌다. 더해서, ant, make와도 유사한 점이 많다고 하여 각각 무엇인지 짧게 정리해보았다.들어가며개발자는 소프트웨어 도구를 사용하여 개발 활동을 보다 쉽고 관리 할 수 있다. 예를 들어, Sbt(Apache의 Maven 및 Ant 와 유사한 Scala 및 Java 프로젝트를 위한 오픈 소스 빌드 도구), Gradle 및 Visual Build(소프트웨어 개발자와 빌드 마스터가 소프트웨어 빌드 를 위한 자동화되고 반복 가능한 프로세스를 생성할 수 있도록 하는 Windows 용 GUI 소프트웨어)가 있다.1. makemake는 유닉스 계열 운영 체제에서 사용되는 프로그램 빌드 도구이다.2. AntAnt는 make와 비슷하지만 자바 언어에서 사용하는 자동화된 소프트웨어 빌드 도구이다.3. Maven Apache Ant와 Maven의 차이점은 Apache Ant는 소프트웨어 빌드 프로세스를 자동화하는 소프트웨어 도구이고 Maven은 소프트웨어 프로젝트 관리 도구라는 것이다. Maven은 소프트웨어 빌드 프로세스를 자동화하는 도구 그 이상이다. 전반적으로 Maven은 Ant보다 더 유연하다.4. Gradle그루비(Groovy): 자바에 파이썬, 루비, 스몰토크등의 특징을 더한 동적 객체 지향 프로그래밍 언어Gradle은 그루비를 이용한 빌드 자동화 시스템이다.Maven vs Gradle5. Poetry파이썬은 인터프리터 언어라 빌드 전 컴파일이 필요 없기 때문에 그런지 몰라도 자바의 gradle처럼 유명한 빌드 툴은 없는 것 같다. 그래도 찾아보니 Pybuilder라는 빌드 자동화 툴이 있긴 하다.조금 다르지만 유사한 역할을 하는 도구로는, 프로젝트 의존성 관리 도구 Poetry가 유명한 것 같다. Poetry와 유사하게는 venv도 쓸 수 있지만 둘 다 써본 바로는 Poetry가 더 자동화 되어 있고 편했다.(참고: https://www.reddit.com/r/Python/comments/luc1yb/what_do_python_programmers_use_as_an_alternative/)결론make, Ant, Maven, Gradle은 빌드 도구이다. Poetry는 의존성 관리 도구이다. 현재 Spring 개발을 위해서 찾아본 것이기 때문에 java 빌드 도구 중 가장 성능이 좋고 많은 기능을 제공하는 gradle을 쓰면 된다는 것만 기억하자. 이 글도 참고해보면 좋을 것 같다.What is the best alternative to Gradle?"
25,"엘리스 AI 트랙 10주차 - 4배포 전 준비 : .gitignore 설정배포 관련 에러 해결 및 배포배포 전 준비 : .gitignore 설정나는 그 전까진 어떤 걸 gitignore로 설정해야 하고 어떤 걸 올려야 할지 고민을 해본 적이 없어서 좀 막막했다. 그런데 좋은 사이트가 있었다. 내 개발 환경을 전달하면 알아서 gitignore을 만들어주는 사이트 : https://www.toptal.com/developers/gitignore두 번째 문제는 이미 내가 그 전에는 이걸 신경쓰지 않았기 때문에 원격 저장소에 gitignore로 관리해주어야 할 것들이 모두 올라가 있다는 것이었다. 이는 구글링으로 https://sustainable-dev.tistory.com/125 이렇게 하면 된다고 해서 시도했다.그런데 내가 올리고 싶지 않았던 폴더가 그대로 올라가있었다. 가상환경 디렉토리나 vscode 설정 디렉토리 등. 이 문제가 나는 gitignore가 동작하지 않는 거라고 생각하고 오랜 시간 구글링하고 삽질을 했다.그런데.. 그냥 내가 원격 저장소에 저장하지 않을 내용을 그냥 gitignore에 수동으로 추가해주니 간단하게 해결되었다. 이미 내 gitignore 파일에 .vscode/*라는게 이미 적혀있었는데 나는 저 코드가 .vscode 폴더를 포함한 하위 모든 파일을 무시하는 거라고 생각했는데, 아니었다. .vscode/를 추가해주니 해결되었다.배포  제일 많은 에러를 겪었다.vm에서 mysql 다시 테이블 및 스키마 설정csv 파일 읽어서 데이터 삽입 다시.. → excel의 mysql 도 못쓰고 코드로 해야하는 문제데이터베이스 이름 설정을 로컬에서 설정한 거랑 다르게 해서 다시 똑같이 맞춰주는 문제시도한 방법 : db를 이름만 변경하는 것이 단순한 일이 아니었다. 해당 링크처럼 dump 로 저장한 후에 새 데이터베이스에 데이터만 넣어주려고 했더니 오류 발생했다.(https://parkeunsang.github.io/blog/database/2021/02/11/mysql-database.html)오류는 나오지만 덤프는 받아진다는 글 : https://blog.boxcorea.com/wp/archives/2944그런데도 방법대로 안돼서 그냥 로컬에서 새로 코드를 짰다.import csvfrom datetime import date, datetimefrom dotenv import load_dotenvimport osimport mysql.connectorload_dotenv()mysql_pw = os.environ.get(&quot;MYSQL_PASSWORD&quot;)mydb = mysql.connector.connect(  host=&quot;localhost&quot;,  user=&quot;root&quot;,  password=mysql_pw,  database=&quot;elice_library&quot;)mycursor = mydb.cursor()beforeSQL = &quot;DELETE FROM books_tb;&quot;mycursor.execute(beforeSQL)mydb.commit()sql = &quot;INSERT INTO books_tb (book_name, publisher, author, publication_date, pages, isbn, description, link, img_path) VALUES(%s, %s, %s, %s, %s, %s, %s, %s, %s)&quot;with open('library.csv', 'r', encoding='UTF-8-sig') as f:    reader = csv.DictReader(f)    for row in reader:        publication_date = datetime.strptime(                        row'publication_date', '%Y-%m-%d').date()        img_path = f&quot;/book_img/{row'id'}&quot;        try:            open(f'../static/{img_path}.png')            img_path += '.png'        except:            img_path += '.jpg'        val = (row'book_name', row'publisher', row'author', publication_date, int(row'pages'), int(row'isbn'), row'description', row'link', img_path)        mycursor.execute(sql, val)    mydb.commit()    print(mycursor.rowcount, &quot;record inserted.&quot;)기타 오류오류 1 : 디렉토리 경로를 일부 정리하면서 하위 모듈에서 상위 폴더와 같은 위치의 다른 모듈 참조해야 하는 문제. → 참고 : https://jhryu1208.github.io/devlang/2020/11/17/dirimport/오류 2 : 인코딩 문제 (참고 : https://airpage.org/xe/language_data/20205)오류 3: key error → csv 파일에서 데이터가 없는 로우가 (, , , , ) 이런 식으로 저장되고 있었음 → 빈 문자열을 int 등의 형식에 맞추어 저장하려 하니 에러 남 → vscode에서 모두 지우고 주어진 데이터만 저장.오류 4 : 인코딩 문제 2 →엑셀에서 id로 저장해주었던 컬럼이 가져와지지 않는 문제 : https://github.com/clld/clldutils/issues/65 로 해결오류 5: **sudo python3 app.py** 할 때모듈이 없다 릴레이 → mysql이 없다 dotenv가 없다 flask_bcrypt가 없다....... 모두 새로이 다운로드 해주었음. 그런데도 flask_bcrypt는 계속 없다고 나옴 → 구글링을 계속 해서 3페이지까지의 모든 포스팅을 봤는데 모두 거의 같은 내용으로 설치 해주라고만 떴다.... 설치는 됐는데 계속 노 모듈이라고 오류 뱉음... → sudo를 붙이고 설치해주니까 됐음..유저 네임과 비밀번호 설정 등을 엘리스에서 준 id 와 비번으로 해야하는 줄 알고 잘못 설정해서 다시 해야했던 오류mysql 로그인 오류 참고 : https://passing-story.tistory.com/142나는 로컬에서 연결할 때 root로 설정해두었다 → root 비밀번호 변경 방법 : https://swpfun.tistory.com/701"
26,"엘리스 AI 트랙 10주차 - 4vscode 내장 터미널 보이지 않는 문제 해결 방법 탐구배포 전 준비 단계 (.env 파일 설정, 프로젝트 디렉토리 구조 정리 등)데이터분석 현직자 강의(2시간)vscode 내장 터미널이 보이지 않는 문제이 문제 해결로 거의 시간 보냄. 원래는 powershell로 설정되어 있고 + 버튼 옆의 셀렉트 박스를 누르면 git bash 등 여러 터미널을 설정할 수 있었는데, +를 눌렀을 때 아래와 같은 두 항목만 나왔음.    그냥 원인을 구글링 하고 따라해보아도 나타나지 않았음. 종료 후 재실행, vscode 삭제 후 재설치, 세팅에서 변경사항 리셋하기, terminal.integrated.inheritEnv를 true로 설정하기 등의 여타 해결법이 모두 해당 없었음. 그래서 일단 외부 터미널 열어서 작업 진행.    → 하루 후 다시 vscode 들어가서 외부 터미널로 작업하다가 갑자기 내장 터미널 떠서 해결됨. 이유는 아직도 모르지만 불규칙적으로 사라졌다가 등장한 문제가 있었음.배포 전 준비그대로 배포만 하면 되는 줄 알았는데 생각보다 신경써주어야 할 게 많았다. 공개적인 곳에 올라가는 만큼 내 개인적인 비밀번호 등의 정보등과 쓸데없는 폴더나 파일을 gitignore로 관리해주어야 했다. 어떤 걸 올리고 안올릴지 처음 생각해 보는 것이라 고민을 꽤나 많이 했다.비밀번호 등 .env 파일로 설정 (참고 : https://one-step-a-day.tistory.com/152). 방법이 config 파일 설정도 있었고 몇 가지 검색 결과가 있었는데 가장 먼저 이해된 게 .env 파일을 만드는 것이었다.프로젝트 구조 변경 시도 (파일 디렉토리 구조를 깔끔하게 정리하고 싶음)  → 문제 생길 가능성이 많아서 일단은 그대로 진행하기로 결정. 추후 유지보수 단계에서 수정하면 좋을 것 같다."
27,"엘리스 AI 트랙 10주차 - 3페이지네이션 구현별점 표시 수정UI 정리 (글꼴, 가로 세로 정렬, 색 정돈 등)줄바꿈 단어 단위로 하게 수정TIL페이지네이션방법 고민 1. &quot;왼쪽 버튼 1 2 3 4 5 오른쪽 버튼&quot; 이런 식으로 만들까? 생각하니 전체 책 데이터가 5페이지를 넘지 않아서 가능하지 않다.그러면 &quot;왼쪽 버튼 1 2 3 오른쪽 버튼&quot;으로 만들까? → 이 경우엔 &quot;1 2 3&quot; 이 부분을 동적으로 바꿔주는 것도 생각해야 한다. 현재 페이지가 가장 가운데로 오도록 할까? 아니면 그냥 그 자리에서 표시만 크게 또는 굵게 해줄까? &quot;1 2 3&quot; 자리에 몇 페이지부터 몇 페이지를 집어 넣을지는 어떻게 정할까? → 생각할 시간이 좀 더 필요한 방식. 현재 프로젝트 기간이 얼마 남지 않았으므로 다른 방식으로 먼저 구현하자.&quot;왼쪽 버튼 1 오른쪽 버튼&quot; 형식으로 구현하자. → 1 자리엔 현재 페이지 넘버가 표시된다.&lt;div id=&quot;pagenation&quot;&gt;  {% if page &gt; 0 %}  &lt;a href=&quot;{{ url_for('.home', page=page-1) }}&quot; id=&quot;left-btn&quot;&gt;◀&lt;/a&gt;  {% endif %}  &lt;p id=&quot;this-page&quot; style=&quot;display: inline; padding: 5px;&quot;&gt;&lt;b&gt;{{page+1}}&lt;/b&gt;&lt;/p&gt;  {% if page|int() != last_page|int() %}  &lt;a href=&quot;{{ url_for('.home', page=page+1) }}&quot; id=&quot;right-btn&quot;&gt;▶&lt;/a&gt;  {% endif %}&lt;/div&gt;코드 짜기까지 고민 : 1페이지에서는 왼쪽 버튼을 보여주지 않고, 마지막 페이지에서는 오른쪽 버튼을 보여주지 말자 → page 변수 값에 따라 변경. + last_page로 마지막 페이지인지 백엔드 코드에서 넘겨주었음. 페이지네이션 참고 : https://pythonq.com/so/python/119132    ```python    @board.route('/', defaults={'page': 0})    @board.route(&quot;/&lt;int:page&gt;&quot;)    def home(page):        if session.get('login') is None:            return redirect(&quot;/login&quot;)        else:            page_size = 8            books = db.session.query(Books)            last_page = math.ceil(len(books.all()) / page_size) - 1            if page_size:                books = books.limit(page_size)            if page:                books = books.offset(page*page_size).all()            return render_template(&quot;index.html&quot;, books = books, page=page, last_page=last_page)    ```    - route가 &quot;/&quot;뒤에 페이지 넘버가 붙기도 하고 안 붙기도 하는 문제 → 같은 함수를 두개의 라우팅 주소로 연결하는 것으로 해결. default로 page를 0으로 주어 &quot;/&quot;를 요청한 경우에 1페이지를 바로 보여줄 수 있게 했음.        route 참고 : https://stackoverflow.com/questions/13678397/python-flask-default-route-possible(https://stackoverflow.com/questions/13678397/python-flask-default-route-possible)    - sqlalchemy에서 페이지를 나누어 가져오기 위해 limit 함수와 offset 함수를 이용하여 해당 페이지의 데이터를 뽑아 전달해주었다.- 별점 표시 수정    - 아예 평점이 없어도 빈 별로 별점을 표시해주도록 기능을 수정했다. 간단한 파이썬 문법을 통해 구현할 수 있다. 추후에는 클릭으로 별점을 수정하는 기능을 넣으면 좋을 것 같다.    ```python    &lt;p class=&quot;stock&quot;&gt;{{&quot;★&quot;*book.rating_avg + &quot;☆&quot;*(5-book.rating_avg)}}&lt;/p&gt;    ```- 줄바꿈 단어 단위로 하게 수정(css)    참고 : https://www.codingfactory.net/10658(https://www.codingfactory.net/10658)    ```css    word-break: keep-all;    ```    - 원래는 jinja를 이용해서 아래처럼 글자가 15자 이상이면 여러줄로 바꿀까 생각 → 2줄이면 깔끔하지만 더 많이 줄바꿈이 일어나야 할 경우도 생긴다 → 그냥 위 방식으로 수정.        ```html        &lt;a href=&quot;{{ url_for('.bookInfo', book_id = book._id) }}&quot;&gt;          {% if book.book_name|length &gt; 15 %}            {% set split_len = book.book_name.split()|length %}          {% set name1 = book.book_name.split():split_len//2 %}          {% set name2 = book.book_name.split()split_len//2: %}          {{ name1|join(&quot; &quot;) }}          &lt;br /&gt;          {{ name2|join(&quot; &quot;) }}          {% else %}          {{ book.book_name }}          {% endif %}        &lt;/a&gt;        ```        - jinja2에서도 join을 쓸 수 있다.        참고 : https://stackoverflow.com/questions/2061439/string-concatenation-in-jinja(https://stackoverflow.com/questions/2061439/string-concatenation-in-jinja)결과 화면"
28,"엘리스 AI 트랙 10주차 - 2comment 권한이 있으면 수정하는 기능 추가comment 권한이 있으면 삭제하는 기능 추가UI 일부 정리TILcomment 권한이 있으면 수정하는 기능 추가엘리스 실습 코드를 참고해서 변형했다. → 로그인 한 user가 그 댓글의 user이면 jinja2 를 이용하여 보여준다. html과 js, jinja2 사용법이 헷갈려서 찾아보느라 시간이 조금 걸린 것 같다. html코드에서 js 함수로 jinja2를 이용한 매개변수 여러 개를 넘기는 방법은 아래와 같았다.       {% if g.user._id == comment.user_id %}        &lt;div id=&quot;edit-delete-btns&quot;&gt;          &lt;a href=&quot;#&quot; onclick=&quot;updateComment('{{comment._id}}', '{{book._id}}');return false;&quot; id='editBtn{{comment._id}}'&gt;수정하기&lt;/a&gt;          &lt;a href=&quot;#&quot; onclick=&quot;deleteComment('{{comment._id}}', '{{book._id}}');return false;&quot; id='deleteBtn{{comment._id}}'&gt;삭제하기&lt;/a&gt;          &lt;/div&gt;        {% endif %}javascript로 임시 html을 만들어 해당 댓글의 본문을 input박스와 별점 체크 select 태그를 이용해서 바꾸어 주는 부분이다.            function updateComment(commentId, bookId) {              let rating = $(`#user-rating${commentId}`).text()              let content = $(`#user-comment${commentId}`).text()              let tmpHtml = `&lt;form class=&quot;row g-2&quot; action=&quot;#&quot; onsubmit=&quot;postUpdateComment(${commentId}, ${bookId}); return false;&quot;&gt;                                &lt;div class=&quot;col-md-7&quot;&gt;                                  &lt;label for=&quot;inputCity&quot; class=&quot;form-label&quot;&gt;댓글 수정&lt;/label&gt;                                  &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;userEidContent${commentId}&quot;&gt;                                &lt;/div&gt;                                &lt;div class=&quot;col-md-3&quot;&gt;                                  &lt;label for=&quot;rating&quot; class=&quot;form-label&quot;&gt;평가하기&lt;/label&gt;                                  &lt;select id=&quot;user-rating${commentId}&quot; class=&quot;form-select&quot;&gt;                                    &lt;option selected disabled hidden&gt;별점을 선택하세요.&lt;/option&gt;                                    &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;                                    &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;                                    &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;                                    &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt;                                    &lt;option value=&quot;5&quot;&gt;5&lt;/option&gt;                                  &lt;/select&gt;                                &lt;/div&gt;                                &lt;div class=&quot;col-12&quot;&gt;                                  &lt;button type=&quot;submit&quot; class=&quot;btn btn-warning&quot;&gt;수정 완료&lt;/button&gt;                                &lt;/div&gt;                              &lt;/form&gt;`              $(&quot;#edit-area&quot;).empty()              $(&quot;#edit-area&quot;).append(tmpHtml)              $(`#editBtn${commentId}`).hide()              $(`#deleteBtn${commentId}`).hide()              $(`#userEidContent${commentId}`).val(content)              $(`#user-rating${commentId}`).children().first().text(rating.length)            }기존의 댓글을 수정하는 요청은 PATCH로 했다. 그 부분만 수정하는 것이므로!댓글과 평점이 제대로 입력되었는지 먼저 확인하고 ajax로 데이터를 담아 수정 요청을 보낸다.오류 핸들링 : 처음에는 comment와 star_rating이 &quot;&quot;인지 검사를 했는데 comment는 아무 입력을 받지 않았는지 상태 검사를 &quot;&quot;로 할 수 있지만, select 태그를 이용한 셀렉트 박스 기능은 아무 선택도 하지 않은 경우 val을 가져오면 null값으로 설정되어 있다.            function postUpdateComment(commentId, bookId) {              let star_rating = $(`#user-rating${commentId}`).val()              let comment = $(`#userEidContent${commentId}`).val()              if (comment == &quot;&quot; || star_rating == null) {                  alert(&quot;댓글과 평점은 필수 항목입니다.&quot;);                  return;              }              $.ajax({                  url: '/info/'+bookId,                  type: 'PATCH',                  data: {                      &quot;comment_id&quot;: commentId,                      &quot;comment&quot;: comment,                      &quot;star_rating&quot;: star_rating,                  },                  success: function (res) {                      if (res'result' == 'success') {                          alert(&quot;수정되었습니다.&quot;)                          window.location.reload()                      }                  }              })            }백엔드 코드받아온 데이터 이용하여 수정할 코멘트 db에서 검색. 코멘트와 별점, 수정한 시각 수정 후 db에 적용한다.        @board.route(&quot;/info/&lt;int:book_id&gt;&quot;, methods=&quot;GET&quot;, &quot;POST&quot;, &quot;PATCH&quot;, &quot;DELETE&quot;)        def bookInfo(book_id):        # ... 중략 ...            elif method == &quot;PATCH&quot;:                  # 댓글 수정                  comment_id = request.form'comment_id'                  comment = request.form'comment'                  star_rating = request.form'star_rating'                  comment_to_edit = Comment.query.filter(Comment._id == comment_id).first()                  comment_to_edit.comment = comment                  comment_to_edit.star_rating = star_rating                  comment_to_edit.created_at = datetime.now()                  db.session.commit()                  return jsonify({&quot;result&quot;: &quot;success&quot;})comment 권한이 있으면 삭제하는 기능 추가삭제는 아래 코드처럼 비교적 간단하게 구현할 수 있다.여기서 오류가 발생했던 부분은 comment id와 book id를 구분하지 않아서 오류가 생겼었다. 생각해보면 url에 나와야 하는 부분은 book에 대한 정보이니 book id가, 삭제할 데이터는 해당 코멘트를 특정지어야 하므로 comment id가 되어야 한다.    function deleteComment(commentId, bookId) {          $.ajax({              url: '/info/'+bookId,              type: 'DELETE',              data: {                  'id': commentId,              },              success: function (res) {                  if (res'result' == 'success') {                      alert(&quot;삭제되었습니다.&quot;)                      window.location.reload()                  } else {                      alert(&quot;삭제 실패&quot;)                  }              }          })        }백엔드 코드db에서 해당 코멘트 삭제한다!    @board.route(&quot;/info/&lt;int:book_id&gt;&quot;, methods=&quot;GET&quot;, &quot;POST&quot;, &quot;PATCH&quot;, &quot;DELETE&quot;)    def bookInfo(book_id):        # ... 중략 ...        else:            # 댓글 삭제            id = request.form&quot;id&quot;            Comment.query.filter(Comment._id == id).delete()            db.session.commit()            return jsonify({&quot;result&quot;: &quot;success&quot;})"
29,"엘리스 AI 트랙 10주차 - 1comment 테이블 추가책 상세 페이지 구현상세 페이지에서 댓글 남기기 기능 구현댓글 내용과 평점 null인 경우 댓글 등록 금지 기능 구현메인 페이지에서 평균 평점 보여주는 기능 구현이메일 중복 체크, 유효한 이메일 형식 체크이름 유효한 형식 체크비밀번호 유효한 형식 체크현재 대여중인 책 중복으로 빌리지 못하게 하는 기능 추가대여 기록 페이지 구현TIL1. comment 테이블 추가    mysql&gt; create table `comment_tb`(        -&gt; _id int primary key auto_increment not null,        -&gt; user_id int not null,        -&gt; book_id int not null,        -&gt; comment text,        -&gt; star_rating int not null,        -&gt; created_at date,        -&gt; foreign key(user_id) references user_tb(_id) on update cascade,        -&gt; foreign key(book_id) references books_tb(_id) on update cascade);상세 페이지에서 댓글을 남기면 기록할 comment 테이블을 추가했다. 내용 없이 별점만 남기는 경우가 많아서 별점만 not null로 만들었는데, 제약 조건을 다시 보니 댓글 내용도 null 이 아니어야 해서 alter로 수정했다.(참고 : https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&amp;blogId=siiyoo&amp;logNo=70133007298)mysql&gt; alter table comment_tb modify comment text not null;제약 조건에 댓글을 보여줄 때 최신순으로 보여주는 기능이 있어서, date보다는 datetime으로 저장하는 게 나을 것 같아서 수정했다.mysql&gt; alter table comment_tb modify created_at datetime;같은 내용 python sqlalchemy 테이블이다. 이 코드를 만들기 전에 자꾸 오류가 났었다. db.Datetime이 없다고 오류가 나서 구글링을 또 한참 열심히 했다. 결론은 db.DateTime이다. 대문자 한 끝 차이였다. 조심하자. (참고 : https://stackoverflow.com/questions/62262102/attributeerror-sqlalchemy-object-has-no-attribute-datetime)```pythonclass Comment(db.Model):    __tablename__='comment_tb'    # 1. 작성자 2. 책id 3. 내용 4. 별점 5. 작성일    _id = db.Column(db.Integer, primary_key=True, nullable=False, autoincrement=True)    user_id = db.Column(db.Integer, db.ForeignKey('user_tb._id'), nullable=False)    book_id = db.Column(db.Integer, db.ForeignKey('books_tb._id'), nullable=False)    comment = db.Column(db.Text, nullable=False)    star_rating = db.Column(db.Integer, nullable=False)    created_at = db.Column(db.DateTime, default=datetime.utcnow)    def __init__(self, user_id, book_id, comment, star_rating):        self.user_id = user_id        self.book_id = book_id        self.comment = comment        self.star_rating = star_rating```- mysql에서 테이블 전체 데이터 삭제하는 방법    ```sql    delete from mytable;    ```2. 책 상세 페이지 구현 &amp; 3. 상세 페이지에서 댓글 남기기 기능 구현책 이름 누르면 상세 페이지로 가게 url_for 이용→ 여기서 url을 어떤 식으로 넘겨줄지 많은 고민과 에러와 싸운 끝에 다음처럼 구현.(참고 : https://flask.palletsprojects.com/en/2.0.x/api/#flask.url_for)&lt;h5 class=&quot;book-name&quot;&gt;&lt;a href=&quot;{{ url_for('.bookInfo', book_id = book._id) }}&quot;&gt;{{ book.book_name }}&lt;/a&gt;&lt;/h5&gt;info.html은 bootstrap에서 테이블 형식, form 태그 형식 등을 가져와서 구현했다. (참고 : https://getbootstrap.com/docs/5.1/forms/layout/)백엔드 코드는 다음과 같다. 라우팅을 restful하게 작성해보았다. (참고 : https://velog.io/@wody/Flask-Tutorial)요청이 get일 땐 info.html에서 해당 책의 모든 정보와 댓글들을 불러온다.요청이 post일 땐 댓글 추가하면서 해당 책의 평균 평점도 계산해서 db에 반영한다.평균 평점은 round 함수를 통해 반올림해주었다.평균 평점을 구하기 위해 sqlalchemy에서 avg 함수를 어떻게 쓰는지 알아보았다.from sqlalchemy import func 를 추가한다.ratings = db.session.query(db.func.avg(Comment.star_rating).label(&quot;rating_avg&quot;)).filter(Comment.book_id==book_id).first() 처럼 db.func.avg 형태로 쓸 수 있다. label을 추가하면 sql에서 as로 alias 설정(별명지어주는 기능)과 같다.avg, min, max 등 사용법 참고 : https://www.py4u.net/discuss/149852sqlalchemy 이용법 참고 : https://lowelllll.github.io/til/2019/04/19/TIL-flask-sqlalchemy-orm/sqlalchemy에서 alias 설정 방법 : https://stackoverflow.com/questions/9187530/using-alias-for-select-as-in-sqlalchemy@board.route(&quot;/info/&lt;int:book_id&gt;&quot;, methods=&quot;GET&quot;, &quot;POST&quot;)def bookInfo(book_id):   book = Books.query.filter(Books._id==book_id).first()   if request.method == &quot;GET&quot;:       # 책 정보 모두, 댓글 정보 모두       comments = Comment.query.filter(Comment.book_id==book_id).order_by(Comment.created_at.desc()).all()       return render_template(&quot;info.html&quot;, book=book, comments=comments)   else:       # 댓글 추가 -&gt; comment 테이블에 값 추가       commenter = request.form'commenter'       book_id = request.form'book_id'       comment = request.form'comment'       star_rating = request.form'star_rating'       c = Comment(commenter, book_id, comment, star_rating)       db.session.add(c)       db.session.commit()       ratings = db.session.query(db.func.avg(Comment.star_rating).label(&quot;rating_avg&quot;)).filter(Comment.book_id==book_id).first()       book.rating_avg = round(ratings.rating_avg)       db.session.commit()       return jsonify({&quot;result&quot;: &quot;success&quot;})4. 댓글 내용과 평점 null인 경우 댓글 등록 금지 기능 구현댓글 등록하기 버튼을 누르면 실행되는 javascript 함수에서 아래처럼 검사한다.let comment = $(&quot;#comment&quot;).val()let star_rating = $(&quot;#star-rating&quot;).val()if (comment == '' || star_rating == '') {   alert(&quot;댓글과 평점은 필수 항목입니다.&quot;);   return;}5. 메인 페이지에서 평균 평점 보여주는 기능 구현본문 사이에 아래와 같이 추가해서 간단하게 구현했다. python에서 문자열 곱하기 기능을 이용했다.&lt;p class=&quot;stock&quot;&gt;{{&quot;★&quot;*book.rating_avg}}&lt;/p&gt;6. 이메일 중복 체크, 유효한 이메일 형식 체크유효한 이메일 형식은 구글링으로 정규표현식을 이용해서 처리했다.유효한 이메일 정규표현식 참고 : https://www.w3resource.com/javascript/form/email-validation.php정규 표현식 참고 : https://heropy.blog/2018/10/28/regexp/Uncaught TypeError: Cannot read properties of undefined (reading 'match') 에러 해결 : 위의 정규표현식 참고 페이지에서 복사해서 사용하니 이런 에러가 나왔다. 이는 if문 내부에 input.value.match(mailformat)으로 설정되어 있던 코드에서 value를 지워주니 해결되었다.function validateEmail(inputText)   {       let mailformat = /^\w+(\.-?\w+)*@\w+(\.-?\w+)*(\.\w{2,3})+$/;       if(inputText.match(mailformat))       {           return true;       }       else       {           alert(&quot;유효하지 않은 이메일입니다.&quot;);           return false;       }   }이메일 중복 체크는 백엔드 코드에서 다음처럼 이미 해당 email을 사용하는 user가 있는지 검사한다. 이미 있으면 duplicate라는 결과 값을 넘겨주었다.user = User.query.filter(User.email == user_email).first()if user is not None:   return jsonify({&quot;result&quot;: &quot;duplicate&quot;})받은 결과로 알림을 띄워준다. (ajax 내부 코드)success: function (res) {   if (res'result' == 'success') {       alert(&quot;회원가입 성공!&quot;);       window.location.href = '/'   }   else if (res'result' == 'duplicate'){       alert(&quot;중복된 아이디입니다.&quot;);       window.location.reload()   }}7. 이름 유효한 형식 체크구글링으로 한글 또는 영문인지 검사하는 정규표현식을 이용했다.참고 : https://codingbroker.tistory.com/119function validateName(inputText){   const regex = /^ㄱ-ㅎ|가-힣|a-z|A-Z|+$/;   if(inputText.match(regex)){       return true;   }   else{       alert(&quot;이름은 영문 또는 한글만 입력 가능합니다.&quot;);       return false;   }}8. 비밀번호 유효한 형식 체크개인정보 보호조치 기준에 맞추어 영문, 숫자, 특수문자 3종류 이상을 조합하여 최소 8자리 이상의 길이인지 확인하는 정규표현식을 이용했다. 영문은 대소문자 구분 없이 포함하게 했다. 아래 링크들을 참고하여 구현하였다.유효한 비밀번호 정규표현식 참고 : https://velog.io/@broccoliindb/password-validation-javascript참고 2 : https://stackoverflow.com/questions/12090077/javascript-regular-expression-password-validation-having-special-charactersfunction validatePW(inputText){  var strongRegex = new RegExp(&quot;^(?=.*a-zA-Z)(?=.*0-9)(?=.*!@#\$%\^&amp;\*)(?=.{8,})&quot;);  if(inputText.match(strongRegex)){      return true;  }  else{      alert(&quot;영문, 숫자, 특수문자를 모두 포함하여 8자리 이상의 비밀번호를 입력하세요.&quot;);      return false;  }}9. 현재 대여중인 책 중복으로 빌리지 못하게 하는 기능 추가백엔드 코드 : 현재 대여중인 책은 아직 반납일이 기록되지 않아 null 값이다. 따라서 반납일이 아직 설정되지 않은 같은 책이라면 중복이라고 결과를 전달한다.TypeError: 'BaseQuery' object is not callable 에러가 나서 Querying with function on Flask-SQLAlchemy model gives BaseQuery object is not callable error  해당 링크를 참고하여 해결했다.same_book = db.session.query(Rent).filter(Rent.book_id==book_id, Rent.user_id==user_id, Rent.return_date==None).first()if same_book is not None:   return jsonify({&quot;result&quot;: &quot;duplicated&quot;})프론트 코드에서 ajax의 success 결과를 받아 다음 코드를 넣어주었다.else if (result == &quot;duplicated&quot;) {   alert(&quot;이미 대여한 책입니다.&quot;)}10. 대여 기록 페이지 구현html 코드는 거의 return 페이지와 유사하다.백엔드 코드도 return 부분과 비슷한데 다른 점 한가지는 반납일 컬럼 값이 null 값이 아니어야 반납된 책이다. 따라서 이미 반납된 책만 불러와야 한다. sqlalchemy에서 다음처럼 null값 검사를 할 수 있다. filter 내부에 Rent.return_date.isnot(None) 형식으로 조건을 줄 수 있다. Rent.return_date!=None은 에러가 발생한다.(참고 : https://stackoverflow.com/questions/21784851/sqlalchemy-is-not-null-select)records = db.session.query(Books.img_path, Books.book_name, Books._id, Books.rating_avg, Rent.rent_date, Rent.return_date).filter(Books._id==Rent.book_id, Rent.user_id==g.user._id, Rent.return_date.isnot(None)).all()대여 기록 페이지 결과 화면"
30,"엘리스 AI 트랙 9주차 - 5Rent 테이블 스키마 구상 및 생성 (mysql, python sqlalchemy)대여하기 기능 구현반납하기 페이지 구현반납하기 기능 구현Rent 테이블 스키마 구상 및 생성 (mysql, Flask sqlalchemy)  mysql&gt; create table `rent_tb`(      -&gt; _id int primary key auto_increment not null,      -&gt; user_id int not null,      -&gt; book_id int not null,      -&gt; rent_date date,      -&gt; due_date date,      -&gt; foreign key(user_id) references user_tb(_id) on update cascade,      -&gt; foreign key(book_id) references books_tb(_id) on update cascade);  Query OK, 0 rows affected (0.30 sec)maria db에서는rent_date date default current_date 의 형태로 지정하면 된다는 글을 보고 시도해 보았지만 에러가 났다.(https://stackoverflow.com/questions/20461030/current-date-curdate-not-working-as-default-date-value)mysql에서는 date를 데이터 삽입하는 당일로 default를 설정하는 방법을 구글링해도 잘 모르겠어서 default 값 설정을 따로 하지 않았다. 일단 데이터 삽입은 mysql cli로 바로 하는 것이 아닌 Flask 에서 할 것이기 때문에 가능한 일이었다.# models.pyclass User(db.Model):  __tablename__ = 'user_tb'  _id = db.Column(db.Integer,  primary_key=True,                 nullable=False, autoincrement=True)  name = db.Column(db.String(20), nullable=False)  email = db.Column(db.String(30), nullable=False, unique=True)  pw = db.Column(db.String(200), nullable=False)  renter = db.relationship(&quot;Rent&quot;, backref='user_tb')  def __init__(self, user_name, user_email, user_pw):      self.name = user_name      self.email = user_email      self.pw = user_pwclass Rent(db.Model):  __tablename__='rent_tb'  _id = db.Column(db.Integer, primary_key=True, nullable=False, autoincrement=True)  user_id = db.Column(db.Integer, db.ForeignKey('user_tb._id'), nullable=False)  book_id = db.Column(db.Integer, db.ForeignKey('books_tb._id'), nullable=False)  rent_date = db.Column(db.Date, default=date.today)  due_date = db.Column(db.Date, default=date.today()+timedelta(days=14))  return_date = db.Column(db.Date)  def __init__(self, user_id, book_id):      self.user_id = user_id      self.book_id = book_id이 코드를 짜기까지 수많은 에러와 구글링을 겪었다. sqlalchemy로 foreign key 설정하는 방법을 잘 몰라서 조금 오래 걸렸다. 찾아볼 때 db.ForeignKey, ForeignKey, foreign_key 등 여러 비슷한 코드가 나왔는데 저것만 설정하는 것이 아닌 참조 받는 테이블에서도 relationship이라는 걸 설정해줘야 했다. renter = db.relationship(&quot;Rent&quot;, backref='user_tb') 이런 식으로!! 괄호 안에는 참조하는 테이블, 참조받는 테이블의 실제 db상 이름을 넣어주었다. → 엘리스 11/11일 실시간 강의 코드를 많이 참고했다. 또, Rent 테이블에서 foreign key 설정할 때 nullable=False를 제일 뒤로 빼줘야 오류가 없었다. (그 전에 났던 오류 : https://stackoverflow.com/questions/59626077/positional-argument-after-keyword-argument-and-regular-parameter-after-paramet)due date를 14일 뒤로 설정해주고 싶었다. 이는 date와 timedelta의 덧셈으로 해결할 수 있었다. (참고한 글 : https://wangin9.tistory.com/entry/datetime)대여하기 기능 구현  function rentBook(bookId){          let renter = `{{g.user._id}}`          $.ajax({              url: '/rent',              type: 'patch',              data: {                  'book_id': bookId,                  'renter': renter,              },              success: function (res){                  let result = res'result'                  if (result == &quot;success&quot;) {                      alert(&quot;대여 완료!&quot;)                      window.location.reload()                  } else if (result == &quot;disable&quot;) {                      alert(&quot;현재 대여가 불가능한 책입니다.&quot;)                  } else {                      alert(&quot;문제가 생겼어요. 다시 시도해 주세요.&quot;)                  }              }          });  @board.route(&quot;/rent&quot;, methods=&quot;PATCH&quot;)  def rent():      book_id = request.form'book_id'      book = Books.query.filter(Books._id==book_id).first()      if book.stock &gt; 0:          book.stock -= 1          db.session.commit()          user_id = request.form'renter'          rent = Rent(user_id, book._id)          db.session.add(rent)          db.session.commit()          return jsonify({&quot;result&quot;: &quot;success&quot;})      return jsonify({&quot;result&quot;: &quot;disable&quot;})&lt;a href=&quot;#&quot; onclick=&quot;rentBook('{{ book._id }}'); return false;&quot; class=&quot;btn btn-primary&quot;&gt;대여하기&lt;/a&gt; 를 통해 대여하기 버튼을 누르면 rentBook 함수가 실행된다. return false;를 붙여 href로 연결된 링크로 이동하지 않게 했다. (참고 : https://ggmouse.tistory.com/418) rentBook 함수에서 책 id와 빌리는 사람을 전달해주어 Rent 테이블에 새로운 값으로 넣어주었다. 책의 재고를 확인해서 1을 빼주는 작업도 처리했다.반납하기 페이지 구현  반납하기 페이지도 메인 페이지와 거의 유사한 형태이다. 하지만 여기서 까다로웠던 부분은 user가 빌린 책의 이미지, 책 이름, 빌린 날짜를 보여주어야 하는데 이는 여러개의 테이블에 나눠져 있는 정보이다. 따라서 orm 쿼리를 짜는 게 조금 어려웠다. 하지만 records = db.session.query(Books.img_path, Books.book_name, Books._id, Rent.rent_date).filter(Books._id==Rent.book_id, Rent.user_id==g.user._id, Rent.return_date==None).all() 이렇게 해결했다.   (sqlalchemy 관련 참고하기 좋은 글 : https://lowelllll.github.io/til/2019/04/19/TIL-flask-sqlalchemy-orm/)  반납하기 기능 구현  반납하기 버튼을 누르면 Rent 테이블에 저장되어 있던 데이터 중에 해당 user가 빌린 그 책의 return_date를 오늘로 업데이트 해야 한다. 분명 Flask에서 처리를 했는데 (datetime 라이브러리의 date.today() 이용) 아무리 db에서 확인해도 null값이길래 왜 그런지 헤매다가 이유를 찾았다. db.session.commit()을 안했던 것.. ㅋㅋㅋ 바보같은 실수였지만 발생할 수 있는 실수이므로 앞으로 주의해야겠다.현재까지 결과https://oceanic-sesame-1f5.notion.site/434d494e42fe494093d764d7e64ba6c7"
31,"엘리스 AI 트랙 9주차 - 4메인 페이지 구현books_tb 스키마 수정TILmain 페이지 구현과 books_tb 스키마 수정오늘의 오류 해결 과정books_tb에 재고(stock)를 추가해야 했다. 구글링 후 아래처럼 하니 기존에 있던 모든 데이터에 stock 컬럼 값이 1로 추가되었다.  ALTER TABLE `books_tb` ADD `stock` INT DEFAULT 1;    확인해본 결과! 모든 재고가 1로 저장 됨.html img 태그로 로컬에 저장되어 있는 파일을 불러오려고 아래와 같이 시도했다. 하지만 어림없지! 오류 발생.  &lt;img src=&quot;'{{book.img_path}}'&quot; alt=&quot;책 이미지&quot;&gt;&lt;내가 추측해본 오류의 원인 세가지&gt;jinja 템플릿 문법을 내가 잘 몰라서 발생한 오류 url 주소에 띄어쓰기가 포함되어 있어서 잘 못 읽어오는 것 구글링 해보니 flask에선 static 폴더 내부에 이미지 파일을 저장해야 불러올 수 있다고 해서 발생한 오류내 경우에는 3번이었다. 일단은 설명부터.  내 데이터베이스에는 img_path가 아래 사진처럼 저장되어 있었다.    여기서 내가 잘못 생각하고 있던 몇가지...나는 저 path를 url이라고 생각했다... 그런데 url이 아니라 uri라고 한다. (친구한테 오류 물어보다가 url이라구 말했는데 친구가 못알아듣고 내가 아? 저건 url이 아닌가? 하고 바로 구글링 후 아닌 걸 깨달음.)        **&lt;url과 uri 차이&gt;**        https://blog.naver.com/wishket/222475083068(https://blog.naver.com/wishket/222475083068) 참고           따라서 데이터베이스 테이블 컬럼 이름인 img_url은 틀린 것. → img_path로 변경했다.           !(https://images.velog.io/images/sue/post/9a346808-5dc9-45da-b36a-7fca3ab0c55b/image.png)           이어서 파이썬에서 models.py(http://models.py)의 테이블도 수정했다.           !(https://images.velog.io/images/sue/post/d6f2da83-5aca-4758-b1bc-5e0c506c6870/image.png)        2. 나는 static 폴더 내부에 이미지를 저장하면 프로젝트 폴더가 너무 용량이 커져서 왠지 모르게 부하가 생기거나 성능이 나빠질 거라고 생각했다. 그래서 구글링 할 때 왜 자꾸 사람들이 static 폴더에 넣는 방법만 썼지? 하면서 혼자 이해 못하고 있었다. 하지만 여기서 또 잘못 생각한점... 서버가 이미지를 전달해주려면 당연히 서버를 돌리는 프로젝트 폴더 내에 있어야 한다.. ㅠㅠ 그게 싫으면 CDN이라는 걸 사용하면 된다. (CDN이란 ? 참고 자료 : https://www.akamai.com/ko/our-thinking/cdn/what-is-a-cdn) 다른 로컬 환경에 저장되어 있으면 보안상의 문제 때문에 접근할 수 없게 막아둔게 당연한 거였다.&lt;br&gt;&lt;br&gt;      그래서 고친 방법.         1. static 폴더 내부에 모든 이미지 저장         2. db에서 img_path 수정            !(https://images.velog.io/images/sue/post/803e0e8e-4234-4417-8cce-822a08eec34a/image.png)        3. 아래 코드로 수정.        ```html        &lt;img src=&quot;{{ url_for('static', filename = book.img_path) }}&quot; alt=&quot;책 이미지&quot;&gt;        ```css 조금 적용한 후 결과 화면"
32,"엘리스 AI 트랙 9주차 - 3python으로 img url 데이터 mysql에 삽입회원가입 기능 구현로그인, 로그아웃 기능 구현TIL예전에 엘리스 실습에서 진행했던 회원가입, 로그인, 로그아웃 코드 활용하여 세 가지 기능 구현. &lt;Error 해결 로그&gt;User 테이블에서 저장하는 내용이 다르므로 맞추어 User 테이블 구성. (기존 id, pw -&gt; 현재 name, email, pw)1번으로 파생된 변수명으로 인한 오류 해결 (api.py, models.py User 테이블 init 함수, 회원가입/로그인 html 파일의 ajax post 요청 등)bcrypt로 암호화하여 pw 저장하면서 글자 수가 너무 길어짐 : 기존에 생각했던 데이터 타입을 벗어나는 형태 -&gt; alter로 타입 변경타입 변경 후 회원가입 진행.  user 데이터 다시 조회하면 아래처럼 나옴.python으로 img url 데이터 mysql에 삽입(기존 데이터에 img_url 컬럼 값만 변경하기)import mysql.connectormydb = mysql.connector.connect(  host=&quot;localhost&quot;,  user=&quot;유저&quot;,  password=&quot;비밀번호&quot;,  database=&quot;elice_library&quot;)mycursor = mydb.cursor()sql = &quot;UPDATE books_tb SET img_url=%s WHERE _id=%s&quot;path = &quot;C:/ProgramData/MySQL/MySQL Server 8.0/Uploads/book_img&quot;data_cnt = 32for i in range(1, data_cnt+1):    new_path = path + '/'+str(i)    try:        open(f'{new_path}.png')        new_path += '.png'    except:        new_path += '.jpg'    val = (new_path, i)    mycursor.execute(sql, val)mydb.commit()print(mycursor.rowcount, &quot;record inserted.&quot;)books_tb의 _id인 132에 해당하는 그림이 같은 디렉토리에 132로 저장되어 있어서, 어제 엑셀로 데이터 삽입할 때 같이 수동으로 넣어줄까 하다가 python으로 삽입. png와 jpg를 선택하는 문제는 try except문으로 해결."
33,"엘리스 AI 트랙 9주차 - 2파이썬 가상 환경(venv) 세팅엑셀 파일 데이터를 mysql table에 삽입models.py에서 모델 Books 생성TIL아래 실시간 강의 때 필기한 내용을 보며 파이썬 가상 환경(venv)으로 작업하려고 세팅실패 해결 기록                          pip를 21.3.1로 업그레이드 하라는 위의 warning 해결 시도    → 에러 로그에서 user 를 붙이라고 해서, 붙여 시도    → 에러 로그 구글링하여 아래 글 시도  https://littlewether.blogspot.com/2018/12/pylint-install-can-not-perform-user.html  → 여전히 오류    → 또 구글링 후 발견한 방법    → 시도하니 성공하긴 했는데 이미 내가 요구한 게 적용되어 있다는 로그. 왜 그런지는 알 수 없지만 확인해보니 진짜 적용되어 있음. &lt;br&gt;   &lt;br&gt;- 어제 실패한 엑셀 파일 데이터를 mysql table에 삽입    - 실패 해결 기록        - 실패기록 1            ```sql            LOAD DATA INFILE 'C:\Users\hmkim\Downloads/books.csv' INTO TABLE `books_tb` FIELDS TERMINATED BY ',';            ```            - *This statement cannot be executed because the MySQL server is running with the -secure-file-priv option.*            - 구글링 후 해결 방법 :                  error code: 1290. the mysql server is running with the --secure-file-priv option so it cannot execute this statement 해결방법(https://yongku.tistory.com/entry/error-code-1290-the-mysql-server-is-running-with-the-secure-file-priv-option-so-it-cannot-execute-this-statement-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95)        - 실패 기록 2            ```sql            LOAD DATA INFILE 'C:\ProgramData\MySQL\MySQL Server 8.0\Uploads/books.csv' INTO TABLE `books_tb` FIELDS TERMINATED BY ',';            ```            - 위와 같이 파일 속성의 경로 복사 붙여넣기 후 계속 오류남 → \를 /로 쓰면 해결            &lt;br&gt;        - 기타 실패 해결            - 엑셀 파일 컬럼 이름 적힌 첫 행 제거 후 csv 파일로 변환            - 엑셀 파일 인코딩 문제 → https://sidorl.tistory.com/27(https://sidorl.tistory.com/27) 보고 해결            &lt;br&gt;            - 그런데도 계속 `Row 1 doesn't contain data for all columns` 이런 오류 발생            - 메모장으로 csv 파일을 열어서 확인해보니 개행문자가 description 텍스트 중에 빈번하게 들어가 있어서 그럴지도 모른다는 생각. 해결 방법 찾다가 뾰족한 수가 없었다.            &lt;br&gt;            - 다른 방법 탐색! → mysql에서 시도하지 말고 엑셀에 기능이 없을까????                !(https://images.velog.io/images/sue/post/1b875f7e-7ec7-4ce4-acb9-4f15be080bd3/image.png)                - 오른쪽 상단 MySQL for Excel로 https://zionh.tistory.com/44(https://zionh.tistory.com/44) 참고하여 해결 완료                - select로 확인하면 잘 보이진 않지만 아래처럼 데이터 삽입이 제대로 되어 있다!                !(https://images.velog.io/images/sue/post/4e72376f-9136-4ffb-b16c-5cded38b69f5/image.png)models.py에서 모델 Books 생성"
34,엘리스 AI 트랙 9주차 - 1엘리스 실습했던 코드 참조하여 프로젝트 생성 및 기초 코드 작성mysql에 excel 데이터 삽입 시도  엘리스 실습했던 코드 참조하여 프로젝트 생성 및 기초 코드 작성  mysql에 excel 데이터 삽입 시도  프로젝트 설계 → 사실 어떻게 하는지 잘 모르겠다. 나름대로 생각 후 엘리스에서 제공해준 기능들 보면서 하나씩 구현 하는 것으로 결론 내렸다.저녁 약속 + 학교 컴퓨터 게임 설계 프로젝트 때문에 시간 투자를 많이 하진 못했다.
35,"엘리스 AI 트랙 4주차 - 1온라인 강의, 실습 내용 정리본 10/13 수요일 &lt;예시로 알아보는 라우팅의 필요성&gt; SPA는 MPA와 달리 리로드 없이 페이지의 일부분만 다시 그린다. 페이지 내부에서 사용자가 링크나 버튼 클릭으로 새로운 컴포넌트가 렌더링되어 화면에 보여진다. 예를 들어 네이버 홈페이지에서 웹툰 탭을 클릭하면 페이지의 일부만 바뀐다. 사용자는 지금 보고 있는 이 화면을 친구에게 공유하고 싶다! 하지만 SPA의 url은 1개이고 해당 url로 들어가면 기본 페이지만 보인다...! ⇒ 구분을 해주고 싶다!!!! 이런 문제점을 해결하기 위해 url 뒷부분에 /webtoon 과 같은 형식으로 특정 컴포넌트와 url의 path를 연결해주는 라우팅 기술을 사용한다.Array.splice(index, 1); // 시작할 인덱스(index)부터 삭제할 개수(1)만큼 삭제!참고) 리다이렉트(redirect)ㆍ 리다이렉트는 http 프로토콜로 정해진 규칙이다. ㆍ 서버는 클라이언트로부터 요청을 받은 후, 클라이언트에게 특정 url 로 이동하라고 요청할 수 있다. 이를 리다이렉트라고 한다.ㆍ 서버에서는 클라이언트에게 응답으로 상태코드를 302와 함께 이동할 url 정보를 location 헤더(header)에 담아 전송한다. 클라이언트는 서버로 부터 받은 상태값이 302이면 location 헤더값으로 재요청을 보내게 된다.이때 브라우저의 주소창은 전송받은 url 로 바뀌게 된다.React 심화2. SPA와 라우팅01. SPA와 라우팅Single Page ApplicationSPA(Single Page Application)은 하나의 페이지 요청으로 전체 웹앱을 사용하는 방식.유저는 웹페이지를 사용하며 모바일 앱 같은 경험을 느낌.리로드 없이 일부분만 변화!Multi Page ApplicationMPA(Multi Page Application)은 서버에 미리 여러 페이지를 두고, 유저가 네비게이션(페이지 이동) 시 요청에 적합한 페이지를 전달.미리 서버에서 전체 페이지를 빌드해 브라우저로 전송됨.서버에서 라우팅 처리 및 여러 페이지를 관리 함.페이지 요청마다 모든 리소스를 다시 받아옴 → 페이지 간 데이터 재활용하기 힘듦.SPA의 특징Client-side routing 기술을 활용, 페이지 진입 시 리로드없이 라우팅함.**AJAX** 기술을 활용, 페이지 이동 시 서버에 데이터만 요청하여 자바스크립트로 페이지를 만듦.MPA와 다르게, 여러 페이지를 하나의 앱의 구성요소로 보고 여러 페이지 간의 스타일, 컴포넌트를 재활용하는 방향으로 구현.자바스크립트만을 활용해 전체 페이지를 만들기에, **첫 요청 시 빈 페이지**를 받게 됨.SPA의 기술적 장점서버에서 페이지를 만들 필요가 없으므로 CDN에 캐싱이 가능. (CDN : 다양한 콘텐츠를 복잡한 네트워크 환경에서 사용자에게 안정적으로 전송해 주는 서비스. 서버와 클라이언트가 먼 거리일 때 중간에서 소통 가능 한 지점이라고 생각하자.)매번 페이지 요청을 할 필요가 없어 네트워크 요청이 줄어듦.마찬가지로 데이터 요청 등을 캐싱하여 재사용하는 등 제약 조건이 줄어듦.웹사이트를 개별 페이지보다는 하나의 앱으로 보는 설계로 고도의 소프트웨어 설계와 패턴을 적용할 수 있음. (상태관리, 라우팅, 컴포넌트 재사용, 훅을 통한 로직 재사용 등)SPA의 기술적 단점MPA방식 보다는 Search Engine Optimization에 불리함. (검색 엔진 노출이 잘 안 됨.)하나의 자바스크립트 앱이 지속하므로, 메모리 관리와 성능, 데이터 활용 등이 중요.여러 페이지를 전송받는 것 보다, 하나의 거대한 자바스크립트 앱을 전송받아야 하므로 코드가 많아질수록 로드 속도가 느려짐.SPA에서의 라우팅주로 **History API** 혹은 URL Hash를 이용해 페이지 리로드 없는 페이지 전환 구현.history, location 등 HTML5 API를 활용.visibilitychange, popstate, beforeunload 등 window event를 활용하여 페이지 전환 등의 이벤트 시 핸들러를 등록.react-router, reach-router 등의 라이브러리를 활용하면, 라우팅 관련 기능을 쉽게 사용할 수 있음.02. react-router 소개react-routerDeclarative routing for React.React의 JSX를 이용하거나, History API를 사용하여 라우팅을 구현.웹에서는 **react-router-dom**을 사용.적용 시, 서버의 모든 path에서 같은 앱을 서빙하도록 해야 함.react-router의 기능React 컴포넌트를 특정 path와 연결하면, 해당하는 path로 진입 시 컴포넌트를 렌더링하게 함.query, path variable 등 URL parameter를 얻어 활용함.조건에 맞지 않을 경우 redirect 함.페이지 이동 시, 이벤트 핸들러를 등록함./posts/my-post-1 등의 nested route를 구현함react-router의 사용반드시 **&lt;BrowserRouter&gt;** 로 감싸 Router Context를 제공해야 함.Route로 path를 정의하고, 그 안에 렌더링하고자 하는 컴포넌트를 넣음.Link로 특정 페이지로 이동 시, 리로드 없이 페이지가 이동함.Switch로, 매칭되는 라우트 하나를 렌더링하게 함.예시        //App.js        import { BrowserRouter, Route, Switch } from 'react-router-dom'        export function App() {            return (                &lt;BrowserRouter&gt;                    &lt;Switch&gt;                        &lt;Route path=&quot;/intro&quot;&gt;&lt;IntroPage /&gt;&lt;/Route&gt;                        &lt;Route path=&quot;/photo&quot;&gt;&lt;PhotoPage /&gt;&lt;/Route&gt;                        &lt;Route path=&quot;/&quot;&gt;&lt;MainPage /&gt;&lt;/Route&gt;                    &lt;/Switch&gt;                &lt;/BrowserRouter&gt;            )        }        //MainPage.jsx        import { NavLink } from 'react-router-dom'        function MainPage() {            return (                &lt;div&gt;                    &lt;nav&gt;                        &lt;NavLink to=&quot;/&quot;&gt;Main&lt;/NavLink&gt;                        &lt;NavLink to=&quot;/intro&quot;&gt;Intro&lt;/NavLink&gt;                        &lt;NavLink to=&quot;/photo&quot;&gt;Photo&lt;/NavLink&gt;                    &lt;/nav&gt;                    &lt;div&gt;Main 페이지&lt;/div&gt;                &lt;/div&gt;            )        }        //IntroPage.jsx        import { NavLink } from 'react-router-dom'        function IntroPage() {            return (                &lt;div&gt;                    &lt;nav&gt;                        &lt;NavLink to=&quot;/&quot;&gt;Main&lt;/NavLink&gt;                        &lt;NavLink to=&quot;/intro&quot;&gt;Intro&lt;/NavLink&gt;                        &lt;NavLink to=&quot;/photo&quot;&gt;Photo&lt;/NavLink&gt;                    &lt;/nav&gt;                    &lt;div&gt;Intro 페이지&lt;/div&gt;                &lt;/div&gt;            )        }        //PhotoPage.jsx        import { NavLink } from 'react-router-dom'        export default function PhotoPage() {            return (                &lt;div&gt;                    &lt;nav&gt;                        &lt;NavLink to=&quot;/&quot;&gt;Main &lt;/NavLink&gt;                        &lt;NavLink to=&quot;/intro&quot;&gt;Intro &lt;/NavLink&gt;                        &lt;NavLink to=&quot;/photo&quot;&gt;Photo &lt;/NavLink&gt;                    &lt;/nav&gt;                    &lt;div&gt;Photo 페이지&lt;/div&gt;                &lt;/div&gt;            )        }   03. react-router 컴포넌트BrowserRouterHTML5의 History API를 사용하여, UI와 URL의 싱크를 맞추는 역할.모든 URL에 대해 동작하게 하기 위해서는 서버 설정 필요.모든 path 앞의 basename을 지정할 수 있음. 예) basename=&quot;/ko&quot;forceRefresh로, 페이지 이동 시 리프레시할 것인지 지정할 수 있음Switch여러 Route 중 매치되는 Route 위에서부터 하나 선택하여 렌더링함.매칭되는 Route가 없으면 아무것도 보여주지 않음. fallback용으로 404 Not Found Page를 추가함.path=&quot;/&quot;의 경우 모든 path에 매칭되므로 exact 키워드를 추가하거나가장 아래로 내림.Routepath와 컴포넌트를 매칭함.매칭되는 컴포넌트는 children으로 넣어주거나 component prop으로 넘김.exact 키워드로 정확하게 매칭하는 path를 설정함.Route로 렌더링 되는 최상위 컴포넌트는 match, location, history를 prop으로 받음.render prop으로, 매칭되었을 때 실제 어떤 컴포넌트를 렌더링할지 통제함RedirectLink와 비슷하나, 렌더링되면 to prop으로 지정한 path로 이동함.Switch 안에서 쓰일 경우, from, to를 받아 이동하게 만듦. 예) from=&quot;/&quot; to=&quot;/login&quot;Link, NavLinkto prop을 특정 URL로 받아, 클릭 시 네비게이션 함.anchor tag를 래핑함.NavLink의 경우, 매칭 시 어떤 스타일을 가질지 등의 추가 기능이 있음.to에 location object나 함수를 받을 수 있음useHistory, useLocation, useParams, useRouteMatch최상위 컴포넌트가 아니더라도, hook으로 react-router 관련 객체에 접근할 수 있음.history, location, params, match 객체에 접근함04. react-router로 페이지 구성하기공통 페이지 레이아웃    import Navigation from './Navigation';    import styled from &quot;styled-components&quot;;    //PageLayout.jsx    export default function PageLayout({ header,         children }) {            return (                &lt;MyLayout&gt;                    &lt;Navigation /&gt;                    &lt;header&gt;                    &lt;h2&gt;{header}&lt;/h2&gt;                    &lt;/header&gt;                    &lt;main&gt;{children}&lt;/main&gt;                &lt;/MyLayout&gt;            );        }    // styled 태그 =&gt; 아래 Layout은 div태그에 아래 스타일 적용된 태그!    const MyLayout = styled.div`        display: flex;        flex-direction: column;        margin-left: 24px;    `;공통 페이지 네비게이션    import { NavLink } from 'react-router-dom'    import styled from &quot;styled-components&quot;;    //Navigation.jsx    export default function Navigation() {        return (            &lt;Nav&gt;                &lt;NavLink to=&quot;/&quot;&gt;Main&lt;/NavLink&gt;                &lt;NavLink to=&quot;/info&quot;&gt;Info&lt;/NavLink&gt;                &lt;NavLink to=&quot;/photo&quot;&gt;Photo&lt;/NavLink&gt;            &lt;/Nav&gt;        );    }    const Nav = styled.div`        margin-top: 24px;        &amp; &gt; a:not(:first-of-type) {        margin-left: 24px;        }    `;  개별 페이지 컴포넌트    import PageLayout from './PageLayout';    //MainPage.jsx    export default function MainPage() {        return (            &lt;PageLayout header=&quot;Main Page&quot;&gt;메인 페이지로 이동했다!&lt;/PageLayout&gt;        );    } 라우터 연결    import { BrowserRouter, Route, Switch } from 'react-router-dom'    import MainPage from './MainPage';    import PhotoPage from './PhotoPage';    import UserInfoPage from './UserInfoPage';    import { Link } from 'react-router-dom';    //App.jsx    export default function App() {        return (            &lt;BrowserRouter&gt;                &lt;Switch&gt;                    &lt;Route exact path=&quot;/&quot;&gt;                        &lt;MainPage /&gt;                    &lt;/Route&gt;                    &lt;Route path=&quot;/info&quot;&gt;                        &lt;UserInfoPage /&gt;                        &lt;Link to=&quot;/info?email=myInfo@gmail.com&amp;address=earth&quot; style={{marginLeft: 24}}&gt;                            사용자 정보                        &lt;/Link&gt;                    &lt;/Route&gt;                    &lt;Route path=&quot;/photo&quot;&gt;                        &lt;PhotoPage /&gt;                    &lt;/Route&gt;                &lt;/Switch&gt;            &lt;/BrowserRouter&gt;        );    }결과 페이지 모습 05. react-router 응용Private Route 만들기특정 조건이 충족되지 않았을 때 다른 페이지로 Redirect 하도록 하는 기능.유저의 상세 페이지, 개인정보 변경 페이지 등을 만들 때 사용됨Private Route 만들기 - declarative    function PrivateRoute({ component: Component, ...props }) {        return &lt;Route {...props} render={props =&gt; {            const isLoggedIn = !!getUserInfo() // !!는 뒤 성분이 유효한지 확인해서 불린으로 바꿔줌.            if (!isLoggedIn) {                return &lt;Redirect to=&quot;/login&quot; /&gt;            }            return &lt;Component {...props} /&gt;        }} /&gt;    }- render는 경로가 일치할 때 전달 받은 함수 실행 Private Route 만들기 - imperative    function usePrivateRoute(validateFunc) {        const history = useHistory()        useEffect(() =&gt; {            if (!validateFunc()) {                history.push(&quot;/login&quot;)            }        }, )    }query string 활용하기URL의 query string 정보를 활용해 앱을 구성할 수 있음.URLSearchParams API를 활용함.    //UserInfoPage.jsx    import PageLayout from './PageLayout';    import { useLocation } from 'react-router';    export default function UserInfoPage() {        const location = useLocation();        const searchParams = new URLSearchParams(location.search); // 쿼리 스트링 가져옴.        const email = searchParams.get(&quot;email&quot;);        const address = searchParams.get(&quot;address&quot;);        return (            &lt;PageLayout header=&quot;User Info&quot;&gt;                &lt;em&gt;{email}&lt;/em&gt;                &lt;br /&gt;                &lt;strong&gt;{address}&lt;/strong&gt;            &lt;/PageLayout&gt;        );    }    import { BrowserRouter, Route, Switch } from 'react-router-dom'    import MainPage from './MainPage';    import PhotoPage from './PhotoPage';    import UserInfoPage from './UserInfoPage';    import { Link } from 'react-router-dom';    //App.jsx    export default function App() {        return (            &lt;BrowserRouter&gt;                &lt;Switch&gt;                    &lt;Route exact path=&quot;/&quot;&gt;                        &lt;MainPage /&gt;                    &lt;/Route&gt;                    &lt;Route path=&quot;/info&quot;&gt;                        &lt;UserInfoPage /&gt;                        &lt;Link to=&quot;/info?email=myInfo@gmail.com&amp;address=earth&quot; style={{marginLeft: 24}}&gt;                            사용자 정보                        &lt;/Link&gt;                    &lt;/Route&gt;                    &lt;Route path=&quot;/photo&quot;&gt;                        &lt;PhotoPage /&gt;                    &lt;/Route&gt;                &lt;/Switch&gt;            &lt;/BrowserRouter&gt;        );    }"
36,"엘리스 AI 트랙 3주차 - 2온라인 강의, 실습 내용 정리본 10/8 금요일React 기초1. props와 State01. Props (Properties)1) Props란?컴포넌트에 원하는 값을 넘겨줄 때 사용변수, 함수, 객체, 배열 등 제한 없이 JS 요소를 넘겨줄 수 있다.주로 컴포넌트의 재사용을 위하여 사용// 컴포넌트 생성const Greeting = (props) =&gt; {    return &lt;h1&gt;Hi, My name is {props.name}&lt;/h1&gt;;}// 컴포넌트 사용const App =() =&gt; {    return &lt;div&gt;        &lt;Greeting name=&quot;IceBear&quot; /&gt;        &lt;Greeting name=&quot;Panda&quot; /&gt;        &lt;Greeting name=&quot;Greezly&quot; /&gt;    &lt;/div&gt;;}2) Props는 읽기 전용: props 값 임의 변경 사용하면 X. 변경 원할 시 새로운 변수 사용하기.// 잘못된 코드!!!!!!!!!!!! 오류는 아니지만 잘못된 사용임!!const Greeting = (props) =&gt; {    props.name = props.name + &quot;곰&quot;;    return &lt;h1&gt;Hi, My name is {props.name}&lt;/h1&gt;;}// 올바른 사용법const Greeting = (props) =&gt; {    const bear = props.name + &quot;곰&quot;;    return &lt;h1&gt;Hi, My name is {bear}&lt;/h1&gt;;}3) DOM Element의 Attributes기본적인 DOM Element(div, span 등)들의 Attribute : camel case로 작성. (예: tabIndex, className 등)‘data-’ 또는 ‘aria-’ 로 시작하는 Attribute는 예외!HTML의 Attribute와 다른 이름을 가지는 Attribute 주의하기. (class → className, for → htmlFor 등)HTML의 Attribute와 다른 동작 방식을 가진 Attribute 주의하기. (checked(defaultChecked), value(defaultValue), style 등)React에서만 쓰이는 새로운 Attribute 주의하기. (key 등)4) HTML과 다른 방식의 React Attribute (checked, value)HTML에서 checked 또는 value는 해당 값이 초기값 vs React 내에서는 현재 값을 의미즉, checked 값이 false로 설정돼있으면 체크박스 클릭해도 값의 변화 없다.초기값의 의미로 checked 또는 value를 사용하려면 defaultChecked, defaultValue속성으로 설정!(&lt;input type=&quot;checkbox&quot; checked={false} /&gt;)5) React에서만 쓰이는 새로운 Attribute(key)Key는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 돕는다.Key는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 Element에 지정해야 함Key는 배열 내부 형제 사이에서 고유해야 하고 전체에서 고유할 필요 X. → 다른 배열을 만들 때는 key 같아도 O.const Bears = () =&gt; {    const bears =         {key: '3', value: 'iceBear'},         {key: '1', value: 'greezly'},         {key: '2', value: 'panda'}        return (        &lt;div&gt;            {bears.map((item) =&gt; (                &lt;li key={item.key}&gt;{item.value}&lt;/li&gt;            ))}        &lt;/div&gt;    );}02. State1) State란?: State는 컴포넌트 내부, 지속적으로 변경이 일어나는 값을 관리하기 위해 사용.const App = () =&gt; {    const value, setValue = useState(초기값); // value: state명, setValue: set+State명    return ...}useState import 하기  import { useState } from &quot;react&quot;;State 값 변경시 꼭 setState 함수로! state 값을 임의로 변경하지 말자.  const value, setValue = useState(&quot;&quot;);  ...  setValue(&quot;안녕하세요&quot;);State는 Component 내에서 유동적인 값을 저장. 개발자 의도나 사용자 입력에 의해 변할 수 있다. State 값 변경되고 재렌더링이 필요하면 React가 자동으로 변경된 부분 렌더링.  (이러기 위해서는 setState 함수 사용 필수. 임의 변경시 리액트가 알아차리지 못함!)  import {useState} from 'react';  function DoorBell(){      const cnt, setCnt = useState(0);      return (          &lt;div&gt;              &lt;button onClick={() =&gt; setCnt(cnt + 1)}&gt;딩동&lt;/button&gt;              &lt;p&gt;초인종을 {count}번 눌렀다!&lt;/p&gt;          &lt;/div&gt;      );  }  2) State를 변경하는 두 가지 방법setState 내에 변경할 값 넣기  const count, setCount = useState(0);  setCount(count+1);setState에 함수를 넣기 : 함수가 반환(return)하는 값으로 State가 변경  const count, setCount = useState(0);  setCount((current) =&gt; {      return current + 1;  });  → 현재 값을 기반으로 State를 변경할 땐 함수를 넣는 방법을 권장3) 배열이나 객체를 갖는 State 만들 때 주의사항: 예시의 경우 React가 State의 변경을 감지하지 못함! 내용물만 바뀌고 bear 객체 자체가 변경되지 않았기 때문! 리액트는 객체와 배열은 그 자체가 변경될 경우에만 다시 렌더링 함!!!!!!!!! (예를 들어 마치 슈뢰딩거의 고양이.. 고양이가 박스 안에서 살아있는 상태에서 죽은 상태로 바뀌어도 박스 밖에선 모른다. 리액트는 우리처럼 모른다.)// 잘못된 사용const bear, setBear =useState({name: &quot;iceBear&quot;, age: 5})setBear((current) =&gt; {    current.age = 6;    return current;})// 올바른 사용const bear, setBear =useState({name: &quot;iceBear&quot;, age: 5})setBear((current) =&gt; {    const newBear = {...current};    newBear.age = 6;    return newUser;})2. 이벤트 처리01. 이벤트 소개1) 이벤트란?: 이벤트(event)란 웹 브라우저가 알려주는 HTML 요소에 대한 사건의 발생. 유저의 행동, 개발자 의도한 코드에 의해 발생할 수도 있다. Element가 로딩되었을 때, Element를 클릭, 마우스 오버, 더블 클릭, 키보드 입력 등 다양한 이벤트가 존재. 이벤트 핸들러 함수는 이벤트 생겼을 때 처리하는 방법이다.2) 이벤트 처리(핸들링) 방법: React에서 이벤트를 처리하는 방법은 크게 두 가지! 별도의 핸들링 함수를 선언하고 Element에 넘겨주는 방법과 이벤트를 할당하는 부분에서 익명 함수를 작성하는 방법으로 나뉜다.핸들링 함수 선언  const App = () =&gt; {      const handleClick = () =&gt; {          console.log(&quot;눌렀다!&quot;);      }      return (          &lt;div&gt;              &lt;button onClick={handleClick}&gt;눌러보자&lt;/button&gt;          &lt;/div&gt;      );  }익명 함수로 처리  const App = () =&gt; {      return (          &lt;div&gt;              &lt;button onClick={() =&gt; {console.log('눌렀다!')}}&gt;눌러보자&lt;/button&gt;          &lt;/div&gt;      )  }3) 이벤트 객체DOM Element의 경우 핸들링 함수에 event object를 매개변수로 전달.event object를 이용하여 이벤트 발생 원인, 이벤트가 일어난 Element에 대한 정보 접근 가능.이벤트 형태와 DOM 종류(button, form, input 등)에 따라 전달되는 이벤트 object의 내용 다름.참고: https://developer.mozilla.org/ko/docs/Web/API/Eventconst App = () =&gt; {    const handleChange = (event) =&gt; {        alert(event.target.value + '라고 입력했어요!'); // event.target은 이벤트가 일어난 엘리먼트를 뜻함.    }    return (        &lt;div&gt;            &lt;input onChange={handleChange} /&gt;        &lt;/div&gt;    );}4) 많이 쓰이는 DOM 이벤트onClick : Element를 클릭했을 때onChange : Element의 내용이 변경되었을 때(input의 텍스트를 변경, 파일 선택 등)onKeyDown, onKeyUp, onKeyPress : 키보드 입력이 일어났을 때onDoubleClick : Element를 더블 클릭했을 때onFocus : Element에 Focus되었을 때onBlur : Element가 Focus를 잃었을 때onSubmit : Form Element에서 Submit 했을 때02. 컴포넌트 내 이벤트 처리1) DOM Input 값을 State에 저장하기: event object의 target은 이벤트의 원인이 되는 Element를 가리킨다. 현재 event의 target은 input element이므로 입력된 value를 가져와 setState를 하는 예시.const App = () =&gt; {    const inputValue, setInputValue = useState(&quot;&quot;);    const handleChange = (event) =&gt; {        setInputValue(event.target.value);    }    return (        &lt;div&gt;            &lt;input onChange={handleChange} defaultValue={inputValue} /&gt;            &lt;br /&gt;            입력한 값: {inputValue}        &lt;/div&gt;    );}2) 여러 Input 동시에 처리하기: 한 개의 이벤트 핸들링 함수를 재사용해 여러 input element에서 값을 입력받는 방법object 값 변경 시 보통 object.key = &quot;value&quot;와 같이 작성하는데그 대신, object&quot;key&quot; = &quot;value&quot; 처럼 작성할 수 있고 &quot;key&quot; 자리에 변수를 대입하여 다이나믹하게 값 변경 가능.Dynamic key 예시const obj = {    a: &quot;example1&quot;,    b: &quot;example2&quot;,    c: &quot;example3&quot;}const key = &quot;b&quot;;objkey = &quot;수정&quot;console.log(obj);// { a: &quot;example11&quot;, b: &quot;수정&quot;, c: &quot;example3&quot; }이런 Object 특성을 이용 → 한 개의 이벤트 핸들링 함수로 여러 element의 이벤트를 처리 가능!: 여러 State 선언 대신 object를 활용하여 여러 개의 input을 state로 관리하는 방법이 있다. target으로부터 name을 받아와 해당 name의 key에 해당하는 value를 변경하여 state에 반영하기!const App = () =&gt; {    const bearInfo, setBearInfo = useState({bearName: &quot;아이스베어&quot;, home: &quot;동굴&quot;});    const handleChange = (event) =&gt; {        const {name, value}        const newBearInfo = {...bearInfo};        newBearInfoname = value;        setUser(newBearInfo);    };    return (        &lt;div&gt;            &lt;input name=&quot;bearName&quot; onChange={handleChange} value={bearInfo.bearName} /&gt;            &lt;br /&gt;            &lt;input name=&quot;home&quot; onChange={handleChange} value={bearInfo.home} /&gt;            &lt;p&gt;                내 친구 {bearInfo.bearName}는 {bearInfo.home}에 살고 있어요.            &lt;/p&gt;        &lt;/div&gt;    );}03. 다른 컴포넌트로 이벤트 전달1) 컴포넌트간 이벤트 전달하기: 입력 받은 정보를 부모 컴포넌트에서 활용해야 하는 경우 이벤트를 Props로 전달하여 처리const MyForm = ({onChange}) =&gt; {    return (        &lt;div&gt;            &lt;span&gt;곰 이름: &lt;/span&gt;            &lt;input onChange={onChange} /&gt;        &lt;/div&gt;    );}const App = () =&gt; {    const bearname, setBearname = useState('');    return (        &lt;div&gt;            &lt;h1&gt;{bearname} 곰이에요.&lt;/h1&gt;            &lt;MyForm                 onChange={(event) =&gt; {                    setBearname(event.target.value)                }}             /&gt;        &lt;/div&gt;    );}2) 커스텀 이벤트const RingDingDong = ({onRingDingDong}) =&gt; {    const count, setCount = useState(0);    const handleClick = () =&gt; {        if(count &gt;= 2) {            onRingDingDong();        }        setCount(count + 1);    }    return &lt;button onClick={handleClick}&gt;        똑똑똑 버튼 세번 누르면 문이 열립니다.({count})    &lt;/button&gt;}const App = () =&gt; {    return (        &lt;div&gt;            &lt;RingDingDong                onSOS={() =&gt; {                    alert(&quot;문 열어주기!&quot;);                }}            /&gt;        &lt;/div&gt;    );};3) 이벤트 명명법직접 이벤트 제작 시 이름 자유 설정 가능. 보통은 관습적으로 “on” + 동사 or  “on” + 명사 + 동사 형태로 작성. (예: onClick, onInputChange)핸들링 함수의 경우, “handle” + 동사 or “handle” + 명사 + 동사 의 형태로 작성. “handle” 대신 이벤트명과 동일한 “on”을 앞에 붙여도 O. (예. handleClick)3. Hooks01. Hooks 개요1) Hook이란?: 함수 컴포넌트에서 데이터를 관리(State)하고 데이터가 변경될 때 상호작용(Effect)을 하기 위해 사용2) 유의사항Hook은 React 함수(컴포넌트, Hook) 내에서만 사용 가능Hook의 이름은 반드시 **use**로 시작최상위 Level에서만 Hook을 호출할 수 있다. (if문, for문 안 쪽 또는 콜백함수 내에서 호출 불가)const App = () =&gt; {    const name, setName = useState('')        return (            &lt;div&gt;                &lt;h1&gt;{name}님 접속하셨네요!&lt;/h1&gt;            &lt;/div&gt;        );}02. State Hook과 Effect Hook1) State HookuseState는 컴포넌트 내 동적인 데이터를 관리할 수 있는 hook.최초에 useState가 호출될 때 초기값으로 설정되고 이후 재 렌더링이 되면 초기값 무시.state는 읽기 전용이므로 직접 수정 불가!! (사실 가능한데 이렇게 하면 재 렌더링이 안 됨.)state를 변경하기 위해서는 setState를 이용.state가 변경되면 자동으로 컴포넌트가 재 렌더링 됨.const App = () =&gt; {    // 일반적인 useState 사용법    const state이름, setState이름 = useState(초기값);}state 변경 방법 두 가지 :setState 함수에 직접 값을 입력현재 값을 매개변수로 받는 함수를 전달 : 함수에서 return되는 값이 state에 반영 됨.const App = () =&gt; {    const lyrics, setLyrics = useState(&quot;&quot;);    // State를 변경할 값을 직접 입력    setLyrics(&quot;안녕하세요. 선생님~&quot;)    // 또는 현재 값을 매개변수로 받는 함수 선언    // return 값이 state에 반영됨    setLyrics((current) =&gt; {        return current + &quot;안녕? 친구야&quot;;    })}2) Effect HookEffect Hook을 사용하면 함수 컴포넌트에서 side effect 수행 가능.컴포넌트가 최초로 렌더링될 때 &amp; 지정한 State나 Props가 변경될 때마다 effect 콜백 함수가호출 됨.Deps : 변경을 감지할 변수들의 집합(배열)EffectCallback : Deps에 지정된 변수가 변경될 때 실행할 함수const App = () =&gt; {    useEffect(EffectCallback, Deps?)}const App = () =&gt; {    const count, setCount = useState(0);    useEffect(() =&gt; {    console.log('버튼 클릭 : ${count} 번')    }, count)    return (        &lt;div&gt;            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;                클릭!            &lt;/button&gt;        &lt;/div&gt;    )}useEffect의 이펙트 함수 내에서 다른 함수를 return할 경우: state가 변경되어 컴포넌트가 다시 렌더링되기 전과 컴포넌트 소멸 시(Destroy) 호출할 함수를 지정.const App = () =&gt; {    useEffect(() =&gt; {        // State가 변경될 때, 컴포넌트를 렌더링할 때            const intervalId = setInterval(()=&gt;{                console.log(&quot;State가 변경될 때, 컴포넌트를 렌더링할 때 실행!&quot;);            }, 3000);        // 컴포넌트를 재 렌더링 하기 전에, 컴포넌트가 없어질 때만 실행될 함수 지정        return () =&gt; {            clearInterval(intervalId);        }    }, ) ...03. 이외의 HooksuseMemo  const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), a, b)메모이제이션 된 값 반환지정한 State나 Props가 변경될 경우 해당 값을 활용해 계산된 값을 메모이제이션하여 재렌더링 시 불필요한 연산을 줄인다.useMemo의 연산은 렌더링 단계에서 이루어짐 → 시간이 오래 걸리는 로직을 작성하지 않는 것이 권장됨.const App = () =&gt; {  const mammal, setMammal = useState('bear')  const animalName, setAnimalName = useState('ice')  // 포유류 또는 동물 이름이 바뀔 때마다 메모이제이션  // useMemo 내부 함수에서 리턴된 값이 animalFullName 변수에 들어간다.  const animalFullName = useMemo(() =&gt; {      return ′${animalName} ${mammal}′  }, animalName, mammal)}useCallback  const memoizedCallback = useCallback(      () =&gt; {          doSomething(a, b);      },       a, b  );메모이제이션 된 콜백 함수 반환컴포넌트가 재렌더링될 때 불필요하게 함수가 다시 생성되는 것 방지useMemo(() =&gt; fn, deps) 와 useCallback(fn, deps) 는 같다. (useMemo에서 함수를 리턴해주는 것과 useCallback은 일치) → 단지 개발자의 편의를 위해 분리했다고 생각하자const App = () =&gt; {  const mammal, setMammal = useState('bear')  const animalName, setAnimalName = useState('ice')  // 포유류 또는 동물 이름이 바뀔 때마다  // 풀네임을 return하는 함수를 메모이제이션  const getAnimalFullName = useCallback(() =&gt; {      return ′${animalName} ${mammal}′  }, animalName, mammal)  return &lt;&gt;{getAnimalFullName()}&lt;/&gt;}useRef  const refContainer = useRef(initialValue);컴포넌트 생애 주기 내에서 유지할 ref 객체를 반환ref 객체는 .current라는 프로퍼티를 가지며 이 값을 자유롭게 변경할 수 있다.일반적으로 React에서 DOM Element에 접근 할 때 사용(DOM Element의 ref 속성이용)useRef에 의해 반환된 ref 객체가 변경되어도 컴포넌트가 재렌더링되지 않는다.const App = () =&gt; {  const inputRef = useRef(null)  const onButtonClick = () =&gt; {      inputRef.current.focus()  }  return (      &lt;div&gt;          &lt;input ref={inputRef} type=&quot;text&quot; /&gt;          &lt;button onClick={onButtonClick}&gt;              input으로 포커스 이동하기          &lt;/button&gt;      &lt;/div&gt;  )}04. 커스텀 Hook1) Custom Hook: UI 요소의 재사용성을 높이기 위해 컴포넌트를 만드는 것처럼, 로직의 재사용성을 높이기 위해 Custom Hook을 제작. ⇒ 커스텀 훅은 그냥 훅을 사용하는 함수임!function useMyHook(args) {    const status, setStatus = useState(undefined);    // ...    return status;}한 로직이 여러 번 사용될 경우 함수를 분리하는 것처럼 Hook을 만드는 것Hook의 이름은 ‘use’로 시작해야 한다.한 Hook 내의 state는 공유되지 않는다."
37,엘리스 AI 트랙 2주차 - 4실시간 강의 정리본 10/1 금요일'&lt;li&gt;'+topicsi.title+'&lt;/li&gt;' 대신 &lt;li&gt;${topicsi.title}&lt;/li&gt; 하면 됨.&lt;!-- placeholder는 hint같은 것. 코드 아래는 코드 실행 결과 화면--&gt;&lt;p&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;title&quot;&gt;&lt;/p&gt;&lt;p&gt;    &lt;textarea placeholder=&quot;body&quot;&gt;&lt;/textarea&gt;&lt;/p&gt;&lt;p&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;            site: opentutorials.org(http://opentutorials.org) html라고 구글에 검색하면 opentutorials.org에서 html 검색한 결과만 보여줌.url에서 ? 이후 값은 쿼리스트링(구글로 입력하는 입력값)&lt;form action=&quot;https://www.google.com/search&quot;&gt;    &lt;p&gt;        &lt;input type=&quot;text&quot; name=&quot;q&quot; placeholder=&quot;title&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;input type=&quot;submit&quot;&gt;    &lt;/p&gt;&lt;/form&gt;form 태그의 action : submit했을 때 submit한 데이터를 어디로 전송할 것인지 주소 적는 곳. 나중에 서버 연동하면 서버 주소 적으면 됨.google에서 뭔가 검색하면 https://www.google.com/search?q=... 형식임.위 코드는 q에 뭐가 들어갈지 입력 받아서 submit 누르면 구글에서 검색해 주는 코드&lt;!-- submit 버튼 클릭 시 onsubmit 실행 --&gt;&lt;form onsubmit=&quot;    event.preventDefault();    let title = event.target.title.value;    let body = event.target.body.value;&quot;&gt;    &lt;p&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;title&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;textarea placeholder=&quot;body&quot;&gt;&lt;/textarea&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;input type=&quot;submit&quot;&gt;    &lt;/p&gt;&lt;/form&gt;submit 버튼 클릭 시 onsubmit 실행
38,"엘리스 AI 트랙 3주차 - 1온라인 강의, 실습 내용 정리본 10/6 수요일React 기초1. 들어가며전통적 페이지 vs SPA(single page application) 의 클라이언트-서버 간 통신전통적 페이지: 최초 접속 요청 → 서버로부터 HTML 전달 받음 → 페이지 변경 필요할 때 데이터 전달하며(Form Post) 서버에 요청 → HTML 전달 받음⇒ 페이지 reload!————————————————————————————————————SPA: 최초 접속 요청 → 서버로부터 HTML 전달 받음 → 페이지 변경 필요할 때 데이터 전달하며(AJAX 통신) 서버에 요청 → 변경 필요한 부분 JSON으로 전달 받음⇒ 페이지 reload 없이 변경된 부분만 계산해서 다시 렌더링!01. React?React: 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리Component : React에서 서비스를 개발하는 데 있어 쪼개어 구현하는 독립적인 단위Virtual DOM : 가상적인 표현을 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 실제 DOM과 동기화하는 프로그래밍 개념 → 가상 돔으로 그려본 후에 다른 부분만 동기화JSX : JavaScript 내에서 UI를 작성시 개발자에게 익숙한 환경을 제공하는 HTML과 유사한 템플릿 라이브러리.02. React의 장점생산성 / 재사용성: Component와 Hook을 활용, 작은 단위의 독립적인 요소로 개발하여 생산성과 재사용성 up풍부한 자료 / 라이브러리: 현재 React는 세계적으로 가장 활발한 커뮤니티 활동 有 → 방대한 자료 &amp; 편리한 오픈소스 라이브러리 등이 공유됨 (redux, fluent UI, Ant Design, mobx 등)다양한 사용처: 웹 앱뿐만 아니라 React-Native에 적용하여 안드로이드 앱 및 iOS 앱 등 개발 가능HTML, JS vs React  &lt;body&gt;      &lt;p id=&quot;content&quot;&gt;&lt;/p&gt;      &lt;script&gt;          document.getElementById(&quot;content&quot;).innerText = &quot;Hi Hello&quot;;      &lt;/script&gt;  &lt;/body&gt;HTML+JS : 레이아웃을 구성하는 HTML과 UI 내 데이터를 변경하는 JavaScript 로직이 분리됨 → 코드 파악에 오랜 시간 소요!  const App = () =&gt; {      const content = &quot;Hi Hello&quot;;      return &lt;p&gt;{content}&lt;/p&gt;;  }React : JSX를 활용하여 HTML 내에 필요한 데이터를 한 공간에 삽입 가능 → 개발이 간단해지고 개발 의도를 파악하기 쉬워짐.최신 JS 문법var → const &amp; let  :  const는 선언 후 값을 바꿀 수 없는 상수, let은 선언과 변경이 자유로운 변수. const로 선언된 변수는 같은 스코프 내에서 중복된 이름을 가질 수 없음. 웬만하면 const로 써서 오류 처리 쉽게 하자! 변경 필요한 경우에만 let 쓰기Array 메소드(forEach)  : Array.forEach는 배열의 요소를 이용해 순차적으로 함수 실행. Array.forEach에 실행할 콜백 함수는 현재 값, 인덱스, forEach를 호출한 배열을 매개변수로 받음. 함수 내에서 따로 return을 할 필요 없다.  const arr = 0, 1, 2, 3  arr.forEach(function(item){ // item은 현재 값!!      console.log(item);  });  Array 메소드(map)  : Array.map은 배열의 요소를 이용해 순차적으로 함수 실행하여 각 리턴 값을 모아 새로운 배열 반환. Array.map에 실행할 콜백 함수는 현재 값, 인덱스, map을 호출한 배열을 매개변수로 받음. 함수 내에서 반드시 새로운 값 return 해줘야 함.  const arr = 0, 1, 2, 3  const newArr = arr.map(function(item){      return item + 1;  }); Array 메소드(filter)  : Array.filter는 배열의 요소를 이용해 순차적 함수 실행하여 조건을 통과하는 요소를 모아  새로운 배열로 반환. Array.filter에 실행할 콜백 함수는 현재 값, 인덱스, map을 호출한 배열을 매개변수로 받음. 함수 내에서 true를 return할 경우만 새로운 배열에 추가됨.  const arr = 0, 1, 2, 3  const newArr = arr.filter(function(item){      return item &gt; 2;  });  Arrow function  : Arrow Function(화살표 함수)은 function 키워드를 생략하고 매개변수를 받은 뒤 =&gt; 를 써주는 형태의 간단한 함수 표현. 중괄호 내부에 로직을 작성하며 return 값만 존재하는 짧은 함수는 중괄호와 return을 생략하고 바로 return할 값 입력 가능.  const a = (x, y) =&gt; {      console.log(x, y);  };  a(5, 6);  const b = (x, y) =&gt; console.log(x, y);  b(1, 2);  구조 분해 할당 (Destructuring assignment)  : Destructuring Assignment(구조 분해 할당)은 객체나 배열을 해체하여 개별 변수에 담을 수 있게하는 표현식.  // 객체 구조 분해 할당   const a = {i: 1, j: 2, k: 3};  const {i, j, k} = b;  // 배열 구조 분해 할당  const b = 1, 2, 3;  const d0, d1, d2 = d;  단축 속성명 (Shorthand property names)  : 단축 속성명을 이용해 객체 선언을 간편하게! 새로 선언하는 객체에 key값과 같은 변수명을 가진 변수를 할당할 경우 value 값을 생략해서 적을 수 있다.  const name = &quot;iceBear&quot;;  const age = 5;  var bear1 = {name: name, age: age}; // 기존 코드  const bear2 = {name, age}; // 단축 속성명 사용 코드  전개 구문(Spread Syntax)  : 전개 구문은 배열이나 객체를 전개할 때 사용. 배열이나 객체에 ...을 붙여 사용. 함수 호출 및 선언, 배열 선언, 객체 선언 시 다양하게 사용. 객체에서 전개 구문 사용 시, 만약 두 객체를 합성할 때 겹치는 key가 있을 경우 나중에 오는 값이 채택됨.// Spread Syntax 배열 예시const nums = 1, 2, 3, 4, 5;function getMul(...n){ // n이라는 변수에다가 개수에 상관없이 값을 받아줘! 라는 의미  let mul = 1;  n.forEach((item) =&gt; {      mul *= item;  });  return mul;}getMul(...nums); // nums의 값들을 전개해서 넣어줘! 라는 의미const newNums = 0, ...nums, 6; // nums 안의 요소들 전개해서 넣어줘! 의미/*********************************************************************/// Spread Syntax 객체 예시const bear = {name: &quot;iceBear&quot;, age: 5, home: &quot;cave&quot;}; // 기존 코드const bear1 = {...user, skill: ninza, age: 6}; // Spread Syntax 객체 적용 코드. age: 6이 채택됨.템플릿 리터럴(Template literals)  : 템플릿 리터럴은 표현식을 허용하는 문자열 리터럴. 기본적으로 `(back quote)로 감싸 문자열을 표현. 문자열 내에 표현식을 사용하기 위해서는 ${ }로 표기.  const bear = &quot;iceBear&quot;;  const greeting1 = &quot;Hello &quot; + bear; // 기존 코드  const greeting2 = `Hello ${bear}`; // 템플릿 리터럴 사용  Optional chaining  : Optional chaining 연산자는 객체나 변수에 연결된 다른 속성을 참조할 때 유효한 속성인 지(존재하는지) 검사하지 않고 값을 읽을 수 있도록 해준다. 만약 유효한 속성이 아니면, 에러를 발생시키지 않고 undefined를 반환. 배열의 경우 array?.index 와 같이 사용.  const bear = {          name: iceBear,      skillScore: {          cooking: 10,                  cleaning: 50      }  }  let result;  if(bear &amp;&amp; bear.skillScore &amp;&amp; bear.skillScore.cleaning){      result = bear.skillScore.cleaning;  } // 기존 코드  const res = bear?.skillScore?.cleaning; // Optional chaining 사용  console.log(bear?.skillScore?.cleaning); // 50  console.log(bear?.skillScore?.speaking); // undefined  console.log(bear?.skillScore.speaking); // Error  const arr = {name:&quot;iceBear&quot;, age:2}, {name:&quot;panda&quot;, age:4};  console.log(arr?.1?.name); // &quot;panda&quot;  console.log(arr?.2?.name); // undefined  리액트 프로젝트 생성01. Create React App 소개Create React App을 쓰지 않고 아래처럼 직접 script를 추가해서 사용 가능. but 개발에 유용한 기능 다수 포함 &amp; 다수의 개발자에게 익숙한 환경이라 협업에 도움이 되므로 사용 권장.  &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;  &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;  &lt;script scr=&quot;https://unpkg.com/babel-standalone@6babel.min.js&quot;&gt;&lt;/script&gt;  Create React App(CRA)란?React 프로젝트를 손쉽게 생성할 수 있도록 도와주는 보일러플레이트(Boilerplate)많은 React용 보일러플레이트 중 Facebook에서 제작, 관리하는 Create React App이 가장 많이 쓰임프로젝트 생성에 필요한 다양한 기능을 Command로 제공함Create React App(CRA)의 장점개발자가 온전히 React App 개발에 집중할 수 있도록 함상대적으로 덜 중요한 코드는 노출되지 않음 → 리액트 코드에 집중 가능강력한 Command 지원 → 커스터마이징 가능(대부분의) 모든 브라우저에서 해석될 수 있도록 transcompile 지원Babel → 기본 내장되어 있음.배포 시 코드 번들링 → 다른 사람들이 코드 알아보기 어렵도록 함.Webpack → 압축 해줌02. Node.js / NPM 소개Node.js / NPMCreate React App으로 React 프로젝트 시작 시 Node.js 개발 환경을 제공함Node.js와 NPM에 대해 알면 이해에 큰 도움Node.js주로 서버 프로그래밍에 사용되는 JavaScript 기반의 소프트웨어 플랫폼HTTP 통신 관련 라이브러리 내장NPM을 통한 방대한 라이브러리 제공Create React App으로 프로젝트 생성 시 개발 환경 및 테스트 서버로 이용됨NPMNode.js 환경에서 사용하는 각종 패키지들을 관리하는 저장소Node.js 설치 시 함께 설치됨패키지 관리 뿐만 아니라 서버 실행 및 관리에 필요한 다양하고 편리한 명령어를 제공React와 관련된 모듈들이 NPM에서 배포됨Node.js, NPM 설치 : https://nodejs.org LTS 버전 다운로드 및 설치03. React 프로젝트 생성해보기npx create-react-app &lt;디렉토리명&gt;cd &lt;디렉토리명&gt;npm startwindow 이용자 : git bash 사용하기npx : npm 패키지를 1회성으로 내려 받아 실행할 때 사용하는 명령어. 위 예시는 ‘create-react-app’ 이라는 패키지를 한 번 내려 받아 실행한 것.npm start : 현재 디렉토리의 프로젝트를 실행npm installnpm install &lt;패키지명&gt;npm startnpm build(Ctrl + C)npm install : package.json에 정의된(현재 프로젝트에 필요한 모든 모듈) dependency(의존성 패키지)들을 설치.npm install &lt;패키지명&gt; : npm 서버로부터 원하는 패키지 다운로드. (필요한 라이브러리 다운)npm start : 프로젝트 실행(Node.js 서버 이용).npm build : 프로젝트 빌드.(Ctrl + C) : 명령 중지(npm start 후 프로젝트 종료하기).디렉토리 구조./node_modules/: npm을 이용해 설치한 패키지들 모음./public/: 정적인 파일들을 모아 놓는 곳./src/: 리액트 개발을 위한 파일들을 모아 놓는 곳./package.json: 프로젝트에 관한 정보와 사용하는 패키지들을 명세하는 파일04. 라이브러리 설치와 불러오기라이브러리 설치  : npm install을 통해 npm으로부터 패키지 다운로드.  npm install        //package.json 파일 내에 정의된 패키지 모두 설치  npm install &lt;패키지명&gt;            //npm 서버로부터 패키지 내려받기  npm install &lt;패키지명&gt;@&lt;version&gt;        //특정 버전의 패키지 내려받기  npm install &lt;Git 레포지토리 주소&gt;    // npm이 아닌 Git 레포지토리로부터 패키지 내려받기설치 후 package.json엔 dependencies(의존성) 라는 키 아래에 설치한 패키지 목록이 나열됨.참고 : 버전명에는 ^(캐럿. 최신 버전 설치해줘! 라는 표시), &lt;, &lt;=, &gt;, &gt;= 등의 기호를 이용해 범위를 나타낼 수 있다.^(캐럿) 예시: ^1.0.2 : &gt;=1.0.2 &lt;2.0               ^1.0 : &gt;=1.0.0 &lt;2.0                ^1 : &gt;=1.0.0 &lt;2.0설치한 라이브러리를 프로젝트 내에서 불러오기import &quot;패키지명&quot; : CSS나 import하는 것 만으로 역할을 하는 라이브러리인 경우 패키지명을 바로 import 함. import something from &quot;패키지명&quot; : 기본적으로 패키지를 불러와 활용할 때에는 할당할 이름을 작성.import {a, b} from &quot;패키지명&quot; : 패키지 내의 일부 메소드나 변수만 가져올때는 구조분해 사용하면 효율적.import * as something from &quot;패키지명&quot; : 패키지에 default로 export되는 객체가 존재하지 않을 경우 * as 이름 으로 불러올 수 있다.CSS 불러오기import &quot;./App.css&quot;; : 별도의 CSS 파일을 작성 후 프로젝트에 적용 시 사용.JSX와 컴포넌트01. JSX1) JSX란?JSX는 함수 호출과 객체 생성을 위한 문법적 편의를 제공하는 JavaScript의 확장HTML과 비슷하게 생겼으나 JavaScript이며 HTML과 차이 있음.const App = () =&gt; {    return (        &lt;div&gt;            &lt;p&gt;Hi&lt;/p&gt;            &lt;NewComponent&gt;NiceToMeetYou&lt;/NewComponent&gt;            &lt;div&gt;bye&lt;/div&gt;        &lt;/div&gt;    );}JSX는 Babel에 의해서 Transcompile 됨.2) JSX 장점개발자 편의성 향상협업에 용이 / 생산성 향상문법 오류와 코드량 감소3) JSX 특징 / HTML과 차이점HTML 태그 내에 JavaScript 연산 가능class → className 사용스타일은 object로 표현(&quot;&quot; 말고 {} 내부에 표현!)닫는 태그 필수 (예. )최상단 element는 반드시 하나여야 함HTML 태그 내에 JavaScript 연산const App = () =&gt; {    const a = 1;    const b = 2;    return &lt;div&gt;{a}+{b} = {a+b}&lt;/div&gt;}class → className(    &lt;div className=&quot;greeting&quot;&gt;Hello World!&lt;/div&gt;)스타일은 object로 → 아래 예시가 {{}}인 이유는 자바 스크립트 코드임을 알리는 {}와 객체임을 표현하는 {}이기 때문.(    &lt;div style={{color: 'red', fontSize: 10px}}&gt;&lt;/div&gt;)주의  : 위와 같은 Inline style의 Property name은 camelCase로 적는다. (예시: font-size → fontSize, padding-left: paddingLeft)닫는 태그 필수 : HTML에서는 닫는 태그를 작성하지 않아도 에러가 발생하지 않고 &lt;input&gt;, &lt;br&gt;같은 일부 태그의 경우 아예 닫는 태그를 생략했지만 JSX에서는 닫는 태그를 필수로 작성해야 함.최상단 element는 반드시 하나: JSX의 원칙상 최상단 Element는 한 개만 작성이 가능 ⇒ &lt;div&gt; 또는 &lt;React.Fragment&gt; 를 이용해 감싼다. 실제 렌더링 시에는 Fragment 안에 있는 내용만 출력됨. &lt;React.Fragment&gt;는 간단히 &lt;&gt; 로 표기.  const App = () =&gt; {      return (          &lt;div&gt;Ice&lt;/div&gt; // 에러 발생함.          &lt;div&gt;Bear&lt;/div&gt;      )  }  const App = () =&gt; {      return (          &lt;&gt;          &lt;div&gt;Ice&lt;/div&gt; // 에러 발생 X.          &lt;div&gt;Bear&lt;/div&gt;        &lt;/&gt;      )  }02. 컴포넌트1) 컴포넌트란?React에서 페이지를 구성하는 최소단위Component의 이름은 대문자로 시작Class Component / Function Component 로 나뉨Controlled Component / Uncontrolled Component → 스테이트 추적 or 필요할 때 받아오기Component를 만들고(왼쪽) 다른 Component에서 자유롭게 활용(오른쪽)할 수 있다. 2) Class Component와 Function Component: 초기 React의 Component는 모두 Class Component 였지만 현재는 Function Component가 주로 사용됨. 3) Class Component 특징Class 개념이 많이 활용되는 Java 개발자에게 친숙한 형태이다.React의 생명주기를 파악하기 쉽다.4) Component의 특징Props(Properties. 컴포넌트의 프로퍼티) : 컴포넌트의 Attribute에 해당하는 부분.children : 컴포넌트 안에 작성된 하위 Element.children도 props 중 하나!&lt;NewComponent user={{name: &quot;iceBear&quot;}} color=&quot;white&quot;&gt;    &lt;div&gt;아이스 베어 소개&lt;/div&gt;&lt;/NewComponent&gt;const NewComponent = (props) =&gt; {    const {user, color, children} = props    return (        &lt;div style={{color}}&gt;            &lt;p&gt;{user.name}의 하위 element는&lt;/p&gt;            {children}        &lt;/div&gt;    )}상위 Element로부터 전달받은 props를 활용하는 코드. 이 컴포넌트의 자식(children) 요소 역시 props 로부터 값을 받아와 렌더링 함.컴포넌트끼리 데이터를 주고받을 땐 : Props컴포넌트 내에서 데이터를 관리할 땐 : State데이터는 부모 컴포넌트 → 자식 컴포넌트로만 전달"
39,"엘리스 AI 트랙 2주차 - 3온라인 강의, 실습 내용 정리본 9/30 목요일자바스크립트 기초3. DOM과 이벤트01. DOM1) 문서 객체 모델(Document Object Model)객체 지향 모델로써 구조화된 문서를 표현하는 형식 → 문서를 트리 형태로!DOM은 XML이나 HTML 문서의 프로그래밍 인터페이스DOM은 프로그래밍 언어가 문서 구조, 스타일, 내용 등을 변경할 수 있도록 함2) DOM의 종류Core DOM : 모든 문서 타입을 위한 모델HTML DOM: HTML 문서를 위한 모델. HTML 문서 조작 및 접근하는 표준화된 방법. HTML DOM을 통해 모든 HTML 요소 접근 가능XML DOM: XML 문서를 위한 모델.3) Document 객체Document 객체 = 웹 페이지 자체를 의미웹 페이지 HTML 요소에 접근하고자 할 때는 반드시 Document 객체부터 시작!4) HTML 작업 위한 다양한 Document 메소드HTML 요소 선택  document.getElementById() // 해당 아이디 요소 선택  document.getElementByClassName() // 해당 클래스 요소 선택  document.getElementByName() // 해당 name 속성값 가지는 요소 선택  document.getElementsByName() // 해당 name 속성값 가지는 요소 모두 선택. 객체로 리턴됨.  document.querySelectorAll() // 해당 선택자로 선택되는 요소 모두 선택  document.querySelector() // 해당 선택자로 선택되는 가장 첫번째 요소 선택HTML 요소 생성  document.createElement() // 지정된 HTML 요소 생성  document.write() // 웹 페이지에 출력(HTML 출력 스트림을 통해 텍스트 출력)HTML 이벤트 핸들러 추가  xxx.onclick = function(){} // 마우스 클릭 이벤트와 연결되는 이벤트 핸들러02. 자바스크립트와 DOMDOM 요소 스타일 변경  let item = document.getElementById(&quot;ice-bear&quot;);  item.style.backgroundColor = &quot;blue&quot;;  item.innerHTML =&quot;아이스베어는 귀엽다.&quot;;03. Node 객체: HTML DOM에서 정보를 저장하는 계층적 단위1) 노드의 종류문서 노드(document node) : HTML 문서 전체요소 노드(element node) : 각 HTML 요소. 속성 노드 가질 수 O주석 노드(comment node) : HTML 문서의 모든 주석속성 노드(attribute node) : HTML 요소의 속성. 요소 노드의 자식 노드엔 포함 X텍스트 노드(text node) : HTML 문서의 모든 텍스트2) 노드 정보 접근nodeName (이름), nodeValue (값), nodeType (타입)  document.childNodes1.nodeName;  document.getElementById(&quot;ice-bear&quot;).nodeValue;  document.getElementById(&quot;ice-bear&quot;).firstChild.nodeType;nodeType 프로퍼티 값 : 숫자로 표현됨.  요소 노드:1  속성 노드: 2  텍스트 노드: 3  주석 노드: 8  문서 노드: 904. 이벤트(Event)HTML 요소에 대해 발생하는 사건(마우스 호버, 마우스 움직임, 마우스 클릭 등). 웹 브라우저가 감지.자바스크립트는 발생한 이벤트에 반응하여 특정 동작 수행 가능1) 이벤트 타입폼, 키보드, 마우스, HTML DOM, Window 객체 등// 마우스 클릭 이벤트 예시. this는 p 태그 돔 객체 자기 자신을 의미&lt;p onclick=&quot;changeHTML(this)&quot;&gt;클릭하기&lt;/p&gt;&lt;script&gt;    function changeHTML(element) {        element.innerHTML = &quot;클릭했을 때 변경할 HTML&quot;;    }&lt;/script&gt;2) 이벤트 핸들러이벤트 처리 담당 함수지정된 이벤트가 발생하면, 웹 브라우저는 그 요소에 등록된 이벤트 핸들러를 실행// 이 함수는 HTML 문서가 로드될 때 실행.window.onload = function() {    alert(&quot;로드되었습니다.&quot;);}객체나 요소에 이벤트 핸들러 등록하는 방법자바스크립트 코드에서 프로퍼티로 등록 window.onload = function() { } // 이 함수는 HTML 문서가 로드될 때 실행됨.HTML 태그에 속성으로 등록 &lt;p onclick=&quot;this.innerText = '클릭됨!'&quot;&gt;클릭하기&lt;/p&gt;addEventListener 대상객체.addEventListener(이벤트명, 실행할이벤트핸들러, 이벤트전파방식)기타 유용한 Javascript 코드xxx.getAttribute(&quot;href&quot;); // 해당 태그가 갖고 있는 속성의 속성값window.scrollTo({ //특정 지점으로 스크롤링    'behavior': 'smooth',    'top': xxx.offsetTop // 특정 영역의 위에서의 좌표값});setInterval(function(){...}, 1000); // 1초마다 코드 실행. ms 단위.xxx.animate({    marginLeft: &quot;0px&quot;, &quot;1000px&quot;}, {    duration: 500,    easing: &quot;ease&quot;,    iterations: 1,    fill: &quot;both&quot;}); // 애니메이션 실행xxx.classList.remove(클래스명) // 요소에서 특정 클래스 제거xxx.classList.add(클래스명) // 요소에 해당 클래스 추가nodeList.forEach(function(item) { // 배열의 모든 요소에 코드 적용    console.log(item)})xxx.previousElementSibling; // 이전 요소 선택xxx.nextElementSibling; // 다음 요소 선택xxx.parentElement; // 부모 요소 선택xxx.firstElementChild; // 첫번째 자식 요소 선택xxx.lastElementChild; // 마지막 자식 요소 선택JQuery1. 제이쿼리란?자바스크립트 언어로 구성된 라이브러리. 언어 X.간단한 명령어로 주요 기능을 쉽게 구현 가능현업에선 비중 줄었지만 사용하는 웹사이트는 꾸준히 증가 추세.제이쿼리 공식 홈페이지에서 다운로드하여 사용(다운로드 버튼 클릭 → 원하는 것 오른쪽 클릭 → 다른 이름으로 링크 저장)제이쿼리 먼저 불러온 후 자바스크립트 파일 적용하자!  &lt;script src=&quot;jquery-3.6.0.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;자바스크립트 vs 제이쿼리  let txt = document.getElementById(&quot;txt&quot;); // 자바스크립트  $(&quot;#txt&quot;) // 제이쿼리예전 jquery 버전에선 아래와 같이 사용  $(document).ready(function(){  })jquery-3.x.x 버전에선 아래와 같이 사용. 꼭 써주자!→ 이전 형식($(document).ready)은 지원하지 않음.  $(function(){     // 원하는 제이쿼리 코드 삽입  });제이쿼리 선택자 : $(&quot;xxx&quot;)의 형태2. jQuery 이벤트$(&quot;h1&quot;).slideDown(function() { …… });$(&quot;h1&quot;).click(function() { …… });$(&quot;h1&quot;).mouseenter(……); // 마우스 올렸을 때$(&quot;h1&quot;).mouseleave(……); // 마우스 뗐을 때$(&quot;h1&quot;).hide(); // 숨기기$(&quot;h1&quot;).show(); // 보여주기$(&quot;h1&quot;).toggle(); // hide, show 토글$(&quot;h1&quot;).fadeOut();$(&quot;h1&quot;).fadeIn();$(&quot;h1&quot;).fadeToggle();$(&quot;h1&quot;).addClass(…); // 클래스 추가$(&quot;h1&quot;).removeClass(…); // 클래스 제거$(&quot;h1&quot;).toggleClass();  // addClass와 removeClass$(&quot;h1&quot;).hasClass(…); // 해당 클래스 있는지 확인3. this어떤 영역에 이벤트를 적용할 때 this는 선택된 영역만 의미제이쿼리에서 this 적용 방법  var $myImg = $(&quot;.myImg&quot;);      $myImg.click(function() {      $(this)……  })변수의 데이터가 제이쿼리면? → 변수명은 보통 $로 시작기타 유용한 Javascript 및 jQuery 코드e.preventDefault(); // 기본 동작 정지xxx.find(&quot;XXX&quot;)$(&quot;a&quot;).attr(&quot;href&quot;);xxx.prev(); // 이전 요소 선택xxx.next();xxx.first(); xxx.last();hash : 이동할 페이지의 좌표가 HTML 문서 어디에 위치하는지 추적find() : 선택된 요소의 자식 요소를 찾을 때 사용attr() : 선택된 태그의 특정 속성값을 가져오거나 속성값을 부여할 때 사용let $target = $(this.hash);    $(&quot;html, body&quot;).animate({ scrollTop: $target.offset().top }, &quot;fast&quot;);scrollTop : 원하는 위치에 스크롤링 효과 적용해서 페이지 이동시킬 때 사용offset().top : 브라우저의 최상단부터 선택된 영역의 상단까지의 거리를 절대좌표로 반환"
40,"Ethereum ClientEthereum 사양을 구현하는 SW 어플리케이션다른 클라이언트와 P2P network로 통신기본 구현들Parity (Rust), Geth(Go), cpp-ethereum(C ++), pyethereum (python), Mantis (Scala), Harmony (java)Full node로 실행되어야 하는가?Full node 이더리움에 참여했을 때, 참여자가 해야하는 모든 역활을 수행하는 형태의 노드이더리움 개발에는 풀노드는 필요하지 않음remote client (원격 클라이언트)모든 블록체인 데이터를 저장하지 Xwallet + transaction 생성 + broadcast + 몌ㅑ 모두Full Node장점모든 transaction을 정식적으로 검증중개자 없이 공개 블록체인에 직접 배포 가능단점처음 시작할 때 동기화하는데 오래 걸림하드웨어와 대역폭 자원 확대 필요Public Testnet (공개 테스트넷)장점동기화에 더 적은 데이터 필요많은 users &amp; contracts의 공개 블록체인 존재단점실제처럼 테스트할 수 없다 (fees, network congestion, confirm delay .. )Local Blockchain Simulation장점동기화 X, Ether 필요 X, 다른 사용자 X,단점mainnet처럼 실행하지 않음Go-Ethereum (Geth) : 공식적인 이더리움 클라이언트 구현Go 언어로 구현JSON-RPC Interface이더리움의 클라이언트는 JSON-RPC API 제공8545 포트로 HTTP 서비스 제공Remote Ethereum Clientsfull client의 일부기능 제공.더 빠르고 데이터 용량도 더 적게 요구제공하는 기능지갑의 개인키&amp;주소 관리transaction 생성, 서명, 배포smart contract 연결web3 인스턴스를 웹 브라우저에 삽입local 또는 remote node에 RPC 서비스 제공"
41,"Ether: 이더리움의 화폐 단위1 ETH = 1*1018 wei (wei : 더 작은 단위)Ethereum Wallet (지갑)사용자의 Ethereum account 관리사용자 key를 저장 &amp; transaction 생성형태 : mobile, desktop, web-based대표적인 지갑MetaMask : Browser extension walletJaxxMyEtherWalletWorld ComputerEther : smart contact가 실행되는 비용으로 사용Smart contract : EVM에서 실행되는 프로그램EVM : 이더리움 가상 머신Ethereum blockchain : 상태변화를 기록Account Type (계정 유형)(1) Exterally owned account (EOA)MetaMask wallet안에서 사용자의 계정Address, private key, Ether 포함(2) Contract accountAddress, code, Ether 포함목적지의 Transaction은 contract addressEVM에서 실행되는 contract 생성contract안의 함수 호출코드의 논리에 따라 Owned &amp; Controlled(주로 EOA계정에서 블록체인에 등록된 smart contract 주소로 접근해 특정기능 수행)Simple Contract : Test Ether FaucetSolidity: Ehereum에서 smart contact를 작성하는 언어Faucet 기능: Ether를 요청한 주소에 Ether 제공solidity로 construct 작성faucet.sol// Version of Solidity compiler this program was written forpragma solidity 0.6.4;// Our first contract is a faucet!contract Faucet {   // &lt;- declare a contract    // Accept any incoming amount    receive() external payable {}      // Give out ether to anyone who asks    function withdraw(uint withdraw_amount) public {  // withdraw_amount : pay        // Limit withdrawal amount        require(withdraw_amount &lt;= 100000000000000000); // condition check        // Send the amount to the address that requested it (실제 인출)        msg.sender.transfer(withdraw_amount);    }}"
42,"1. What is Ethereum?World Computer컴퓨터 사이언스 관점Deterministic, unbounded staate 머신접근가능한 singleton state + 가상 머신실용적 관점오픈 소스, 탈중앙화 컴퓨팅 구조smart contract 실행하는 프로그램블록체인을 이용해 동기화 &amp; 상태변화 저장암호화폐 사용 (Ether)플랫폼으로서    - 경제적 기능을 내장한 탈중앙화 앱    - 높은 사용성, 중립성, 투명성 .. 제공2. Bitcoin &amp; Ethereum공통점P2P 네트워크디지털 서명과 해시암호학 기반 기술 사용차이점Bitcoin화폐 흐름 추적 &amp; 관리에 초첨제한된 스크립트 언어 사용Ethereum임의의 데이터들의 상태 변화에 초점범용 프로그래밍 가능, 튜링 완전 언어3. Ethereum ComponentsP2P network : 이더리움 메인 네트워크Consensus rules(합의 규칙)Transactions : {sender, recipient, value, data paylooad}를 포함State machine : EVM(Ethereum Virtual Machine)Data Structure : 참여하는 노드에 데이터베이스 형태로 저장.Consensus algorithm(합의 알고리즘) : PoW(Etash,current) -&gt; PoS(Casper, near future)Clients : 이더리움 블록체인에 참여할 수 있는 사용자 프로그램Go-Ethereum(Geth), Parity"
43,"문제 설명단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다.제한사항s는 길이가 1 이상, 100이하인 스트링입니다.입출력 예sreturn&quot;abcde&quot;&quot;c&quot;&quot;qwer&quot;&quot;we&quot;SOLVE홀수 : slen(s)//2 =slen(s)//2 : len(s)//2+1짝수 : slen(s)//2-1 : len(s)//2+1두 케이스에서 규칙을 찾자면..sm or m-1 : m+1로 표현할 수 있다.홀수일때 m이고, 짝수일때 m-1임을 표현해보면sm-1 +(len(s)%2) : m+1을 통해 하나의 식으로 표현 가능def solution(s):m = len(s)//2return sm-1+(len(s)%2):m+1if문 없이 하고 싶어서 발악을 한번 해봤다ㅋㅋ"
44,"비밀지도네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 &quot;공백&quot;(&quot; &quot;) 또는 &quot;벽&quot;(&quot;#&quot;) 두 종류로 이루어져 있다.전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 &quot;지도 1&quot;과 &quot;지도 2&quot;라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.&quot;지도 1&quot;과 &quot;지도 2&quot;는 각각 정수 배열로 암호화되어 있다.암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.입력 형식입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.1 ≦ n ≦ 16arr1, arr2는 길이 n인 정수 배열로 주어진다.정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.출력 형식원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.입출력 예제narr1arr2출력59, 20, 28, 18, 1130, 1, 21, 17, 28&quot;#####&quot;,&quot;# # #&quot;, &quot;### #&quot;, &quot;# ##&quot;, &quot;#####&quot;SOLVEarr1i과 arr2i을 이진수로 변환하고, 겹쳐서 1인 부분이 '#'이다.arr1i와 arr2i의 각 비트 중 한 곳에만 있으면 1로 반환하면 된다즉, 두 비트 중 한 곳에만 있어도 1이므로, bit연산 중 OR연산을 수행하면 쉽게 구할 수 있다.bin(arr1i | arr2i)이를 문자열로 바꾸고 배열의 크기인 n에 맞춰서 0을 채워줘야 한다tmp = str(bin(arr1i | arr2i))2:.zfill(n)문자열에서 '1' -&gt; '#'으로, '0' -&gt; ' '으로 replace  tmp = tmp.replace('1','#')  tmp = tmp.replace('0',' ')def solution(n, arr1, arr2):  answer =   for i in range(n):      tmp = str(bin(arr1i | arr2i))2:.zfill(n)      tmp = tmp.replace('1','#')      tmp = tmp.replace('0',' ')      answer.append(tmp)  return answer"
45,"문제 설명어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 &quot;AB&quot;는 1만큼 밀면 &quot;BC&quot;가 되고, 3만큼 밀면 &quot;DE&quot;가 됩니다. &quot;z&quot;는 1만큼 밀면 &quot;a&quot;가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.제한 조건공백은 아무리 밀어도 공백입니다.s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.s의 길이는 8000이하입니다.n은 1 이상, 25이하인 자연수입니다.입출력 예snresult&quot;AB&quot;1&quot;BC&quot;&quot;z&quot;1&quot;a&quot;&quot;a B z&quot;4&quot;e F d&quot;SOLVE시저암호는 예전에 ctf에서 가장 쉬운 문제에서 나왔던 문제였다.%연산자를 이용해서 범위에 알맞게 밀 수 있도록 하기.def solution(s, n):    answer = ''    for i in s:        if i.islower(): # 소문자            answer+=chr((ord(i)-97+n)%26+97)        elif i.isupper(): # 대문자            answer+=chr((ord(i)-65+n)%26+65)        else: # 나머지는 무시            answer+=i    return answer"
46,"문제 설명새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요.단, 금액이 부족하지 않으면 0을 return 하세요.제한사항놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수입출력 예pricemoneycountresult320410SOLVE위의 예시를 풀어보면..(3 + 6 + 9 + 12) - 20 을 리턴한다.3*(1 + 2 + 3 + 4) - 20 price * (1 + 2 + .. + count) - money등차수열의 합 공식 사용 : price*(count)(count+1)/2 - money위의 코드를 바로 리턴하였는데 왜...안되지 하다가, 문제에서 금액이 부족하지 않으면 0을 리턴하라 했었다.(지불 비용) &lt; money이면 0리턴(지불 비용) &gt; money이면 그 차를 리턴def solution(price, money, count):  return price*count*(count+1)//2-money if price*count*(count+1)//2&gt;money else 0조건 연산자 러버의 답안다른 사람의 풀이에서 max((지불비용-money),0)을 통해 조건연산자 없이 리턴하는 방법이 있었다.. 와우def solution(price, money, count):    return max(0,price*(count+1)*count//2-money)"
47,"문제 설명자연수 n이 매개변수로 주어집니다. n을 x로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 x를 return 하도록 solution 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다.제한 사항3 ≤ n ≤ 1,000,000입출력 예nresult1031211SOLVE나머지가 1이되는 가장 작은 자연수를 찾으라 한다.n%KEY == 1 이되는 KEY를 찾으면 바로 리턴 (단, KEY는 1부터 점점 커짐)def solution(n):  answer = 1  while True:      if n%answer==1: return answer      answer+=1"
48,"문제 설명명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.명함 번호가로 길이세로 길이16050230703603048040가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.제한사항sizes의 길이는 1 이상 10,000 이하입니다.sizes의 원소는 w, h 형식입니다.w는 명함의 가로 길이를 나타냅니다.h는 명함의 세로 길이를 나타냅니다.w와 h는 1 이상 1,000 이하인 자연수입니다.입출력 예sizesresult60, 50, 30, 70, 60, 30, 80, 40400010, 7, 12, 3, 8, 15, 14, 7, 5, 15120SOLVE원래는 그냥 가로길이 중 max값과 세로길이 중 max값을 곱하는 줄 알았는데,명함을 회전시킬 수 있다는 조건이 있었다.명함이 w, h로 있을 때, 무조건 w&gt;h되도록 회전시킨 뒤정렬된 명함을 가지고 지갑의 wF, hF와 비교하기 (wF&gt;hF)wF &lt;- w (if w&gt;wF)hF &lt;- h (if h&gt;hF)def solution(sizes):total=0,0for card in sizes:  card.sort()  for i in range(2):      if cardi&gt;totali:    totali=cardireturn total0*total1"
49,"문제설명2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 &quot;TUE&quot;를 반환하세요.제한 조건2016년은 윤년입니다.2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)입출력 예abresult524&quot;Tue&quot;SOLVEdatetime모듈의 weekday()로 요일정보를 불러오기import datetimedef solution(a, b):    days = 'MON','TUE',&quot;WED&quot;,&quot;THU&quot;,&quot;FRI&quot;,&quot;SAT&quot;,'SUN'    return daysdatetime.date(2016,a,b).weekday()"
50,"문제설명길이가 n이고, &quot;수박수박수박수....&quot;와 같은 패턴을 유지하는 문자열을 리턴하는 함수, solution을 완성하세요. 예를들어 n이 4이면 &quot;수박수박&quot;을 리턴하고 3이라면 &quot;수박수&quot;를 리턴하면 됩니다.제한 조건n은 길이 10,000이하인 자연수입니다.입출력 예nreturn3&quot;수박수&quot;4&quot;수박수박&quot;SOLVE파이썬은 너무 좋다. 문자열 곱셈이 되니..n이 짝수 : &quot;수박&quot;*(n//2)n이 홀수 : &quot;수박&quot;*(n//2)+&quot;수&quot; def solution(n):  return &quot;수박&quot;*(n//2) if n%2==0 else &quot;수박&quot;*(n//2)+&quot;수&quot;다른 사람의 풀이를 보니, if문을 사용하지 않고도 풀 수 있는 방법을 봤다.def solution(n):    return &quot;수박&quot;*(n//2) +(&quot;수&quot;)*(n%2)"
51,"문제 설명자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.제한사항n은 1 이상 100,000,000 이하인 자연수입니다.입출력 예nresult457125229SOLVEn(10)n1(3)n1(3)_reversen2(10)45120000217- n -&gt; n1 : 3진수로 변환```pythondef ten_to_three(x):arr=while True:if x&lt;3:arr.append(x)arr.reverse()return arr    #: 리스트로 반환arr.append(x%3)x=x//3```- n1리스트를 0번째부터 다시 10진수로 바꾼다(0번째부터 돌리므로 뒤집어서 10진수로 바꾼것과 같음)```pythondef solution(n):re = ten_to_three(n)finalRe=0for i in range(len(re)):finalRe+=(3*i)int(rei)return finalRe```def ten_to_three(x):    arr=    while True:        if x&lt;3:            arr.append(x)            arr.reverse()            return arr        arr.append(x%3)        x=x//3def solution(n):    re = ten_to_three(n)    finalRe=0    for i in range(len(re)):        finalRe+=(3**i)*int(rei)    return finalRe다른 사람의 풀이 중 좋은 풀이를 가져와봤다def solution(n):    tmp = ''    while n:        tmp += str(n % 3)        n = n // 3    answer = int(tmp, 3)  # int()로 10진수    return answerhttps://programmers.co.kr/learn/courses/30/lessons/68935"
52,"문제 설명S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.제한사항d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.입출력 예dbudgetresult1,3,2,5,4932,2,3,3104### SOLVE최대한 많은 부서를 지원하려면, 작은 금액을 신청한 부서들부터 지원해야 한다.지원금액 리스트를 오름차순으로 정렬.정렬한 리스트를 0번째부터 budget을 초과하는지 checksum : 지금까지 지원한 예산중간에서 초과되면 (지원한 부서 수) 바로 리턴리스트를 다돌때까지 리턴이 안되면 =&gt; 모두 지원한 것def solution(d, budget):sum=0d.sort()for i in range(len(d)):  if sum+di &gt; budget:      return i  sum+=direturn len(d)"
53,"문제 설명함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요.제한 조건x는 -10000000 이상, 10000000 이하인 정수입니다.n은 1000 이하인 자연수입니다.입출력 예xnanswer252,4,6,8,10434,8,12-42-4,-8### solve그냥 for문으로 n개를 돌려주면 된다```pythondef solution(x, n):return x*(i+1) for i in range(n)```"
54,"문제 설명프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다.전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요.제한 조건phone_number는 길이 4 이상, 20이하인 문자열입니다.입출력 예phone_numberreturn&quot;01033334444&quot;&quot;*******4444&quot;&quot;027778888&quot;&quot;*****8888&quot;### solve필요한 부분 : 뒤에서 4글자  뒤에서 4글자 자르기 : phone_number-4:나머지 글자들은 '*'로 표시문자 곱셈을 이용하면 편하게 나머지 부분을 표시해줄 수 있다.'*'를 (나머지 부분의 글자수)만큼 표시나머지 부분 : len(phone_number)-4 def solution(phone_number):    return '*'*(len(phone_number)-4)+phone_number-4:"
55,"문제설명양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.제한 조건x는 1 이상, 10000 이하인 정수입니다.입출력 예arrreturn10true12true11false13false### solve하샤드 수인지 검사하는 코드를 짜면 된다.입력값 x의 각 자리수의 합을 구한다.  각 자리수를 10씩 나눠서 구하는 것은 너무 귀찮다.  그냥 문자열로 바꿔서 각 자리를 int()형으로 바꿔서 리스트로 만들자  arr = int(i) for i in str(x)  리스트로 만들면 간단하게 sum()을 사용하면 모든 요소의 총합을 구할 수 있다.  totalSum = sum(int(i) for i in str(x))검사x % (각 자리수 합)이 0 =&gt; True 리턴0이 아니라면 =&gt; False 리턴def solution(x):    totalSum = sum(int(i) for i in str(x))    return True if x%totalSum==0 else False"
56,"프로그래머스 lv1에 있는 MySQL문을 이용하는 문제들을 풀어봤다.문제 설명ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.solve모든 레코드 조회하기문제      동물 보호소에 들어온 모든 동물의 정보를 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요.solve테이블에 있는 정보를 모두 조회 =&gt; select 사용테이블 조회 (SELECT)ex. sql select (필드명's) from (테이블명) where 조건모든 필드 선택 : *****중복되는 값 제거 : distinct 키워드 사용select distinct name from students;정렬 : order byASC : 오름차순 (기본 설정)DESC : 내림차순 select name from students order by (정렬 기준 컬럼)select * from ANIMAL_INS order by ANIMAL_ID;동물의 아이디와 이름문제동물 보호소에 들어온 모든 동물의 아이디와 이름을 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요.solve조회할 컬럼 : ID, Name오름차순 정렬 =&gt; order by (기준 대상)SELECT ANIMAL_ID,NAME from ANIMAL_INS order by ANIMAL_ID;역순 정렬하기문제동물 보호소에 들어온 모든 동물의 이름과 보호 시작일을 조회하는 SQL문을 작성해주세요. 이때 결과는 ANIMAL_ID 역순으로 보여주세요.solve테이블에 있는 모든 정보 중.. name, datetime 컬럼 조회SELECT NAME,DATETIME from ANIMAL_INS;여기에 ANIMAL_ID 순으로 내림차순 정렬하라는 조건이 붙는다.SELECT NAME,DATETIME from ANIMAL_INS order by ANIMAL_ID desc;아픈 동물 찾기문제동물 보호소에 들어온 동물 중 아픈 동물의 아이디와 이름을 조회하는 SQL 문을 작성해주세요. 이때 결과는 아이디 순으로 조회해주세요.solve(where을 사용해 특정 조건에 부합하는 데이터들만 조회할 수 있다)아픈 동물은 INTAKE_CONDITION에 'Sick'값이 들어 있다.SELECT ANIMAL_ID,NAME from ANIMAL_INS where INTAKE_CONDITION='Sick' order by animal_id;어린 동물 찾기문제동물 보호소에 들어온 동물 중 젊은 동물의 아이디와 이름을 조회하는 SQL 문을 작성해주세요. 이때 결과는 아이디 순으로 조회해주세요.solve늙은 동물은 INTAKE_CONDITION에 'Aged'값이 들어 있다.즉, 젊은 동물들은 INTAKE_CONDITION에 'Aged'값이 들어있지 않으면 된다.SELECT ANIMAL_ID,NAME from ANIMAL_INS where INTAKE_CONDITION!='Aged';여러 기준으로 정렬하기문제동물 보호소에 들어온 모든 동물의 아이디와 이름, 보호 시작일을 이름 순으로 조회하는 SQL문을 작성해주세요. 단, 이름이 같은 동물 중에서는 보호를 나중에 시작한 동물을 먼저 보여줘야 합니다.solveSELECT ANIMAL_ID,NAME,DATETIME from ANIMAL_INS order by NAME,DATETIME desc;다중정렬 : 여러 기준을 가지고 정렬order by절에 ,(쉼표)로 구분order by col1 asc, col2 desc;   // col1을 먼저 정렬한 뒤, 위의 정렬에서 같은 순위에 한해서만 col2로 정렬ASC(오름차순)DESC(내림차순)숫자작은값 우선큰값 우선문자사전순사전 반대 순날짜빠른 날짜 순늦은 날짜 순NULL가장 마지막에 나옴가장 먼저 나옴상위 n개 레코드문제동물 보호소에 가장 먼저 들어온 동물의 이름을 조회하는 SQL 문을 작성해주세요.solve가장 먼저 들어온 동물 : datetime이 가장 빠른 동물 =&gt; datetime 오름차순으로 정렬했을 때, 가장 위의 데이터 MySQL 조회 개수 제한 (LIMIT)LIMIT : 조회할 데이터의 갯수를 지정ex. sql select * from (테이블명) limit n (n개의 데이터만 조회)    SELECT NAME from ANIMAL_INS order by DATETIME limit 1;이름이 없는 동물의 아이디문제동물 보호소에 들어온 동물 중, 이름이 없는 채로 들어온 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다.solve이름이 없는 동물들은 NAME필드가 비어있다 =&gt; 즉, NAME이 NULL인지 확인.null 유무 확인is null : 비어있나?is not null : 비어있지 않나?ex. select * from (테이블 명) where (필드명) is (not) null;SELECT ANIMAL_ID from ANIMAL_INS where NAME is null order by ANIMAL_ID;이름이 있는 동물의 아이디문제동물 보호소에 들어온 동물 중, 이름이 있는 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다.solve위의 문제랑 다른점은 이제는 NAME필드에 값이 있는지 확인하자 =&gt; NAME이 not NULL인지 확인.SELECT ANIMAL_ID from ANIMAL_INS where NAME is not null order by ANIMAL_ID;최대값 구하기문제가장 최근에 들어온 동물은 언제 들어왔는지 조회하는 SQL 문을 작성해주세요.solve가장 최근에 들어온 동물 : datetime 값이 가장 큰 동물이다.데이터 최대, 최소 값 가져오기 (MAX, MIN 함수)최대값 : MAXselect MAX(필드명) from (테이블명)최소값 : MINsql select MIN(필드명) from (테이블명)SELECT max(datetime) from animal_ins; 참조) 프로그래머스-코딩테스트 연습 https://programmers.co.kr/learn/courses/30/lessons/59034"
57,"문제 설명수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.제한 조건시험은 최대 10,000 문제로 구성되어있습니다.문제의 정답은 1, 2, 3, 4, 5중 하나입니다.가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.입출력 예solve완전탐색을 이용하는 문제였다.answers의 각 번호당 답을 수포자1,2,3의 답과 일일이 비교하자.  1번 수포자 : 1,2,3,4,5가 반복되고 있음  2번 수포자 : 2,1,2,3,2,4,2,5가 반복되고 있음  3번 수포자 : 3,3,1,1,2,2,4,4,5,5가 반복되고 있음 def solution(answers):    dic2=2,1,2,3,2,4,2,5    dic3 = 3,3,1,1,2,2,4,4,5,5    answer = 0,0,0    for i in range(len(answers)):        if i%5+1==answersi:           #1            answer0+=1        if dic2i%8 == answersi:     #2            answer1+=1        if dic3i%10 == answersi:    #3            answer2+=1    m = max(answer)    return sorted(i+1 for i in range(len(answer)) if answeri==m)출처) 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/courses/30/lessons/42840"
58,"1. 완전탐색이란?가능한 모든 경우의 수를 다 확인하여 해를 구하는 방법.    ""brute force""라고도 불림      확실하게 정답을 찾을 수 있지만, 효율적이지 않다.2. 완전 탐색 활용하기활용하기 위해 여러 알고리즘 기법이 사용.    brutee-force 기법 - 반복/조건문을 활용해 모두 테스트  순열(permutation) - n개의 원소 중 r개의 원소를 중복 허용 없이 나열  재귀 호출(recursion)  비트마스크 - 2진수 표현 기법을 활용   BFS(너비우선탐색), DFS(깊이우선탐색) 활용3. 활용 문제들&lt;프로그래머스 - 모의고사&gt;https://velog.io/@c43t4rd/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-LV1-%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC이후 추가 예정.."
59,"Box Model문서의 레이아웃을 구성하는 사각형 모양의 요소문서의 레이아웃을 계산할 때, 브라우저의 렌더링 엔진은 표준 CSS 기본 박스 모델에 따라 각각의 요소를 _사각형 박스로 표현_한다.CSS는 박스의 _크기, 위치, 속성(색, 배경, 테두리 모양 등)을 결정_한다.하나의 박스는 _네 부분(영역)_으로 이루어지며, 각 영역을 _콘텐츠 영역, 안쪽 여백(패딩) 영역, 테두리 영역, 그리고 바깥 여백(마진) 영역_이라고 부른다.Box Model의 영역Content : _내용(Content)_이 들어 있는 Box, 가로는 width, 세로는 heightPadding : 안쪽여백, Content와 Border 사이의 공간을 의미Border : _테두리_를 의미하며 굵기, 스타일, 색상 순서로 명시 ex) border : 1px solid #000;Margin : 바깥 여백, 요소와 요소 사이의 간격을 의미Box model의 속기형(Shorthand)시계방향(top, right, bottom, left)순서대로 설정값을 입력top, bottom과 right, left는 짝 값의 명시가 없다면 _짝의 값을 동일_하게 적용ex) padding : 20px 10px 30px 40px;, padding : 20px 10px;Box Sizing요소의 너비와 높이를 계산하는 방법을 지정Box Sizing은 요소에 _사이즈_를 잡는 선언이다.content-box, border-box속성을 사용하여 선언하며 기본적으로 HTML요소들은 box-sizing의 값이 _content-box로 설정_된다..box {  /* weight, height로 설정한 값은 content영역에만 적용 */  box-sizing: content-box;}.box {  /* weight, height로 설정한 값은 content + padding + border영역에 적용 */  box-sizing:border-box }참고 자료CSS 기본 박스 모델 입문 - MDNbox-sizing - CSS: Cascading Style Sheets | MDN"
60,"CSS란?마크업된 HTML문서에 Style을 적용하기 위해 사용되는 스타일 언어 CSS(Cascading Style Sheets)는 HTML로 작성된 문서의 표시 방법을 기술하기 위한 _스타일 시트 언어_이다.CSS는 요소가 화면, 종이, 음성이나 다른 매체 상에 어떻게 _렌더링_되어야 하는지 지정하는 역활을 담당한다. 즉 마크업 언어(HTML)가 웹사이트의 _몸체_를 담당한다면 CSS는 옷과 액세서리처럼 _꾸미는 역할_을 담당한다. 이를 활용하여 HTML 구조는 그대로 두고 CSS 파일만 변경해도 전혀 다른 웹사이트처럼 꾸밀 수 있다.HTML문서에 CSS파일을 적용하는 방법스타일을 적용 및 수정할 때 HTML문서를 확인하는 것은 _비효율적_이다. 즉 스타일에 관한 코드를 작성할 때는 _CSS파일만 바라보는 것_이 바람직하다.HTML문서에 CSS파일을 적용하는 방법은 크게 3가지로 구분된다.&lt;head&gt;태그에 &lt;link&gt;태그로 적용&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;&lt;/head&gt;&lt;head&gt;태그에 &lt;style&gt;태그로 적용&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    p {      font-size: 32px;    }  &lt;/style&gt;&lt;/head&gt;inline스타일 방법으로 적용&lt;body&gt;  &lt;p style=&quot;font-size: 32px;&quot;&gt;    Lorem ipsum, dolor sit amet consectetur adipisicing elit.     Ipsum optio sequi vero nesciunt commodi voluptates voluptatum.  &lt;/p&gt;&lt;/body&gt;특수한 상황이 아니라면 &lt;head&gt;태그에 &lt;link&gt;태그로 적용하는 방법을 사용하는 것이 일반적이다.참고 자료 CSS: Cascading Style Sheets | MDN"
61,"Sectioning ElementsHTML에서는 Sectioning Element Tags를 사용하여 _문서의 구획_을 나눈다.책을 펼치면 목차가 있고 그 안에 각각의 주제에 맞는 컨텐츠가 있듯 HTML 문서도 각각의 구성을 주는 요소들이 있다.Sectioning Element는 &lt;header&gt;, &lt;main&gt;, &lt;footer&gt;의 _3단 병렬구조 문서_를 구성하며, 그 안에서 추가로 &lt;nav&gt;, &lt;aside&gt;, &lt;section&gt;, &lt;article&gt;을 사용한다.이는 &lt;div&gt;, &lt;span&gt;을 사용하는 것보다 의미, 뉘앙스가 더 부각되어 _Semantic Markup_이 된다.Header Tag소개 및 탐색에 도움을 주는 콘텐츠를 나타내는 태그HTML의 &lt;header&gt;는 _문서의 시작_이나 Sectioning elements 태그안에서 _도입부_를 나타낼때 사용한다. 이 때 &lt;header&gt;를 사용함에 있어 문법적인 주의사항이 없다. 즉 _중복사용이 가능_하다.하지만 너무 많이 남용한다면 문제가 되므로 개발자는 _적절한 선에서 사용_해야 한다.&lt;header&gt;  &lt;h1&gt;    &lt;a href=&quot;#&quot;&gt;      &lt;img src=&quot;#&quot; alt=&quot;Home Page Image&quot; /&gt;    &lt;/a&gt;  &lt;/h1&gt;&lt;/header&gt;Main Tag문서 &lt;body&gt;의 주요 콘텐츠를 나타내는 태그HTML의 &lt;main&gt;은 본문에 있어서 가장 _핵심적인 컨텐츠_를 나타낼 때 사용한다.&lt;main&gt;은 Sectioning Elements태그가 아니므로 태그안에 heading태그 필요하지 않다.또한 &lt;header&gt;와는 달리 제약조건이 있기 때문에 하나의 HTML문서에서는 _단 한개_의 &lt;main&gt;을 사용할 수 있다.즉 &lt;header&gt;는 Sectioning elements태그 안에서 여러번 사용되지만 &lt;main&gt;태그는  Sectioning elements태그 밖에서 단 한번 감싸는 역활로 사용한다.&lt;main&gt;  &lt;header&gt;    &lt;h1&gt;Home&lt;/h1&gt;    &lt;button type=&quot;button&quot; aria-label=&quot;Timeline options&quot;&gt;      Click Button    &lt;/button&gt;    &lt;div&gt;      &lt;h2&gt;Home shows you top Tweets first&lt;/h2&gt;      &lt;button type=&quot;button&quot;&gt;                Click Button      &lt;/button&gt;      &lt;a href=&quot;#&quot;&gt;              View content preferences      &lt;/a&gt;    &lt;/div&gt;  &lt;/header&gt;&lt;/main&gt;Footer Tag가장 가까운 구획 콘텐츠나 구획 루트의 footer를 나타내는 태그HTML의 &lt;footer&gt;는 일반적으로 구획의 작성자, 저작권 정보, 관련 문서 등의 내용을 표현한다.&lt;footer&gt;는 &lt;header&gt;와 비슷하게 _문서의 마지막_이나 Sectioning elements 태그안에서 _하단부_를 나타낼때 사용한다. &lt;footer&gt;  &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;Terms&lt;/a&gt;  &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;Ads info&lt;/a&gt;  &lt;button type=&quot;button&quot;&gt;    More  &lt;/button&gt;  &lt;div&gt;    &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;About&lt;/a&gt;    &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;Status&lt;/a&gt;  &lt;/div&gt;  &lt;span&gt;    © 2020 Twitter, Inc.  &lt;/span&gt;&lt;/footer&gt;Nav Tag자주 쓰이는 예제는 메뉴, 목차, 색인등을 표현하는 태그HTML의 &lt;nav&gt;는 문서의 부분 중 현재 페이지 내, 또는 다른 페이지로의 _링크를 보여주는 구획_을 나타낸다.&lt;nav&gt;  &lt;h1&gt;Global Navigation Menu&lt;/h1&gt;  &lt;ul&gt;    &lt;li&gt;      &lt;a href=&quot;#&quot;&gt;        Home      &lt;/a&gt;    &lt;/li&gt;    &lt;li&gt;      &lt;a href=&quot;#&quot;&gt;        Explore      &lt;/a&gt;    &lt;/li&gt;    &lt;li&gt;      &lt;a href=&quot;#&quot;&gt;        Notifications      &lt;/a&gt;    &lt;/li&gt;&lt;/nav&gt;Aside Tag사이드바 혹은 콜아웃 박스로 표현하는 태그HTML의 &lt;aside&gt;는 문서의 _주요 내용과 간접적으로만 연관된 부분_을 나타낸다.&lt;aside&gt;  &lt;header&gt;    &lt;h1&gt;      Worldword trends    &lt;/h1&gt;    &lt;button type=&quot;button&quot; aria-label=&quot;Options&quot;&gt;      Click Button    &lt;/button&gt;  &lt;/header&gt;  &lt;ol&gt;    &lt;li&gt;      &lt;button type=&quot;button&quot; aria-label=&quot;Options&quot;&gt;        Click Button      &lt;/button&gt;      &lt;a href=&quot;#&quot;&gt;        &lt;span&gt;1 · Trending worldwide&lt;/span&gt;                &lt;span&gt;100K Tweets&lt;/span&gt;      &lt;/a&gt;    &lt;/li&gt;    &lt;li&gt;      &lt;button type=&quot;button&quot; aria-label=&quot;Options&quot;&gt;        Click Button      &lt;/button&gt;      &lt;a href=&quot;#&quot;&gt;        &lt;span&gt;2 · Trending worldwide&lt;/span&gt;              &lt;span&gt;100K Tweets&lt;/span&gt;      &lt;/a&gt;    &lt;/li&gt;&lt;/aside&gt;Section TagHTML 문서의 독립적인 구획을 나타내는 태그HTML의 &lt;section&gt;는 HTML 문서의 _독립적인 구획_을 나타내며, 더 적합한 의미를 가진 요소가 없을 때 사용한다. 보통 &lt;section&gt;은 제목을 포함하지만, 항상 포함하는 것은 아니다.&lt;section&gt;  &lt;h1&gt;Your Timeline&lt;/h1&gt;  &lt;ol&gt;    &lt;li&gt;      Call    &lt;/li&gt;  &lt;/ol&gt;&lt;/section&gt;Article TagHTML 문서내 재사용할 수 있는 구획을 나타내는 태그HTML &lt;article&gt; 는 문서, 페이지, 애플리케이션, 또는 사이트 안에서 독립적으로 구분해 배포하거나 _재사용할 수 있는 구획_을 나타낸다. 대표적인 예제로 게시판, 블로그 글, 매거진, 뉴스 기사 등이 있다.&lt;article class=&quot;forecast&quot;&gt;    &lt;h1&gt;Weather forecast for Seattle&lt;/h1&gt;    &lt;article class=&quot;day-forecast&quot;&gt;        &lt;h2&gt;10 March 2022&lt;/h2&gt;        &lt;p&gt;Rain.&lt;/p&gt;    &lt;/article&gt;    &lt;article class=&quot;day-forecast&quot;&gt;        &lt;h2&gt;11 March 2022&lt;/h2&gt;        &lt;p&gt;Periods of rain.&lt;/p&gt;    &lt;/article&gt;    &lt;article class=&quot;day-forecast&quot;&gt;        &lt;h2&gt;12 March 2022&lt;/h2&gt;        &lt;p&gt;Heavy rain.&lt;/p&gt;    &lt;/article&gt;&lt;/article&gt;참고 자료&lt;header&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;main&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;footer&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;nav&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;aside&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;section&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;article&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
62,"HTML문서의 기본 골격HTML문서의 기본 골격은 다음과 같다.&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;!-- 웹 문서에 관한 메타 데이터 --&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 웹 문서에 들어갈 내용 --&gt;  &lt;/body&gt;&lt;/html&gt;위 코드처럼 &lt;!DOCTYPE html&gt;을 사용하여 작성된 문서는 _HTML5 버전을 사용하겠다고 선언_한 뒤 _루트태그_인 &lt;html&gt;을 시작으로 마크업을 시작한다.이전 포스팅에 소개했던 태그들은 &lt;body&gt;에 사용되어 웹 문서에 직접적으로 내용을 마크업한다.그리고 이제 &lt;head&gt;에 사용되어 _웹 문서에 관한 메타 데이터_를 구성하는 Tag들을 확인해보자.&lt;head&gt;태그 안에 사용되는 태그들Title TagHTML문서에 대제목을 표시하는 태그HTML의 &lt;title&gt;은 브라우저의 제목 표시줄이나 페이지 탭에 보이는 _문서 제목_을 정의한다.이는 _검색 최적화_에 매우 중요하며 텍스트만 포함할 수 있다. 태그를 포함하면 무시된다.&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;!-- 웹 문서에 관한 메타 데이터 --&gt;    &lt;title&gt;Shopping Mall Web Site&lt;/title&gt;    &lt;/head&gt;  &lt;body&gt;    &lt;!-- 웹 문서에 들어갈 내용 --&gt;  &lt;/body&gt;&lt;/html&gt;&lt;title&gt;을 효과적으로 작성하는 방법으로는 크게 3가지가 있다.단순 키워드 나열은 비효율적_각각의 페이지_에 맞게 변경단순한 문장보다는 무엇에 관한 내용인지 자세하게 서술Link TagCSS Style Sheet를 첨부하는 태그HTML의 &lt;link&gt;은 _현재 문서와 외부 리소스_의 관계를 명시한다.주로 &lt;link&gt;는 _CSS 스타일 시트를 연결_할 때 제일 많이 사용하지만, 사이트 아이콘(&quot;파비콘&quot;과 홈 화면 아이콘) 연결 등 _범용적_으로 사용될 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;!-- 웹 문서에 관한 메타 데이터 --&gt;    &lt;title&gt;Shopping Mall Web Site&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 웹 문서에 들어갈 내용 --&gt;  &lt;/body&gt;&lt;/html&gt;Style Tag문서나 문서 일부에 대한 스타일 정보를 포함하는 태그HTML의 &lt;style&gt;은 H_TML문서 내에서 CSS코드를 작성_할 때 사용하는 태그다.하지만 특수한 경우가 아니라면 사용을 지양하고 CSS코드는 _CSS파일에 직접 작성_하는 것이 좋다.&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;!-- 웹 문서에 관한 메타 데이터 --&gt;    &lt;title&gt;Shopping Mall Web Site&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;    &lt;style&gt;      body {        font-size: 20px;      }  &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 웹 문서에 들어갈 내용 --&gt;  &lt;/body&gt;&lt;/html&gt;Script TagHTML문서 내에 JavaScript파일을 첨부할 때 사용하는 태그HTML의 &lt;script&gt;는 데이터와 실행 가능한 코드를 문서에 포함할 때 사용하며 보통 _JavaScript 코드_와 함께 사용한다.WebGL의 GLSL 셰이더 프로그래밍 언어, JSON 등 다른 언어와도 사용할 수 있다.&lt;script&gt;는 상대경로, HTML문서내 직접적 코드작성 2가지의 방법이 있다.특수한 경우가 아니라면 HTML과 Java Script코드를 분리해서 작성하기 위해 _상대경로 방법을 사용_하는 것이 좋다.&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;!-- 웹 문서에 관한 메타 데이터 --&gt;    &lt;title&gt;Shopping Mall Web Site&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;    &lt;style&gt;      body {        font-size: 20px;      }  &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 웹 문서에 들어갈 내용 --&gt;    &lt;!-- 상대경로를 지정해서 사용하는 방법 --&gt;    &lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;    &lt;!-- HTML문서에서 Java Script코드를 작성하는 방법 --&gt;    &lt;script&gt;      let h1 = document.querySelector('h1');      h1.addEventListener('click', function (event) {        this.textContent = 'hi'      })    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;Meta Tag앞선 Tag들로 표현할 수 없는 데이터들을 표현하는 태그HTML의 &lt;meta&gt;는 &lt;link&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;과 같은 다른 메타관련 요소로 _나타낼 수 없는 메타데이터_를 나타낸다.&lt;meta&gt;는 name, content속성을 사용하여 _메타데이터의 종류, 값_을 표현한다.&lt;meta name=&quot;메타데이터 종류&quot; content=&quot;메타데이터 값&quot;&gt;&lt;!-- viewport는 사용하고 있는 기계의 화면 전체사이즈 --&gt;&lt;!-- width=device-width는 화면사이즈의 가로는 디바이스의 가로크게 맞춤 --&gt;&lt;!-- initial-scale=1.0는 처음 화면을 보여줄 때 디바이스의 원래사이즈에 맞게 보여줘라 --&gt;&lt;!-- 디바이스의 사이즈에 맞게 변형되는 반응형 웹사이트 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;!-- author는작성자 명시 --&gt;&lt;meta name=&quot;author&quot; content=&quot;mirrer&quot;&gt;&lt;!-- keywords는 브라우저에게 키워드를 알려주고 다른사람이 해당키워드를 검색할 때 잘 보여줌 --&gt;&lt;meta name=&quot;keywords&quot; content=&quot;mirrer, HTML, front-end&quot;&gt;&lt;!-- description은 해당 웹페이지에 대한 설명(웹접근성적 측면에서 좋은 효과) --&gt;&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;참고 자료&lt;head&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;title&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;link&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;style&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;script&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;meta&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
63,"Abbr Tag약자, 약어, 줄임말등을 마크업할 때 사용하는 태그HTML의 Abbr Tag는 _준말 또는 머리글자_를 나타내며 선택 속성인 title을 사용하면 준말의 전체 뜻이나 _설명을 제공_할 수 있다.title 속성은 전체 설명만을 가져야 하며 다른건 포함할 수 없다.  &lt;p&gt;    &lt;!-- title속성에 풀네임을 입력 --&gt;    너의 &lt;abbr title=&quot;Myers-Briggs Type Indicator&quot;&gt;MBTI&lt;/abbr&gt;는 뭐니?  &lt;/p&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.Address Tag해당 대상에 연락망을 마크업할 때 사용하는 태그HTML의 Address Tag는 가까운 HTML 요소의 사람, 단체, 조직 등에 대한 _연락처 정보_를 나타낸다.연락망의 종류로는 _(물리적)주소, URL, E-Mail주소, 전화번호, SNS연결 링크_등등...이 포함된다.  &lt;address&gt;        &lt;h1&gt;      구글 &lt;!-- 대상 --&gt;    &lt;/h1&gt;    &lt;a href=&quot;https://www.google.co.kr&quot;&gt;https://www.google.co.kr&lt;/a&gt; &lt;!-- 연락망 --&gt;  &lt;/address&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.Pre Tag코드의 들여쓰기 그대로 화면에 출력하고 싶을 때 사용하는 태그HTML의 Pre Tag는 미리 서식을 지정한 텍스트_를 나타내며, HTML에 작성한 _내용 그대로 표현한다.텍스트는 보통 _고정폭 글꼴_을 사용해 렌더링하고, 요소 내 _공백문자를 그대로 유지_한다.  &lt;p&gt;    &lt;!-- 들여쓰기 생략되어 화면에 출력 --&gt;    서울특별시    대전광역시    &lt;/p&gt;    &lt;!-- 들여쓰기 그대로 화면에 출력 --&gt;  &lt;pre&gt;    서울특별시    대전광역시  &lt;/pre&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.Code Tag HTML문서안에서 소스코드를 작성하고 싶을 때 사용하는 태그HTML의 Code Tag는 _짧은 코드 조각_을 나타내는 스타일을 사용해 자신의 콘텐츠를 표시한다.기본 스타일은 사용자 에이전트의 _고정폭 글씨체_다.또한 여러줄의 코드를 사용할때는 _들여쓰기가 중요_하므로 &lt;pre&gt;안에 &lt;code&gt;를 사용한다.  &lt;!-- 한줄의 코드를 마크업할때는 &lt;code&gt;태그 단독사용 --&gt;  &lt;code&gt;    console.log('Hi HTML!!');  &lt;/code&gt;  &lt;!-- 여러줄의 코드를 마크업할때는 &lt;pre&gt;, &lt;code&gt;태그 같이사용 --&gt;  &lt;pre&gt;    &lt;code&gt;      console.log('Hi HTML!!');      let name = 'mirrer';    &lt;/code&gt;  &lt;/pre&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.참고 자료&lt;abbr&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;address&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;pre&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;code&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
64,"Audio Tag문서에 소리 콘텐츠를 포함할 때 사용하는 태그HTML의 Audio Tag는 문서에 _음성파일을 삽입_할 때 사용하는 태그다.Audio Tag의 속성src : 상대경로를 사용해서 해당 음성파일 적용controls : 지정한 파일의 _오디오 플레이어_를 적용autoplay : 접속과 동시에 적용한 음악파일을 재생loop : 지정한 음성파일의 반복재생 유무 적용type : 지정한 음성파일의 _MIME Type_을 적용  &lt;audio controls autoplay loop&gt;    &lt;source src=&quot;./assets/audios/windSound.mp3&quot; type=&quot;audio/mpeg&quot;&gt;  &lt;/audio&gt;브라우저마다 제공하는 음성 파일의 형식이 다르기 때문에 이 점을 고려해서 마크업해야 한다.Vedio Tag비디오 플레이백을 지원하는 미디어 플레이어를 문서에 삽입하는 태그HTML의 Vedio Tag는 &lt;audio&gt;와 기본적인 _사용 방법이 동일_하다.또한 오디오 콘텐츠에도 사용할 수 있지만 &lt;audio&gt;가 사용자 경험(User Experience)에 좀 더 적합하다.  &lt;vedio controls autoplay loop&gt;    &lt;source src=&quot;/media/cc0-videos/flower.webm&quot; type=&quot;video/webm&quot;&gt;  &lt;/vedio&gt;Iframe Tag현재 문서 안에 다른 HTML 페이지를 삽입하는 태그HTML의 Iframe Tag는 _중첩 브라우징 맥락_을 나타내는 태그다. 즉 HTML문서안에 또 다른 HTML문서, 컨텐츠등을 _임베디드할 때 사용_한다.&lt;iframe&gt;는 대부분 직접 작성하지 않고 _해당 영상의 공유 Embed링크를 사용_한다.&lt;iframe src=&quot;https://www.openstreetmap.org/export/embed.html?bbox=-0.004017949104309083%2C51.47612752641776%2C0.00030577182769775396%2C51.478569861898606&amp;layer=mapnik&quot;&gt;&lt;/iframe&gt;참고 자료&lt;audio&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;vedio&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;iframe&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
65,"Table  Tag행과 열로 이루어진 표를 나타내는 태그HTML의 Table Tag는 데이터를 담을 _표를 만들 때 사용_하는 태그다.&lt;table&gt;은 &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;로 테이블의 _데이터를 표현_하고 &lt;thead&gt;, &lt;tbody&gt;, &lt;tfoot&gt;로 테이블의 _데이터를 정의_한다.&lt;table&gt;의 구성 요소&lt;tr&gt; : 데이터의 _행을 표현_하는 요소&lt;th&gt; : 데이터 _헤더를 표현_하는 요소&lt;td&gt; : _데이터를 표현_하는 요소&lt;thead&gt; : 테이블 _데이터의 제목_을 정의하는 요소&lt;tbody&gt; : 테이블 _데이터의 내용_을 정의하는 요소&lt;tfoot&gt; : 테이블 _데이터의 종합, 요약_등을 정의하는 요소  &lt;table&gt;    &lt;thead&gt;      &lt;tr&gt;        &lt;th&gt;&lt;/th&gt;        &lt;th&gt;ID&lt;/th&gt;        &lt;th&gt;이름&lt;/th&gt;        &lt;th&gt;나이&lt;/th&gt;              &lt;/tr&gt;          &lt;/thead&gt;    &lt;tbody&gt;      &lt;tr&gt;        &lt;th&gt;사용자 1&lt;/th&gt;          &lt;td&gt;hong1234&lt;/td&gt;        &lt;td&gt;홍길동&lt;/td&gt;        &lt;td&gt;20&lt;/td&gt;      &lt;/tr&gt;      &lt;tr&gt;        &lt;th&gt;사용자 2&lt;/th&gt;          &lt;td&gt;ikj12&lt;/td&gt;        &lt;td&gt;임꺽정&lt;/td&gt;        &lt;td&gt;40&lt;/td&gt;      &lt;/tr&gt;    &lt;/tbody&gt;  &lt;/table&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.&lt;table&gt;의 Attribute&lt;table&gt;는 rowspan, colspan속성을 사용해 _셀을 병합_할 수 있다.단 병합대상이 된 데이터는 입력하지 않고 생략한다.또한 &lt;th&gt;만 사용할 수 있는 scope속성을 사용해 명시적으로 _데이터의 헤더를 지정_할 수 있다.&lt;!-- 세로줄의 헤더 --&gt;&lt;th scope=&quot;col&quot;&gt;ID&lt;/th&gt;&lt;!-- 가로줄의 헤더 --&gt;&lt;th scope=&quot;row&quot;&gt;사용자 1&lt;/th&gt;참고 자료&lt;table&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
66,"Textarea Tag멀티라인 일반 텍스트 편집 컨트롤을 나타내는 태그HTML의 Textarea Tag는 사용자에게 _여러줄의 데이터를 입력_받을 때 사용하는 태그다.&lt;input type=&quot;text&quot;&gt;와 &lt;textarea&gt;태그의 차이점은 입력받을 수 있는 _데이터의 양_이다.또한 &lt;textarea&gt;는 cols와 rows속성으로 입력받는 데이터의 _크기를 제한_한다.&lt;!-- 짧은 글자의 input 데이터를 입력 받을 때 사용 --&gt;&lt;input type=&quot;text&quot; placeholder=&quot;재료명&quot;&gt;&lt;!-- 여러줄의 input데이터를 입력 받을 때 사용 --&gt;&lt;!-- cols와 rows속성으로 입력받는 데이터의 크기를 제한 --&gt;&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot; placeholder=&quot;재료의 효능을 소개하세요.&quot;&gt;&lt;/textarea&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.Button Tag클릭 가능한 버튼을 나태내는 태그HTML의 Button Tag는 _사용자가 클릭할 수 있는 버튼_을 표현하며 버튼은 양식 내부는 물론 간단한 표준 버튼 기능이 필요한 곳이라면 문서 _어디에나 배치_할 수 있다.&lt;button&gt;의 기본값은 사용자 에이전트의 호스트 플랫폼과 비슷한 디자인을 따라가지만, 외형은 CSS로 변경할 수 있다.&lt;button&gt;의 Attributes&lt;button&gt;은 크게 3가지의 속성을 사용하며 속성별로 외형적인 차이점은 없다.&lt;button type=&quot;button&quot;&gt; : 특정한 목적이 없이 일반적인 버튼을 사용&lt;button type=&quot;submit&quot;&gt; : &lt;form&gt;태그의 데이터를 서버에 제출할 때 사용&lt;button type=&quot;reset&quot;&gt; : &lt;input&gt;태그와 같이 연결된 태그의 내용을 초기화 할 때 사용   &lt;button type=&quot;button&quot;&gt;    &lt;!-- 버튼안에 들어갈 텍스트 --&gt;    Button Type  &lt;/button&gt;  &lt;button type=&quot;submit&quot;&gt;    &lt;!-- 버튼안에 들어갈 텍스트 --&gt;    Submit Type  &lt;/button&gt;  &lt;button type=&quot;reset&quot;&gt;    &lt;!-- 버튼안에 들어갈 텍스트 --&gt;    Reset Type  &lt;/button&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.참고 자료&lt;textarea&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;button&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
67,"Select, Option Tag옵션 메뉴를 제공하는 컨트롤을 생성하는 태그HTML의 Select Tag는 _fall down menu_를 만들때 사용하고 Option Tag는 fall down menu안에 _list값_을 만들 때 사용하는 태그이다.menu의 다중 항목 선택시 &lt;select&gt;태그에 multiple속성 사용한다.또한 &lt;input&gt;태그와는 다르게 &lt;select&gt;태그에만 name속성을 적용하면 자식인 &lt;option&gt;태그에도 _자동으로 적용_된다.  &lt;form action=&quot;&quot; method=&quot;get&quot;&gt;    &lt;!-- &lt;label&gt;태그와 &lt;select&gt;태그 연결시 &lt;input&gt;태그와 동일하게 for, id속성값 지정해서 사용 --&gt;    &lt;label for=&quot;skill&quot;&gt;사용가능을 고르시오.&lt;/label&gt;    &lt;!-- 위와 같이 코드를 작성한 뒤 값을 선택하면 선택한 값이 서버로 전송 --&gt;    &lt;select name=&quot;skill&quot; id=&quot;skill&quot; multiple&gt;      &lt;option value=&quot;html&quot;&gt;HTML&lt;/option&gt;      &lt;option value=&quot;css&quot;&gt;CSS&lt;/option&gt;      &lt;option value=&quot;js&quot;&gt;Java Script&lt;/option&gt;    &lt;/select&gt;       &lt;button type=&quot;submit&quot;&gt;      submit    &lt;/button&gt;  &lt;/form&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.참고 자료&lt;select&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;option&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
68,"Radio Attribute&lt;input&gt;의 속성으로 하나의 항목만 선택이 가능한 버튼Radio Attribute는 &lt;input&gt;의 요소로 보통 서로 관련된 옵션_을 나타내는 _라디오 버튼 콜렉션, _라디오 그룹_에 사용한다.임의의 그룹 내에서는 동시에 하나의 라디오 버튼만 선택할 수 있다. 라디오 버튼은 흔히 _원형_으로 그려지며, 선택한 경우 _속을 채우거나 강조 표시_를 한다.  &lt;h1&gt;나이가 20대입니까?&lt;/h1&gt;  &lt;label for=&quot;answerYes&quot;&gt;네&lt;/label&gt;  &lt;input type=&quot;radio&quot; id=&quot;answerYes&quot;&gt;  &lt;label for=&quot;answerNo&quot;&gt;아니요&lt;/label&gt;  &lt;input type=&quot;radio&quot; id=&quot;answerNo&quot;&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.Name Attribute와 Value AttributeRadio Attribute을 사용할때는 _name, value속성_을 사용하는 것을 권장한다.name속성 : 각각의 radio속성이 서로 연관되어 있다는 것을 알려주기 위해 사용  &lt;h1&gt;나이가 20대입니까?&lt;/h1&gt;  &lt;!-- name속성을 사용해서 같이 묶지 않으면 중복으로 선택가능 --&gt;  &lt;label for=&quot;answerYes&quot;&gt;네&lt;/label&gt;  &lt;input type=&quot;radio&quot; id=&quot;answerYes&quot; name=&quot;answer&quot;&gt;  &lt;label for=&quot;answerNo&quot;&gt;아니요&lt;/label&gt;  &lt;input type=&quot;radio&quot; id=&quot;answerNo&quot; name=&quot;answer&quot;&gt;value속성 : 여러 항목 중 선택된 항목의 값을 서버에서 구분하기 위해서 사용&lt;h1&gt;나이가 20대입니까?&lt;/h1&gt;&lt;form action=&quot;#&quot; method=&quot;GET&quot;&gt; &lt;!-- value값을 설정하면 각각의 항목을 선택함에 따라 서버에 전송되는 값이 다름 --&gt; &lt;label for=&quot;answerYes&quot;&gt;네&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;answerYes&quot; value=&quot;answerYes&quot; name=&quot;answer&quot;&gt; &lt;!-- value값을 설정하면 선택에 맞게 다르게 전송됨 --&gt; &lt;label for=&quot;answerNo&quot;&gt;아니요&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;answerNo&quot; value=&quot;answerNo&quot; name=&quot;answer&quot;&gt; &lt;button type=&quot;submit&quot;&gt;   확인 &lt;/button&gt;&lt;/form&gt;Checkbox Attribute&lt;input&gt;의 속성으로 여러 개의 항목이 선택 가능한 버튼Checkbox Attribute는 &lt;input&gt;의 요소로 Radio Attribute와 사용 방법이 동일하다.단 하나의 차이점이 있다면 Checkbox Attribute는 _다중선택이 가능_하다는 것이다.  &lt;h1&gt;나이가 20대입니까?&lt;/h1&gt;  &lt;label for=&quot;answerYes&quot;&gt;네&lt;/label&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;answerYes&quot;&gt;  &lt;label for=&quot;answerNo&quot;&gt;아니요&lt;/label&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;answerNo&quot;&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.참고 자료 &lt;input type=&quot;radio&quot;&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;input type=&quot;radio&quot;&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
69,"Input Tag사용자의 데이터를 받을 수 있는 대화형 컨트롤을 생성하는 태그HTML의 Input Tag는 _사용자에게 정보를 받아서 필드를 생성_하는 태그다.Div Tag는 &lt;input&gt;를 사용하며 _다양한 속성_을 통해 각각의 입력 데이터 유형과 컨트롤 위젯을 설정한다. 입력 유형과 특성의 다양한 조합 가능성으로 인해, &lt;input&gt;요소는 HTML에서 제일 강력하고 복잡한 요소로 평가 받는다.Input Tag의 속성type=&quot;유형&quot; : 입력 동작 방식 (필수 입력)placeholder=&quot;문구&quot; : _입력전 문구_를 표시minlength=&quot;n&quot;, maxlength=&quot;n&quot; : 최소, 최대 입력 글자 제한required : 필수 입력 항목disabled : 입력할 수 없게 제한value=&quot;초깃값&quot; : 초깃값  &lt;input type=&quot;text&quot; placeholder=&quot;이름을 입력하세요.&quot; minlength=&quot;2&quot; maxlength=&quot;5&quot; required value=&quot;홍길동&quot;&gt;  &lt;input type=&quot;text&quot; placeholder=&quot;입력하지 마세요.&quot; disabled&gt;type속성의 종류&lt;input type=&quot;text&quot;&gt; : 사용자에게 text를 입력받는 가장 기본적인 input형태&lt;input type=&quot;email&quot;&gt; : 사용자에게 email을 입력받는 input형태&lt;input type=&quot;password&quot;&gt; : 사용자에게 password를 입력받는 input형태&lt;input type=&quot;url&quot;&gt; : 사용자에게 url을 입력받는 input 형태&lt;input type=&quot;number&quot;&gt; : 사용자에게 숫자를 입력받는 input 형태&lt;input type=&quot;file&quot;&gt; : 사용자에게 파일첨부를 입력받는 input 형태  &lt;input type=&quot;text&quot;&gt;&lt;br&gt;  &lt;input type=&quot;email&quot;&gt;&lt;br&gt;  &lt;input type=&quot;password&quot;&gt;&lt;br&gt;  &lt;input type=&quot;url&quot;&gt;&lt;br&gt;  &lt;input type=&quot;number&quot;&gt;&lt;br&gt;  &lt;input type=&quot;file&quot;&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.Label Tag사용자 인터페이스 항목의 설명을 나타내는 태그HTML의 Label Tag는 &lt;input&gt;와 함께 연결되어 특정 _폼 양식에 이름_을 붙여주는 용도로 사용한다.Label Tag는 &lt;label&gt;를 사용하며 for속성값을 &lt;input&gt;태그의 id속성과 _동일한 속성값_을 사용하여 연결한다.보통 id속성 값을 사용할때는 #id형식으로 사용하지만 &lt;label&gt;태그에서는 _예외_다.  &lt;label for=&quot;user-name&quot;&gt;이름&lt;/label&gt;  &lt;input type=&quot;text&quot; id=&quot;user-name&quot; placeholder=&quot;이름을 입력하세요.&quot;&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.참고 자료&lt;input&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;label&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
70,"Form  Tag정보 제출을 위해 대화형 컨트롤을 포함한 문서 구획을 나타내는 태그HTML의 Form Tag는 사용자로부터 _입력(input)을 받은 뒤 데이터를 서버에 제출_하기 위해 사용하는 태그다.Form Tag는 &lt;form&gt;를 사용하며 action, method 이 두가지 속성을 지원한다.&lt;form&gt;의 action, method속성action=&quot;api주소&quot; : 사용자의 input을 입력 받은 뒤 처리할 _백앤드 경로_를 입력한다.method=&quot;GET or POST&quot; : 중요한 정보, 정보의 양이 많을 때 POST, 그렇지 않을때는 _GET_을 사용한다.  &lt;form action=&quot;데이터를 전달받을 주소&quot; method=&quot;GET&quot;&gt;    &lt;!-- 사용자로부터 입력을 받을 태그들 --&gt;  &lt;/form&gt;참고 자료&lt;form&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
71,"Div Tag콘텐츠를 용도에 맞춰 분할하는 태그HTML의 Div Tag는 플로우 콘텐츠를 위한 통용 컨테이너 태그다.Div Tag는 &lt;div&gt;를 사용하며 주로 _CSS스타일링_을 위해 단어, 문장, 내용 전체등등 범용적으로 사용하는 태그다,&lt;div&gt;는 CSS를 사용하기 전에는 콘텐츠나 레이아웃에 어떠한 영향도 주지 않는다.  &lt;div&gt;    아무런 변화가 없다.&lt;br&gt;    &lt;a href=&quot;#&quot;&gt;자식요소도 아무런 변화가 없다.&lt;/a&gt;    &lt;ul&gt;      &lt;li&gt;자식요소도 아무런 변화가 없다.&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.Span Tag&lt;div&gt;처럼 콘텐츠를 용도에 맞춰 분할하는 태그HTML의 Span Tag는 &lt;span&gt;를 사용하며 Div Tag와 마찬가지로 플로우 콘텐츠를 위한 통용 컨테이너 태그다.즉&lt;span&gt;도 CSS를 사용하기 전에는 콘텐츠나 레이아웃에 어떠한 영향도 주지 않는다.  &lt;span&gt;    아무런 변화가 없다.&lt;br&gt;    &lt;a href=&quot;&quot;&gt;자식요소도 아무런 변화가 없다.&lt;/a&gt;    &lt;ul&gt;      &lt;li&gt;자식요소도 아무런 변화가 없다.&lt;/li&gt;    &lt;/ul&gt;  &lt;/span&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.Div Tag와 Span Tag의 차이점&lt;div&gt;, &lt;span&gt;태그는 콘텐츠를 위한 통용 컨테이너로서 용도가 비슷하다. 하지만 이 두 태그를 구분할 수 있는 가장 큰 차이점은 태그가 차지하고 있는 _영역_이다.&lt;div&gt;는 영역 전체_를 차지하는 블록 레벨 요소인 반면 &lt;span&gt;은 _자신의 컨텐츠만큼 크기를 차지하는 인라인 요소이다.  &lt;h1&gt;div&lt;/h1&gt;  &lt;p&gt;Lorem, ipsum &lt;div&gt;dolor sit amet&lt;/div&gt; consectetur adipisicing elit. Repellat, ad.&lt;/p&gt;  &lt;h1&gt;span&lt;/h1&gt;  &lt;p&gt;Lorem, ipsum &lt;span&gt;dolor sit amet&lt;/span&gt; consectetur adipisicing elit. Repellat, ad.&lt;/p&gt;위 코드를 실행하면 &lt;div&gt;태그는 자신의 영역을 전체를 차지하고, &lt;span&gt;은 자신의 영역만큼 차지하는 결과를 확인할 수 있다.Div, Span Tag 사용시 유의사항&lt;div&gt;, &lt;span&gt;태그는 CSS로 스타일링 작업을할 때 유용하게 사용할 수 있는 태그다.하지만 무분별하게 태그 사용을 남용하게 된다면 Semantic Markup을 해치기 때문에 최대한 사용을 금하되 어떠한 의미가 도저히 떠오르지 않을 때 사용을 권장한다.참고 자료&lt;Div&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;Span&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
72,"Description List Tag용어 정의 및 Key-Value로 정보를 제공하는 태그HTML의 Description List Tag는 &lt;dl&gt;를 사용하여 _설명 목록_을 나타낸다.크게 _용어를 정의_하거나 _Key-Value_의 형태로 정보를 제공할 때 사용하는 태그다.&lt;dl&gt;태그는 &lt;dt&gt;로 표기한 용어와 &lt;dd&gt; 요소로 표기한 설명 그룹의 목록을 감싸서 설명 목록을 생성한다. 주로 용어사전의 구현이나 메타데이터(키-값 쌍 목록)를 표시할 때 사용한다.&lt;dl&gt;   &lt;!-- &lt;dt&gt;태그 : key-value에서 key값 --&gt;  &lt;dt&gt;계단&lt;/dt&gt;  &lt;!-- &lt;dd&gt;태그 : &lt;dt&gt;태그에 대한 설명 --&gt;  &lt;dd&gt;    높이가 다른 곳으로 걸어서 움직일 때, 밟고 오르내릴 수 있도록 턱을 지어 만든 설비  &lt;/dd&gt;  &lt;dd&gt;    일을 하는 데 밟아야 할 순서  &lt;/dd&gt;&lt;/dl&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.사전적으로 의미를 _구체화_하고 싶으면 &lt;dt&gt;태그안에 &lt;dfn&gt;태그를 사용한다.&lt;dl&gt;  &lt;dt&gt;    &lt;dfn&gt;계단 &lt;/dfn&gt;  &lt;/dt&gt;  &lt;dd&gt;    높이가 다른 곳으로 걸어서 움직일 때, 밟고 오르내릴 수 있도록 턱을 지어 만든 설비  &lt;/dd&gt;  &lt;dd&gt;    일을 하는 데 밟아야 할 순서  &lt;/dd&gt;&lt;/dl&gt;Quotations Tag인용문을 표현하는 태그HTML의 Quotations Tag들은 해당 요소를 _인용문으로 표현_할 때 사용하는 태그다.인용문의 길이_에 따라 &lt;blockquote&gt;, &lt;q&gt;,태그를 사용할 수 있으며, _문단이나 내용 전체_가 하나의 인용문일때는 &lt;blockquote&gt;, _문장내 인용문을 사용할때 사용때는 &lt;q&gt;를 사용한다.&lt;q&gt;는 &lt;blockquote&gt;와 달리 사용시 해당 문장이 &quot; &quot;로 나타난다.  &lt;!-- &lt;blockquote&gt;태그안에 cite속성을 사용하여 출처를 밝히면 더 완벽한 인용문 코드 --&gt;&lt;blockquote cite=&quot;https://brunch.co.kr/@brunchflgu/72&quot;&gt;    역사적 성공의 반은 죽을지도 모른다는 위기에서 비롯되었고,&lt;br&gt;    역사적 실패의 반은 찬란했던 시절에 대한 기억에서 시작되었다.&lt;br&gt;&lt;br&gt;    &lt;!-- 문장으로 출처를 밝히고 싶을 때 &lt;cite&gt;태그 사용 --&gt;  &lt;cite&gt;-아놀드 토인비&lt;/cite&gt;&lt;/blockquote&gt;&lt;p&gt;              &lt;q&gt;훌륭함과 널리 알려진 정도에 대한 기준은 사람마다 다 제각각이고 주관적이기에&lt;/q&gt;&lt;br&gt;    섣불리 어떤 말을 무조건 명언이라고 단정하기는 어렵다. 2번의 의미로 &lt;br&gt;    쓴다면 훌륭한 말은 아니고, 널리 대중들에게 알려진 유명한 말이라고 할 수 있다.&lt;/p&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.참고 자료&lt;dl&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;blockquote&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;q&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
73,"Image Tag문서에 이미지를 넣는 태그HTML의 Image Tag는 문서에 _이미지를 마크업_할 때 사용하는 태그다. 이 때 사용하고자 하는 이미지가 _정보로서 가치가 없을때_는 굳이 이미지태그를 사용하기보다는 _CSS로 처리_하는 것이 Semantic한 Markup이다.이미지태그는 &lt;img&gt;태그를 사용하며 src, alt속성을 사용해 참조하는 이미지의 주소, _대체 텍스트_를 입력한다.&lt;img src=&quot;이미지 참조주소&quot; alt=&quot;이미지 대체 텍스트&quot;&gt;이미지 참조방법이미지의 주소를 입력하는 src속성을 사용하는 방법은 크게 2가지가 있다.절대주소 (해당 이미지의 주소를 참조)상대주소 (해당 폴더에서 다른 폴더의 이미지를 참조)  &lt;!-- 1. 절대주소(해당이미지의 주소복사한 뒤 입력) --&gt;  &lt;img src=&quot;https://img.khan.co.kr/news/2020/10/28/l_2020102901002861100258121.jpg&quot; alt=&quot;저녁 노을 사진&quot;&gt;  &lt;!-- 2. 상대주소(.:해당폴더에서 images폴더에서 sunflower.png사진을 업로드) --&gt;  &lt;img src=&quot;./images/sunflower.png&quot; alt=&quot;해바라기 사진&quot;&gt;alt속성값 작성시 유의사항&lt;img&gt;태그에 이미지에 대해 할말이 없고 정보자체가 큰 의미가 없을때는 _alt값을 공백_으로 입력하는 것이 더 올바른 마크업이다.&lt;img&gt;태그와 다른 태그를 같이 사용하는데 그 요소가 &lt;img&gt;태그를 설명해주는 태그라면 alt=&quot;&quot;속성값은 생략하는것이 좋다.&lt;img&gt;태그에는 빈 공백이여도 src, alt속성값이 _반드시 입력_되어 있어야 한다.Lists Tag요소들을 리스트로 나열하는 태그HTML의 Lists Tag들은 해당 _요소들을 목록_으로 나타낼 때 사용하는 태그다.리스트태그는 _순서를 보장하는 유무_에 따라 &lt;ol&gt; (Ordered List), &lt;ul&gt; (Unordered List)태그를 사용하며 _태그안에 항목_을 &lt;li&gt; (List Item)태그로 표현한다.  &lt;ol&gt;    &lt;li&gt;아이템 1&lt;/li&gt;    &lt;li&gt;아이템 2&lt;/li&gt;    &lt;li&gt;아이템 3&lt;/li&gt;  &lt;/ol&gt;  &lt;ul&gt;    &lt;li&gt;아이템 1&lt;/li&gt;    &lt;li&gt;아이템 2&lt;/li&gt;    &lt;li&gt;아이템 3&lt;/li&gt;  &lt;/ul&gt; 위 코드를 실행하면 아래와 같은 결과가 출력된다. 리스트태그 사용시 주의사항&lt;ul&gt;과 &lt;ol&gt;태그 사용시 _직계 자식요소_는 무조건 &lt;li&gt;태그만 사용이 가능하다.  &lt;ul&gt;    &lt;div&gt; 사용 불가능 &lt;/div&gt;    &lt;p&gt; 사용 불가능 &lt;/p&gt;    &lt;li&gt; 사용 가능!! &lt;/li&gt;  &lt;/ul&gt;아래 코드처럼 직계자손에서 &lt;li&gt;태그를 사용하고 &lt;li&gt;태그안에 다른 태그를 사용하는 것은 가능하다.  &lt;ul&gt;    &lt;li&gt;      &lt;a href=&quot;https://www.naver.com/&quot;&gt;네이버로 이동&lt;/a&gt;                    &lt;/li&gt;    &lt;li&gt;                      &lt;a href=&quot;https://www.daum.net/&quot;&gt;다음으로 이동&lt;/a&gt;    &lt;/li&gt;  &lt;/ul&gt;참고 자료&lt;img&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;ol&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;ul&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;li&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
74,"Emphasis Tags텍스트의 강조를 마크업하는 태그HTML의 Emphasis Tag는 _텍스트의 강조_를 마크업할 때 사용하는 태그다. 강조태그는 컴퓨터에게 해당 내용을 강조한다는 _메세지를 전달_하기 위해 사용한다.Emphasis Tag의 종류는 크게 2가지로 &lt;em&gt;, &lt;strong&gt;를 사용한다.&lt;em&gt;태그와 &lt;strong&gt;태그의 차이&lt;em&gt;태그를 사용하면 텍스트가 강조되면서 기울어진다, 반면에 &lt;strong&gt;태그는 강조만 된다.이는 추후에 css로 _변경이 가능_하기 때문에 굳이 두 태그를 구별해서 사용할 필요는 없다.  &lt;p&gt;Lorem ipsum dolor sit amet consectetur, adipisicing elit.&lt;/p&gt;  &lt;em&gt;Lorem ipsum dolor sit amet consectetur, adipisicing elit.&lt;/em&gt;  &lt;!-- &lt;br&gt;태그는 줄바꿈을 하는 태그 --&gt;  &lt;br&gt;  &lt;strong&gt;Lorem ipsum dolor sit amet consectetur, adipisicing elit.&lt;/strong&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.Anchor Tag특정 목적지로 이동할 수 있는 하이퍼링크를 마크업하는 태그HTML의 Anchor Tag는 &lt;a&gt;를 사용하며 href속성을 통해 다른 페이지나 같은 페이지의 어느 위치, 파일, 이메일 주소와 그 외 _다른 URL로 연결할 수 있는 하이퍼링크_를 만든다.&lt;a&gt;안의 콘텐츠는 _링크 목적지의 설명_을 나타내야 한다.Anchor Tag를 참조하는 방법  &lt;!-- 1. 이동하고자 하는 사이트에 주소 직접 입력 --&gt;  &lt;a href=&quot;https://www.naver.com/&quot;&gt; 네이버로 이동 &lt;/a&gt;  &lt;br&gt;  &lt;!-- 2. 이동하고자 하는 HTML문서의 상대경로 --&gt;  &lt;a href=&quot;./move.html&quot;&gt; move.html로 이동 &lt;/a&gt;  &lt;br&gt;  &lt;!-- 3. 페이지내 이동(id값 사용) --&gt;  &lt;a href=&quot;#move&quot;&gt; section태그로 이동 &lt;/a&gt;  &lt;section id=&quot;move&quot;&gt;    &lt;p&gt; section태그 문단 &lt;/p&gt;  &lt;/section&gt;  &lt;!-- 4. 메일쓰기 --&gt;  &lt;a href=&quot;mailto:kmd2504@naver.com&quot;&gt;메일쓰기&lt;/a&gt;  &lt;br&gt;  &lt;!-- 5. 전화걸기(모바일에서 사용) --&gt;  &lt;a href=&quot;tel:01084827415&quot;&gt; 전화걸기 &lt;/a&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.새 탭으로 페이지를 여는 방법&lt;!-- target속성에 _blank값 사용 --&gt;&lt;a href=&quot;https://www.naver.com/&quot; target=&quot;_blank&quot;&gt; 네이버 열기 &lt;/a&gt;참고 자료&lt;em&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;strong&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;a&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
75,"Heading Tags문단의 제목을 마크업하는 태그HTML의 Heading Tag는 컨텐츠 _제목_에 해당하는 내용을 마크업할 때 사용하는 태그다.Heading Tag는 총 _6단계_의 구획 제목을 나타낼 수 있고 각 단계는 _숫자의 크기_로 그 중요성을 분류한다. (&lt;h1&gt; &gt; &lt;h2&gt; &gt; ... &gt; &lt;h6&gt;)제목의 단계는 중요하지 않고 _제목에 해당하는 내용_을 정확하게 마크업하는게 중요하다.  &lt;h1&gt;Heading 1&lt;/h1&gt;  &lt;h2&gt;Heading 2&lt;/h2&gt;  &lt;h3&gt;Heading 3&lt;/h3&gt;  &lt;h4&gt;Heading 4&lt;/h4&gt;  &lt;h5&gt;Heading 5&lt;/h5&gt;  &lt;h6&gt;Heading 6&lt;/h6&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.Paragraph Tag문단에 해당하는 내용을 마크업하는 태그HTML의 Paragraph Tag는 하나의 _문단_을 나타낼때 사용한다. 이 때 문단은 HTML에서 _서로 관련있는 콘텐츠_를 의미한다.Paragraph Tag는 &lt;p&gt;를 사용하며 사용방법은 Heading Tag와 동일하다.  &lt;h1&gt;Heading 1&lt;/h1&gt;  &lt;p&gt;Lorem ipsum dolor sit amet consectetur, adipisicing elit. Dolorum, natus.&lt;/p&gt;위 코드를 실행하면 아래와 같은 결과가 출력된다.참고 자료&lt;header&gt; - HTML: Hypertext Markup Language - MDN Web Docs&lt;p&gt; - HTML: Hypertext Markup Language - MDN Web Docs"
76,"HTML이란?웹 페이지의 구조를 설계하기 위해 사용되는 마크업 언어HTML(Hypertext Markup Language,하이퍼텍스트 마크업 언어)는 프로그래밍 언어는 아니고, 우리가 보는 _웹페이지가 어떻게 구조화_되어 있는지 브라우저로 하여금 알 수 있도록 하는 _마크업 언어_이다.HTML은 _elements_로 구성되어 있으며, 이들은 적절한 방법으로 나타내고 실행하기 위해 각 컨텐츠의 여러 부분들을 감싸고 마크업을 한다._tags_는 웹 상의 다른 페이지로 이동하게 하는 하이퍼링크 내용들을 생성하거나, 단어를 강조하는 등의 역할을 합니다.this is the title만약 다음의 문장을 제목으로 표시하고 싶다면, 태그 중 &lt;h1&gt;로 감싸 엘리먼트를 문단으로 명시할 수 있다.&lt;h1&gt;this is the title&lt;/h1&gt;HTML 요소(Element)의 구조HTML의 요소는 크게 4가지 부분으로 나눌수 있다.여는 태그(Opening tag): 이것은 요소의 이름과 열고 닫는 꺽쇠 괄호로 구성된다.닫는 태그(Closing tag): 이것은 요소의 이름 앞에 슬래시(/)가 있는것을 제외하면 여는 태그(opening tag)와 동일하다.내용(Content): 요소의 내용이며, 이 경우 단순한 텍스트이다.요소(Element): 여는 태그, 닫는 태그, 내용을 통틀어 요소(element)라고한다.Semantic Markup시맨틱(Semantic) 마크업(Markup)이란 의미가 잘 전달되도록 문서를 작성하는 것시맨틱 마크업을 하기 위해선 각 태그를 _컨텐츠와 용도_에 맞게 사용해야 한다.this is the title다음의 문장은 웹 페이지의 제목으로 사용된다. 위의 경우에는 문단을 나타내는 &lt;p&gt;태그보다 제목을 나타내는 &lt;h1&gt;태그를 사용하는 것이 Semantic한 Markup이다.  &lt;!-- Bad --&gt;  &lt;p&gt;this is the title&lt;/p&gt;  &lt;!-- Good --&gt;  &lt;h1&gt;this is the title&lt;/h1&gt;Semantic Markup의 장점검색엔진이 시맨틱 태그를 중요한 키워드로 간주하여 _검색엔진 최적화(SEO)_에 유리하다.웹 접근성 측면에서, 시각장애가 있는 사용자로 하여금 그 의미를 훨씬 잘 파악할 수 있다.단순한 div, span태그로 둘러싸인 요소들보다 코드를 읽을 때 가독성이 더 좋습니다.참고 자료HTML: Hypertext Markup Language - MDN Web Docs"
77,"목차SRP: 단일 책임 원칙OCP: 개방 폐쇄 원칙LSP: 리스코프 치환 원칙ISP: 인터페이스 분리 원칙DIP: 의존 역전 원칙SOLID 원칙의 배경: 응집도는 높이고(High Cohesion), 결합도는 낮추자(Loose Coupling)1. SRP - 단일 책임 원칙&quot;어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.&quot;한 클래스의 수정이 다른 부분의 수정으로 이어지면 안된다.한 클래스가 너무 많은 책임을 지고 있으면, 여러 클래스로 분할해야 함.잘못된 경우1. 메소드class dog{   final static Boolean male = true;   final static Boolean female = false;   Boolean sex;   void pee(){      if(this.sex == male){         // lift one leg      }      else {         // sit      }   }}메소드가 단일 책임 원칙을 지키지 않을 경우, 다중 if문이 나타나게 됨.2. 변수하나의 속성이 여러 의미를 갖는 경우ex) db table 하나의 필드가 다른 필드가 무엇이냐에 따라 의미가 바뀌는 경우. 토지일 때는 면적, 건물일 때는 층수를 나타내는 경우어떤 객체는 전혀 쓰지 않는 속성이 클래스에 정의되어 있을 경우ex) 사람이라는 클래스로 여자와 남자를 만들었는데 군번이라는 변수를 남자라는 객체만 사용할 경우2. OCP - 개방 폐쇄 원칙&quot;소프트웨어 엔티티는 확장에 대해서는 열려 있어야 하지만, 변경에 대해서는 닫혀 있어야 한다.&quot;&quot;자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.&quot;엔티티 종류가 늘어남을 가정했을 때, 그 엔티티를 사용하는 호출부의 수정이 최소화되어야 한다.비유 : 개발자가 작성한 소스코드는 운영체제의 변화에 닫혀 있고, 각 운영체제별 JVM은 확장에 열려 있는 구조가 되는 것이다.3. LSP - 리스코프 치환 원칙서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.상위에서 정해둔 규칙은 하위에서도 지켜야 함.하위 클래스의 추가 원칙하위형에서 선행 조건은 강화될 수 없다.선행 조건 : 함수의 로직을 실행하기 전에 validation 등을 하는 것상위 클래스의 정의된 메소드를 하위 클래스에서 오버라이딩 했을 때, validation 강도를 더 강화시키면 안됨.ex) if(data &lt; 0) throw -&gt; if(data &lt;=0) throw하위형에서 후행 조건은 약화될 수 없다.후행 조건 : 함수의 로직을 실행 후, 데이터가 유효한지 여부를 검사하는 것(리턴 값 등 검사)상위 클래스에서 설정해둔 후행 조건을 하위 클래스에서 마음대로 완화시키면 안됨.하위형에서 상위형의 불변 조건은 반드시 유지되어야 한다.상위 클래스에 있는 불변 데이터를 하위 클래스에서 마음대로 바꿔버리면 안됨.물려줄 특성이 많을 수록이 좋다빈약한 상위 클래스를 이용할 경우, 자식 클래스에 정의된 메소드를 사용하기 위해 형변환과 instanceOf를 많이 사용해야 함. (다형성 사용X)4. ISP - 인터페이스 분리 원칙클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.인터페이스 최소주의 원칙 : 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하자.인터페이스는 그 역할에 충실한 최소한의 기능만 공개하자 : 강제하는 기능을 최소화하자.5. DIP - 의존 역전 원칙자주 변경되는 구체 클래스에 의존하지 마라. 추상체에 의존할 것.public class service{  private Repository repository; // private JdbcRepository repository; (x)}public class JdbcRepository implements Repository{}비즈니스 로직이 추상체를 사용하게 하면, 구현체가 더 늘어나도 다형성을 사용함으로써 영향을 받지 않음."
78,"목차추상 메소드와 추상 클래스생성자클래스 생성 시의 실행 블록, static 블록final 키워드instanceof 연산자package 키워드interface 키워드와 implements 키워드this 키워드super 키워드1. abstract 키워드 - 추상 메서드와 추상 클래스추상 메서드: 선언부는 있는데 구현부가 없는 메서드추상 메서드를 가지고 있는 클래스는 추상 클래스가 됨.추상 클래스는 인스턴스, 즉 객체를 만들 수 없는 클래스가 된다.추상 메서드는 하위 클래스에게 메서드의 구현을 강제한다.2. 생성자용도 : 객체가 매개변수의 일부분만 사용해도 될때개발자가 필요한만큼 오버로딩해서 만들 수 있음.개발자가 아무런 생성자도 만들지 않으면 자바는 인자가 없는 기본 생성자를 자동으로 만들어준다.인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성자를 만들어 주지 않는다.3. 클래스 생성 시의 실행 블록, static 블록static 블록: 클래스가 static 영역에 배치될 때 실행되는 코드블록static 블록에서 사용할 수 있는 속성과 메소드는 static 멤버 뿐이다.static 블록 실행 시 해당 클래스의 객체는 하나도 존재하지 않기 때문에 객체 멤버에 접근할 수 없음.클래스가 처음으로 사용될 때 로딩됨 : 메모리는 최대한 늦게 사용을 시작하고 최대한 빨리 반환하는 것이 유리하기 때문이다.클래스의 정적 속성을 사용할 때클래스의 정적 메서드를 사용할 때클래스의 인스턴스를 최초로 만들 때4. final 키워드final과 클래스 : 상속을 허락하지 않겠다는 의미final과 변수 : 변경 불가능한 상수final과 메서드 : 오버라이딩 금지5. instanceof 연산자LSP(리스코프 치환 원칙)를 어기는 코드에서 주로 나타나는 연산자 (다형성에 위반)6. package 키워드package 키워드: namespace를 만들어주는 역할.다른 사업부에서 같은 이름의 도메인을 사용하는 경우 패키지로 나누어서 사용하면 좋음.7. interface 키워드와 implements 키워드인터페이스는 public 추상 메서드와 public 정적 상수만 가질 수 있음.interface Speakable { public static final double PI = 3.14159; public static final double absoluteZeroPoint = -275.15; public abstract void sayYes();}public, static, final, abstract이 자동이지만, 붙여서 가독성을 높이자.자바 8의 변화2014년부터 빅데이터와 병렬성 지원을 위해 자바8을 출시함.람다 추가 -&gt; 변수에 로직을 저장할 수 있게 됨.로직을 변수에 저장할 수 있고, 메서드의 인자로 쓸 수 있고, 메서드의 반환값으로 사용할 수 있음.함수형 언어가 지닌 특성을 자바도 수용함.디폴트 메서드 추가8. this 키워드this는 객체가 자기 자신을 지칭할 때 쓰는 키워드지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 지역 변수가 우선한다.메모리에 가까운 순서(스택프레임(지역변수)가 가장 가까움)객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this를 접두사로 사용한다.정적 변수와 이름이 같은 지역 변수가 있는 경우 정적 변수를 사용하려면 클래스명을 접두사로 사용한다.객체 멤버의 메소드와 메모리JVM은 객체 멤버 메소드를 스태틱 영역에 보유한다.객체의 메소드 실행 시, 객체 자신을 나타내는 this 객체 참조 변수를 넘겨서 메소드를 실행함.9. super 키워드상위 클래스의 인스턴스를 지칭하는 키워드super 키워드로 상위 클래스의 속성과 메소드 접근"
79,"목차객체 지향은 인간 지향이다객체 지향의 4대 특성클래스 vs 객체추상화: 모델링상속: 재사용+확장다형성: 사용편의성캡슐화: 정보 은닉1. 객체 지향은 인간 지향이다기존의 구조적 프로그래밍 언어에서 중요한 것 : 함수긴 코드를 논리적 단위의 블록으로 나눈다.직관적인 객체 지향세상에 존재하는 모든 것은 객체이다.각각의 사물은 고유하다.사물은 속성을 갖는다.사물은 행위를 한다.2. 객체 지향의 4대 특성캡슐화: 정보 은닉상속: 재사용추상화: 모델링다형성: 사용 편의3. 클래스 vs 객체클래스 : 객체 = 개념 : 실체  붕어빵틀과 붕어빵의 비유의 의미는 붕어빵틀은 결국 붕어빵을 만드는 팩터리라는 뜻이다.예시사람 : 김연아동물 : 펭귄4. 추상화: 모델링추상화 : 도메인 내에 있는 객체들의 공통 특성을 추출하여 재조합하는 것모델링 : 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것.객체: 속성과 기능을 가진 낱개클래스: 분류, 집합. 같은 속성과 기능을 가진 객체를 총칭하는 개념객체지향 설계를 잘한다 -&gt; 클래스 설계를 잘한다 -&gt; 추상화를 잘한다도메인 내에서 사용되는 것을 잘 분석해야 함.추상화와 T메모리Static 영역 (Method Area)클래스 변수(static 변수)들 저장Method Info에 클래스에 정의된 메소드의 구현 내용이 들어가 있음.정적 속성은 해당 클래스의 모든 객체가 같은 값을 가질 때 사용함.정적 메소드는 객체들의 존재 여부에 관계없이 사용할 수 있는 메소드주로 유틸리티성 메소드Heap 영역Mouse micky = new Mouse();객체 참조 변수 micky가 힙 영역에 만들어진 Mouse의 인스턴스를 가리키게 됨.micky = null; 되면, 힙 영역에 있는 Mouse의 인스턴스가 참조되지 않으므로, Garbace Collector가 처리함.Garbage Collector 알고리즘지역 변수는 한 지역에서 쓰는 변수지만, 멤버 변수는 공유 변수의 성격을 지니고 있기 때문에, 초기화를 해줌.5. 상속: 재사용+확장상속: 상위 클래스의 특성을 하위 클래스에서 상속하고, 필요한 특성을 확장해서 사용할 수 있다.하위 클래스는 상위 클래스다.김연아는 사람이다.고래는 포유류다.상속의 강력함하위클래스 is a kind of 상위 클래스추상화를 통해 다형성을 구현할 수 있음.하위클래스는 상위 클래스의 특성을 재사용(super)하고 재정의(override)하고 확장함.상위 클래스는 하위클래스에게 물려줄 특성이 많을수록 좋음 : LSP(리스코프 치환 원칙)다중 상속과 자바Q. 자식이 두 클래스를 상속한다면, 만약 두 클래스에 공통적으로 정의된 메소드를 자식의 객체가 사용했을 때, 어느 부모의 메소드를 실행해야할까?A. 자바는 위 문제를 인터페이스를 도입하여 득을 취하고 실을 버림.인터페이스구현 클래스 is able to 인터페이스구현 클래스가 기능을 구현하도록 강제함.인터페이스는 구현을 강제할 메서드가 적을수록 좋음. : ISP(인터페이스 분할 원칙)최대한 분할하여 인터페이스에 한 메소드를 추가했을 때, 모든 구현클래스에 메소드를 추가해야하는 부담을 줄임.6. 다형성: 사용편의성오버라이딩: 자식 클래스에서 부모에 이미 정의되어 있는 메서드를 같은 인자들로 내용을 재정의하는 것.오버로딩: 하나의 클래스에서 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의하는 것.Animal pingu = new Penguin();컴파일 시에는 Animal에 정의되어 있는 멤버와 메소드밖에 사용하지 못하지만, 만약 Penguin이 Animal의 메소드를 오버라이딩했다면, 런타임 시에 재정의된 메소드로 실행된다.7. 캡슐화: 정보 은닉접근제어자private: 본인만 접근 가능default: 같은 패키지 내의 클래스에서 접근 가능protected: 상속 / 같은 패키지 내의 클래스에서 접근 가능public: 모두가 접근 가능정적멤버인 경우 클래스명.정적멤버 형식으로 접근해야 함. 객체 참조 변수명.정적멤버로 접근할 경우, 바로 스태틱 영역으로 접근하지 않고 스택 프레임-&gt;힙 영역-&gt;스태틱 영역으로 우회하여 접근하게 됨.참조 변수의 복사Call By Value : 기본 자료형 변수 저장Call By Reference : 주소값 저장기본 자료형 변수를 복사하면, 값 자체가 복사됨. 원래 변수를 다른 값으로 변경 시, 새로운 변수는 아무 영향 받지 않음.참조형 변수를 복사하면, 주소값이 복사됨. 같은 곳을 가리키기 때문에 가리키고 있는 값을 다른 값으로 변경 시, 새로운 변수 또한 영향을 받음."
80,"목차자바 프로그램의 개발과 구동변수와 메모리: 변수! 너 어디 있니?블록 구문과 메모리: 블록 스택 프레임지역 변수와 메모리: 스택 프레임에 갇혔어요!메서드 호출과 메모리: 메서드 스택 프레임2전역 변수와 메모리: 전역 변수 쓰지 말라니까요!멀티 스레드 / 멀티 프로세스의 이해1. 자바 프로그램의 개발과 구동JDK(Java Development Kit) : 자바 개발 도구JRE(Java Runtime Environment) : 자바 실행 환경JVM(Java Virtual Machine) : 자바 가상 기계JVM ∈ JRE ∈ JDK 인 관계가 성립한다. JDK는 javac.exe를 사용하여 자바 소스를 컴파일해 목적 파일인 class 파일을 생성해내고, JRE는 java.exe를 사용해 클래스 파일을 실행한다.자바가 JDK, JRE, JVM과 같은 환경을 채택한 이유는 하드웨어와 OS의 조합에 맞게 각 플랫폼마다 다른 설치파일을 준비해야 했던 불편함을 없애기 위해서이다.(Write Once Run Anywhere)1-1. 프로그램이 메모리를 사용하는 방식CodeData(T 메모리 구조)Static : 클래스의 놀이터Stack : 메소드의 놀이터Heap : 객체의 놀이터1-2. 자바에 존재하는 절차적/구조적 프로그래밍의 유산goto 쓰지 마라 : 프로그램의 실행 순서가 복잡해짐. (스파게티 코드)함수 써라 : 중복 코드 제거와 논리의 분할을 위해전역변수보다 지역 변수를 써라 : 전역 변수는 공유 사용 시 문제가 발생하기 쉽다1-3. 다시 보는 main() 메서드 : 메서드 스택 프레임main() 메서드가 실행되기 전 JVM에서 수행하는 전처리 작업들java.lang 패키지를 T 메모리 스태틱 영역에 배치import된 패키지를 T 메모리 스태틱 영역에 배치프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치모든 메서드는 스택 영역에서 스택 프레임을 생성되고, 호출이 끝나면 프레임이 소멸된다.2. 변수와 메모리: 변수! 너 어디 있니?메서드 내의 지역 변수는 해당 메서드의 스택 프레임 내에 밑에서부터 메모리가 할당됨.변수는 선언하는 명령문과 값을 할당하는 명령문으로 나눠서 실행됨.3. 블록 구문과 메모리: 블록 스택 프레임if 블록public class Start3{  puvlic static void main(String args){    int i=10;    if(i==10){    }else{    }  }}스택 프레임 내에 스택 프레임이 중첩되어 생긴다.예시와 같은 경우 if(true)인 스택 프레임이 main() 스택 프레임 내에 생성됨.실행 지점이 블록 스코프를 벗어나게 되면 해당 스택 프레임이 소멸된다.main()이 종료되면 T 메모리 소멸, JVM 기동 중지, JRE가 사용한 시스템 자원 OS에 반납의 절차가 일어남.4. 지역 변수와 메모리: 스택 프레임에 갇혔어요!지역 변수 : 스택 프레임 내에 생성되고, 스택 프레임 소멸 시 같이 소멸됨.클래스 멤버 변수 : 스태틱 영역 내에 생성되고, JVM이 종료되기 전까지 소멸되지 않음.객체 멤버 변수 : 힙에서 생성되고, 가비지 컬렉터가 객체를 힙에서 회수시 같이 소멸됨.지역 변수는 그 변수가 생성된 스택 프레임에서만 사용할 수 있고 외부에서는 사용할 수 없다.내부 지역에서 외부 지역의 변수를 사용하는 것은 가능하지만, 그 반대는 안됨.5. 메서드 호출과 메모리: 메서드 스택 프레임2메서드 호출이 일어나면 호출되는 메서드의 스택 프레임이 T 메모리의 스택 영역에 새로 생성되고, 반환값과 매개변수가 차례대로 스택 프레임 내에서 메모리를 할당받는다.재귀와 같은 경우는 스택 내에 프레임이 지속적으로 생기기 때문에 무한으로 호출될 경우 스택 오버플로우가 생길 수 있음.5-1. Call By Value메인 메서드 내의 지역변수를 메서드의 매개변수로 사용한다고 해서 같은 변수가 아님.매개변수와 지역변수 모두 서로 다른 스택 프레임 내에서 별도의 변수 공간을 가지게 되기 때문에 서로 독립적이다.같은 값이 복사되어서 다른 공간에 할당되는 것임.5-2. 스택 프레임 사이의 접근메서드 스택 프레임에서 다른 메서드 스택 프레임의 내부 변수는 접근이 불가하다.메서드 사이에 소통하는 방법은 메서드의 매개변수와 반환값말고는 없다.메서드는 서로의 고유 공간이다.호출된 메서드에서 호스트의 지역변수에 접근하려면 메모리값을 알아야하기 때문에 포인터가 필요하다.자바에서는 포인터를 사용할 수 없다.6. 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!메서드 사이에 매개변수와 반환값 외의 방법으로 값을 공유하는 방법 : 전역 변수지역 변수 : 스택 프레임에 종속적임전역 변수 : 스택 프레임에 독립적임6-1. 잘 쓰지 않는 이유여러 메서드에서 전역 변수 값을 변경하기 시작하면 전역 변수에 저장돼 있는 값을 파악하기 어려워짐.읽기 전용으로 전역 상수로써 활용하는 것은 추천됨.쓰기 가능한 전역 변수를 사용하게 되면 thread-safe 하지 않게됨.7. 멀티 스레드 / 멀티 프로세스의 이해멀티 스레드(Multi Thread)스택 영역을 스레드 개수만큼 분할함스태틱 영역과 힙 영역은 공유해서 사용하기 때문에 메모리를 적게 사용할 수 있다.thread-safe를 위해 락을 통해 전역 변수를 write하면 멀티 스레드의 장점은 버리게 됨.멀티 프로세스(Multi Process)다수의 T 메모리를 갖는 구조임.서로 참조할 수 없다.메모리 사용량은 그만큼 크다."
81,"목차신기술은 이전 기술의 어깨를 딛고기계어에서 객체 지향 프로그래밍 언어로짧은 글, 긴 생각책 출간의 변1. 신기술은 이전 기술의 어깨를 딛고스프링까지 가기 위해 이전 기술들이 인간의 필요에 의해 어떻게 발전되었나 간단하게 살펴보자.2. 기계어에서 객체 지향 프로그래밍 언어로2-1. 기계어- 0과 1의 행진 / 너무나 비인간적인 언어컴퓨터는 0과 1밖에 모르는 바보지만, 우리는 왜 컴퓨터의 세상에 살고있는 것인가?컴퓨터는 2진법밖에 모르지만, 실수없이 빠르고 정확하게 대량의 연산을 수행할 수 있기 때문이다.기계어는 기계마다 규칙과 해석이 달라 인간이 이해하기에 너무 어려웠다.2-2. 어셈블리어 - 0과 1의 행진을 벗어나 인간 지향으로 / 기계어 니모닉&quot;기계어의 명령들을 일상 용어로 표현하고 이걸 기계가 알 수 있는 기계어로 번역하게 하면 어떨까?&quot;장점 : 기계어에 반해 인간의 언어를 사용할 수 있다는 것에서 크게 발전했다.단점 : 기종마다 다른 어셈블리어를 필요로 했기에, 한가지의 언어를 범용적으로 사용하기에는 어려움이 있었다.2-3. C 언어 - 강력한 이식성 / One Source Multi Object Use Anywhere좋아진 이식성이전 언어들의 단점을 보완하여, 기종이 몇 개든 단 하나의 소스파일을 사용하면 되었다.단, 소스 파일을 컴파일하는 컴파일러는 운영체제별로 달랐기 때문에 소스 수정은 불가피했다.어셈블리어 대비 이식성(O) / 자바 대비 이식성(X)하나의 수식으로 더 많은 기계어 함축이전에는 하나의 연산에 하나의 기계어가 대응이 되었는데 이제는 하나의 수식으로 m 개의 기계어를 함축할 수 있게 되면서 명령의 길이가 줄어들었다.2-4. C++ / JAVA - 정말 인간적인 프로그래밍 방법론, 객체 지향C++ : C에 객체 지향 개념이 도입된 언어지만, 객체 없이 프로그래밍도 가능하다.JAVA : 메인메소드 조차 클래스 내부에 존재하는, 클래스 없이는 프로그래밍이 불가능한 진정한 객체 지향 언어이다.JAVA(Write Once Use Anywhere)C처럼 컴파일러를 기종별로 따로 구비할 필요 없이, 하나의 소스파일과 하나의 컴파일러만 필요하다.코드가 돌아갈 환경에 JRE만 설치되어 있으면 상관 없다.기계어어셈블리어CJAVA개발자의 코딩0과 1의 나열일상 단어 사용수학적 기호 사용수학적 기호 사용소스 파일기종마다 하나씩기종마다 하나씩기종이 몇 개든 단 하나기종이 몇 개든 단 하나목적파일소스 그 자체어셈블러로 기계어 생성운영체제 별 컴파일러로 기계어 생성기종이 몇 개든 단 하나의 JVM용 기계어 생성기계어 비교-기계어랑 1:! 대응하는 니모닉기계어와 m:n 대응하는 수학적 기호기계어와 m:n 대응하는 수학적 기호비고-기종별 어셈블러 필요기종별 어셈블러 필요단 하나의 컴파일러만 필요, 기종별 JRE 세팅 필요(한 번만 설치하면 됨)3. 짧은 글, 긴 생각3-1. UML을 대하는 자세UML은 의사소통의 수단이므로, 규칙에 너무 얽매일 필요 없다.3-2. CBD, SOA 등 방법론을 대하는 자세CBD(Component Based Development) : 애플리케이션을 의미 있는 단위로 구분하고 그 단위를 하나하나씩 부품으로 개발하여 마치 레고 블록을 쌓아올리듯 개발하는 방법론SOA(Service Oriented Architecture) : 서비스 중심 구조. 개발자 입장의 개발이 아닌 실제 현실의 업무를 기준으로 개발하는 사상.위와 같은 개발 방법론은 절대적이지 않으며, 하나의 제품만이 그 방법론을 담고 있는 것이 아니다.개발자로써 우리가 갖춰야할 자세는 본질을 잘 살펴서 취할 건 취하고 버릴 건 버리는 자세이다.3-3. 객체지향의 4대 특성JAVA 속에 객체지향 4대 특성, 객체지향 설계 5원칙, 객체지향 best practice 디자인 패턴 을 온전히 이해하는데 집중할 것.위 개념 기반으로 스프링이 만들어진 것이기 때문에 개념을 이해하는 것이 필수적이다.4. 책 출간의 변우리가 알아야 할 것OOP 개념자바 언어의 문법자바가 OOP 개념을 구현한 방식"
82,"Abstract Factory배경추상 팩토리는 생성적 디자인 패턴으로, 구체적인 자식 클래스 명시 없이 연관된 객체 그룹을 생성하게 한다. 팩토리에서의 Product가 한 종류에서 여러개로 늘어났다고 생각하면 된다. 팩토리 : 한개의 그룹 ex. Transport -&gt; Ship, Truck..추상 팩토리 : 여러개의 그룹 ex. Chair-&gt;ModernChair, VictorianChairSofa-&gt;ModernSofa, VictorianSofa💀 문제 정의가구가게를 생각해보자. 가구가게 어플리케이션이 제공해야하는 product들은 :연관된 상품 그룹 : 의자 + 소파 + 커피테이블각 상품 그룹의 다양한 버전 : Modern, Victorian, ArtDeco고객이 이미 가지고 있는 버전에 맞는 가구를 제공해야함ex. 이미 Modern 의자와 소파가 있는데 한개만 Victorian이면 안됨.새로운 상품이나 연관 상품들을 프로그램에 추가할 때마다 기존의 핵심 코드를 매번 변경하고 싶지 않다. 😊 해결방안추상팩토리 패턴을 사용해보자. 위 사진처럼 소파와 커피테이블도 같은 구조를 따를 것이다.하나의 가구팩토리에는 연관된 가구 그룹을 생성하는 팩토리 메소드들이 있다. 가구팩토리 인터페이스를 구현한 자식 팩토리들은 하나의 버전으로 묶인 가구들을 생성해낸다. VictorianFurnitureFactory는 Victorian 버전만, ModernFurnitureFactory는 Modern 버전의 가구만 생성한다.가구를 제공할 때 클라이언트는 팩토리 안에 무슨 팩토리가 있는지, 그 팩토리에서 무슨 버전의 가구를 생성하는지 관심없다. 만약 의자를 생성하고 싶다면, 팩토리의 createChair 메소드를 호출한다. 그 의자가 무슨 버전인지 상관 없이 모두 추상화된 의자 인터페이스를 통해 다룬다. 클라이언트가 보게 되는 것은 오직 의자의 메소드인 sitOn이다.하지만 추상화된 인터페이스로 비즈니스 로직을 구성한다 하더라도, 결국에 처음에는 조건에 따라 버전별로 팩토리를 생성하는 부분이 있어야 한다. 무엇이 팩토리 객체를 만드는가? 통상적으로, 앱의 초기화 단계에서 추상팩토리를 구현한 자식팩토리들을 생성한다.🧱 구조Abstract Products : 의자, 소파, 커피테이블 등을 정의Concrete Products : 각 가구의 여러가지 버전. 의자의 A버전, B버전, 소파의 A버전, B버전 등.The Abstract Factory : 각 abstract product를 생성하는 메소드들이 존재함Concrete Factories : 추상 팩토리의 생성 메소드를 구현함. 각 concrete factory는 product의 한 버전에 대응하고 오직 그 버전의 product들만 생성함.  ex VictorianFactory에서는 Victorian 가구만 생성.비즈니스 로직을 담은 Client Code : Client는 추상 인터페이스들을 통해 모든 concrete factory/product와 상호작용한다.🙋 언제 사용해요?여러 버전의 연관 상품들을 다뤄야 하지만 각각 버전의 상품들로부터 최대한 독립적이고 싶을 때! 혹은 어떻게 될 지 몰라서 미래의 확장성을 고려하고 싶을 때🔪 장단점장점하나의 팩토리에서 반환된 상품들을 서로 호환된다.client code와 product의 여러가지 버전이 서로 독립적이다.Single Responsibility Principle(SRP). product 생성부분을 떼어내어서 유지보수가 쉬워진다.Open/Closed Principle(OCP). 최소화의 수정으로 최대한의 확장 가능.단점버전이 너무 많아지면 상품의 자식클래스들과 인터페이스가 많아지면서 코드의 복잡성 증가.📝 질문 및 고찰결국에는 (버전)X(추상 product 개수)만큼의 클래스를 정의해야하는데, 버전이 유한개가 아니거나 특정지어지지 않은 경우에는 어떻게 해야할까?🧐참고Refactoring Guru"
83,"Factory Method배경팩토리 메소드는 생성적 디자인 패턴 중 하나로서, 부모 클래스에서 객체를 생성하는 인터페이스를 제공한다. 자식 클래스들은 객체를 생성할 때 형을 변환할 수 있다.💀 문제 정의물류 관리 애플리케이션을 만든다고 생각해보자. 앱의 첫 버전은 오직 트럭 운송을 다루기 때문에, 앱의 코드는 Truck 클래스 속에 있다.얼마 후, 이 앱이 유명해져서 해상 운송 회사로부터 해상 운송도 지원해달라는 요청이 쏟아지고 있다.이미 Truck 클래스와 많이 엮여있는 코드에 Ships를 추가하여 변경하는 것은 쉽지 않을 것이다.확장성이 떨어지는 코드에 문제가 있는 것이다.😊 해결방안이 때, 팩토리 메소드 디자인 패턴은 new를 통해 객체를 생성하는 부분을 특별한 팩토리 메소드를 호출하는 것으로 대체할 것을 제안한다. 즉, 팩토리 메소드 안에서 new를 통해 객체가 생성되는 것이다. 팩토리 메소드를 통해 생성되는 객체들은 product로 불린다.효과 : 팩토리 메소드(createTransport)를 통해 자식 클래스에서 만들어지는 객체의 타입을 변경할 수 있다!Logistics l=new RoadLogistics(); or new SeaLogistics(); Transtport t=l.createTransport();t.deliver()조건에 따라 해상 운송, 트럭 운송을 결정하고, 하나의 팩토리 메소드를 통해 상황에 맞는 객체를 생성한다.생성 부분만 분리하여 코드 중복 없이 기존 deliver 메소드 호출 부분을 그대로 사용할 수 있기 때문에 메인 로직은 흔들리지 않음.운송수단마다 달라지는 deliver 부분은 Transport 인터페이스에서 deliver 메소드를 정의하여 자식클래스들이 구현하게 함.팩토리 메소드를 통해 만들어진 product들은 모두 추상체인 Transport로 취급됨. 따라서, 구상체가 많이 늘어나도 코드 상으로는 달라지는 것이 없음.🧱 구조 팩토리 메소드를 통해 만들어지는 Product 부분. 팩토리메소드를 통해 생성된 모든 객체들(Concrete Product들)에게 적용되는 특징을 고려하여 Product 인터페이스를 정의함.Concrete Product들은 Product의 인터페이스를 각자에 맞게 구현함.Creator 클래스에서는 Product object를 생성하는 팩토리 메소드를 선언한다. 메소드의 반환 타입이 product와 매치되는 것이 중요하다.팩토리 메소드를 추상화하여 Creator의 자식클래스들이 각자의 버전으로 메소드를 구현하도록 강제하는 것도 가능하다. 아니면 base 팩토리 메소드가 디폴트 버전을 리턴하는 것도 하나의 방법이다.Creator 이름을 보고 오해하지 말아야할 것은, Product를 생성하는 것이 Creator의 주기능이 아니라는 것이다. 통상적으로, Creator 클래스는 이미 기존 Product와 관련된 핵심 비즈니스 로직을 가지고 있다. 팩토리 메소드는 이 로직을 Concrete Product로부터 떼어내는 것을 도와준다.Concrete Creators는 Creator 클래스의 base 팩토리 메소드를 상속받아 다른 타입의 product를 반환한다.꼭, 팩토리 메소드들이 새로운 버전의 인스턴스를 생성해낼 필요는 없다. 캐시나, object pool 등 기존에 존재하는 객체를 반환할 수도 있다.🙋 언제 사용해요?매번 비즈니스 로직을 다시 짜는 것 대신 기존에 존재하는 object들을 재사용함으로써 시스템 리소스들을 아끼고 싶을 때기존 객체를 재사용하고 싶을 때 거쳐야 하는 과정생성된 모든 객체들을 추적하고 있는 저장공간 생성누가 객체를 요청했을 때, 프로그램은 pool에서 free object를 찾음.return없으면 new를 통해 생성 or pool에 등록해당 로직은 클래스의 생성자 부분에 넣기 적합하나, 생성자들은 무조건 new objects들을 return 해야함. 기존 존재하는 객체를 반환할 수 없음.따라서, 팩토리 메소드를 통해 생성/재사용을 둘다 할 수 있음.코드와 연관이 깊은 객체의 정확한 타입과 연관관계, 의존관계를 사전에 모르는 경우팩토리 메소드는 product를 사용하는 로직과 product를 생성하는 로직을 분리한다. 따라서 기존의 코드와 상관없이 product를 확장하는데 유리하다.라이브러리 또는 프레임워크의 사용자에게 내부 구성요소를 확장하는 방법을 제공하고 싶을 때🔪 장단점1. 장점생성부분과 concrete product간의 강한 결합을 피할 수 있다.Single Responsibility Principle(SRP)를 잘 지킨다. 생성부분을 하나의 곳으로 옮김으로써 한 부분의 수정이 다른 부분의 수정에 영향을 미치는 일을 없도록 함.Open/Closed Principle(OCP). 기존에 존재하는 코드를 갈아엎어야 하는 일 없이 새로운 타입의 product를 적용할 수 있다. 확장에 강하다.2. 단점이 패턴을 구현하기 위해 많은 자식 클래스들이 추가되어서 코드가 더 복잡해질 수 있다.📝 예시Shape.javapublic interface Shape{    void draw();}Circle.javapublic class Circle implements Shape{    @Override    public void draw(){        System.out.println(&quot;Inside Circle::draw() method.&quot;);    }}Rectangle.javapublic class Circle implements Shape{    @Override    public void draw(){        System.out.println(&quot;Inside Rectangle::draw() method.&quot;);    }}Square.javapublic class Circle implements Shape{    @Override    public void draw(){        System.out.println(&quot;Inside Square::draw() method.&quot;);    }}ShapeFactory.javapublic class ShapeFactory{    public Shape getShape(String shapeType){        if(shapeType==null){            return null;        }        if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){            return new Circle();        } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){            return new Rectangle();        } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){            return new Square();        }        return null;    }}FactoryPatternDemo.javapublic class FactoryPatternDemo{    public static void main(String args){        ShapeFactory shapeFactory=new ShapeFactory();        Shape shape1=shapeFactory.getShape(&quot;CIRCLE&quot;);        shape1.draw();        Shape shape2=shapeFactory.getShape(&quot;RECTANGLE&quot;);        shape1.draw();        Shape shape3=shapeFactory.getShape(&quot;SQUAREa&quot;);        shape1.draw();    }}참고Refactoring Guru예제 코드"
84,"StringBuffer를 사용하는 이유String은 Immutable하다.Java의 String은 특별하다. Java에서 String은 Constant Pool을 사용하고 있기 때문에, += 연산을 활용하여 String을 조작 시, 기존 String이 변경되는 것이 아니라 새로운 String이 Constant Pool에 생성된다. 때문에, +=을 활용한 조작을 반복적으로 하면 메모리를 비효율적으로 사용하게 된다.예를 들어,String greeting=&quot;Hello&quot;for(int i=0; i&lt;10; i++){    greeting+=&quot;a&quot;;}이런 식의 코드가 있다고 생각해보자. 이런 식으로 기존의 Hello라는 문자열이 변경되는 것이 아니라 새로운 문자열이 생성되며 메모리를 차지하게 된다. Constant Pool 내에서 사용되지 않는 문자열들은 Garbace Collector의 제거 대상이 된다.이와 같은 문제의 해결방안이 바로 Buffer를 이용하는 것이다.mutable한 StringBuilder, StringBufferStringBuffer sb=new StringBuffer();sb.append(&quot;Hello&quot;);for(int i=0; i&lt;10; i++){   sb.append(&quot;a&quot;);}System.out.println(sb);StringBuffer와 StringBuilder의 차이동기화의 지원유무이다.StringBuffer : 동기화를 지원하여 멀티쓰레드 환경에서도 안전하게 동작StringBuilder : 동기화를 지원하지 않는 대신, 단일 쓰레드 환경에서 StringBuffer보다 성능이 우수함.동기화를 지원한다는 것은동기화를 지원한다는 뜻은, 하나의 쓰레드가 StringBuffer 클래스 내의 append 메소드를 사용하려고 했을 때, 다른 쓰레드는 block 처리되어 그 쓰레드가 메소드를 탈출할 때까지 기다리고 있는 것을 말한다. critical section에서 한개의 쓰레드만 해당 부분을 사용하는 것을 의미.참고StringBuffer, StringBuilder가 String보다 좋은 이유와 원리StringBuffer와 StringBuilder는 무슨 차이가 있는가"
85,"1장 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션어플리케이션에는 계산 중심, 데이터 중심이 있다.계산 중심 : CPU 성능이 크게 어플리케이션 성능을 좌우함.데이터 중심 : 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도에 의해 결정.데이터 중심 어플리케이션이 공통으로 필요로 하는 기능DB(database) : 영구적으로 데이터 저장캐시(cache) : 읽기 속도 향상 위해 비용이 높은 수행 결과를 기억검색 색인(search index) : 데이터 검색, 다양한 방법으로 필터링하는 것을 빠르게 함.스트림 처리(stream processing) : 다른 프로세스로 메시지 보내기일괄 처리(batch processing) : 주기적으로 대량의 누적된 데이터 분석데이터 시스템에 대한 생각데이터 시스템 : 데이터베이스, 큐, 캐시 등으로 다양한 use case를 효현하기 위해 만든 포괄적 용어, 각각의 도구도 이제 경계가 흐려지고 있음. 또한, 단일 도구로는 요구사항 대응 불가다양한 도구레디스(Redis) : 메시지 큐로 사용하는 데이터스토어(datastore)카프카(Apache Kafka) : DB처럼 지속성(durability)를 보장하는 메시지 큐신뢰성하드웨어나 소프트웨어 결함, human error 같은 역경에 직면하더라도 시스템은 원하는 성능 수준에서 정확한 기능을 수행해야 함.내결함성(fault-tolerant), 탄력성(resilient) 높음 : 결함을 예측하고 대처할 수 있는 시스템 =&gt; 에러핸들링의 중요성을 짚는 듯 하다.장애(failure)!=결함(fault)장애 : 서버 죽은 거 의미한다.결함 : 에러내결함성 시스템에서 결함을 고의적으로 일으켜 시스템을 지속적으로 훈련하고 테스트 함. ex) Netflix보안 문제는 예방책이 해결책보다 더 좋은 경우임. 되돌릴 수 업슨ㄴ 경우도 있기 때문에.해결책이 있는 결함 유형1. 하드웨어 결함하드디스크 고장, 램에 결함, 대규모 정전 사태, 데이터 센터에서 일하는 누군가의 실수 등으로 일어남.해결책 각 하드웨어 구성 요소에 중복(redundancy)를 추가한다.구성 요소 하나가 죽으면 고장 난 구성 요소가 교체되는 동안 중복된 구성 요소 대신 사용장점 예시 : 운영체제 보안 패치처럼 장비를 재부팅해야하는 경우, 단일 서버 시스템은 계획된 중단시간 필요, 중복성 있는 시스템은 전체 시스템의 중단시간 없이 순회식 업그레이드 가능.2. 소프트웨어 오류시스템 내 체계적 오류(systematic error) : 예상하기 더 어렵고, 노드 간 상관관계 때문에 하드웨어 결함보다 시스템 오류 더욱 많이 유발.잘못된 특정 입력에 대한 대응이 되지 않아 서버 인스턴스 다운.CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원 과도 사용하는 일부 프로세스시스템 속도 느려저 반응이 없거나 잘못된 응답 반환하는 서비스연쇄 장애(cascading failure)해결책주의 깊게 생각하기빈틈없는 테스트 (TDD)프로세스 격리(process isolation)죽은 프로세스의 재시작 허용배포 환경에서 시스템 동작 측정, 모니터링, 분석하기시스템이 뭔가를 보장하게 한다 (메시지 큐 수신=송신 메시지) =&gt; 수행 중에 지속적으로 확인해 차이가 생기는 경우 경고 발생3. 인적 오류사람이 하는 실수 방지하려면? 최고의 시스템은 다양한 접근 방식을 결합한다.오류의 가능성을 최소화하는 방향으로 시스템 설계 : 잘 설계된 추상화, API, 관리 인터페이스사람의 실수로 장애가 발생할 수 있는 부분 분리. 실제 데이터 사용해 안전하게 살펴보고 실험할 수 있는 비 프로덕션 샌드박스(sandbox) 제공unit test, integration test 등 모든 수준에서 철저하게 테스트. TDD 적용장애 영향 최소화 : 설정 변경 내역 roll back, 새로운 코드 roll out, 데이터 재계산 도구 제공명확한 모니터링 대책 : 성능 지표, 오류율, MySQL 락 등. 특정 가정이나 제한 벗어나는 지 확인.확장성&quot;시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?&quot;&quot;추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?&quot;부하 기술하기부하 매개변수로 나타낼 수 있다.EX) 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자(active user), 캐시 적중률 등트위터(Twitter) 예시트윗 작성 (평균 초당 4.6k 요청, 피크일 때 초당 12k 요청 이상.)홈 타임라인 (초당300k 요청)트위터의 확장성 문제는 fan-out 때문에 일어남.fan-out : 하나의 수신 요청을 처리하는 데 필요한 다른 서비스의 요청 수사용자가 트윗을 작성하면 다른 사용자의 홈 타임라인에도 영향을 미침.읽는 시점에 sql 이용 홈 타임라인 합치기SELECT tweets.*, users.* FROM tweetsJOIN users ON tweets.sender_id=users.idJOIN follows ON follows.followee_id = users.idWHERE follows.follower_id = current_user쓰는 시점에 팔로워 홈 타임라인 캐시 업데이트하기 (팬아웃방식)사용량 : 트윗 게시 &lt; 홈 타임라인 읽기일 양 : 트윗 게시 &gt; 홈 타인라인 읽기 =&gt; 이렇게 되어야 함.주의 : 사용자마다 팔로워 수가 매우 다르다. 유명인들의 경우 매우 많은 홈 타임라인 쓰기 요청이 되어버림.사용자당 팔로워의 분포가 이 사례에서 핵심 부하 매개변수결국 혼합형을 채택. 팔로워수가 매우 많은 소수 사용자들은 1번 방식 적용.성능 기술하기&quot;부하 매개변수를 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?&quot;부하 매개변수 증가, 성능 유지되려면 어떤 자원을 얼마나 늘려야할까?&quot;=&gt; 모두 성능 수치 필요.하둡(Hadoop) 같은 일괄 처리 시스템처리량(throughput)* : 초당 처리할 수 있는 레코드 수, 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간.온라인 시스템응답 시간(response time)* : 클라이언트가 요청을 보내고 응답을 받는 사이의 시간. (클라이언트 관점)주의 : 지연 시간(latency)은 요청이 처리되길 기다리는 시간, 응답 시간은 요청 처리하는 실제 시간(서비스 시간) 이에 네트워크 지연, 큐 지연 등 모두 포함.평균은 얼마나 많은 사용자가 실제로 지연을 경험했는지 알려주지 않기 때문에 중앙값(median)을 사용한 백분위를 사용한다. 예를 들어 95분위 응답 시가이 1.5초, 100개 요청 중 95개는 1.5초 미만, 5개는 1.5초 이상. 그 상위 백분위 응답 시간을 꼬리 지연 시간(tail latency)으로 부름.보통 응답 시간이 가장 느리다 =&gt; 고객들이 많은 구매를 해서, 고객 중에서 계정에 가장 많은 데이터를 갖고 있어서. =&gt; 증맬 소중한 고객이라는 뜻.느린 원인 중 대표적인 것 =&gt; 큐 대기 지연(queueing delay)큐 자체가 어쨌든 앞에 녀석이 처리되어야 뒤에 녀석이 처리되기 때문에 선두가 처리되지 않으면 뒤에 녀석들은 계속 기다려야 함. HOL(Head Of Line Blocking) 문제 발생.비슷한 예시로, 하나의 API 요청이 여러 백엔드 호출로 이루어 질 때, 그 중 하나의 백엔드 호출만 느려도 결국 그 호출로 인해 응답 시간 길어짐.=&gt; 응답 시간 집계하는 것이 중요. =&gt; forward decay, t-digest, HdrHistogram 같은 알고리즘 사용하여 시간 구간 내 모든 요청의 응답 시간 목록 유지, 1분마다 목록 정렬.부하 대응 접근 방식용량 확장(scaling up)(수직 확장(vertical scaling)) : 좀 더 강력한 장비로 이동규모 확장(scaling out)(수평 확장(horizontal scaling)) : 다수의 낮은 사양 장비에 부하를 분산 =&gt; 비공유 아키텍쳐탄력적(elastic) 시스템 : 부하 증가 감지시 컴퓨팅 자원 자동 추가. (auto-scaling, ex. aws ec2)일반적인 통념은 고가용성 요구가 있을때까지 단일 노드에 DB 유지. (용량 확장) 왜냐하면 다수의 장비에 stateless한 서비스를 배포하는 것은 간단하지만 단일 노드에 stateful한 데이터 시스템을 분산 설치하는 일은 복잡함. 하지만 점점 대용량 데이터와 트래픽을 다루지 않아도 MSA가 기본 아키텍처로 자리 잡을 가능성 있음.아키텍처 결정 요소읽기의 양쓰기의 양저장할 데이터의 양데이터의 복잡도응답 시간 요구사항접근 패턴크기가 1kB인 초당 100,000건 요청 처리하는 시스템vs크기가 2GB인 분단 3건의 요청 처리하는 시스템같은 데이터 처리량이라 해도 매우 다름.따라서, 주요 동작이 무엇이고, 잘 하지 않는 동작이 무엇인지에 대한 가정이 곧 부하 매개변수가 된다.유지보수성버그 수정시스템 운영 유지장애 조사새로운 플랫폼 적은기술 채무(technical debt) 상환새로운 기능 추가등이 유지보수에 해당됨.레거시 소프트웨어를 직접 만들지 않게끔 소프트웨어를 설계하기 위해 고려해야 하는 점운용성(operability)운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라단순성(simplicity)시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라발전성(evolvability) (유연성, 수정 가능성, 적응성 등으로 불림.)엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하여 요구사항에 유연하게 대응하도록 해라.운용성: 운영의 편리함 만들기시스템 장애를 모니터링하고 상태가 좋지 않다면 빠르게 서비스 복원시스템 장애, 성능 저하 등의 문제 원인 추적보안 패치 포함해 소프트웨어와 플랫폼을 최신 상태로 유지다른 시스템이 서로 어떻게 영향 주는지 확인. 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단미래에 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결(용량 계획)배포, 설정 관리 등을 위한 모범 사례, 도구 마련애플리케이션을 특정 플랫폼 -&gt; 다른 플랫폼 등 복잡한 유지보수 태스크 수행설정 변경으로 생기는 시스템 보안 유지보수예측 가증한 운영, 안정적인 서비스 환경 유지 위한 절차 정의개인 인사 이동에도 시스템에 대한 조직 지식을 보존.좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중.좋은 모니터링으로 런타임(runtime) 동작, 시스템 내부에 대한 가시성 제공 (콘솔 등)표준 도구 이용해 자동화, 통합개별 장비 의존성 회피. 시스템 전체에 영향 x.좋은 문서, 이해하기 쉬운 운영 모델만족할 만한 기본 동작 제공, 필요할 때 기본값 다시 정의할 수 있는 자유 관리자에게 부여.self-healing, 필요에 따라 관리자가 시스템 상태 수동으로 제어.예측 가능하게 동작.단순성:복잡도 관리복잡도가 나타나는 이유모듈 간 강한 커플링(tight coupling)복잡한 의존성일관성 없는 명명임시방편으로 문제를 해결한 특수 사례시스템을 단순하게 만든다 =&gt; 우발적 복잡도(accidental complexity)를 줄인다.해결 : 추상화.직관적인 외관 아래로 많은 세부 구현 숨기기. 좋은 추상화는 다른 애플리케이션에서도 사용 가능. 비슷한 기능 여러 번 재구현하지 않도록.좋은 추상화는 큰 시스템의 일부를, 잘 정의되고 재사용 가능한 구성 요소로 추출할 수 있게 함.발전성: 변화를 쉽게 만들기추상화와 매우 밀접한 관련이 있음. 애자일 환경에서는 TDD, 리팩토링을 생활화."
86,"대학교 3학년이 끝이 났다. 요즘 들어 '의미'에 대해 많은 사유를 하게 된다. 2021년은 올해 초에 세운 계획의 80 퍼센트는 이루었다. 참 쉴새 없이 달려왔다.(아직 메인브랜치로 반영안된거 있어서 덜표시됨ㅋ)작년 줄거리 1월, 2월 달에 html, css, javascript, php로 엉망진창인 웹사이트를 만들고, 웹의 전반적인 개념을 익혔다. 동시에, 네이버 개발자님이 진행하는 멘토링에서 또 하나의 웹 프로젝트를 병행했다. node js를 처음으로 익혔다. 마무리되지는 않았다. 이것도 엉망진창이었다. 물론, 처음 치고는 둘 모두 준수했다. 1학기에는 지옥의 5팀플을 나름 성공리에 마쳤다. 오픈소스입문, 시스템프로그래밍및실습, 기계학습, 데이터베이스, 인공지능, IT전문영어를 들었다. 여기서 나름 얻어간 것이 많았던 과목은 시프와 기계학습 같다. 시프에서는 스레드를 활용한 소켓 프로그래밍을 배우고, 비효율적인 구조를 mutex lock을 통해 확장성이 있는 구조로  바꾼 경험을 했고, 기계학습에서는 parameter tuning을 통해 모델 성능을 올려보는 경험을 했다. 여름 방학에는 1년간 중학교 수학을 가르치는 과외가 끝이 났다. 이로써 롯데장학재단에서 멘토링 장학이 희망 장학으로 전환 되었고, 졸업 전까지 학기마다 생활비를 받을 수 있게 되었다. 또, 국가우수장학(이공계)에 선발 되어, 졸업 전까지 등록비를 지원받을 수 있게 되었다. 두 재단 덕분에 돈 걱정은 하지 않아도 되게 되었다. 2학기에는 파란학기와, 현장실습인턴, 구글부트캠프를 병행했다. 사실 구글부캠은 계획에 없었던 것이었는데, 우연히 합격(?)해서 참여를 하게 되었다. 체계적인 교육과정이라기 보다는, 코세라 교육과정과 캐글, 자격증을 참가자 본인이 따는 과정이라 보면 된다. 물론 테크 토크는 현재 인공지능 시장이 어떤지 많은 인사이트를 얻을 수 있었고, 더 관심을 가지게 되는 계기가 되었다.  파란학기에서는 node.js를 이용한 프로젝트를 하게 되었는데, 이전 프로젝트보다 모듈화와 아키텍쳐에 대한 고려를 반영하여 진행했다. 인턴에서는 스타트업의 체계를 경험하고, 데이터베이스에 대해 더 깊은 이해를 하게 되었다. (전보다는...) 검색시스템과 결제시스템을 만들어본게 뿌듯하다. 그리고 11월달에는 유도 유단자가 되었다. 유도를 시작한지 1년 5개월이 되는 시점이었다. 검은띠가 시작이라는게 너무 와닿더라. 앞으로 더 열심히 해야지. 12월달에 인턴이 마무리되면서, 네이버 ai tech와 당근마켓 윈터코딩을 지원했으나, 둘다 최종합까지 가지는 못했다. ai tech는 2차 코딩테스트에서 떨어졌고, 당근은 직무 면접에서 탈했다. 첫 기술면접이었다. 어떤 걸 요구하고 어떤 걸 공부해야하는지, 내가 어떤 것이 부족한지 명확해졌다. 나라는 사람 성취한 것이 많음에도 불구하고 느껴지는 공허함은 그 동안 내 마음을 살필 기회가 없었기 때문일 것이다. 그래서 다음 학기는 휴학하려고 한다. 휴학을 생각한 계기는 크게 두 가지다.나를 더 잃어버리기 전에 '개발'에만 몰두하다 보니, 나의 다른 면에  대해 점점 잊어버리는 것 같다. 점점 감정이 무뎌지고, 회의적으로 변했다. 자기객관화가 잘 되어 있는 편이라고 생각했던 어느 날, 내가 가지고 있는 것보다 내가 가지지 못한 것에 대해서만 해박한 나를 발견했다. 분명 나도 반짝반짝 빛나는 사람일텐데, 타인의 칭찬을 받아들이지 못하고 의심을 먼저 하게 되었다. 나를 과대평가하고 있는 걸거야. 나도 모르는 사이, 내면이 망가져있음을 깨달았다.1. 마음 놓고 쫓아도 될 목표에 대하여목표를 이루기 위해 노력한 과정에 비해 성취에 대한 행복은 찰나더라. 통장이 두둑해진다고 해서 내 마음도 두둑해지는 건 아니더라. 그래서 마음 놓고 쫓아도 되는 목표는 없다. 모두 다 흘러가니까, 결국 흘러가는 이 순간을 소중히 할 줄 알고, 과정을 즐기는 사람이 행복할 수 있다. 그래서 순간을 즐기려 했더니, 내 머릿속은 미래만 바라보더라. 넓은 들판에서 뛰노는 방법 중에 깃발을 어딘가에 꽂고 달려가는 것 밖에 몰랐던거야. 아무 걱정 없이 순간을 즐기는 방법을 어느새 잊은 것 같다.그래서 제멋대로인 자유로운 사람들을 좋아했나보다. 종이의 집에 도쿄, 도시남녀 사랑법의 윤선아 2. 머릿속이 시끄러워생각에 생각이 꼬리를 물고 이어진다. 이걸 해결하는 방법은 두 가지다. 마주하거나, 도피하거나. 지금은 마주해서 이렇게 책상 앞에 앉아 정리를 하고 있다. 평소에는 도피한다. 도피하면 넷플릭스를 보거나, SNS를 하거나. 2022년에는 문제와 할 일, 해야하는 생각들을 바로바로 마주하는 내가 할 수 있기를. 정리를 해야해프로젝트를 많이 하는게 중요한게 아니다. 물론, 내 환경 상 많이 할 수 밖에 없긴 함. '제대로된' 프로젝트가 중요하다. 기술적으로 많은 것을 경험해 본 프로젝트, 문제 해결 과정이 많이 일어난 프로젝트, 챌린지를 풀어내는 프로젝트. 백엔드 입장에서는 많은 사용자를 경험해보는게 중요하다. 하지만, 토이 프로젝트 수준으로는 경험할 수 없으니, 아키텍쳐와 CS를 다지는게 중요하다.완결되지 않은 프로젝트들을 정리하고, 디벨롭시켜야겠다.감사함지옥의 5팀플을 버틸 수 있게 해준 동기들어마무시한 기획을 같이 실현한 파란학기 팀원들4개월을 재밌게 근무할 수 있게 만들어준 현장실습 동료들언제나 가르침을 주시는 사범님, 관장님, 관원들가족들(특히 고생하시는 우리 엄마)소중한 내 친구들한 해 동안 수고한 나진로 및 계획백엔드와 머신러닝 중 고민하고 있다. 노드는 1월 내로 기술 정리를 하고, 2월 달부터 스프링을 학습할 것이다. ML을 서비스에 적용해보고 싶다. (그런데 ai engineer 가기엔 방대한 공부량이 두려운,,)하고 싶은 거데이터베이스 중심 설계 완독, 정리핸즈온 머신러닝 학습스프링 학습Node.js 마무리Elastic Search 사용해보기Kafka 사용해보기PS (C++) 연습CS 공부 (데이터베이스 -&gt; 운영체제 -&gt; 자료구조/알고리즘 순)GCP ML Engineer 자격증캐글 메달권 들기프로젝트Elastic 활용한 프로젝트노드 경매시스템 + 푸시알림chess + ML (chess.com 클론코딩)1월 계획Node 마무리Node Event Loop 뜯어보기노드 경매시스템 + 푸시알림데중설 1부 정리핸즈온 Chap 1장~3장 정리GCP ML Engineer 획득"
87,"✔ 메모리 관리 배경메모리 용량이 증가함에 따라 프로그램의 크기 또한 계속 증가하고 있기 때문에 메모리는 언제나 부족하여 제한된 물리 메모리의 효율적인 사용과 메모리 참조 방식을 제공하기 위한 전략이다.  제한된 물리 메모리(Ram) - 각 프로세스는 독립적인 메모리 공간을 갖고, 운영체제나 다른 프로세스의 메모리 공간에 접근할 수 있는 제한이 걸려있다.(운영체제만 운영체제 메모리 영역과 사용자 메모리 영역 접근에 제약을 받지 않음 )- 단편화: 메모리 공간을 비 효율적으로 사용되어 낭비되는 현상프로세스들이 메모리에 적재되고 제거되는 일이 반복되어 메모리 틈 사이에 사용하지 못할 만큼의 작은 공간들이 늘어나는 것단편화로 생기는 현상총 메모리 공간은 충분하지만 실제 사용X실제 사용 가능한 메모리 공간이 줄어들어 시스템 성능 저하를 일으킬 수 있음사용할 수 있는 메모리 공간을 찾아야 함페이지 교체 자주 함Swapping외부 단편화 : 메모리 공간 중 사용하지 못하게 되는 일부분   (Ram 에서 사이사이  남는 공간들)세그멘테이션에서 나타나는 문제점으로 동적 메모리 할당 해제를 자주 할 경우내부 단편화 : 프로세스가 사용하는 메모리 공간에 표함된 남는 부분  (메모리 100B / 프로세스 a 98B 사용하면 남는 2B )페이징 기법에서 나타나는 문제점으로 한 페이지를 너무 크게 할 경우- swapping메모리 관리를 위해 사용되는 기법으로 Round Robin과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치로 내보내고 다른 프로세스에 메모리를 할당할 수 있다.주기억장치(Ram)으로 불러오는 과정을 Swap in보조기억장치로 내보내는 과정을 Swap out✔ 메모리 관리 방법페이징(Paging)‘하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다’ 는 제약을 없앤 메모리 관리 방법외부 단편화를 해결하기위해 나온 개념이다.크게 물리 메모리와 논리 메모리로 분리 된다.  물리 메모리는 ‘Frame’ 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는 메모리)는 페이지라는 고정 크기의 블록으로 분리된다. 이는 페이지 교체 알고리즘으로 교체된다.페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 지정될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로써 외부 단편화를 해결할 수 있지만,하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고(논리메모리에서) 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping 되어 저장하다보니 내부 단편화가 늘어 난다는 단점이 있다.ex) 메모리 공간: 400MB -&gt; 물리메모리(Frame): 100MB프로세스가 메모리 등록할때 사용할 수 있는 적정량 논리메모리(Page) :220MB100 100 100(20....80)내부 단편화 늘어남.. 세그멘테이션(Segmentation)페이징기법의 문제점을 해결하기 위해  메모리를 같은 크기로 나누는 것이 아닌 서로 다른 크기의 논리적 단위인 세그먼트로 분할하는 메모리 관리 기법.프로세스에 할당된 메모리가 분리되어 분리된 세그먼트가 디스크립터 테이블에 저장단점: 가변적인 크기의 세그먼트들이 메모리에 적재되고 제거되는일이 반복되어 외부 단편화의 문제가 생김메모리에 배치하는 건 페이징기법과 동일하다.ex) 메모리 공간: 400MB 프로세스가 메모리 등록할때 필요한 메모리 :220MB 세그먼트로 50, 50, 120 크기로 배치 -&gt; 가변적인 크기"
88,"✔ 트랜잭션이란?데이터베이스의 상태를 변경시키기 위해 수행하는 작업 단위  (하나의 작업(한번에 수행), 나눌수 x)데이터베이스에서 다른테이블에 데이터를 입력, 삭제할때 오류가 생긴다면 모든 작업을 원상복구한다. 처리결과가 성공했을때만 결과에 반영.:안전성을 확보하기위한 방법SELECT, UPDATE, INSERT, DELETE 와 같은 행동을 뜻함상황에 따라 여러 개가 만들어질 수 있다.하나의 트랜잭션은 저장(Commit)되거나 철회(Rollback)된다.commit:모든 작업들을 정상 처리하겠다고 확정하는 명령어. 하나의 트랙잭션 종료rollback:작업중 오류가 생긴다면 변경사항을 취소하는 명령어. 시작하기 전 상태로 돌아감✔ 특징(ACID)원자성 (Atomicity)트랜잭션의 연산은 데이터베이스에 모두 반영되던가 모두 반영되지 않아야 한다.트랜잭션의 모든 명령은 반드시 완벽하게 수행되어야 하고, 하나라도 오류가 발생하면 전부 취소되어야한다.일관성 (Consistency)트랜잭션이 실행을 끝내면 일관성 있는 데이터베이스 상태로 변환한다.트랜잭션 수행 전과 수행 완료 후 상태가 같아야 한다.독립성 (Isolation)둘 이상의 트랜잭션이 동시에 실행되는 경우 실행중인 트랜잭션에 다른 트랜잭션의 연산이 끼어들 수 없다.실행중인 트랜잭션이 완료되기 전까지 다른 트랜잭션의 결과를 참조할 수 없다.지속성 (Durability)완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영된다.✔ 트랜잭션의 상태활동(Active) : 트랜잭션이 실행중인 상태  성공 : ↓(성공)부분 완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태↓(Commit)완료(Committed) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태  실패: ↓(오류)실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태↓(Rollback)철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태"
89,"동기와 비동기: 데이터를 받는 방식✔ 동기(synchronous )동시에 일어난다는 뜻으로 요청과 결과가 동시에 일어난다는 약속이다. 요청을 하면 시간이 얼마나 걸리는지 상관없이 그 자리에서 결과가 나와야 한다. (요청후→응답받고→다음동작실행)노드와 노드 사이의 작업처리단위를 동시에 맞추겠다.장점:설계과 매우 간단하고 직관적이다.단점:결과가 주어질때까지 아무일도 하지못하고 대기해야한다.✔ 비동기(Asynchronous)동시에 일어나지않는다는 뜻으로 요청과 결과가 동시에 일어나지 않는다는 약속이다. (요청후→응답상관없이 다음동작실행)요청한 그 자리에서 결과가 나오지않음노드와 노드사이의 작업처리단위를 동시에 맞추지않겠다.장점:요청을하고 결과가 나오는 시간동안 다른작업을 할 수 있으므로 자원을 효율적으로 사용한다단점:동기보다 복잡하다.동기와 비동기는 어떤 작업 혹은 그와 연관된 작업을 처리하고자 하는 시각의 차이이다.✔비동기 작업callback() :비동기 방식의 함수다른 함수의 매개변수로 함수를 전달하고, 어떠한 이벤트가 발생한 후 매개변수로 전달한 함수가 다시 호출된다. 코드가 길어지면 가독성이 떨어져 관리어려움 → 콜백헬const f1=(callback)=&gt;{    setTimeout(function(){        console.log(&quot;1번 주문완료&quot;);        callback();    }, 1000);};const f2=(callback)=&gt;{    setTimeout(function(){        console.log(&quot;2번 주문완료&quot;);        callback();    }, 2000);};const f3=(callback)=&gt;{    setTimeout(function(){        console.log(&quot;3번 주문완료&quot;);        callback();    }, 1000);};console.log('시작')f1(function(){      f2(function(){        f3(function(){            console.log(&quot;끝&quot;)        });    });});promise()비동기적으로 실행하는 작업의 결과를 나타내는 객체 (비동기의 결과를 객체화 시킴)콜백 행들링하기 좋다const pf1 = () =&gt; {  return new Promise((res, rej) =&gt; {    setTimeout(() =&gt; {      res(&quot;1번 주문완료&quot;);    }, 1000);  });};const pf2 = () =&gt; {  return new Promise((res, rej) =&gt; {    setTimeout(() =&gt; {      res(&quot;2번 주문완료&quot;);    }, 2000);  });};const pf3 = () =&gt; {  return new Promise((res, rej) =&gt; {    setTimeout(() =&gt; {      res(&quot;3번 주문완료&quot;);    }, 3000);  });};console.log(&quot;시작&quot;);pf1()  .then((res) =&gt; pf2(res)) //f1(프로미스반환)실행, resolve함수를 실행으로 넘긴값을 f2로 넘겨줌  .then((res) =&gt; pf3(res))  .then((res) =&gt; console.log(res))  .catch(console.log)  .finally(() =&gt; {    console.log(&quot;끝&quot;);  });async/await()가장 간편함, 프로미스의 then메소드를 체인형식으로 호출하는것보다 가독성이 좋음const pf1 = () =&gt; {  return new Promise((res, rej) =&gt; {    setTimeout(() =&gt; {      res(&quot;1번 주문완료&quot;);    }, 1000);  });};const pf2 = (message) =&gt; {  console.log(message);  return new Promise((res, rej) =&gt; {    setTimeout(() =&gt; {      res(&quot;2번 주문완료&quot;);    }, 2000);  });};const pf3 = (message) =&gt; {  console.log(message);  return new Promise((res, rej) =&gt; {    setTimeout(() =&gt; {      res(&quot;3번 주문완료&quot;);    }, 3000);  });};console.log(&quot;시작&quot;);async function order() { //await는 async함수 내부에서만 사용가능 일반함수에서 사용하면 에러  const result1 = await pf1();//프로미스 차례가 될때까지 기다림 result에 pf1의 resolve된 값을 넣어줌  const result2 = await pf2(result1);  const result3 = await pf3(result2);  console.log(result3);  console.log(&quot;종료&quot;);  //result1 변수에 pf1()데이터가  기다렸다가 들어가니깐 promise의 then보다 가독성이 좋음}order();"
90,"📕 문제풀면서 개념정리2Hello, JavaScript✔  배열 문제1) 배열 arr의 앞에 &quot;begin&quot;, 뒤에 &quot;end&quot; 문자열을 엘리먼트로 추가하세요.var arr=1,2,3;arr.push(&quot;end&quot;);//배열 앞에 추가arr.unshift(&quot;begin&quot;); //배열 뒤에 추가console.log(arr);//'begin',1,2,3,'end'✔  if 문 문제2) age의 값을 판정해서 20세 미만인지 이상인지 코드를 작성하세요var age = 25;if(age &lt; 20){    console.log(&quot;20세 미만입니다.&quot;);}else{    console.log(&quot;20세 이상입니다.&quot;);    } 문제3) 인자 year가 윤년인지 아닌지를 true, false로 반환하는 solution함수를 완성하세요.(편의상, 4의 배수인 해는 모두 윤년으로 생각하세요.)function solution( year ){    if(year%4==0)    return true;    else(year%4!=0)    return false;}console.log(solution(4));//true✔ while 문 문제4) while문으로 0-9 출력하시오let count = 0;while( count &lt; 10){    console.log( count );    count++;✔ for 문 문제5)for문을 이용해서 배열 cost의 값을 모두 더해 total_cost 변수에 저장하세요.let cost =  85, 42, 37, 10, 22, 8, 15 ;let total_cost = 0;for(i=0; i&lt;cost.length; i++){    total_cost+=costi;}console.log(total_cost); //219"
91,"📕 문제풀면서 개념정리Hello, JavaScript✔ 변수활용문제1)변수 a를 선언하고 변수 a의 값을 2로 만들어 보세요.const a=2;//const:선언후초기화,재할당x,중복x,블록레벨스코프//let:선언후초기화,재할당o,중복x,블록레벨스코프 //var:(선언,할당,사용)이 자유로움,중복o,함수레벨스코프✔ 자료형 문제2)변수 a의 자료형은 무엇입니까?const a=true;console.log(typeof(a)); //boolean//typeof 연산자는 데이터타입 확인할 때 사용 문제3)변수 str에 저장된 문자열을 정수로 변환해서 pi_int에 저장하세요.const str=&quot;3.141592는 Pi의 근사값입니다.&quot;const pi_int = parseInt(str);console.log(&quot;pi_int의 값은&quot;, pi_int, &quot;입니다.&quot; );//parseInt()함수는 문자열-&gt;숫자열로, 2진법-&gt;16진번 변환할 때 사용 //parseFloat()함수는 문자열-&gt;실수로 변환✔ null, undefined 문제4)undefined 값을 가진 변수 a와, null 값을 가진 변수 b를 선언해보세요.let a; let b=null; console.log(&quot;a의 자료형 :&quot;, typeof(a), &quot;입니다.&quot;); //undefinedconsole.log(&quot;b의 자료형 :&quot;, typeof(b), &quot;이고, 값은&quot;, b, &quot;입니다.&quot;);//null//undefined:변수선언,값할당x //null:객체,변수선언,값할당o//undeclared:변수선언조차x✔ object 문제5)변수 obj를 객체로 선언해서 name과 age라는 속성을 추가하고, 각각에 자신의 이름과 나이를 입력하세요.const obj={name:&quot;홍길동&quot;,age:27}; //객체: 하나의 값이 아니라 속성의 집합(이름-값(모든 자료형))문제6)book의 title을 이용해서 코드 2번째 줄이 책의 제목을 출력하도록 만들어 보세요.let book = {&quot;title&quot;:&quot;어린왕자&quot;};console.log(&quot;제목:&quot;, book.title);}; ✔ 관계연산자 문제7)함수 solution의 내용을 수정해서 a와 b가 모두 True라면 True를, 그렇지 않으면 False를 return하도록 만들어 보세요.function solution(a, b) {  if (a == true &amp;&amp; b == true) return true;  else return false;  console.log(solution(true,true)); //true}✔ string 문제8)함수 solution을 수정해서 인자 str의 첫번째 글자를 return하는 함수를 만들어 보세요.function solution(str){    let a=str0;    return a; console.log(solution(&quot;test&quot;)); // t}"
92,"제어문 : 프로그램의 순차적인 흐름을 제어해야 할 때 사용하는 실행문으로 조건문, 반복문 등이 포함되어 있다.반복문 : 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 실행문이다. (for / while / do-while) 📕 문제풀면서 개념정리✔ forfor(i=0; i&lt;11; i++){ //(초기식; 조건식; 증감식)console.log(i); //실행문 1~10 입력}문제1) for문을 이용해서 배열 cost의 값을 모두 더해 total_cost 변수에 저장하세요.let cost =  85, 42, 37, 10, 22, 8, 15 ;let total_cost = 0;for(i=0; i&lt;cost.length; i++){     total_cost+=costi;}console.log(total_cost); //219✔ whilelet i=0; //초기식while(i&lt;11){ //while(조건식)      console.log(i); //실행문 i~10출력  i++; //증감식  i는 10까지 반복하고 종료함      }문제1) for 문제1을 while문 형식을 이용해서 배열 cost의 값을 모두 더해 total_cost 변수에 저장하세요.let cost =  85, 42, 37, 10, 22, 8, 15 ;let total_cost = 0;let i=0; // 초기식while(i&lt;cost.length){ //while(조건식)total_cost+=costi; //실행문b++; //증감식}console.log(total_cost); //219✔ do whiledo {표현식의 결과가 참인 동안 반복적으로 실행하고자 하는 실행문;} while (조건식);문제1) 1~10까지 출력하시오var i = 0; //(초기식)do {   i++;  //(증감식)   console.log(i);  //(실행문) 1~10출력}while (i&lt;10);  //(조건식)"
93,"제어문이란? : 프로그램의 순차적인 흐름을 제어해야 할 때 사용하는 실행문으로 조건문, 반복문 등이 포함되어 있다.조건문 : 프로그램 내에서 주어진 표현식의 결과에 따라 별도의 명령을 수행하도록 제어하는 실행문이다. (if / if-else / switch) 📕 문제풀면서 개념정리✔ if문if (조건1){    실행문 ; // 조건1이 true이면 실행, false이면 else if 조건2로...}else if(조건2){    실행문 ; //조건2 true이면 실행, false이면 else 로...}else {    실행문 ;}문제) 나이를 입력하고, 성인이면 '환영합니다' , 아니라면 '죄송합니다.' 창이 나오게 해주세요.  const age = prompt(&quot;나이를 입력하시오&quot;);      if (age &gt;= 20) {        alert(&quot;환영합니다.!&quot;);      } else {        alert(&quot;죄송합니다.&quot;);      }✔ switch문switch (조건값){case 값1: 조건값1일때 실행문;  break; //조건값에 맞는 실행문이 실행하고, switch문을 빠져나가게 해줌case 값2: 조건값2일때 실행문;  break;case 값3: 조건값3일때 실행문;  break;default: 기본값, 위에 있는 조건값이 해당하지않을때 실행문;(필수값은 아님)       break;  }문제) 숫자를 입력해서 짝수인지, 홀수인지 창이 나오게 해주세요const num = prompt(&quot;숫자를 입력하세요&quot;);      switch (num % 2) {        case 0:          alert(&quot;짝수&quot;);          break;        case 1:          alert(&quot;홀수&quot;);          break;        default:          alert(&quot;다시입력해주세요&quot;);      }"
94,"✔ HTTP(Hypertext Transfer Protocol)텍스트 기반의 통신 규약으로, 웹에서 클라이언트와 서버 간에 요청/응답으로 데이터를 주고 받을 수 있는 프로토콜이다.흐름: 클라이언트가 어떠한 서비스를 URL을 통해 서버에 요청(Request)하면 서버에서 그 결과를 응답(Response)하는 형태HTML 문서 외에도 JSON 데이터나 XML 데이터 등의 정보를 주고받을 수 있다.(초기 HTTP는 오직 HTML 문서를 주고받기 위해 설계됨)특징상태가 없는 무상태  : 비연결성 특성으로 클라이언트와 서버의 연결이 해제되면 이전에 요청한 결과는 사라진다. 클라이언트가 바로 이전에 요청한 데이터를 원해도 다시 서버에 연결해 동일한 요청을 해야한다.연결 상태를 유지하지 않는 비연결성 : 클라이언트 요청에 대한 서버의 응답이 마치면 연결을 끊어 버린다. 수십만명이 사용하더라도 접속 유지는 최소한으로 할 수 있어 많은 유저의 요청을 처리할 수 있지만 클라이언트의 이전 상태를 알 수 없다.✔ HTTP의 문제점평문 통신이기에 도청이 가능하다.완전성을 증명할 수 없기 떄문에 변조가 가능하다.통신 상대를 확인하지 않기 때문에 위장이 가능하다.암호화되지 않은 데이터를 전송하기 때문에 서버와 클라이언트가 주고 받는 메시지를 외부에서 볼 수 있다 → 보안에 매우 취약함(→해결하기 위해 HTTPS)✔ HTTPS(Hypertext Transfer Protocol)웹 통신 프로토콜인 HTTP의 보안이 강화된 버전의 프로토콜이다.HTTP + 데이터 암호화 추가(HTTP+SSL)SSL: 응용 계층과 전송 계층 사이에서 동작하는 보안 소켓 계층을 뜻하고, 데이터를 안전하게 전송하기 위한 인터넷 암호화 통신 프로토콜공개키 암호화 방식 사용흐름:클라이언트는 서버에 접속하면, 서버인증서(CA)를 받음→ 서버인증서 신뢰 여부 체크 후, 공개키를 추출 → 클라이언트는 서버와 통신하는 동안만 사용할 대칭키를 임의로 만들고, 해당 대칭키를 공개키로 암호화 후 전송→ 서버는 개인키로 클라이언트가 보낸 메시지를 복호화하여 대칭키를 추출하고, 해당 대칭키를 이용하여 클라이언트와 통신함"
95,"✔ 데이터베이스란?여러 사람들이 공유하고 사용할 목적으로 통합 관리되는 데이터들의 모임이다.DBMS(Database Management System)데이터베이스를 관리하고 운영하는 소프트웨어✔ 데이터베이스를 사용하는 이유파일을 기반으로 데이터를 관리하게 되면 데이터 중복, 데이터 불일치등 문제가 발생해 이러한 파일 시스템의 단점을 보안하기 위해서 파일시스템과 데이터베이스의 참이점무결성의 원칙 / 중복성과 불일치✔ 특징사용자의 질의에 대하여 즉각적인 처리와 응답이 이루어진다.생성, 수정, 삭제를 통하여 항상 최신의 데이터를 유지한다.사용자들이 원하는 데이터를 동시에 공유할 수 있다.사용자가 원하는 데이터를 주소가 아닌 내용에 따라 참조 할 수 있다.응용프로그램과 데이터베이스는 독립되어 있으므로, 데이터의 논리적 구조와 응용프로그램은 별개로 동작된다.✔ 종류계층형(데이터 간의 관계가 트리 형태의 구조)-구조변경어려움, 비효율네트워크형(계층형의 단점을 보완하여 데이터 간 N:N구성이 가능한  망형 모델/구조복잡)관계형(키와 값으로 이루어진 데이터들을 행과 열로 구성된 테이블 구조 /sql사용/많이 사용 )객체 지향형(객체지향 프로그래밍 개념에 기반하여 만든 모델/ 정보를 객체의 형태로 표현)객체 관계형(관계형에 객체 지향 개념을 도입하여 만든 모델/데이터다입도 관계형보다 다양함)NoSQL(Not Only SQL/ SQL뿐만 아니라 다양한 특성을 지원)NewSQL(New와 SQL의 합성어/SQL과 NoSQL의 장점으로 결합한 모델)"
96,"데이터베이스를 관리하고 운영하는 소프트웨어(DBMS)인 오라클을 사용하기위해 교육용 11버전을 다운받습니다. Oracle download다운로드하여 압축을 푼 다음, cmd창에서 계정 설정해야합니다.📌 cmd창에서 계정 설정sqlplus 접속 C:&gt;sqlplus Enter user-name :system Enter password : (oracle 설치할때 입력한 비밀번호를 입력하기)관리자권한으로 접속SQL&gt;conn/as sysdbaConnected.계정 생성SQL&gt;create user id identified by pw;id, pw에는 계정을 생성할 id랑 pw를 입력하시면 됩니다.User created.권한 부여계정을 생성한 다음 권한을 줘야합니다.SQL&gt;grant connect, resource, dba to id;Grant succeeded.commit지금까지 변경사항들을 적용합니다.SQL&gt;commit;Commit complete.📌 이클립스 연동이클립스창 상단에 window - show view - data source explorer을 선택합니다.  아래 하단에 database connections ( 우클릭 ) - new-oracle 선택합니다.Drivers: 창 옆에 아이콘을 클릭해서, Oracle Thin Driver11 을 선택한 다음,JAR List 에 남아있는건 지우고, ojdbc6을 추가해줍니다. C:\oraclexe\app\oracle\product\11.2.0\server\jdbc\libProperties 에서 Connection URL : jdbc:oracle:thin:@localhost:1521:db  // db -&gt;xe로 수정Database Name : db-&gt; xe 수정하고,id와 pw를 입력해줍니다.창 아래에 Test Connection 클릭하고,  ping succeeded! 이 나오면 됩니다."
97,"get 과 post 는 HTTP 메서드로 서버가 요청을 수행하기 위해 해야할 행동을 표시합니다.여기서  HTTP 는 웹에서 클라이언트와 서버간에 요청, 응답으로 데이터를 주고 받을 수 있는 통신 프로토콜입니다.프로토콜 : 특정기간에 데이터를 주고받기 위해 상호간의 정의한 규칙 ✔ GET 이란?get 메소드는 클라이언트에서 서버로 어떠한 리소스의 정보를 요청할때 사용합니다.어떤 값이나 내용, 상태 등을 바꾸지 않고 읽거나 검색할때만 사용합니다.( -&gt; 데이터변형의 위험이 없음) 쿼리스트링을 포함한 URL : www.example-url.com/resources?name1=이예지 &amp; name2=이지수쿼리스트링: URL 뒤에 파라미터 포함해서 데이터를 입력하는, 가장 단순한 데이터 전달 방법 ✔ POST 란?post 메소드는 리소스를 생성/업데이트하기 위해 서버에 데이터를 보내는데 사용합니다.보안적인 부분에서 get 보다 안전하다고 생각할 수 있지만, 크롬의 개발자도구나 fiddler(피들러) 와 같은 툴로 요청내용을 확인할 수 있기때문에 민감한 데이터는 암호화해야합니다.전송해야 할 데이터를 HTTP 메시지의 body 에 담아서 전송합니다.post로 요청을 보낼 때는 요청 헤더의 Content-Type에 요청 데이터의 타입을 표시해야 합니다. 그렇지않으면 서버는 내용이나 URL에 포함된 리소스의 학장자명으로 데이터타입을 유추할 수 밖에 없습니다.리소스 : 사용될 수 있는 어떤 항목, 자원(메모리, 데이터, 루틴..)✔ GET 과 POST 의 차이점getpost주로 사용&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;리소스 요청&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;리소스 생성브라우저 기록&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⭕&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❌북마크 추가&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⭕&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❌데이터 길이 제한&nbsp;&nbsp;⭕(url에 데이터를 넣다보니)❌(대용량 데이터도 가능)리소스 전달 방식&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;쿼리 스트링HTTP Body (URL 데이터 표시X)캐시캐시됨(같은 요청 여러번해도 항상 같은 답)캐시되지x(다른답이 올 수 있음)idempotent(멱등성)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;멱등성 성립⭕멱등성 성립❌HTTP 응답 코드200(Ok) /(여러 형식의 데이터와 함께 반환)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;201(Created)get-캐싱하기때문에(저장된 데이터를 활용하므로) 빠르게 접근가능함캐시: 기억장치와 CPU사이에 위치하는 보조 기억 장치로 컴퓨터 성능 향상을 위해 사용하는 메모리(자주 사용하는 데이터들을 기억) idempotent(멱등성) : 연산을 여러번 적용하더라고 결과가 달라지지 않는 성질"
98,"Apache Tomcat(아파치 톰캣)이란?아파치 소프트웨어 재단에서 개발한 서블릿 컨테이너(또는 웹 컨테이너)만 있는 웹 애플리케이션 서버이다.톰캣은 웹 서버와 연동하여 실행할 수 있는 자바 환경을 제공하여,자바서버 페이지(JSP)와 자바 서블릿이 실행할 수 있는 환경을 제공하고 있다.톰켓은 자바 실행환경이 필요하므로 JRE가 설치되어 있어야 한다.이클립스를 설치하면서 JDK를 설치했다면, JRE도 같이 설치되기 때문에 따로 하지않아도 된다.✔ Apache Tomcat 설치Apache Tomcat 사이트에서 '32-bit/64-bit Windows Service Installer (pgp, sha512)'을 다운받으면 된다.설치할때는 default설정으로 모두 next를 해주면 된다.설치가 완료되어 아래와 같은 창이 뜨면 Run Apache Tomcat, show 체크를 하지않고 finish를 클릭! 하야한다.그다음 HTTP/1.1 Connector Port에 적혀있는 8080을 -&gt; 8090으로 바꿔줘야 한다.이제 설치는 끝이 났고, 이클립스연동을 해줘야한다.이클립스 하단부분에 'server' 우클릭-New 를 클릭해서 사진처첨 'Tomcat v9.0 Server'을 선택한다.그다음 상단부분에 window-preferences-server-runtime environments 여기에 있던건 지워야한다. add - 'Apache tomcat v9.0' 선택하고,-Browser에 톰켓이 있는 위치를 찾아주면된다.'C:\Program Files\Apache Software Foundation\Tomcat 9.0'마지막으로 하단에 server-tomcat을 클릭해서 오른쪽 Ports 부분에 Tomcat admin port : 9005로 바꿔주면 된다."
99,"✔ jdk설치java를 사용하려면 이클립스 설치하기전 jdk 를 먼저 설치해야 합니다.jdk 홈페이지에 들어가서 java8 - 8u301 window 64 를 다운받아주세요.✔ 환경설정다운이 완료되면, 제어판 -&gt; 시스템 -&gt; 고급 시스템 설정 -&gt; 환경변수에 들어가서2가지를 설정해주세요.&nbsp;&nbsp;&nbsp;1. 시스템 변수 - 새로만들기를 클릭하여 아래처럼 입력. 변수이름:JAVA_HOME변수 값: jdk파일 경로(C:\Program Files\Java\jdk1.8.0_301) 시스템 변수에 'path' 를 선택하고 편집 클릭-&gt; 새로만들기를 클릭해 '%JAVA_HOME%\bin' 을 입력환경변수 설정을 완료했다면,  cmd창에서 'java -version' 을 입력해 다운받은 버전이 나온다면 jdk 설치성공! ✔ 이클립스 설치이제 이클립스 홈페이지 에서 이클립스를 설치해주세요.(Eclipse IDE for Enterprise Java and Web Developers 선택!)✔ 환경설정설치가 다 되었으면 UTF-8 인코딩 설정부터 해야되요! (총 4개 설정해야 함)상단의 Windows → Preference -&gt; General 의 Workspace 에서 encoding - other : 'UTF-8'을 선택해주세요.Web에서 CSS, HTML, JSP 도 'UTF-8'을 선택해주세요. 이제 작업을 시작하시면 됩니다!"
100,"✔ 자바스크립트란? + 특징자바스크립트는 객체 기반의 스크립트 언어입니다.  (상속과 클래스라는 개념은 없습니다.)동적이며, 타입을 명시할 필요가 없는 인터프리터 언어입니다. 객체 지향형 프로그래밍과 함수형 프로그래밍을 모두 표현할 수 있습니다.🤞스크립트언어 : 이미 존재하는 애플리케이션을 제어하기 위한 프로그래밍 언어.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;대부분 인터프리터 언어이다. 인터프리터 : 한줄 단위로 번역하고, 번역과 동시에 실행시키는 프로그램.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그래서 번역속도는 빠르지만 실행속도는 느리다.✔ 변수에 대해서..변수란  ?어떤 값을 저장하기 위한 공간이라고 합니다.자바스크립트의 변수 생성은 선언, 할당(초기값 대입), 사용의 단계로 구분됩니다. 변수 선언하는 3가지 방법이 있습니다. ( var / const / let )기본적으로 const를 사용하고, 재할당이 필요한 경우에 한정해 let을 사용하는 것을 권장합니다.var선언, 할당, 사용이 위치와 상관없이 자유롭습니다.스코프에( { }:중괄호 ) 상관없이 값의 접근이 가능하며, 중복선언도 가능합니다.(함수 레벨 스코프)if(true){   var a=3;}console.log(a); //3 정상 실행-값의 변경이 자유로워 의도한 값의 저장 및 유지가 실패할 수 있습니다.const상수형 변수.상수 선언후 초기화를 해야하며 ,한번 할당된 값은 변경할 수 없  습니다.  const a1 = 0;  a1=1; //에러 const c; //에러:초기화되지않은 상수형 변수 -스코프안에서 중복선언시 에러가 발생합니다.스코프를 벗어나면 변수가 인식되지 못합니다.(블록 레벨 스코프)let변수 선언후 초기화를 해야하며, 재할당이 가능한 변수입니다.-스코프안에서 중복선언시 에러가 발생합니다.스코프를 벗어나면 변수가 인식되지 못합니다.(블록 레벨 스코프)if(true){ let a=3;}console.log(a); //에러 참고사이트_tcpschool"
101,"BOJ 2109 순회강연 바로가기📍 문제한 저명한 학자에게 n(0 ≤ n ≤ 10,000)개의 대학에서 강연 요청을 해 왔다. 각 대학에서는 d(1 ≤ d ≤ 10,000)일 안에 와서 강연을 해 주면 p(1 ≤ p ≤ 10,000)만큼의 강연료를 지불하겠다고 알려왔다. 각 대학에서 제시하는 d와 p값은 서로 다를 수도 있다. 이 학자는 이를 바탕으로, 가장 많은 돈을 벌 수 있도록 순회강연을 하려 한다. 강연의 특성상, 이 학자는 하루에 최대 한 곳에서만 강연을 할 수 있다.예를 들어 네 대학에서 제시한 p값이 각각 50, 10, 20, 30이고, d값이 차례로 2, 1, 2, 1 이라고 하자. 이럴 때에는 첫째 날에 4번 대학에서 강연을 하고, 둘째 날에 1번 대학에서 강연을 하면 80만큼의 돈을 벌 수 있다.📍 입력첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 각 대학에서 제시한 p값과 d값이 주어진다.📍 출력첫째 줄에 최대로 벌 수 있는 돈을 출력한다.📍 풀이✍ 코드# 2109 순회 강연 &lt; 골드 3 &gt;import heapqfrom sys import stdinlst, heap = ,  # pay, day 배열, heap 배열income = 0 # 총 수입N = int(stdin.readline())for _ in range(N):  p, d = map(int,stdin.readline().split())  lst.append(d,p)lst.sort() # 일자 기준 오름차순 정렬for i in range(N):  day, pay = lsti  heapq.heappush(heap, pay,day) # 힙에 현재 일정 추가  if day &lt; len(heap): # 현재 날짜보다 많은 일정이 있다면    heapq.heappop(heap) # 제일 작은 일정 제거for h in heap:  income += h0print(income)"
102,"BOJ 11501 주식 바로가기📍 문제홍준이는 요즘 주식에 빠져있다. 그는 미래를 내다보는 눈이 뛰어나, 날 별로 주가를 예상하고 언제나 그게 맞아떨어진다. 매일 그는 아래 세 가지 중 한 행동을 한다.주식 하나를 산다.원하는 만큼 가지고 있는 주식을 판다.아무것도 안한다.홍준이는 미래를 예상하는 뛰어난 안목을 가졌지만, 어떻게 해야 자신이 최대 이익을 얻을 수 있는지 모른다. 따라서 당신에게 날 별로 주식의 가격을 알려주었을 때, 최대 이익이 얼마나 되는지 계산을 해달라고 부탁했다.예를 들어 날 수가 3일이고 날 별로 주가가 10, 7, 6일 때, 주가가 계속 감소하므로 최대 이익은 0이 된다. 그러나 만약 날 별로 주가가 3, 5, 9일 때는 처음 두 날에 주식을 하나씩 사고, 마지막날 다 팔아 버리면 이익이 10이 된다.📍 입력입력의 첫 줄에는 테스트케이스 수를 나타내는 자연수 T가 주어진다. 각 테스트케이스 별로 첫 줄에는 날의 수를 나타내는 자연수 N(2 ≤ N ≤ 1,000,000)이 주어지고, 둘째 줄에는 날 별 주가를 나타내는 N개의 자연수들이 공백으로 구분되어 순서대로 주어진다. 날 별 주가는 10,000이하다.📍 출력각 테스트케이스 별로 최대 이익을 나타내는 정수 하나를 출력한다. 답은 부호있는 64bit 정수형으로 표현 가능하다.📍 풀이✍ 코드from sys import stdinT = int(stdin.readline())for _ in range(T):  N = int(stdin.readline())  C = list(map(int,stdin.readline().split()))  M = C-1 # 가까운 미래 중 가장 큰 수  profit = 0  for i in range(N-2,-1,-1): # 뒤에서 부터 진행    if M &gt; Ci: # M 보다 현재 주가가 낮다면      profit += M - Ci # M - 현재 주가 만큼 이익 추가    else: # M 보다 더 높은 주가가 존재한다면      M = Ci # M의 값 갱신  print(profit)"
103,"BOJ 2212 센서 바로가기📍 문제한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.📍 입력첫째 줄에 센서의 개수 N(1 ≤ N ≤ 10,000), 둘째 줄에 집중국의 개수 K(1 ≤ K ≤ 1000)가 주어진다. 셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 있으며, 좌표의 절댓값은 1,000,000 이하이다.📍 출력첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.📍 풀이✍ 코드import heapqfrom sys import stdinN = int(stdin.readline()) # 센서의 개수K = int(stdin.readline()) # 집중국의 개수M = sorted(list(map(int,stdin.readline().split()))) # 센서 위치 오름차순 정렬if N &lt; K: # 센서보다 집중국의 개수가 많으면  print(0)  exit()distance =  # 센서 간 거리 값for i in range(N-1):  heapq.heappush(distance, Mi - Mi+1)for _ in range(K-1):  heapq.heappop(distance)print(abs(sum(distance)))"
104,"BOJ 1700 멀티탭 스케줄링 바로가기📍 문제기숙사에서 살고 있는 준규는 한 개의 멀티탭을 이용하고 있다. 준규는 키보드, 헤어드라이기, 핸드폰 충전기, 디지털 카메라 충전기 등 여러 개의 전기용품을 사용하면서 어쩔 수 없이 각종 전기용품의 플러그를 뺐다 꽂았다 하는 불편함을 겪고 있다. 그래서 준규는 자신의 생활 패턴을 분석하여, 자기가 사용하고 있는 전기용품의 사용순서를 알아내었고, 이를 기반으로 플러그를 빼는 횟수를 최소화하는 방법을 고안하여 보다 쾌적한 생활환경을 만들려고 한다.예를 들어 3 구(구멍이 세 개 달린) 멀티탭을 쓸 때, 전기용품의 사용 순서가 아래와 같이 주어진다면, 키보드헤어드라이기핸드폰 충전기디지털 카메라 충전기키보드헤어드라이기키보드, 헤어드라이기, 핸드폰 충전기의 플러그를 순서대로 멀티탭에 꽂은 다음 디지털 카메라 충전기 플러그를 꽂기 전에 핸드폰충전기 플러그를 빼는 것이 최적일 것이므로 플러그는 한 번만 빼면 된다. 📍 입력첫 줄에는 멀티탭 구멍의 개수 N (1 ≤ N ≤ 100)과 전기 용품의 총 사용횟수 K (1 ≤ K ≤ 100)가 정수로 주어진다. 두 번째 줄에는 전기용품의 이름이 K 이하의 자연수로 사용 순서대로 주어진다. 각 줄의 모든 정수 사이는 공백문자로 구분되어 있다. 📍 출력하나씩 플러그를 빼는 최소의 횟수를 출력하시오. 📍 풀이✍ 코드from sys import stdinPlug =  # 현재 플러그에 꽂혀있는 전자기기의 정보count = 0 # 콘센트를 뽑는 경우의 수N, K = map(int,stdin.readline().split()) # 콘센트 수, 사용할 전자기기 개수Order = list(map(int,stdin.readline().split())) #  사용할 전자기기 순서for i in range(K):  if Orderi in Plug: # 현재 멀티탭에 전기 용품이 꽂혀있을 경우    continue  if len(Plug) &lt; N: # 멀티탭에 공간이 존재할 경우    Plug.append(Orderi)    continue  # 현재 멀티탭에 공간이 없고 전기 용품이 꽂혀있지 않을 경우  idx = 0 # 멀티탭에서 제거할 전기 용품의 위치  MAX = 0 # 멀티탭에서 멀리 위치  for j in range(N):    try:      if MAX &lt; Orderi:.index(Plugj):        MAX = Orderi:.index(Plugj)        idx = j    except:      idx = j      break  Plugidx = Orderi  count += 1print(count)"
105,"BOJ 1783 병든 나이트 바로가기📍 문제병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다.2칸 위로, 1칸 오른쪽1칸 위로, 2칸 오른쪽1칸 아래로, 2칸 오른쪽2칸 아래로, 1칸 오른쪽병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다. 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다. 이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.📍 입력첫째 줄에 체스판의 세로 길이 N와 가로 길이 M이 주어진다. N과 M은 2,000,000,000보다 작거나 같은 자연수이다.📍 출력병든 나이트가 여행에서 방문할 수 있는 칸의 개수중 최댓값을 출력한다.📍 풀이✍ 코드# 1783 병든 나이트 &lt; 실버 4 &gt;from sys import stdinN, M = map(int,stdin.readline().split()) # 세로, 가로if N == 1: # 세로 길이가 1일 경우  count = 1 # 경우 없이 모두 1elif N == 2: # 세로 길이가 2일 경우  if M &lt;= 7: count  = (M+1)//2 # 가로가 7보다 작을 경우 (M+1)//2  else: count = 4 # 나머지 모든 경우 4elif 3 &lt;= N: # 세로 길이가 3이상일 경우  if M &lt;= 4: count = M # 가로가 4보다 작은 경우 M  elif 5 &lt;= M &lt;= 6: count = 4 # 5~6의 경우 4  else: count = M - 2 # 나머지 모든 경우 M - 2print(count)"
106,"BOJ 3109 빵집 바로가기📍 문제유명한 제빵사 김원웅은 빵집을 운영하고 있다. 원웅이의 빵집은 글로벌 재정 위기를 피해가지 못했고, 결국 심각한 재정 위기에 빠졌다.원웅이는 지출을 줄이고자 여기저기 지출을 살펴보던 중에, 가스비가 제일 크다는 것을 알게되었다. 따라서 원웅이는 근처 빵집의 가스관에 몰래 파이프를 설치해 훔쳐서 사용하기로 했다.빵집이 있는 곳은 R*C 격자로 표현할 수 있다. 첫째 열은 근처 빵집의 가스관이고, 마지막 열은 원웅이의 빵집이다.원웅이는 가스관과 빵집을 연결하는 파이프를 설치하려고 한다. 빵집과 가스관 사이에는 건물이 있을 수도 있다. 건물이 있는 경우에는 파이프를 놓을 수 없다.가스관과 빵집을 연결하는 모든 파이프라인은 첫째 열에서 시작해야 하고, 마지막 열에서 끝나야 한다. 각 칸은 오른쪽, 오른쪽 위 대각선, 오른쪽 아래 대각선으로 연결할 수 있고, 각 칸의 중심끼리 연결하는 것이다.원웅이는 가스를 되도록 많이 훔치려고 한다. 따라서, 가스관과 빵집을 연결하는 파이프라인을 여러 개 설치할 것이다. 이 경로는 겹칠 수 없고, 서로 접할 수도 없다. 즉, 각 칸을 지나는 파이프는 하나이어야 한다.원웅이 빵집의 모습이 주어졌을 때, 원웅이가 설치할 수 있는 가스관과 빵집을 연결하는 파이프라인의 최대 개수를 구하는 프로그램을 작성하시오.📍 입력첫째 줄에 R과 C가 주어진다. (1 ≤ R ≤ 10,000, 5 ≤ C ≤ 500)다음 R개 줄에는 빵집 근처의 모습이 주어진다. '.'는 빈 칸이고, 'x'는 건물이다. 처음과 마지막 열은 항상 비어있다.📍 출력첫째 줄에 원웅이가 놓을 수 있는 파이프라인의 최대 개수를 출력한다.📍 풀이✍ 코드from sys import stdinmatrix = count = 0DY = -1,0,1def DFS(x, y, R, C):  if x == C - 1: # 원웅이의 빵집 도달 시    return True  for dy in DY: # 대각선 위, 오른쪽, 대각선 아래    if y + dy &lt; 0 or y + dy &gt;= R: # 필드를 벗어나면      continue    if matrixy+dyx+1 == '.': # 이동 가능한 공간이라면      matrixy+dyx+1 = 'x' # 막은 후      if DFS(x+1,y+dy,R,C): # DFS 재귀 실행        return True  return FalseR, C = map(int,stdin.readline().split()) # 세로, 가로for _ in range(R):  matrix.append(list(stdin.readline().rstrip()))for i in range(R):  if matrixi0 == '.':    if DFS(0,i,R,C):      count += 1print(count)"
107,"BOJ 1080 행렬 바로가기📍 문제0과 1로만 이루어진 행렬 A와 행렬 B가 있다. 이때, 행렬 A를 행렬 B로 바꾸는데 필요한 연산의 횟수의 최솟값을 구하는 프로그램을 작성하시오.행렬을 변환하는 연산은 어떤 3×3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것이다. (0 → 1, 1 → 0)📍 입력첫째 줄에 행렬의 크기 N M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 행렬 A가 주어지고, 그 다음줄부터 N개의 줄에는 행렬 B가 주어진다.📍 출력첫째 줄에 문제의 정답을 출력한다. 만약 A를 B로 바꿀 수 없다면 -1을 출력한다.📍 풀이✍ 코드from sys import stdin# 3 X 3 크기의 부분 배열 값 0 → 1, 1 → 0 으로 변환def Change(x, y):   for i in range(y, y+3):    for j in range(x, x+3):      Bij = 1 - BijA, B = , count = 0N, M = map(int,stdin.readline().split()) # 세로, 가로for _ in range(N):  A.append(list(map(int,stdin.readline().rstrip())))for i in range(N):  B.append(list(map(int,stdin.readline().rstrip())))for y in range(N-2):  for x in range(M-2):    if Ayx != Byx: # 현재 위치의 값이 다르다면      Change(x, y) # 3 X 3 부분행렬 변환 함수 실행      count += 1 # count 1 증가if A != B: # A 행렬과 B 행렬이 다르다면  print(-1)else:  print(count)"
108,"BOJ 7576 토마토 바로가기📍 문제철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다. 창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.📍 입력첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.토마토가 하나 이상 있는 경우만 입력으로 주어진다.📍 출력여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.📍 풀이✍ 코드from collections import dequefrom sys import stdindef BFS(D):  days = -1  dx =  -1, 1, 0, 0  dy =  0, 0, -1, 1  TMP = deque()  while D or TMP:    TMP = deque()    while D:      x, y = D.popleft()      for i in range(4): # 현재 위치에서 상하좌우로 이동        nx, ny = x + dxi, y + dyi        if nx &lt; 0 or nx &gt;= M or ny &lt; 0 or ny &gt;= N: # 만약 박스의 범위를 넘는다면          continue # 다음 반복문 실행        if BOXnynx == 0: # 현재 위치에 토마토가 존재할 경우          BOXnynx = -1 # 토마토를 제거          TMP.append(nx, ny) # 다음 위치를 TMP에 추가    days += 1 # D의 실행이 종료된 후 dyas += 1    D = TMP # TMP에 임시 저장한 위치 정보들 D에 할당  for b in BOX: # 만약 박스에 익지 않은 토마토가 존재한다면    for t in b:      if t == 0: return -1 # -1 반환  return days # 박스에 모든 토마토가 익었닸면 days 반환BOX = D = deque()M, N = map(int,stdin.readline().split()) # 가로, 세로for i in range(N):  tmp = list(map(int,stdin.readline().split()))  for idx in range(M):    if tmpidx == 1:      D.append(idx, i)  BOX.append(tmp)print(BFS(D))"
109,"BOJ 1202 보석도둑 바로가기📍 문제세계적인 도둑 상덕이는 보석점을 털기로 결심했다.상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.📍 입력첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)다음 N개 줄에는 각 보석의 정보 Mi와 Vi가 주어진다. (0 ≤ Mi, Vi ≤ 1,000,000)다음 K개 줄에는 가방에 담을 수 있는 최대 무게 Ci가 주어진다. (1 ≤ Ci ≤ 100,000,000)모든 숫자는 양의 정수이다.📍 출력첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.📍 풀이✍ 코드import heapqfrom sys import stdinMV =  #  무게, 가격, 무게, 가격, ... C =  #  가방의 용량, ... TMP =  # 임시 보관함SUM = 0 # 보석 가격의 합의 최대값N, K = map(int,stdin.readline().split())for _ in range(N):  MV.append(tuple(map(int,stdin.readline().split())))for _ in range(K):  C.append(int(stdin.readline()))MV.sort()C.sort()idx = 0for c in C: # 가방 용량 작은 순서대로  while idx &lt; N:     m, v = MVidx    if m &lt;= c: # 현재 보석의 무게가 가방의 용량과 같거나 작다면      heapq.heappush(TMP,-v) # 우선순위큐에 추가      idx += 1    else:      break # 현재 보석의 무게가 가방의 용랴옵다 크다면  if TMP: # 현재 우선순위큐에 값이 존재한다면    SUM += -heapq.heappop(TMP) # 보석 가격 추가print(SUM)"
110,"BOJ 15720 카우버거 바로가기📍 문제윤진이는 이번에 카우버거 알바생으로 뽑히게 되었다. 그녀는 카우버거를 평소에 이용하면서 들었던 의문점 한가지가 있었다.&quot;카우버거에는 왜 세트 메뉴에 대한 할인이 존재하지 않는가?&quot;따라서 윤진이의 아이디어로 카우버거에 세트 할인을 도입하고자 한다. 세트 메뉴는 버거 1개, 사이드 메뉴 1개, 음료 1개를 선택 할 경우 각각의 제품에 대해서 10%의 세트 할인을 적용하는 방식으로 진행된다.하지만 카우버거 점주는 POS기의 소프트웨어가 오래되어 세트 할인에 대한 내용을 추가할 수가 없었다. 따라서 소프트웨어학부에 재학 중인 윤진이는 전공을 살려 직접 프로그램을 만들어보려고 한다. 윤진이를 도와 POS기에 들어갈 세트 할인에 대한 프로그램을 작성해보자.📍 입력첫째 줄에는 주문한 버거의 개수 B, 사이드 메뉴의 개수 C, 음료의 개수 D가 공백을 사이에 두고 순서대로 주어진다. (1 ≤ B, C, D ≤ 1,000)둘째 줄에는 각 버거의 가격이 공백을 사이에 두고 주어진다.셋째 줄에는 각 사이드 메뉴의 가격이 공백을 사이에 두고 주어진다.넷째 줄에는 각 음료의 가격이 공백을 사이에 두고 주어진다.각 메뉴의 가격은 100의 배수이며, 10000원을 넘지 않는다.📍 출력첫째 줄에는 세트 할인이 적용되기 전 가격을 출력한다.둘째 줄에는 세트 할인이 적용된 후의 최소 가격을 출력한다.📍 풀이✍ 코드from sys import stdinB, C, D = map(int,stdin.readline().split())Set = result = 0for i in range(3):  tmp = list(map(int,stdin.readline().split()))  tmp.sort(reverse = True) # 내림차순으로 정렬  result += sum(tmp) # result += 모든 메뉴의 가격  Set.append(tmp)print(result)MIN = min(B, C, D) # 버거, 음료, 사이드 중 개수가 가장 작은 값for i in range(MIN):  result -= (Set0i + Set1i + Set2i) // 10 # result -= 할인 값print(result)"
111,"BOJ 11724 연결 요소의 개수 바로가기📍 문제방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.📍 입력첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.📍 출력첫째 줄에 연결 요소의 개수를 출력한다.📍 풀이✍ 코드from collections import dequefrom sys import stdinN, M = map(int,stdin.readline().split())matrix =  for _ in range(N+1) # 연결 노드visited = True for _ in range(N+1) # 방문한 노드count = 0 # 요소의 개수for _ in range(M):  x, y = map(int,stdin.readline().split())  matrixy.append(x)  matrixx.append(y)# BFSfor i in range(1,N+1):   if visitedi:    count += 1    D = deque(matrixi)    while D:      tmp = D.popleft()      if visitedtmp:        visitedtmp = False        D += matrixtmpprint(count)"
112,"BOJ 1012 유기농 배추 바로가기📍 문제차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.📍 입력입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 두 배추의 위치가 같은 경우는 없다.📍 출력각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.📍 풀이✍ 코드from collections import dequefrom sys import stdindef DFS(x,y):  dx = 1,-1,0,0  dy = 0,0,1,-1  D = deque(x,y)  while D:    x, y = D.popleft()    for i in range(4):      curX = x + dxi      curY = y + dyi      if  curX &lt; 0 or curX &gt; M-1 or curY &lt; 0 or curY &gt; N-1:        continue      if fieldcurYcurX:        D.append(curX,curY)        fieldcurYcurX = 0T = int(stdin.readline())result = for _ in range(T):  M, N, K = map(int,stdin.readline().split()) # 가로, 세로, 배추 갯수  field = 0 for _ in range(M) for _ in range(N)  for _ in range(K):    x, y = map(int,stdin.readline().split())    fieldyx = 1  count = 0  for y in range(N):    for x in range(M):      if fieldyx: # 현재 위치에 배추가 존재한다면        count += 1 # 지렁이 갯수 + 1        DFS(x,y) # DFS  result.append(count)for c in result:  print(c)"
113,"BOJ 9655 돌 게임 바로가기📍 문제돌 게임은 두 명이서 즐기는 재밌는 게임이다.탁자 위에 돌 N개가 있다. 상근이와 창영이는 턴을 번갈아가면서 돌을 가져가며, 돌은 1개 또는 3개 가져갈 수 있다. 마지막 돌을 가져가는 사람이 게임을 이기게 된다.두 사람이 완벽하게 게임을 했을 때, 이기는 사람을 구하는 프로그램을 작성하시오. 게임은 상근이가 먼저 시작한다.📍 입력첫째 줄에 N이 주어진다. (1 ≤ N ≤ 1000)📍 출력상근이가 게임을 이기면 SK를, 창영이가 게임을 이기면 CY을 출력한다.📍 풀이✍ 코드from sys import stdinN = int(stdin.readline())if N % 2: print(&quot;SK&quot;)else: print(&quot;CY&quot;)"
114,"BOJ 12927 배수 스위치 바로가기📍 문제강호는 전구 N개를 가지고 있다. 전구는 1번부터 N번까지 번호가 매겨져 있으며, 일렬로 놓여져 있다. 전구는 켜져있거나 꺼져있다.강호는 모든 전구를 끄려고 한다. 강호는 전구를 켜고 끌 수 있는 스위치 N개를 가지고 있고, 스위치도 1번부터 N번까지 번호가 매겨져 있다. i번 스위치는 i의 배수 번호를 가지는 전구의 상태를 모두 반전시킨다.현재 전구의 상태가 주어졌을 때, 모든 전구를 끄기 위해서 스위치를 몇 번 눌러야하는지 구하는 프로그램을 작성하시오.📍 입력첫째 줄에 전구의 상태가 1번 전구부터 차례대로 주어진다. Y는 전구가 켜 있는 경우, N은 전구가 꺼져있는 경우이다. 전구의 개수는 1보다 크거나 같고 1,000보다 작거나 같은 자연수이다.📍 출력모든 전구를 끄기 위해서 스위치를 몇 번 눌러야 하는지 출력한다. 만약, 모든 전구를 끌 수 없다면 -1을 출력한다.📍 풀이✍ 코드from sys import stdinLights = 0 + list(stdin.readline().rstrip())count = 0 # 스위치 동작 횟수num = len(Lights) # 전구 갯수for i in range(1, num):  if Lightsi == 'Y': # i 위치의 전구가 켜져있다면    count += 1 # 스위치 동작 횟수 + 1    for j in range(i,num,i): # i의 배수 전구의 값 변환      if Lightsj == 'Y': Lightsj = 'N'      else: Lightsj = 'Y'print(count)"
115,"BOJ 2606 바이러스 바로가기📍 문제신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.예를 들어 7대의 컴퓨터가 &lt;그림 1&gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.📍 입력첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.📍 출력1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.📍 풀이✍ 코드from collections import dequefrom sys import stdinN = int(stdin.readline())L = int(stdin.readline())NET = 0 for _ in range(N+1) for _ in range(N+1)for _ in range(L):  x, y = map(int,stdin.readline().split())  NETyx = x  NETxy = yD = deque(1) # 출발 컴퓨터 1visited = False, False + True for _ in range(N-1)count = 0while D:  cur = D.popleft() # 현재 PC  for num in NETcur: # 현재 PC에 연결된 다른 PC    if num and visitednum: # 현재 PC에 연결된 다른 PC가 count 되지 않았다면      D.append(num) # 다른 PC 번호 Deque에 추가      visitednum = False # count 처리      count += 1 # count값 증가print(count)"
116,"BOJ 2667 단지번호붙이기 바로가기📍 문제&lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. &lt;그림 2&gt;는 &lt;그림 1&gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.📍 입력첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.📍 출력첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.📍 풀이✍ 코드from collections import dequefrom sys import stdindef BFS(x, y):  D = deque(x, y)  count = 0  while D:    x, y = D.popleft()    if x - 1 &gt;= 0 and MAPyx-1: # MAP 범위 내에 아파트가 존재한다면      D.append(x-1, y) # 다음 아파트 추가      MAPyx-1 = 0 # 다음 아파트 MAP에서 제거      count += 1 # 아파트 갯수 추가    if x + 1 &lt; N and MAPyx+1:      D.append(x+1, y)      MAPyx+1 = 0      count += 1    if y - 1 &gt;= 0 and MAPy-1x:      D.append(x, y-1)      MAPy-1x = 0      count += 1    if y + 1 &lt; N and MAPy+1x:      D.append(x, y+1)      MAPy+1x = 0      count += 1  return count # 형성된 단지내 아파트 갯수N = int(stdin.readline())MAP = answer = for _ in range(N):  MAP.append(list(map(int,stdin.readline().rstrip())))for x in range(N):  for y in range(N):    if MAPyx:      answer.append(BFS(x,y))answer.sort()print(len(answer))for a in answer:  print(a)"
117,"BOJ 2178 미로 탐색 바로가기📍 문제N×M크기의 배열로 표현되는 미로가 있다.미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.📍 입력첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.📍 출력첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.📍 풀이✍ 코드from collections import dequefrom sys import stdinN, M = map(int,stdin.readline().split())maze = for _ in range(N):  tmp = list(map(int,stdin.readline().rstrip()))  for i in range(M):    if tmpi == 1: tmpi = 10001 # 이동할 수 있는 칸의 값을 1에서 10001으로 변경  maze.append(tmp)D =  deque(0, 0, 1)answer = 0while D:  x, y, count = D.popleft() #  x좌표, y좌표, 이동 횟수   #  미로의 범위내 and 이동할 수 있는 칸 and 이동 횟수가 현재 이동할 칸의 값보다 작을 때  if x - 1 &gt;= 0 and mazeyx-1 != 0 and mazeyx-1 &gt; count+1:    D.append(x-1,y,count+1) # BFS에 이동할 칸 추가    mazeyx-1 = count + 1 # 이동할 칸에 이동 횟수 입력  if x + 1 &lt; M and mazeyx+1 != 0 and mazeyx+1 &gt; count +1:    D.append(x+1,y,count+1)    mazeyx+1 = count + 1  if y - 1 &gt;= 0 and mazey-1x != 0 and mazey-1x &gt; count +1:    D.append(x,y-1,count+1)    mazey-1x = count + 1  if y + 1 &lt; N and mazey+1x != 0 and mazey+1x &gt; count +1 :    D.append(x,y+1,count+1)    mazey+1x = count + 1print(mazeN-1M-1) # 도착지점의 이동횟수 값 출력"
118,"BOJ 1260 DFS와 BFS 바로가기📍 문제그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.📍 입력첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.📍 출력첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.📍 풀이✍ 코드from sys import stdinfrom collections import dequedef DFS(v, visited):  print(v, end=&quot; &quot;)  visitedv = False # 방문한 노드 체크  for i in arrv:    if visitedi: # 방문하지 않은 노드      DFS(i,visited) # DFS 재귀def BFS(v, visited):  visitedv = False  D = deque(v)  while D:    tmp = D.popleft() # 제일 앞 노드    print(tmp,end=&quot; &quot;)    for i in arrtmp:      if visitedi: # 방문하지 않은 노드        visitedi = False        D.append(i) # 방문 리스트에 추가N, M, V = map(int,stdin.readline().split())arr =  0 for _ in range(N+1) for _ in range(N+1) for _ in range(M):  x, y = map(int,stdin.readline().split())  arrxy = y  arryx = xvisited = False+True for _ in range(N)DFS(V, visited)print()visited = False+True for _ in range(N)BFS(V, visited)"
119,"BOJ 11051 이항 계수 2 바로가기📍 문제자연수 N과 정수 K가 주어졌을 때 이항 계수 NCK 를 10,007로 나눈 나머지를 구하는 프로그램을 작성하시오.📍 입력첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ K ≤ N)📍 출력NCK 를 10,007로 나눈 나머지를 출력한다.📍 풀이✍ 코드from sys import stdinN, K = map(int,stdin.readline().split())value = 1for i in range(K):  value  = (value * (N - i) // (i + 1))print(value%10007)"
120,"BOJ 5002 도어맨 바로가기📍 문제정인이는 강남의 유명한 클럽 Top Root의 도어맨이다. 클럽의 사장은 정인이에게 클럽이 꽉찼을 때, 클럽에 있는 남자와 여자의 수는 거의 비슷해야 한다고 말해주었다.사람들은 클럽이 문을 열기 전 부터 줄을 서 있는다. 클럽이 문을 열면, 한 명씩 직접 정인이가 입장시켜 준다. 정인이는 그들이 줄을 순서를 바탕으로 입장시켜 준다. 이때, 항상 첫 번째에 있는 사람을 입장시켜야 하는 것은 아니다. 정인이는 재량을 발휘하여 두 번째로 줄 서있는 사람을 첫 번째 사람보다 먼저 입장을 시켜줄 수 있다. 물론 이런 상황이 자주 발생하면 앞 사람이 매우 짜증이 날 것이고, 정인이에게 시비를 걸 수도 있다. 하지만, 정인이는 모든 싸움을 이길 수 있는 사람이기 때문에 이런 걱정은 하지 않아도 된다.안타깝게도, 정인이는 이렇게 싸움은 잘하지만, 숫자 계산은 잘 하지 못한다. 정인이는 항상 클럽에 들어가있는 남자와 여자의 차이를 머리속에 계산하고 있어야 한다. 이 차이가 정인이가 기억할 수 있는 값보다 크게 된다면 남은 사람들은 클럽에 입장을 할 수 없게 된다.줄을 서 있는 순서와 정인이가 기억할 수 있는 차이의 최댓값이 주어졌을 때, 클럽에 있는 사람의 수의 최댓값을 구하는 프로그램을 작성하시오.📍 입력첫째 줄에 정인이가 기억할 수 있는 가장 큰 차이 X&lt;100이 주어진다. 둘째 줄에는 줄을 서 있는 순서가 주어진다. W는 여성, M은 남성을 나타내며, 길이는 최대 100이다. 가장 왼쪽에 있는 글자가 줄의 가장 앞에 서 있는 사람의 성별이다. 📍 출력클럽에 있는 사람 수의 최댓값을 출력한다.📍 풀이✍ 코드from sys import stdinX = int(stdin.readline())people = list(stdin.readline().rstrip())num = len(people)total = 0 # 입장 인원 수count = 0 #  남자와 여자의 차이idx = 0 # 손님의 순서 indexwhile(idx &lt;num):  if peopleidx == 'W': # 현재 손님이 여성이라면    if count &gt; -X: # 기억할 수 있는 차이보다 적다면      count -= 1    else: # 기억할 수 있는 차이보다 많다면      if idx + 1 &lt; num and peopleidx+1 == 'M': # 다음 손님이 남자가 맞다면        idx += 1 # 다음 손님을 먼저 입장하고        total += 1 # 현재 손님을 다음에 입장      else: # 다음 손님이 남자가 아니라면        break # 프로그램 종료  elif peopleidx == 'M':    if count &lt; X:      count += 1    else:      if idx+1 &lt; num and peopleidx+1 == 'W':        idx += 1        total += 1      else:        break  idx += 1 # 다음 손님  total += 1 # 입장한 고객 수print(total)"
121,"🤔process란?os로부터 자원을 할당받는 작업의 단위🤔Thread란?여러 갈래의 작업 흐름을 만듦으로써 한 앱 안에서 여러 동작을 하는 것이 가능하게끔 만들어줌ex)음악을 다운로드 받는 동안, 음악 재생이 가능하나의 프로세스에서 동작하기 위해 한 프로세스의 자원을 고융할당받은 자원을 이용하는 실행의 단위Multi ThreadingMulti Processing적은 메모리 공간 차지Context Switching이 빠름하나의 process가 죽도라도 다른 프로세스에 영향을 주지 않아 안정성이 높음동기화 문제,하나의 thread장애로 전체 thread가 종료될 위험많은 메모리공간,cpu시간구현 방법① thread를 상속 받는 클래스 구현 (Thread라는 클래스)② Runnable 구현 (runnable&gt;인터페이스) 이유: 다중 상속 스레드 구현 가능뷰에 직접적인 접근 불가! thread1은 imageView.setImageResource(수진)thread2는 imageView.setImageResource(성채) 라 했을때, 이미지뷰는 무엇을 보여줄까?? 정말 no 답 thread들이 무분별하게 화면 UI에 접근하는것을 막기 위해 MainThread를 통해서만 UI를 변경할 수 있다  그래서 작업쓰레드와 메인 쓰레드를 이어주는것이 Handler! 서브 thread는 Handler를 통해서 MainThread에 접근할 수 있다.thread는 이미지를 변경해달라는 요청을 메시지 형태로 만들어 핸들러에게 전달하게 된다이 것을 메세지 큐를 이용해 순차적으로 관리해준다.🤔Handler란?스레드와 스레드 사이의 통신, 스레드에서 View 자원에 접근을 도와주는 다리  &lt;강의 계획&gt;    0.프로세스    1.스레드    2.핸들러    3.작은 실습?https://securitymax.tistory.com/141"
122,"cnt1 숫자 자동 올라가기package org.techtown.practice1;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.os.Message;import android.util.Log;import android.widget.Button;import android.widget.TextView;import android.os.Handler;import org.w3c.dom.Text;import java.util.Timer;//할 일//1. 스레드 생성 - 로직 추가//2. 핸들러 생성public class ThreadActivity extends AppCompatActivity {    Button button,button2;    TextView cnt1,cnt2;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_thread);        cnt1 = findViewById(R.id.cnt1);        cnt2 = findViewById(R.id.cnt2);        button = findViewById(R.id.button);        button2 = findViewById(R.id.button2);        //2. Thread객체생성        TimerThread thread = new TimerThread();        //3.Thread 실행        thread.start();    }    //1.스레드 상속    class TimerThread extends Thread {        //5.Thread가 실행이 됐을때, 핸들러를 만들어 주고        TimerHandler handler = new TimerHandler();        //1-1.run        public void run() {            //1-2.기능 구현            for (int i = 0; i &lt; 10; i++) {                Log.d(&quot;TimeThread&quot;, &quot;카운트&quot; + (i + 1));               //4.이후 못씀  cnt1.setText(String.valueOf(i+1));                //Handler에 값을 전달 -&gt; Message객체                Message msg = new Message();                //값을 저장할 수 있는 변수 arg1,2 obj 타입에 맞게 담아두기                msg.arg1=i+1;//★                //Message객체 전송-&gt;핸들러 객체 이용해서 해야됨 &gt; 핸들러 객체 생성                //6.                handler.sendMessage(msg);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    //4.handler    class TimerHandler extends Handler{        @Override        public void handleMessage(@NonNull Message msg) {            //()안 어떤 데이터를 받아오느냐?            //7.msg부터 정보를 받아온 후 변수에 저장하고 괄호에 넣는다            int count = msg.arg1;            cnt1.setText(String.valueOf(count));        }    }}cnt2 버튼 하나 더package org.techtown.practice1;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.os.Message;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.os.Handler;import org.w3c.dom.Text;import java.util.Timer;//할 일//1. 스레드 생성 - 로직 추가//2. 핸들러 생성public class ThreadActivity extends AppCompatActivity {    Button button,button2;    TextView cnt1,cnt2;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_thread);        cnt1 = findViewById(R.id.cnt1);        cnt2 = findViewById(R.id.cnt2);        button = findViewById(R.id.button);        button2 = findViewById(R.id.button2);        button.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                TimerThread thread = new TimerThread();                thread.start();                button.setEnabled(false);            }        });        button2.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                TimerThread2 thread2 = new TimerThread2();                thread2.start();                button2.setEnabled(false);            }        });        //2. Thread객체생성        TimerThread thread = new TimerThread();        //3.Thread 실행        thread.start();    }    //1.스레드 상속    class TimerThread extends Thread {        //5.Thread가 실행이 됐을때, 핸들러를 만들어 주고        TimerHandler handler = new TimerHandler();        //1-1.run        public void run() {            //1-2.기능 구현            for (int i = 0; i &lt; 10; i++) {                Log.d(&quot;TimeThread&quot;, &quot;카운트&quot; + (i + 1));               //4.이후 못씀  cnt1.setText(String.valueOf(i+1));                //Handler에 값을 전달 -&gt; Message객체                Message msg = new Message();                //값을 저장할 수 있는 변수 arg1,2 obj 타입에 맞게 담아두기                msg.arg1=i+1;//★                //Message객체 전송-&gt;핸들러 객체 이용해서 해야됨 &gt; 핸들러 객체 생성                //6.                handler.sendMessage(msg);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    //4.handler    class TimerHandler extends Handler{        @Override        public void handleMessage(@NonNull Message msg) {            //()안 어떤 데이터를 받아오느냐?            //7.msg부터 정보를 받아온 후 변수에 저장하고 괄호에 넣는다            int count = msg.arg1;            cnt1.setText(String.valueOf(count));        }    }    ///////////////////    //1.스레드 상속    class TimerThread2 extends Thread {        //5.Thread가 실행이 됐을때, 핸들러를 만들어 주고        TimerHandler2 handler = new TimerHandler2();        //1-1.run        public void run() {            //1-2.기능 구현            for (int i = 0; i &lt; 10; i++) {                Log.d(&quot;TimeThread&quot;, &quot;카운트&quot; + (i + 1));                //4.이후 못씀  cnt1.setText(String.valueOf(i+1));                //Handler에 값을 전달 -&gt; Message객체                Message msg = new Message();                //값을 저장할 수 있는 변수 arg1,2 obj 타입에 맞게 담아두기                msg.arg1=i+1;//★                //Message객체 전송-&gt;핸들러 객체 이용해서 해야됨 &gt; 핸들러 객체 생성                //6.                handler.sendMessage(msg);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    //4.handler    class TimerHandler2 extends Handler{        @Override        public void handleMessage(@NonNull Message msg) {            //()안 어떤 데이터를 받아오느냐?            //7.msg부터 정보를 받아온 후 변수에 저장하고 괄호에 넣는다            int count = msg.arg1;            cnt2.setText(String.valueOf(count));        }    }    /////////////////}thread 하나로package org.techtown.practice1;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.os.Message;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.os.Handler;import org.w3c.dom.Text;import java.util.Timer;//할 일//1. 스레드 생성 - 로직 추가//2. 핸들러 생성public class ThreadActivity extends AppCompatActivity {    Button button,button2;    TextView cnt1,cnt2;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_thread);        cnt1 = findViewById(R.id.cnt1);        cnt2 = findViewById(R.id.cnt2);        button = findViewById(R.id.button);        button2 = findViewById(R.id.button2);        button.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                //10-6.괄호 안 데이터 넣기                TimerThread thread = new TimerThread(cnt1);                thread.start();                button.setEnabled(false);            }        });        button2.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                TimerThread thread2 = new TimerThread(cnt2);                thread2.start();                button2.setEnabled(false);            }        });        //2. Thread객체생성 11        //TimerThread thread = new TimerThread();        //3.Thread 실행        //thread.start();    }    //1.스레드 상속    class TimerThread extends Thread {        //5.Thread가 실행이 됐을때, 핸들러를 만들어 주고        TimerHandler handler = new TimerHandler();        //10.thread 하나만 이용하는 방법        //10-2 텍스트 뷰 선언        TextView tv;        //10-1.생성자 생성 역할)초기 초기화 클래스 내부에 정의된  필드의 변수들을 초기화 &gt; 초기화되면 객체생성시 객체들은 값을 가지는 역할        public TimerThread(TextView tv){            this.tv = tv;        }        //1-1.run        public void run() {            //1-2.기능 구현            for (int i = 0; i &lt; 10; i++) {                Log.d(&quot;TimeThread&quot;, &quot;카운트&quot; + (i + 1));               //4.이후 못씀  cnt1.setText(String.valueOf(i+1));                //Handler에 값을 전달 -&gt; Message객체                Message msg = new Message();                //값을 저장할 수 있는 변수 arg1,2 obj 타입에 맞게 담아두기                msg.arg1=i+1;//★                //10-2.텍스트뷰 저장                msg.obj = tv;                //Message객체 전송-&gt;핸들러 객체 이용해서 해야됨 &gt; 핸들러 객체 생성                //6.                handler.sendMessage(msg);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    //4.handler    class TimerHandler extends Handler{        @Override        public void handleMessage(@NonNull Message msg) {            //()안 어떤 데이터를 받아오느냐?            //7.msg부터 정보를 받아온 후 변수에 저장하고 괄호에 넣는다            int count = msg.arg1;            //10-3.obj타입으로 업캐스팅되어 저장됐으니 다운캐스팅 해야함            TextView tv = (TextView) msg.obj;            //cnt1.setText(String.valueOf(count));            //10-4. timerThreasd객체 생성 시 넘겨받은 Textview객체에 내용을 업데이트 (이제 위로 올라가 오류!)            tv.setText(String.valueOf(count));        }    }    /////////////////// 11. 노필요!    //1.스레드 상속    class TimerThread2 extends Thread {        //5.Thread가 실행이 됐을때, 핸들러를 만들어 주고        TimerHandler2 handler = new TimerHandler2();        //1-1.run        public void run() {            //1-2.기능 구현            for (int i = 0; i &lt; 10; i++) {                Log.d(&quot;TimeThread&quot;, &quot;카운트&quot; + (i + 1));                //4.이후 못씀  cnt1.setText(String.valueOf(i+1));                //Handler에 값을 전달 -&gt; Message객체                Message msg = new Message();                //값을 저장할 수 있는 변수 arg1,2 obj 타입에 맞게 담아두기                msg.arg1=i+1;//★                //Message객체 전송-&gt;핸들러 객체 이용해서 해야됨 &gt; 핸들러 객체 생성                //6.                handler.sendMessage(msg);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    //4.handler    class TimerHandler2 extends Handler{        @Override        public void handleMessage(@NonNull Message msg) {            //()안 어떤 데이터를 받아오느냐?            //7.msg부터 정보를 받아온 후 변수에 저장하고 괄호에 넣는다            int count = msg.arg1;            cnt2.setText(String.valueOf(count));        }    }    /////////////////}"
123,"🪓 잡자!0.레이아웃 배치아이디ConstraintLayoutTableLowTableLow 3img&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:background=&quot;#F44336&quot;    tools:context=&quot;.mole&quot;&gt;    &lt;TextView        android:id=&quot;@+id/textView&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;@string/title_text&quot;        android:textSize=&quot;32sp&quot;        app:layout_constraintBottom_toTopOf=&quot;@+id/tableLayout&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot;        app:layout_constraintVertical_bias=&quot;0.264&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/textView2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_marginTop=&quot;60dp&quot;        android:layout_marginEnd=&quot;44dp&quot;        android:text=&quot;@string/time&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintHorizontal_bias=&quot;1.0&quot;        app:layout_constraintStart_toEndOf=&quot;@+id/textView&quot;        app:layout_constraintTop_toBottomOf=&quot;@+id/textView&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/textView3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_marginTop=&quot;28dp&quot;        android:text=&quot;@string/count&quot;        app:layout_constraintEnd_toEndOf=&quot;@+id/textView2&quot;        app:layout_constraintHorizontal_bias=&quot;0.0&quot;        app:layout_constraintStart_toStartOf=&quot;@+id/textView2&quot;        app:layout_constraintTop_toBottomOf=&quot;@+id/textView2&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tvTime&quot;        android:layout_width=&quot;30dp&quot;        android:layout_height=&quot;33dp&quot;        android:text=&quot;@string/tvTime_text&quot;        app:layout_constraintBottom_toBottomOf=&quot;@+id/textView2&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toEndOf=&quot;@+id/textView2&quot;        app:layout_constraintTop_toTopOf=&quot;@+id/textView2&quot;        app:layout_constraintVertical_bias=&quot;0.0&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tvCount&quot;        android:layout_width=&quot;18dp&quot;        android:layout_height=&quot;21dp&quot;        android:text=&quot;@string/tvCount_text&quot;        app:layout_constraintBottom_toBottomOf=&quot;@+id/textView3&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toEndOf=&quot;@+id/textView3&quot;        app:layout_constraintTop_toTopOf=&quot;@+id/textView3&quot; /&gt;    &lt;TableLayout        android:id=&quot;@+id/tableLayout&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;0dp&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot;&gt;        &lt;TableRow            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:layout_weight=&quot;1&quot;&gt;            &lt;ImageView                android:id=&quot;@+id/img1&quot;                android:layout_width=&quot;100dp&quot;                android:layout_height=&quot;100dp&quot;                android:layout_weight=&quot;1&quot;                android:src=&quot;@drawable/down&quot; /&gt;            &lt;ImageView                android:id=&quot;@+id/img&quot;                android:layout_width=&quot;100dp&quot;                android:layout_height=&quot;100dp&quot;                android:layout_weight=&quot;1&quot;                android:src=&quot;@drawable/down&quot; /&gt;            &lt;ImageView                android:id=&quot;@+id/img3&quot;                android:layout_width=&quot;100dp&quot;                android:layout_height=&quot;100dp&quot;                android:layout_weight=&quot;1&quot;                android:src=&quot;@drawable/down&quot; /&gt;        &lt;/TableRow&gt;        &lt;TableRow            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:layout_weight=&quot;1&quot;&gt;            &lt;ImageView                android:id=&quot;@+id/img4&quot;                android:layout_width=&quot;100dp&quot;                android:layout_height=&quot;100dp&quot;                android:layout_weight=&quot;1&quot;                android:src=&quot;@drawable/down&quot; /&gt;            &lt;ImageView                android:id=&quot;@+id/img2&quot;                android:layout_width=&quot;100dp&quot;                android:layout_height=&quot;100dp&quot;                android:layout_weight=&quot;1&quot;                android:src=&quot;@drawable/down&quot; /&gt;            &lt;ImageView                android:id=&quot;@+id/img5&quot;                android:layout_width=&quot;100dp&quot;                android:layout_height=&quot;100dp&quot;                android:layout_weight=&quot;1&quot;                android:src=&quot;@drawable/down&quot; /&gt;        &lt;/TableRow&gt;        &lt;TableRow            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:layout_weight=&quot;1&quot;&gt;            &lt;ImageView                android:id=&quot;@+id/img6&quot;                android:layout_width=&quot;100dp&quot;                android:layout_height=&quot;100dp&quot;                android:layout_weight=&quot;1&quot;                android:src=&quot;@drawable/down&quot; /&gt;            &lt;ImageView                android:id=&quot;@+id/img7&quot;                android:layout_width=&quot;100dp&quot;                android:layout_height=&quot;100dp&quot;                android:layout_weight=&quot;1&quot;                android:src=&quot;@drawable/down&quot; /&gt;            &lt;ImageView                android:id=&quot;@+id/img8&quot;                android:layout_width=&quot;100dp&quot;                android:layout_height=&quot;100dp&quot;                android:layout_weight=&quot;1&quot;                android:src=&quot;@drawable/down&quot; /&gt;        &lt;/TableRow&gt;    &lt;/TableLayout&gt;    &lt;androidx.constraintlayout.widget.Guideline        android:id=&quot;@+id/guideline2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;horizontal&quot;        app:layout_constraintGuide_percent=&quot;0.41&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;테마 없애기&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;1.ImageView 선언 및 초기화    ImageView moreArr = new ImageView9;    TextView tvTime,tvCount;2.이미지 변경3.두더지의 상태값 바뀔 수 있게 적용"
124,"🤔Thread란?한 사람이 동시에 여러 작업을 할 수 있다=멀티 태스킹프로세스 vs 스레드프로세스: 독립전 단위, 연속적으로 실행되고 있는 컴퓨터 프로그램동시에 여러 작업&gt; 멀티 프로세스스레드: 하나의 프로그램 내에서 둘 이상의 작업을 동시에 진행하는 프로세스보다 작은 단위여러 개의 스레드가 생성되어 하나의 컴이 여러 작업하나의 프로세스에 여러 개의 스레드가 동시에 동작상수onCreate 안에 하나의 클래스 생성thread 상속num 받음runnable(인터페이스)run메소드 밖에 없음 &gt; 구현해서 new Thread 생성자 안에 그 아래 ? 담아줘야 실행 가능1.카운트 자동 ? 앱2.게임① 시간체크② 두더쥐 움직이기 위에 0 이 눌렀을때 1씩 카운트실습(사진)버튼을 누르면 카운트가 자동으로 세어지게1.객체 선언/초기화2.thread 상속 - run메소드 - 로직 정의3.thread 객체 생성4.handler 만들기 - handleMessage선언4.msg.arg1에 값 넣기 - sendMessage(msg)로 전달1.mainActibity.xml① 객체 생성, 초기화TextView tvNumber;Button btnStart;tvNumber = findViewById(R.id.tvNumber);btnStart = findViewById(R.id.btnStart);② extend Thread    class TimerThread extends Thread{ //스레드 상속        //run을 오버라이드        public  void  run(){            //실행할 로직 정의            //버튼 눌렀을 때 자동 카운트 기능            //            for(int i =0;i&lt;10;i++){                Log.d(&quot;TimerThread&quot;,&quot;카운트&quot;+(i+1));            }        }    }③         //3 Thread 객체 생성        TimerThread thread = new TimerThread();        //실행시키는 메소드 start        thread.start();④                //4. 1초                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }⑤                //5.id변수 넣어주면 여기 값이 들어가는 상태                tvNumber.setText(String.valueOf(i+1));mainThread에서만 ui작업 할 수 있다.subThread에서 ui업데이트를 하려면 Handler를 이용🤔Handler란?subThread에서 작업을 하고 화면을 업데이트 시키고싶은데 그 일은 main만 가능이걸 할 수 있게 하려면? main에 처리한 결과값을 넘겨줘 반영시켜야한다!app실행&gt;mainT자동실행, main에는 messageQueue는 메세지라는 내용을 받았을 때, 실행시켜주는 것sub에서 message&gt; handler&gt; main의 queue 안 | &gt; handler &gt; subT0.Handler 만들기        //8.핸들러 설정?        TimerHandler handler = new TimerHandler();                //7.Handler의 값을 전달해줘야한다 -&gt; Message객체를 전달                Message msg = new Message();                msg.arg1 = i+1;                //message객체 전송                handler.sendMessage(msg);                //값을 어떤 변수에 담아줬는냐 기억!    //핸들러 만들기    class TimerHandler extends Handler{        @Override        public void handleMessage(@NonNull Message msg) {            //틀 만들기 끝!            //sub Thread에서 처리한 결과를  UI에서 업데이트 할 때            //HandlerMessage()안에 정의하면 된다.            int count = msg.arg1;            tvNumber.setText(String.valueOf(count)); //정수니까 바로 넣으면 x &gt; String.valueof()        }    }추가 실습버튼 클릭시, 숫자 올라가게?0.레이아웃1. thread2,Handler2 만들기① onclick 메서드//스레드 객체 실행TimerHandler handler2 = new TimerHandler();//버튼 비활성화btnStart.setEnabled(false);2. 기능"
125,문제⏰알람시계(2884번)import java.util.Scanner;public class Main {    public static void main(String args) {        Scanner sc = new Scanner(System.in);        int H=sc.nextInt();        int M=sc.nextInt();        if(M&lt;45) {            //m-45             H--;            M=M+15;            if(H&lt;0) {                H=23;        }}else{            M=M-45;                    }        System.out.println(H+&quot; &quot;+M);        }}🍞오븐 시계(2525번)참고import java.text.SimpleDateFormat;import java.util.Date;//여기서부터 복붙 ㄱpublic class Main {    public static void main(String args) {        Date ctime = new Date();        System.out.println(ctime);        SimpleDateFormat date = new SimpleDateFormat(&quot;yyyy-mm-dd&quot;);        SimpleDateFormat time = new SimpleDateFormat(&quot;hh:mm:ss&quot;);        System.out.println(&quot;날짜 : &quot; + date.format(ctime));        System.out.println(&quot;시간 : &quot; + time.format(ctime));        }}
126,안드?
127,"복습Firebase메세지 라는 이름으로 data를 저장했다noSQLmessage가 컬랙션(관계형 db는 테이블)collection안에 document 형태로 존재그 안에 key:value (String,number,boolean,object,Array)mainActivitygetinstance()는 받아올 수 있다valueEventListener:참조하고있는경로에 대해 데이터의 변화가 생기면감지를 해 데이터를 읽어올 수 있는 이벤트addChildEventListener로 접근 해야한다message경로 안 데이터에 접근이냐그 안에 또 다른 데이터에 접근이냐에 따라 이벤트 메소드가 다르다!value vs child        myRef.addChildEventListener(new ChildEventListener() {            @Override            public void onChildAdded(@NonNull DataSnapshot snapshot, @Nullable String previousChildName) {                PersonVO value = snapshot.getValue(PersonVO.class);                Log.d(TAG,&quot;Value is &quot;+value);            }chatAdapter① 객체 선언    Context context;    int layout;    ArrayList&lt;ChatVO&gt; list;    LayoutInflater inflater; //xml-&gt;view로 변환★② 생성자 만들기    public ChatAdapter(Context context, int layout, ArrayList&lt;ChatVO&gt; list) {        this.context = context;        this.layout = layout;        this.list = list;        //inflater 초기화 이걸 초기화해줘야 xml &gt; view로 변환 가능★        this.inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);    }③    @Override    //list.size를 넣어야 데이터를 갯수만큼 생성해서 보여주기 가능    public int getCount() {        return list.size();    }    @Override    //데이터를 담아주니까    public Object getItem(int i) {        return list.get(i);    }    @Override    public long getItemId(int i) {        return i;    }④ findview아이디를 접근 할 수 있는 용도위 레이아웃에서 접근하는데..어댑터에서 접근하려면 레이아웃에서 접근해야함    @Override    public View getView(int position, View view, ViewGroup viewGroup) {        //i가 하는 역할은 인덱스 위치!        //view는 아이템 레이아웃을 모두 가진 부모 레이아웃(리스트뷰)        //로직 구현 시작!        //1.뷰 초기화        if(view == null){            //view는 chat_item.xml의 정보를 가진 객체            view = inflater.inflate(layout,viewGroup,false);        }        ImageView imgOther = view.findViewById(R.id.imgOther);        TextView tvOtherNm = view.findViewById(R.id.tvOtherNm);        TextView tvOtherMsg = view.findViewById(R.id.tvOtherMsg);        TextView tvOtherTime = view.findViewById(R.id.tvOtherTime);        TextView tvMyMsg = view.findViewById(R.id.tvMyMsg);        TextView tvMyTime = view.findViewById(R.id.tvMyTime);        return view;    }⑤Chatvo 구현        ChatVO vo = list.get(position);        imgOther.setImageResource(vo.getImgId());        tvOtherNm.setText(vo.getName());        tvOtherMsg.setText(vo.getMsg());        tvMyTime.setText(vo.getTime());        tvMyMsg.setText(vo.getMsg());        tvMyTime.setText(vo.getTime());ChatActivity①    ListView ChatList;    ChatAdapter adapter;    ArrayList&lt;ChatVO&gt; list;    EditText edtMsg;    Button btnSend;②        ChatList = findViewById(R.id.ChatList);        edtMsg = findViewById(R.id.edtMsg);        btnSend = findViewById(R.id.btnSend);        list = new ArrayList&lt;&gt;();③ FirebaseDatabase database = FirebaseDatabase.getInstance();        DatabaseReference myRef  = database.getReference(&quot;talk&quot;);④ 3전    String currentId = getIntent().getStringExtra(&quot;login_id&quot;);        Log.d(&quot;CharActivity&quot;,&quot;현재 로그인한 아이디 : &quot;+currentId);⑤ db 저장        //1.버튼 클릭 시 입력된 메세지를 파이어베이스 데이터베이스에 저장        btnSend.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                String msg = edtMsg.getText().toString();                //저장시 채워넣는 push                myRef.push().setValue(new ChatVO(R.drawable.ic_launcher_background,                        currentId,                        msg,                        &quot;10:25&quot;));            }        });⑥ list객체에 저장⑦⑧"
128,안드로이드already_running해당 경로로 들어가 .lock이 붙은 폴더를 삭제하면 된다!
129,문제 풀이🐈출력 (10171번)코드public class Main {  public static void main(String args) {      System.out.println(&quot;\\    /\\&quot;);      System.out.println(&quot; )  ( ')&quot;);      System.out.println(&quot;(  /  )&quot;);      System.out.println(&quot; \\(__)|&quot;);  }    }\은 두번 써야 출력된다.⌨A/B (1008번)import java.util.Scanner;public class Main {    public static void main(String args) {        Scanner sc = new Scanner(System.in);        double A=0;        double B=0;        A=sc.nextDouble();        B=sc.nextDouble();        System.out.println(A/B);    }}nextDouble()에 유의!🖨문자형 입력(10926번)import java.util.Scanner;public class Main {    public static void main(String args) {        Scanner sc = new Scanner(System.in);        String name =&quot;&quot;;                 name=sc.next();         System.out.println(name+&quot;??!&quot;);    }}문자형 입력은 sc.next()✖곱셈 (2588번)1. 문자로 입력받기import java.util.Scanner;public class Main {    public static void main(String args) {        Scanner sc = new Scanner(System.in);        int A= sc.nextInt();        String B =sc.next();        systemt.out.println( A*(B.charAt(2)-'0') );        systemt.out.println( A*(B.charAt(1)-'0') );        systemt.out.println( A*(B.charAt(2)-'0') );        systemt.out.println( A*Integer.parseInt(B));    }}charAt()로 각 자리수를 참조!문자열의 인덱스 위치에 있는 문자 값을 반환그냥(0)이면 아스키 값이 저장되니까문자열 인덱스를 참조한 뒤 -'0' 을 해준다!Integer.parseInt()입력받은 문자열을 숫자로 바꿔준다2. 숫자로 계산하기import java.util.Scanner;public class Main {    public static void main(String args) {        Scanner sc = new Scanner(System.in);        int A=0;        int B=0;        A=sc.nextInt();        B=sc.nextInt();        System.out.println(A*(B%10));        System.out.println(A*((B%100)/10));        System.out.println(A*((B%1000)/100));        System.out.println(A*B);    }}일의 자리 : a%10십의 자리 : a%100/10백의 자리 : a%1000/100천의 자리 : a%10000/1000
130,"Volley 실습로그인/회원가입0. eclipse이클립스에 AndroidServer 생성1. pom.xml&lt;properties&gt;        &lt;java-version&gt;1.6&lt;/java-version&gt;        &lt;org.springframework-version&gt;5.1.5.RELEASE&lt;/org.springframework-version&gt;&lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;2.5.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;3.Maven Updatemaven project update4.cmdIPv4주소를 복사해http://(IPv4 주소)/android/ 에 넣으면 정상 출력5.액티비티 구성① 화면 구성② id설정6. 로그인 &gt; 회원가입 연결Manifest      &lt;application  android:usesCleartextTraffic=&quot;true&quot;gradleloginActivity          ``` //클릭 이벤트 joinBtn.setOnClickListener(new View.OnClickListener() {     @Override     public void onClick(View view) {         //화면 이동         Intent intent = new Intent(LoginActivity.this,JoinActivity.class);         startActivity(intent);     } });"
131,영화 오피스
132,"문제)List 항목 DataList 항목 layoutMyAdapter0.레이아웃 배치 및 설정scaleType &gt; center 상태에서 조절하면 이미지가 잘린다scaleType &gt; firCenter 상태에서 조절하면 가능!②③ 레이아웃의 크기 조절 wrap_content로 줄여줘야 list의 여러 항목이 한 화면에 나온다1.ContactVO레이아웃에 보여질 데이터셋이 필요 데이터셋은 하나의 데이터가 아닌 여러 개의 값이 들어가있음  이미지,텍스트 다 아우르는 타입은 없기 때문에 하나를 만들어줘야함 데이터를 저장할 클래스 &gt; contactVo를 만든다!2.ContactActivity listView 배치3. ContactAdapterpublic class ContactAdapter extends BaseAdapter {    //1.생성자 선언    Context context;    int layout;    //여러 개의 데이터를 받으니까 어레이    //정의한 연락처정보들을 담은 vo니까 contactVO    ArrayList&lt;ContactVO&gt; list;    //xml파일 -&gt;view 객체로 변환해주는 객체     LayoutInflater inflater;    //생성자    public ContactAdapter(Context context, int layout, ArrayList&lt;ContactVO&gt; list) {        this.context = context;        this.layout = layout;        this.list = list;        //인플레이터 객체는 초기화까지 같이 넣어서 진행        this.inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);    }    @Override    public int getCount() {        //데이터의 갯수 리턴        return list.size();    }    @Override    public Object getItem(int i) {        //i는 인덱스 역할        return list.get(i);    }    @Override    public long getItemId(int i) {        return i;    }    @Override    public View getView(int i, View view, ViewGroup viewGroup) {        //매개변수는 3개         //i는 인덱스 역할 view는 아이템 레이아웃에 대한 정보를 보관        //그룹은 리스트 어댑터        return null;    }}}extends BaseAdapter alt+enter후, 추상메소드 구현"
133,"🤔 ListView 란?리스트 형태로 된 어댑터 뷰 중 하나 상하로 스크롤 가능📌 ListView 실습1.화면 구성&lt;아이디사진&gt;① legecy &gt; ListView 배치 ② 가이드라인-horizontal (90%)③ plainText 배치④ button 배치⑤ id 설정2.?mainActivity.java① 객체 설정ListView lv;ArrayAdapter adapter;ArrayList&lt;String&gt; list;Button btnRegister;EditText edtData;② 초기화lv = findViewById(R.id.lv);list = new ArrayList&lt;String&gt;();edtData = findViewById(R.id.edtData);btnRegister = findViewById(R.id.btnRegister);③ 리스트 추가list.add(&quot;떡복이&quot;);list.add(&quot;해물탕&quot;);list.add(&quot;간장찜닭&quot;);list.add(&quot;김치찜&quot;);list.add(&quot;닭볶음탕&quot;);list.add(&quot;부대찌개&quot;);list.add(&quot;계란후라이&quot;);list.add(&quot;버팔로윙&quot;);list.add(&quot;딸기생크림케이크&quot;);list.add(&quot;김치리조또&quot;);list.add(&quot;쫄병스넥&quot;);list.add(&quot;초밥&quot;);list.add(&quot;연어덮밥&quot;);list.add(&quot;콜라&quot;);list.add(&quot;사이다&quot;);list.add(&quot;환타&quot;);list.add(&quot;치즈스틱&quot;);list.add(&quot;치즈볼&quot;);④ 어댑터 객체 생성new ArrayAdapter(현재 액티비티명.this,레이아웃,데이터)adapter = new ArrayAdapter&lt;String&gt;(                MainActivity.this,                android.R.layout.simple_list_item_1,                list        );⑤ 어댑터를 리스트 뷰에 넣기lv.setAdapter(adapter);3.이벤트 적용  아이템 하나하나 개별적으로 적용되어야 하기 때문에  setOnItemClickListener        lv.setOnItemClickListener(new AdapterView.OnItemClickListener() {            @Override            public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) {                // 클릭이 일어난 AdapterView                //view: 클릭한 아이템뷰를 뷰객체로 반환                //i,l 클릭한 아이템뷰의 행 인덱스를 반환                String data = list.get(i);                Toast.makeText(MainActivity.this, &quot;선택한 항목:&quot;+data, Toast.LENGTH_SHORT).show();            }        });4.가이드라인,레이아웃이후 객체 생성,버튼 초기화까지 하세요5.데이터 추가 이벤트        btnRegister.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                //저장                String food = edtData.getText().toString();                //어딘가에는 저장을 해야하는데?                adapter.add(food);                //디폴트한 데이터를 어댑터 생성할때 넣어지는데                //이후 추가는 추가+갱신(update)한게 필요                //업데이트 한 내용을 갱신해주면서 리스트 뷰에 반환해주는 메소드지만                //지금은 안써도 추가된다네요!                //adapter.notifyDataSetChanged();                //list.add(food) 해도 동작이 되긴합니다.            }        });6.longClick 삭제 이벤트 추가        //4.롱클릭시 아이템 삭제하는 기능 구현        lv.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {            @Override            public boolean onItemLongClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) {                Toast.makeText(MainActivity.this, &quot;롱클릭!&quot;, Toast.LENGTH_SHORT).show();                //어떤 뷰를 선택했느냐에 따라서 지워져야하기 때문에                //우선 리스트로부터 데이터 꺼내와서 삭제할 데이터를 담아주면 삭제 진행된다!                String  food = list.get(i);               adapter.remove(food);                return false;            }        });"
134,실습📌전송 내역이 logcat에 출력📌카메라 캡쳐를 통해 캡쳐 화면 띄우기
135,"Intent 란?하나의 액티비티가 다른 액티비티를 실행시킬 수 있는 메세지 시스템종류표Permission(승인)앱이 특정 기능을 사용하는 경우 권한 승인 -intent를 이용하면 app호출시 권한 승인 필요 x  (단, 민감한 권한은 x)▼ manifest&lt;!-- 전화걸기 권한설정 --&gt;&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot; /&gt;▼ public void onClick(View view) {    Intent intent = new Intent(Intent.ACTION_CALL, Uri.parse(&quot;tel:01089085028&quot;));    //녹음, 전화걸기, 주소록접근, 위치정보접근 등 사용자의 민감한 기능이나 데이터를    //사용해야 하는 경우는 아래와 같이 권한을 체크하고 요청하는 로직을 정의해줘야함    //액티비티에서 실행하는 경우 -&gt; 권한체크    if(ActivityCompat.checkSelfPermission(getApplicationContext(), Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED){    //권한요청    ActivityCompat.requestPermissions(            MainActivity2.this,            new String{Manifest.permission.CALL_PHONE},            0);    return;}startActivity(intent);}실습📌 Intent 실습Intent 를 이용해 버튼마다 기능을 만들자!①②③④📌 Intent 실습2버튼을 누르면 화면이 이동하게 만들자!mainActivitypackage org.techtown.practice1;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;public class MainActivity extends AppCompatActivity {EditText gotext;Button firstbtn;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    gotext = findViewById(R.id.gotext);    firstbtn = findViewById(R.id.firstbtn);    firstbtn.setOnClickListener(new View.OnClickListener() {        @Override        public void onClick(View view) {            String data = gotext.getText().toString();            //intent(현재 액티비티명.this,화면전환액비티미명.class)            Intent intent = new Intent(MainActivity.this,MainActivity2.class);            //intent객체에 전달할 데이터 저장            intent.putExtra(&quot;data&quot;,data);            //intent객체를 실행시키는 메소드            startActivity(intent);        }    });}}**&lt;풀이&gt;**① 버튼을 클릭하면 textview에서 내용 받아와 data에 넣는다  id.getText().toString()② intent 약간 이동 경로지정 느낌인가?③ intent 객체에 전달할 데이터 넣어두기? putExtra(&quot;이름&quot;,데이터값)④startActivity(intent) //실행- mainActivity2package org.techtown.practice1;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import org.w3c.dom.Text;public class MainActivity2 extends AppCompatActivity {TextView gettext;Button secondbtn;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main2);    gettext= findViewById(R.id.gettext);    secondbtn = findViewById(R.id.secondbtn);    //객체 받아오기?    Intent intent = getIntent();    gettext.setText(intent.getStringExtra(&quot;data&quot;));    secondbtn.setOnClickListener(new View.OnClickListener() {        @Override        public void onClick(View view) {            Intent intent  = new Intent(MainActivity2.this,MainActivity.class);            startActivity(intent);        }    });}}※버튼을 누르기 전, 값을 받아와야 한다Intent intent = getIntent();        gettext.setText(intent.getStringExtra(&quot;data&quot;));① 받아오는 intent 객체 생성② 앞에 mainactivity에서 data에 값을 넣어뒀으니 받아와서 gettext에 setText()한다### 📌 Intent 실습3&gt; 로그인 성공하고 여부에따라 성공,실패 출력!(https://velog.velcdn.com/images/iamsh2580/post/29c99a63-b67b-4d9a-9f54-7a764abf30e8/image.png)1-1) kakaologin창 만들고 EditView안에 이메일,비번 입력받기 ( 값 저장)1-2) 로그인 버튼 클릭시 값 전달  2) 전달 받은 값 성공시, 로그인 성공페이지 아니면 실패 페이지? &gt;이메일 + 로그인 성공!- kakaologinpackage org.techtown.practice1;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;public class kakaologin extends AppCompatActivity {EditText edtemail,edtpw;Button loginbtn;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_kakaologin);    edtemail = findViewById(R.id.edtemail);    edtpw = findViewById(R.id.edtpw);    loginbtn = findViewById(R.id.loginbtn);    loginbtn.setOnClickListener(new View.OnClickListener() {        @Override        public void onClick(View view) {            String email = edtemail.getText().toString();            String pw = edtpw.getText().toString();            Intent intent = new Intent(kakaologin.this,kakaologinresult.class);            intent.putExtra(&quot;email&quot;,email);            intent.putExtra(&quot;pw&quot;,pw);            startActivity(intent);        }    });}}-----------------------------------**&lt;풀이&gt;**① email,pw의 변수를 만들어  editview 안에 작성된 내용이 gettext되게 한다    ※문자열로 바꾼다(toString)String email = edtemail.getText().toString();String pw = edtpw.getText().toString();② Intent 객체를 생성하고 어디서 어디로 이동할지 알려준다 &gt; 명시적 intentIntent intent = new Intent(kakaologin.this,kakaologinresult.class);③  intent 객체에 emailpw라는 이름으로 각각  putExtra 시켜준다 ( 저장개념?)intent.putExtra(&quot;email&quot;,email);intent.putExtra(&quot;pw&quot;,pw);④ intent 시작startActivity(intent);- kakaologinresultpackage org.techtown.practice1;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.widget.TextView;public class kakaologinresult extends AppCompatActivity { TextView resulttext;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_kakaologinresult);    resulttext = findViewById(R.id.resulttext);    Intent intent = getIntent();    String email =  intent.getStringExtra(&quot;email&quot;);    String pw = intent.getStringExtra(&quot;pw&quot;);    if(email.equals(&quot;smhrd&quot;) &amp;&amp; pw.equals(&quot;1234&quot;)){        resulttext.setText(&quot;로그인 성공&quot;);    }else{        resulttext.setText(&quot;로그인 실패&quot;);    }}}--------------------------------**&lt;풀이&gt;**① intent 객체 받아오기Intent intent = getIntent();② 받아온걸 email,pw라는 문자열변수에 저장 String email =  intent.getStringExtra(&quot;email&quot;);String pw = intent.getStringExtra(&quot;pw&quot;);③ 로그인 결과 if,else문if(email.equals(&quot;smhrd&quot;) &amp;&amp; pw.equals(&quot;1234&quot;)){    resulttext.setText(&quot;로그인 성공&quot;);}else{    resulttext.setText(&quot;로그인 실패&quot;);}"
136,Layout📖Layout이란?어쩌꾸📱실습📌 Lenear Layout계산기를 만들자! ①②③④📌 Relative Layout그림을 옆으로 넘기자!  ①②③④📌 Constraint Layout주사위 대결을 만들어보자!①②③④📌 Constraint Layout 2카카오 페이지를 만들어보자!①②③④📌 Constraint Layout 2-1카카오 페이지를 가로로 만들어보자!①②③④📌 Constraint Layout 3카카로 로그인 페이지를 만들어보자!
137,"현재 릴리즈는 v16.15.0이지만 나는 14버전이 필요했다..ㅠㅠ원래는 brew로 특정버전 설치했었는데, nodejs 홈페이지를 통해 설치하는게 훨씬 빠르다1. 사용할 버전 검색하기https://nodejs.org/ko/download/releases/2. 파일다운로드 하기Mac 유저는 .pkg 파일을 다운받으면 됩니다."
138,"JSTLJSP에서 자주,공통적으로 사용되는 자바 코드를 쉽고 , 표기법으로 간단히 할 수 있도록 태그화 하여 표준으로 제공하는 것(  if , for , Scope 변수 선언 , 데이터파싱(데이터 변환)  )기본적으로 JSTL Library를 등록해야 한다.해당 JSP의 최상단에 &lt; % @  % &gt; 지시어를 이용해 선언해야한다.&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;prefix : 접두사 , 다른 태그와 구별하기 위해 사용한다(태그 앞에 붙은 태그명.) uri(Uniform Resource Locator) : 네트워크 상에서 자원을 구별하는 식별자 ( 자원을 구분하는 유일한 주소)url(Uniform Resource Identifier) : 인터넷에서 특정 자원 위치를 지정(주소)구별을 잘해야 한다 URI와 URL은 다른거다.1. 변수 선언(C:Set)(C 는 prefix로 지정한 별칭)변수를 선언하고 값을 초기화 하는 태그(초기화는 무조건 수행)c:set 태그로 선언된 변수는 EL을 이용해 출력 할 수 있다.   c:set은 내장객체에 속성을 추가하는 태그C : SET 태그var : 변수명value : 대입되는 ㄱ밧 scope : 변수의 범위 ( Page(기본값) , request , session , application )이때 선언 하면서 '/'닫아줘야 한다.&lt;c:set var=&quot;num&quot; value=&quot;100&quot;/&gt;&lt;c:set var=&quot;num&quot; value=&quot;200&quot; scope=&quot;request&quot; /&gt;2. 변수 삭제(C:remove)이미    지정한 변수 (c:set / setAttribue() 으로 추가된 변수들) 삭제생성된 변수명여 여러개면 scope로 이용해 특저 변수만 선택할 수 있다. scope 범위를 미지정하게 되면 변수명인 동일하면 범위 상관 없이 삭제C : removevar : 삭제하고 싶은 변수 이름scope : 삭제하고 싶은 범위 ( 기본값 : 모든 범위)3. 변수 삭제(C:if)조건문을 사용할 수 있는 태그if문만 가능하고 else if ,else등은 불가능(else는 존재하지 않음)c:if 의 속성test: 조건을 작성하는 속성 단, %{EL}로만 작성할 수 있다&lt;c:set var=&quot;temp&quot; value=&quot;30&quot;/&gt;  &lt;c:if test=&quot;${temp&gt;20 }&quot;&gt;      &lt;!-- test에 작성된 조건이 참일때만 화면에 출력  --&gt;      temp는 20보다 크다&lt;/c:if&gt;&lt;!-- else구문이 없어 반대되는 조건을 별도로 작성해야 한다. --&gt;&lt;c:if test=&quot;${temp&lt;=20}&quot;&gt;   temp는 20보다 작거나 같다.&lt;/c:if&gt;4. 조건문 ifelse ifelse( c:choose , c:when , c:otherwise)if의 else의 상황을 대처하기 위해 사용 가능하다choose 라는 하나의 케이스 안에서 검사하는 형태    &lt;c:set var=&quot;temp2&quot; value=&quot;9&quot;/&gt;    &lt;c:choose&gt;        &lt;c:when test=&quot;${temp2&gt;10}&quot;&gt;            temp2가 10보다 큼        &lt;/c:when&gt;        &lt;c:when test=&quot;${temp2&lt;10}&quot;&gt;            temp2가 10보다 작다        &lt;/c:when&gt;        &lt;c:otherwise &gt;            temp2는 10이다        &lt;/c:otherwise&gt;    &lt;/c:choose&gt;5. 반복문 for / for(향상된)( C : forEach )자바의 반복문처럼 활용한다 (+ 추가기능 몇개)속성var : 현재 반복 횟수에 해당하는 변수 (==int i 같은 느낌)begin : 반복 시작 값end : 반복 종료 값step : 반복할때마다 증가할 값(증감식) , 미작성 시 기본값 1varStatus : 현재 반복에 해당되는 상태 정보제공되는 값 1) current : 현재 반복 횟수 또는 현재 접근 중인 객체 2) index : 현재 객체가 몇 번째 인덱스인지 반환 (0부터 시작) 3) count : 현재 반복문이 몇바퀴 반복 중인지 반환 (1부터 시작) 4) first : 첫 번째 반복일 경우 true 반환 5) last  : 마지막 반복일 경우 true 반환for문&lt;table border=&quot;1&quot;&gt;        &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;1&quot;&gt;         &lt;tr&gt;            &lt;th&gt;${i}&lt;/th&gt;            &lt;td&gt;${i}번재 게시글입니다.&lt;/td&gt;        &lt;/tr&gt;        &lt;/c:forEach&gt;&lt;/table&gt;    향상된 for    &lt;h2&gt;향상된 for문 사용&lt;/h2&gt;    &lt;ul&gt;    &lt;c:forEach var=&quot;str&quot; items=&quot;${paramValues.lang }&quot; varStatus=&quot;vs&quot;&gt;        &lt;li&gt;            &lt;c:if test=&quot;${vs.first}&quot;&gt;                &lt;!-- 첫번째 반복인 경우 --&gt;                &lt;span style =&quot;color:red&quot;&gt; 첫번째 &lt;/span&gt;                        &lt;/c:if&gt;            &lt;c:if test=&quot;${vs.last}&quot;&gt;                &lt;!-- 마지막 반복인 경우 --&gt;                &lt;span style =&quot;color:blue&quot;&gt; 마지막 &lt;/span&gt;                        &lt;/c:if&gt;        &lt;/li&gt;    &lt;/c:forEach&gt;&lt;/ul&gt;EL로 Parameter 얻어오는 방법.${param.name속성}단일 파라미터를 얻어오는 경우여러개의 피라미터가 있는 경우 0번째 값만 얻어온다${paramValue.name속성값} ${paramValues.lang0} &lt;br&gt; ${paramValues.lang1} &lt;br&gt; ${paramValues.lang2} &lt;br&gt;"
139,"상대경로 / 절대경로&lt;a href=&quot;/JSPProject/test/test1.html&quot;&gt;test1&lt;/a&gt; : 절대경로&lt;a href=&quot;test/test1.html&quot;&gt;test1-상대경로&lt;/a&gt;    : 상대경로절대 경로 : 프로젝트를 기준으로 목표할 파일까지의 순서를 나열.상대 경로 : 상대적으로다가 현재 위치를 기준으로 목표하는 파일까지의 순서를 나열.EL (Express Language)표현 언어&lt;% %&gt; / &lt;%= %&gt;  같이 뻘짓 안하고 편하게 출력 가능하다.EL의 특징1 ) Get을 사용하지 않는다단순 출력하는대 뭐가 더 필요하냐에서 시작.2 ) EL은 Null을 빈칸으로 출력한다.null과 관련된 모든 것을 허용하지 않는다.Request에서 Parameter 추출${ param . name_속성값 }Request에서 Attribute 추출${ 속성Key }${ 속성Key.필드명 }(getter가 작성되어 있어야지만 사용 가능.)null 처리 방법EL에서 null을 출력해야 하는 경우 &quot;&quot;(빈문자열)을 출력한다.NullPointerException이 발생하는 코드에서도 &quot;&quot;(빈 문자열)을 출력한다.EL이 null인 경우를 확인할 때 empty를 통해서 확인할 수 있다.Post 요청을 제외하면 모드 Get 요청이다 (a태그 )  Servlet / JSP 내장 객체와 범위Page현재 페이지(Servlet,Jsp)에서만 사용가능request현재 페이지와 , 요청을 위임한 JSP에서까지만 사용 가능session현재 켜져있는 브라우저가 종료되기 전까지는 어디서든 사용 가능하다(로그인)application배포한 웹 애플리케이션이 종료되기전 까지 언제 어디서든 사용 가능하다 (서버가 꺼질 때 삭제)Page scope는 선언한 Servlet/JSP 내에서만 사용 가능하다 (1페이지)Request scope는 선언한 페이지(1번째 페이지)와 , 해당 객체를 위임받은 페이지(2번째 페이지)에서 사용 가능 하다Request Scope사용 방식req.setAttribute(&quot;message&quot;, &quot;Request scope에 저장된 메세지&quot;);Session scope 사용 방식// 1) HttpSession 내장 객체 얻어오기HttpSession session = req.getSession();// 2) session 범위로 값 세팅(request와 방법이 동일)session.setAttribute(&quot;sessionValue&quot;, &quot;999&quot;);application scope// 1)ServletContext  application 내장 객체 얻어오기ServletContext application = req.getServletContext();// 2)application 범위로 값 세팅(Request와 방법 동일)application.setAttribute(&quot;appValue&quot;,&quot;Application Scope 범위&quot; );Session / application둘 모두 Request 객체에서 얻어와야 한다 각각*Session : HttpSessionapplication : ServletContext *선언된 내장 객체의 우선 순위커버리지 범위가 작을 수록 강하다고 보면 된다Page &gt; Request &gt; Session &gt; application"
140,"복습Servlet : 웹 서비스(요청 , 응답)을 위한 자바 클래스.HttpServlet을 상속 받아야 한다Javax.servlet.http.HttpServlet  == 서블릿 컨테이너(Servlet Container)WebServlet (&quot;요청 주소&quot;) : 서브릿클래스임을 등록하면서  요청주소도 같이 매핑한다.주소 등록 방식 프로토콜 이름 :// 클라이언트 아이피 /프로젝트 이름/ ~http://     localhost:10005/JSPProject/  ~Servlet으로 응합 화면 만들기가 어려워 응답화면만 만드는 부분을 분리하자 === JSP의 탄생 눈에 보이는 코드는 HTML으로 보이지만 해석은 JAVAServlet -&gt; Request Dispatcher(요청 발송자) -&gt; forward(전송(req,resp)) -&gt; JSP  jsp로 추가적인 변수를 추가하고 싶을때는 setAttribute 을 이용해 추가한다.//Http Servlet Request 객체에 message 변수를 추가 req.setAttribute(&quot;msg&quot;, message);&lt;%    %&gt; : 스크립틀릿 , 자바코드영역&lt;%=   %&gt; : 표현식&lt;%@  %&gt; : @ =지시자 include( 포함하다 )화면을 만들어 낼 때 footer 혹은 header를 항상 포함하고 중간 body만 만들어내는 듯하게 만들 수 있다.manuBar만들때도 사용 가능할 듯.taglibif문을 스크립트릿으로 사용하기 너무 어려우니깐 그냥 &lt; if&gt;라는 태그로 활용하도록 도와주는 JSP  확장 기능.POST 방식잠깐 설명 못한 Post 쪽으로 넘어왔다. 봉투에 담아 편지를 보내듯이 보내는 방식 여기서 편지봉투를 HTTPBody라는 이름으로 불린다  한글이 다 깨진다 ...데이터 전달 방식 차이점GET : 주소(URI)를 통해서 데이터를 전달          이 때, 문자 인코딩은 제출된 HTML 파일의 문자 인코딩(charset)을 따른다         &lt;br&gt;POST : HTTP Body를 통해서 데이터를 전달      이 때, 문자 인코딩은 서버의 기본 문자 인코딩을 따른다     tomcat(현재 내가 사용중인 서버) -&gt; ISO-8859-1이 기본 문자 인코딩     &lt;Br&gt;&lt;Br&gt;ISO-8859-1 : 모든 문자를 1byteUTF-8 : 영,수,특=1byte , 한글,외국어=3byte     &lt;Br&gt;&lt;Br&gt;해결방법Post 방식으로 전달받은 데이터의 문자 인코딩을 변경 해주면 된다req.setCharacterEncoding(&quot;UTF-8&quot;);문자 인코딩을 UTF-8로 설정상대 경료현재 위치를 기준으로 특정 위치를 기준으로 해서 경로를 표한집주소 : CU건너편 소나무 지나서 오른쪽 위치.절대 경로변하지 않는 절대적인 한 위치를 기준으로해서 경로를 표현집주소 : 대한민국 서울시 중구 남대문로 120-2 대일빌딩2층       &lt;br&gt;파일 경로 : C:\WorkSpace\IntellJ ( C드라이브 기준)       &lt;br&gt;웹 주소 : /JSPProject/signUp        JSPProject 기준String parameterInteger.parseInt = String 자료형을 int형으로 바꿔얻어옴```java//1) 요청 발송자String path=&quot;/WEB-INF/views/el/result.jsp&quot;;RequestDispatcher dispatcher                 = req.getRequestDispatcher(path);//2) 요청 위임할때 추가하고 싶은 값 세팅req.setAttribute(&quot;menu&quot;, menu);req.setAttribute(&quot;person&quot;, p);//3) 요청 위임.dispatcher.forward(req, resp);"
141,"서버가 실행될 때 배포되는 것은 'webapp' 폴더라 내부에 있는 코드는 서버를 끄지않다고 수정 가능하다.Servlet 클래스에 @WebServlet을 이용해 web.xml에 명시하지 않아도 사용할 수 있다.서블릿이라는 것을 명시하면서 (괄호)안에 요청 주소를 명시JSP (JAVA Server Page) : Java코드가 들어가 있는 HTML코드-Java의 웹 서버 프로그램 스펙(서블릿)으로 변환되어 서비스됨.Servlet : 요청에 따라 응답 페이지를 만들어 냄.응답 페이지를 일일이 만들기 힘들다HTML표기법으로 쓸수 있게 잠시 바꿈(JSP)but   : 다 작성시 JAVA로 변환되야 됨.JSP : HTMl 코드 속에서 JAVA 소스코드를 사용할 수 있다.JSP에서 Java로 변환 과정이 하나 더 추가된다고 생각하면 될거같다JSP &gt;변환&gt; .Java &gt;컴파일&gt; .ClssServlet/JSP 동작 순서웹 서버가 클라이언트한태 서블릿에 대한 요청을 받으면 서블릿 컨테이너에 그 요청을 넘김요청을 받은 컨테이너는 HTTPRequest , HTTPResponse객체를 만들어서 doGet/doPost메소드중 하나를 호출클라이언트의 요청을 응답할 때 원래 할때는 Servlet에서 out.writer이 아닌 Request를 이용해서 HTML 부분을  JSP로 분리한다.JSP으로 넘겨진 값을 가지고 응답 화면을 메이킹한 다음 컨테이너에게 Response 전달.전달받은 만들어진 동적 웹 페이지를 로직의 수행 결과와 Servlet 이 결합된 .class 파일이 만들어진다.장점서블릿보다 작성하기 빠르다디자인파트(HTML) 이랑 로직파트(JAVA)로 구성되어 있다 정보,디자인부분(HTML),로직(JAVA) 부분을 분리할 수 있다.직접 작성한 동적 화면보다 최적화된 서블릿으로 생성해줌으로 효율적으로 만들어진다웹 어플리케이션 상에서 변수의 사용 가능한 범위(scope)설정이 쉽다.다시 한번 이해해보기RequestDispatcher dispatcher =  req.getRequestDispatcher(&quot;/WEB-INF/views/loginResult.jsp&quot;);req.setAttribute(&quot;res&quot;, result);dispatcher.forward(req, resp);RequestDispatcher를 이용해 연결한다. 이때 연결객체 정보를 getRequestDispatcher(&quot;주소&quot;)에 명시한다이때 jsp파일의 주소위치는 webapp폴더를 기준으로 작성해야한다. req.setAttribute(Key , Value)를 이용해 jsp에 보낼 값을 setting 한다. (jsp에 값을 Request와 Response만 전달 하기 때문에 )forward : 전달한다 == Request , Response를 전달한다이 때 Req에는 원할 경우 값을 세팅해서 보낼 수 있다.#css 방식으로 색 입힐수 있는걸 방금 알아서 사용해봤는데 엄청 촐싹 맞아 보인다.JSP 파일에서 자바를 이용하고 싶을 경우&lt;% 자바코드 %&gt; : 스크립틀릿(Scriptlet)JSP안에서 자바코드를 수행하고 싶을 경우 위의 태그 내부에 작성한다.&lt;% piza=request.getParameter(&quot;pizza&quot;) %&gt;&lt;%= 자바코드 %&gt; : 표현식(Expressioin)JSP안에서 자바코드를 출력하고 싶을 때 위의 태그 내부에 작성한다. &lt;h1&gt;계산결과 : &lt;%= request.getParameter(&quot;pizza&quot;) %&gt;원&lt;/h1&gt;주석JSP는 HTML안에 자바코드가 있는 형식이라 HTML의 주석스타일을 사용할 수 있다 하지만 이 떄 주석 내부에서 자바코드영영(Scriptlet)을 작성하면 코드가 우선된다&lt; !--  -- &gt;  : HTML 주석 == 개발자 도구에 노출됨&lt;%-- --%&gt;    : JAVA코드 주석 ==개발자 도구에서 안보임"
142,"HttpServlet을 반드시 상속해야 한다.doGet(Request , Response) : 요청 , 응답javax : 자바 외부에서 만드는 외부 확장 코드Servlet 동작 방식DD ( 배포 서술자 , Deployment Descript ) :  web.xml    xml : 1순위 해석 타겟.인터넷에서 요청 /응답 할 수 있도록 프로젝트를 인터넷에 올리는 것.1 )  클라이언트가 URL을 클릭하면 HttpRequest을 Servlet Container으로 전송2 )요청을 전달 받은 Sevlet Container은  두 객체를 생성HttpServletRequest (클라이언트 + 요청 정보)HttpServletResponse(응답 관련 객체)3 ) DD(배포 서술자 , Deployment Descriptor) = web.xml은    사용자가 요청한 url을 분석 해 어떤 서블릿클래스에 요청내용을 전달할 지 탐색4 ) 탐색된 서블릿에서 init() 메소드를 우선 호출 후 service()메소드를 호출해 클라이언트으로 부터 전송받은 방식인 GET,POST 여부에 따라 해당메소드( doGet, doPost)를 호출한다.5) 호출받은 메서드(Get,Post)는 동적페이지를 생성 후 HttpServletResponse객체에 응답을 보낸다.6) 응답 종료시 요청관련 , 응답관련 객체들을 삭제한다.servlet Container (tomcat)자동으로 객체를 관리(생성,삭제)해주고 요청 응답을 제어해준다. 웹 서버와의 통신 지원(listen , accept등을 api로 제공한다)서블릿의 생명 주기 관리(Life Cycle)를 관리해 준다서블릿의 사용 목적이 달성되는 순간 GC를 호출해 지워버린다.멀티 쓰레드 지원 / 관리(쓰레드의 안정성데 대해 신경쓸 필요가 없다)선언적인 보안 관리 (보안관련 내용을 서블릿이나 클래스에 구현하지 않아도 된다.)생명주기클라이언트의 요청이 들어오면 컨테이너는 서블릿이 메모리에 있는지 확인하고 없는 경우 init()메소드를 호출해 적재한다1 init()은 처음 한번만 실행되기 때문에 서블릿의 쓰레드에서 공통적으로 사용해야 하는 것이 있다면 오버라이딩으로 구현2    실행중 서블릿이 변경될 경우 , 기존 서블릿을 파괴하고 새로운 내용을 다시 메모리에 적재한다.init() 메소드가 호출된 후 클라이언트 요청에 따라 service( ) 메소드를 통해 요청을 doGet , doPost를 맞쳐 진행한다.2.1 이 때 서클릿 컨테이너가 클라이언트의 요청이 오면 가장 먼저 Request와 Response를 생성한다.컨테이너가 서블릿에 종료 요청 시 destroy( ) 메서드를 호출하는데 itin( )과 동일하게 한번만 실행된다 1    종료시에 실행되야되는 작업이 있다면 destroy에 오버라이딩해 구현한다.Get( ) , Post( ) 비교/차이클라이언트가 서버로 요청을 보내는 방법 Get 방식 : 데이터를 가져오다/얻어오다url에 데이터를 포함시켜 요청 데이터를 HTTP Header에 포함에 전송.GET방식에서 body는 보통 빈상태로 전송된다전송하는 길이의 한계가 있다( 초과된 데이터는 절삭된다)캐싱이 가능(즐겨찾기 / 북마크) 한번 접근 후 다시 요청 할 시 빠르게 접근 가능Post방식 : (데이터를) 붙이다데이터를 서버로 제출하여 추가 혹은 수정하기 위해 데이터를 전송하는 방식RL에 데이터를 노출하지 않고 요청 데이터를 HTTP Body에 포함해 전송헤더 필드중 Body에 데이터를 설명하는 'Content-Type'이라는 헤더필드가 들어가고 어떤 데이터 타입인지 명시해 줘야 한다.전송하는 길이의 제한이 따로 없다but body에 데이터가 들어가기 떄문에 길이의 제한이 없지만 최대 요청을 받는 시간(Time Out)이 존재해 딜레이가 있다캐싱 불가능 (URL)에 데이터가 노출되지 않음으로 즐겨찾기나 캐싱 불가능Apache아파치 재단의 오픈소스 프로젝트정적 페이지를 응답하는 웹 서버.TomcatDynamic Web을 만들기 위한 웹 컨테이너 (서블릿 컨테이너)정적 페이지를 제외한 요청(Servlet , JSP)에 대한 수신, 응답을 처리하는 웹_응용_서버(WAS : Web Application Server)톰캣에 연결시 동적인 데이터의 처리가 가능함으로 DB연결이나 데이터 조작,다른응용프로그램과의 상호작용이 가능하다.Apache TomcatTomcat == servlet Container == WAS톰캣 처리 할 수 없은 '정적 페이지'처리를 위해 아파치의 일부 기능을 가져와 함께 제공하는 서버"
143,** 웹서비스를 위한 자바 클래스**자바를 이용해 웹을 만들기 위해 필요한 기술.웹 프로그래밍에서 요청 (Request)을 처리하고 그 결과를 응답(Response)하는 구현 규칙을 가진 자바 프로그래밍 기술사용자가 로그인 하려 할 때 아이디와 비밀번호를 입력 후 로그인 버튼을 누르면 서버는 아이디와 비밀번호를 확인하고 다음 페이지를 띄워주는 역할 수행  &lt;&lt; 서블릿은 자바로 구현된 CGI &gt;&gt;CGI(Common GateWay Interface)라이브러리나 도구를 의미하는 것이 아닌 그냥 별도로 제작된 웹서버 와  프로그램간의 교환 방식의 이름CGI방식은 프로그래밍 언어로도 구현 가능하고 별도로 제작한 프로그램에 HTML의 GET / POTS 방식으로 클라이언트 데이터를 환경 변수로 전달하고프로그램의 표준 출력 결과를 클라이언트에게 전송하는 것.Servlet 특징클라이언트의 요청에 따라 동적 으로 작용하는 웹 애플리케이션 컴포넌트클라이언트 요청에 대한 서버 응답 시 미리 만들어둔 화면( 정적)이 아닌 요청을 받을 때 마다 알맞은 화면을 만들어 (동적) 응답한다.HTML을 사용하여 요청에 응답한다Java Thread를 이용하여 동작 (각각의 요청마다 Thread가 생성됨MVC Model 패턴에서 Controller으로 사용Http protocol를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속 받는다단점servlet에 HTML 코드 변경 시 재 컴파일 해야 하는 단점이 있다서블릿 상속 관계Servlet 코드를 작성할 클래스는 반드시 HttpServlet 상속받아 구현해야한다. 상속 관계도오늘 작성한 클래스프로그램의 흐름도1    웹에서 특정한 정보를 가지고 서버로 전송2     서버에서는 전송받은 정보를 가지고 매핑 되어 있는 서블릿을 찾아간다3   서블릿으로 등록된 클래스에서는 전달받은 Request에서 필요한 정보를 뽑아 원하는 형태로 가공한다.연결을 원하는 클래스는 무조건  HttpServlet을 상속 받아야 한다!!!HttpServletRequest : 클라이언트 정보+ 요청 정보HttpServletResponse : &quot;서버&quot;가 클라이언트에게 응답하는 방법을 제공요청 정보는 Parameter로 전달 받아야 한다.req.getParmeter (&quot;전달받을 값의 name&quot;) ;**이 때 전달받는 값이 여러개인 경우에는    ( req.ParameterValues )를 이용해 배열 형태로 받아야 한다.여담form 태그 내부의 값은 지정된 서버로 페이지 제출(전달)하는 역할이다action : input 태그의 값을 전달할 서버 혹은 페이지의 주소를 적는 속성method : 데이터의 전달 방식을 지정하는 속성(Get / Post)General &gt; WorkSpace &gt; Refresh using native hooks or pollingvs에서 수정한 사항을 '실시간' 적용하는 것.src.main.webapp.WEB.INF에는 자바 클래스 파일을 제외한 모든 파일들이 들어간다.이때 index.html은 서버의 접속한 유저에게 Welcome Page를 제공한다.서버로 제출된 모든 input 태그 값들은 String 자료형이다input type = &quot; password &quot;는 화면에서만 안보이고 서버로는 값이 정상적으로 넘어간다
144,"웹페이지 모양을 만들기 위해 구조를 잡는다 hearder로고 삽입검색 상자 생성 및 삽입로그인 블럭 생성.로고 삽입&lt;div&gt;  &lt;a href=&quot;#&quot; &gt;    &lt;img src=&quot;../images/logo.jpg&quot; alt=&quot;logo&quot; id=&quot;home-logo&quot;&gt;  &lt;/a&gt;&lt;/div&gt;  .header&gt;div:nth-child(1){      display: flex;      justify-content: center;      align-items: center;  }  /* 로고(logo) */  #home-logo{      width: 120px;  }대구분인 header의 div의 첫번째 자식에 중앙 정렬을 위해 display:flex 속성과 justify 와 align를 사용하였다.그 후 로고 이미지에 가로폭을 120px으로 고정한다이때 이미지는 이미 자체적인 사이즈를 가지고 있으니 한쪽만 정렬해도자동적으로 모두 정렬 된다.검색창 삽입검색창 삽입을 위한 코드  &lt;!-- 아이콘 추가를 위한 링크 --&gt; &lt;script src=&quot;https://kit.fontawesome.com/ea629e8085.js&quot;                crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;div&gt;  &lt;div class=&quot;search-area&quot;&gt;    #입력 받은 값을 서버나 페이지로 전송하기 위해 form 태그로 감싼다.    &lt;form action=&quot;#&quot; name=&quot;search-form&quot;&gt;      &lt;fieldset&gt;        #입력받는 창을 만든다 autocomplete는 자동완성 사용안함.        &lt;input type=&quot;search&quot; id=&quot;query&quot; name=&quot;query&quot;                autocomplete=&quot;off&quot; placeholder=&quot;검색어를 입력해주세요&quot;&gt;        #검색 모양 버튼을 만드는  submit 버튼             이 때 버튼의 이미지 아이콘을 웹사이트에서 따온다             따온 아이콘은 텍스트 취급(색 , 크기 지정 가능)        &lt;button type=&quot;submit&quot; id=&quot;search-bth&quot;                class=&quot;fa-solid fa-magnifying-glass&quot;&gt;&lt;/button&gt;      &lt;/fieldset&gt;    &lt;/form&gt;  &lt;/div&gt;&lt;/div&gt;.header&gt; div:nth-of-type(2){    #header에서 두번째 순서인 검색창을 조정    display: flex;  #화면을 flex형태로 구현한다.    justify-content: center;    #화면의 흐름방향으로 중앙 정렬 (justify)      align-items: center;   #화면의 흐름의 반대축으로 중앙정렬한다(align).}  &lt;실제 검색 영역에 가로폭을 500px 주면서 테두리를 없앤다.&gt;  .search-area{   width: 500px; border: none;}   &lt;후손인 fieldset에 스타일을 지정한다.&gt;  .search-area fieldset{      padding: 2px; # content와 border의 색       margin: none; # margin을 없앤다.      border: 2px solid #455ba8; # 테두리 두깨와 색       border-radius: 5px; #모서리 곡률      display:flex; # 출력 방식을 flex로 바꾼다.  }  &lt;fieldset 안에 있는 검색 타이핑 범위&gt;  #query{       padding: 10px; # border와 content 간격을 10px 부여                          내부의 placeholder도 이로인해 띄어지게됨.      font-size: 18px; #입력되는 글자의 크기를 지정      font-weight: bold; #글자를 굵게 설정      border: none; #테두리 삭제      outline: 0; #선택됬을때 색 안변하게 설정      width: 92%; # 가로폭 92% 할당  }  &lt;fieldset 안에 검색 버튼&gt;  #search-bth{      width: 8%;  #검색 입력 부분을 제외한 나머지 8% 부분을 할당      cursor: pointer;  #마우스가 올라갔을때       font-size: 1.2em; #부모에게 물려받는 글자 크기에서 1.2배 확장한다.      color: #455ba8; #글자의 색 지정      background-color: white;  #배경색 흰색으로 지정.      border: none;   # 테두리 없애기. 테두리를 없애서 아이콘만 표시하게 한다.  }모양 예시Nav&lt;nav&gt;  &lt;ul&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;공지&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;자유 게시판&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;질문 게시판&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;FAQ&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1:1 문의&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;&lt;/nav&gt;nav{    height:50px; #nav의 높이를 기정    position:sticky;    /* sticky : 스크롤이 임계점(최상단 / 최하단)에 도달 했을 때     화면에 스티커 처럼 붙인다.         평소에는 static(기본 Position상태)        임계점 도달시에는 (fixed 화면 특정위치에 고정)        * top , bottom ,left, right 속성이 필수로 작성되어야 한다.             -&gt;임계점 도달 시 어느 위치에 부착할지 지정해야 하기 때문에.        */        top: 0; /* 최상단에 위치. */        border-bottom: 2px solid black; # 아래쪽 밑줄 긋기용        background-color: white;#붙어서 움직이지만 투명한 뒤쪽이 안보이게 뒷배경색}      /*nav 내부 스타일 */      nav&gt;ul{        display: flex; # 리스트형 자료를 가로로 정렬하기 위해 flex        list-style: none;  # 앞쪽에 리스트 순서 표기를 없애기 위해 사용        margin: 0; # 리스트 간의 margin를 제거        padding: 0; # 리스트의 padding을 삭제.        height: 100%; #높이는 nav의 높이와 동일하게     }    nav li{        flex: 0 1 150px; # 수축 정도를 1 기본 크기를 150px으로 설정    /*  팽창 수축 기본 크기 */}nav a{        display: block; # li 태그를 다 차지하게 block형으로 설정        height: 100%; #block으로 한줄은 다 차지했으니 높이를 차지하게 설정        text-align: center;  # 한 칸을 다 차지한 후 글자를 중앙 정렬한다        /* 글자를세로 가운데 지정하는 방법 */        /* line-height: 48px; */         padding: 11px 0; #상하에 패딩 11px을 줘서 정 중앙으로 위치한다                /* a태그의 밑줄 없애기 */        text-decoration: none;  #하이퍼링크의 밑줄을 긋는다        font-size: 18px;  #글자 크기 설정            font-weight: bold; #글자 두께 설정        color: black;  # 글자 색        border-radius: 5px; #블럭 상자의 곡률        transition-duration:0.5s; #색이 변화하는 시간 0.5s 부여    }nav a:hover{  # a태그에 마우스가 올라갔을 '때'    background-color: #455ba8;  # 배경 색을 변경    color: white;        # 글자 색 변경}ID/PW Section&lt;section class=&quot;content-2&quot;&gt;  &lt;form action=&quot;#&quot; name=&quot;login-form&quot;&gt;     # 입력된 값을 서버나 다른페이지로 전송하기 위한 form태그    &lt;!--아이디/ 비밀번호 / 로그인 버튼 영역 --&gt;    &lt;fieldset id=&quot;id-pw-area&quot;&gt;        #아이디와 비밀번호를 입력하기 위한 section   &lt;section&gt;     &lt;input type=&quot;text&quot; name=&quot;inputId&quot; placeholder=&quot;아이디&quot;&gt;     &lt;input type=&quot;password&quot; name=&quot;inputPw&quot; placeholder=&quot;비밀번호&quot;&gt;   &lt;/section&gt;      #button의 기본값은 submit이라 생략 가능      &lt;section&gt;          &lt;button&gt;로그인&lt;/button&gt;       &lt;/section&gt;    &lt;/fieldset&gt;    #회원가입/ ID,PW 찾기 영역.    &lt;article id=&quot;signup-find-area&quot;&gt;      &lt;a href=&quot;#&quot;&gt;회원 가입&lt;/a&gt;       &lt;span&gt;|&lt;/span&gt;  #회원가입과/id,pw 찾기를 위한       &lt;a href=&quot;#&quot;&gt;ID/PW 찾기&lt;/a&gt;    &lt;/article&gt;  &lt;/form&gt;&lt;/section&gt;    #form 태그 자체의 사이즈를 조정       formname=&quot;login-form&quot;{           height: 140px;           padding: 10px;            #내부의 가로 정렬을 위해 사용              display: flex;           #flex의 기본 축인 왼쪽에서 오른쪽으로 이동하는 것을                               세로로 변경한다.              flex-direction: column;              # 중심 축에 대한 정렬 (세로 가운데 정렬)              justify-content: center;          }        #아이디 박스와 비밀번호 박스 area 세팅           #id-pw-area{              margin: 0px; #아이디/비밀번호 박스를 딱 붙힌다              padding: 0px; #input 박스가 기본적으로 가지고 있는 패딩을 지움              border:1px solid #ddd; #회색 테두리선             #flex모양으로 정렬한다.             이 때 세로 축으로 정렬되있어 정렬도 세로로 된다(?)              display: flex;             #id-pw-area안에서 60%를 차지한다.              flex-basis: 60%;          }          # id/ pw input 영역           #id-pw-area &gt; section:first-child{               flex-basis: 75%;              display: flex; # 화면 값을 flex로 정렬한다              flex-direction: column; # 세로로 정렬한다          }          #로그인 버튼 영역           #id-pw-area &gt; section:last-child{              flex-basis: 25%; # 검색 상자의 크기를 설정              display: flex;  # 검색 상자 정렬를 위해 사용              justify-content: center; #안해도 정렬되는데 머지 왜 했지          }            # 로그인 상자의 후손중 input태그(id/pw블록)          #id-pw-area input{                border: none;     #테두리 없애기              border-right: 1px solid #ddd; 오른쪽면에 회색선              flex-basis: 50%; # 아이디와 비밀번호 반반씩 공간할당              outline:0; #선택시 강조선 안뜨게              margin: 0;  #margin을 삭제해 딱 붙힌다.              padding: 5px; #로그인 상자에서 살짝 떨어트림          }          #id-pw-area input:first-child{ #id상자              border-bottom: 1px solid #ddd; #아래쪽에 선 긋기           }          #id-pw-area input:focus{ #아이디/비밀번호 입력 눌렀을 때              border: 2px solid #455ba8; #색 강조.          }          /* 로그인  버튼 */          #id-pw-area button{              width: 100%; #로그인 박스에서 가로폭 전부 차지              border: 0;    #id/pw에 딱 붙힘              background-color: white; #배경색 흰색              cursor: pointer; #마우스 올렸을 때 손가락 모양          }                #id-pw-area button:hover{ 눌렀을 때               background-color: #455ba8; #색 바꾸고              color: white; #글자색 흰색으로 바꿈          }  /* 회원가입 , id/pw찾기 영역 */          #signup-find-area{              margin-top: 10px;              padding-left: 5px;              border: none;          }          #signup-find-area&gt;a{              color: black;              text-decoration: none;              font-size: 14px;          }          #signup-find-area&gt;span{              padding: 0 10px;                  /* 상하, 좌우*/          }footer은 간단해서 스킵시멘틱 태그(Semantic)   시멘틱(semantic,의미)태그 (의미있는 태그)기존 영역 분할에 주로 사용되던 div, span등의 태그는태그 이름만 봤을 때 나눈다는 것 이외의 의미를 파악할 수 없음.태그만 봤을 때 태그의 목적을 알 수 없어id 또는 class를 반드시 추가해야 했다.이런 문제점을 해결하고자 태그 이름만으로 어느 정도 어떤 역할을 하는지 알 수 있고추가적으로 웹 접근성 향상을 도움이 되는시멘틱 태그가 추가됨 (HTML5)제공하는 태그header 태그 : 문서의 제목, 머리말 영역footer 태그 : 문서의 하단부분, 꼬리말, 정보 작성 영역nav 태그 : 나침반 역할(다른 페이지, 사이트 이동)의 링크 작성 영역main 태그 : 현재 문서의 주된 콘텐츠 작성 영역section 태그 : 구역 구문을 위한 영역article(작은 토막) 태그 : 본문과 독립된 콘텐츠를 작성하는 영역aside 태그 : 사이드바(보통 양쪽), 광고 영역"
145,"변형 관련 스타일참고 이미지는 기본적으로 자신만의 사이즈를 가지고 있어width / height 중 하나의 값만 지정해도 나머지는 방향은 비율에 따라 자동으로 맞쳐 진다2차원 변형이미지를 2차원 평면에서 움직이는 명령들transform : translate ~마우스를 올렸을 때(hover) x축으로 100px 만큼 이동한다.trans-x-2d:hover{    -ms-transform: translate(100px,100px);    -webkit-transform: translate(100px,100px);    transform: translateX(100px); }마우스를 올렸을 때(hover) Y축으로 100px 만큼 이동한다.trans-y-2d:hover{    -ms-transform: translate(100px,100px);    -webkit-transform: translate(100px,100px);    transform: translateY(100px);}마우스를 올렸을 때(hover) 대각선으로 100px 만큼 이동한다.trans-d-2d:hover{     -ms-transform: translate(100px,100px);    -webkit-transform: translate(100px,100px);    transform: translate(100px,100px);                        /*x축  y축*/}CSS속성 작성 시 크로스 브라우저(브라우저가 달라지는 경우) 처리 방법ms- : microsoft (엣지)webkit- : 크롬 , 사파리.o : 오페라 mox : 파이어폭스```cssms-transform: translate(100px,100px); webkit-transform: translate(100px,100px);비율 - Scaletransform : scaleX(값) 가로 방향 비율 확대transform : scaleY(값) 세로 방향 비율 확대transform : scale(값 , 값) 요소 자체를 확대 축소 한다요소를 비율을 조정할 때 margin을 잘 설정 해야한다.x y z 이동.trans-3d:hover{    transform:perspective(300px) translate3d(50px,50px,100px);                                            가로 / 세로 / y축}회전 : rotate요소를 회전한다/* x축 회전  */.trans-rotate-x-3d{    transform:perspective(300px)  rotateX(45deg);}/* y축 회전  */.trans-rotate-y-3d{    transform:perspective(300px)  rotateY(45deg);}/* z축 회전  */.trans-rotate-z-3d{    transform:perspective(300px)  rotateZ(45deg);}/* x,y,z축 회전  */.trans-rotate-3d{    transform:perspective(300px)  rotate3d(0.5,0.5,0.5, 45deg);    /* roatae3d ( x ,y ,z 회전각도);        x/ y / z 는 0~ 1 사이 숫자 */}변경시에 지연 시간 : ( transition )duration : 지연 시간 .test2{    transition-duration: 5s; // 5초만큼 지연된다 (ms 단위도 가능)    border-radius:5% ;  //모서리 둥글게 하는거 50% == 원}   변형 딜레이linear | ease | ease-in | ease-out | ease-in-out | cublic-bezier(n,n,n,n) transition-timing-function: cubic-bezier(0.3, 0.3, 1, 0.5);   변형의 속도를 조절한다. 벡터값이나 이것저것 어려운게 많아 이미 만들어진걸 주로 사용한다."
146,"글자 (text - style)color : 글자 색을 지정하는 속성 color : 색상명(영문),16진수 숫자(#fff,#ffffff)rgb(255,255,255)|rgba(255,255,255,1)hsl(360,100%,100%)|hsla(360,100%,100%,1) 색조,채도,밝기 rgba 와 hsla의 'a'는 투명도를 의미한다(0:투명 , 1:불투명)6개의 색상 지정 방법은 색과 관련된 모든 css 속성에서 사용가능text-decoration : 텍스트에 줄을 긋는 속성{text-decoration:underline ;} : 아래 줄 긋기{text-decoration: line-through;} : 중간에 줄 긋기{text-decoration: overline;}   : 위쪽에 줄 긋기{text-decoration:none;}  : 줄긋기 없애기 (주로 a 태그같은대 사용)text-alige : 글자를 정렬하는 속성(왼쪽,오른쪽,가운데,양쪽)  {text-align:left;} : 왼쪽 정렬   {text-align:right;}  : 오른족 정렬  {text-align:center;}  : 가운데 정렬  {text-align:justify;}          /* flex의 space-between과 같은 효과 (양쪽 끝은 붙임) */        /* inline-block도 적용 가능!! */line-height:줄의 간격(장평)을 지정하는 속성줄 사이 간격을 지정한 만큼 벌리는게 아닌한줄 자체의 높이를 지정하는 속성.줄의 높이가 글자의 크기 보다 큰 경우글자는 해당 줄 세로 가운데 배치된다.letterspacing : 글자사이 간격letter-spacing: 1px  줄의 간격을 조정하면 된다.' - ' 를 표기해 줄을 곂쳐보이게 할 수도 있다.text-shadow :텍스트에 그림자 효과를 추가한다.#shdow-test&gt;p:nth-child(3){    color: rgba(255, 255, 255,0.7);    text-shadow:0px 0px 10px greenyellow;            /*   가로 세로 번짐 색상 순으로 지정 */}   text - shadow 뒤로 가로축, 세로축 , 번짐정도(생략가능) 색상 순으로 지정해 사용하면 된다글꼴 (font-style)font-size 글자의 크기를 조정하는 속성  px : 픽셀(화면 해상도)  pt : 포인트(1pt = 0.72인치 = 1.83cm)  %  : 상위 요소 크기에 대한 백분율(여기서는 body를 기준)  em : 1em == 100%font-weight : 글자의 굵기(두깨)를 조정하는 속성숫자   : 100~ 900 (커질수록 두꺼워짐)nomarl : 폰트에 지정된 기본 두깨(400) bold : 굵게 (700)bolder : 상속받은 두깨보다 더 굵게lighter : 상속받은 두깨보다 더 얇게font-style : 글꼴을 지정하는 속성italic     : 폰트에서 제공하는 비슷한 글자 (제공하면 이거 쓰면됨)oblique   : 강제로 글자를 비스듬하게 변경 (혹시 폰트가 제공안하면 강제로)font-family : 글꼴을 지정하는 속성#배달의민족체가 없을 경우 d2coding 폰트를 사용한다.#family-test1&gt;li:nth-child(3){    font-family:'배달의민족체','d2coding';} 1) 웹 폰트에서 import 한다# 주의점 import는 css의 최상단에 위치해야 한다.@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR&amp;display=swap');2) 웹 폰트에서 제공하는 코드를 복사한다@font-face {    font-family: 'Yeongdo-Rg';    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2202-2@1.0/Yeongdo-Rg.woff') format('woff');    font-weight: normal;    font-style: normal;}"
147,"Flexbox 요소의 정렬되는 방향 , 순서 ,요소간의 간격을        수치적으로 처리하지 않아도 알아서 유연하게 처리해주는 형식.Flexbox 사용 시 필수로 알아야하는 것FlexBox의 구성flex-container : 정렬이 필요한 요소를 감싸주는 요소item  : 정렬을 적용 할 요소 container 와 item에 사용되는 CSS속성이 나눠져있다.FlexBox의 축중심축 ( main axis)교차축,반대축(중심축의) (Cross axis)Flex-Container의 전용속성flex-direction : main axis(중심축) 방향 , 시작/끝 지정row /  row-reversecolumn  /column-reverseflex-wrap : item 한 줄/ 여러줄로 배치 되게 지정nowrap(기본 값) : 한줄로 배치되지만 item의 content가 훼손 될 수 잇다.wrap : 여러 줄로 자동 배치wrap-reverse : 여러줄로 배치 되지만 (cross axis)방향이 반대된다flex-flow : flex-direction / wrap을 동시에 지정하는 것.justify-content : main-axis(중심축)을 기준으로 item을 정렬하는 것.align-content : cross axis(교차축)을 기준으로 item을 정렬    (조건이 flex-wrap이 wrap 또는 wrap-reverse여야 한다.)flex-start          : 축 시작 지점으로 정렬flex-emd           : 축의 끝 지점을 정렬center             : 축의 정 가운데에 정렬space-around     : item에 축방향 양쪽으로 일정 크기 공간을 배치space-evenly     : item에 축방향 양쪽으로 '모두 동일한 크기'의 공간을 배치space-between    :evenly와 동일하지만 양끝은 flex-container에 붙어 있다align-item : cross axis(교차축)을 기준으로 item을 정렬stretch(기본값) : item을 cross axis 방향으로 flex-contaniner 만큼 늘림.단, cross axis 방향으로 지정된 크기 속성(width / height)이 없어야함flex-start : 교착축 시작 지점을 기준으로 정렬.flex-end : 교착축 끝 지점을 기준으로 정렬.center : 교착축 가운데 지점을 기준으로 정렬.baseline : item에 작성된 내용이 한 직선에 배치될 수 있도록 item을 교차축 방향으로 알맞게 배치하는 것.item 전용속성order : item의 순서를 지정하는 속성(기본값 0 , 정수 , 양수,음수 가능).order5{order: 5;} order 값 5 순서대로 정렬 된다.flex - grow (팽창)화면의 팽창 정도를 조절.grow1{flex-grow: 1;}.grow2{flex-grow: 2;}flex-grow 의 값이 크면 클 수록 패창 정도가 증가한다.flex - shrink (수축)화면의 수축 정도를 조절 .shirink0{flex-shrink: 0;}.shirink1{flex-shrink: 1;}flex-shrink 의 값이 작으면 작을 수록 수축하는 정도가 증가한다.flex-basis (크기)itme의 main axis 방향으로 기본 점유율(크기를)지정하는 속성크기 단위 : px , % ,vh(보이는 화면) ,  em ,remwidth / height 와 같은 역할이다flex를 사용 시 한줄의 코드로 grow,shrink,basis를 구성 할 수 있다.flex1{flex: 0,0,100px;/* 팽창 수축 안하고 100px 고정 */}align-self각각의 item별로 cross axis 방향으로 정렬 지정하는 속성.self-start{align-self: flex-start;} //시작 지점 지정 출력"
148,"display : none(투명 X)요소는 존재하지만 영역을 차지하지 않는다.visibility : hidden(투명 O)요소가 화면에 투명한 색으로 보인다.요소들의 영역(여백)content 영역요소의 실제 내역이 작성되어 지는 영역    (시작 태그와 종료태그 사이에 작성되는 모든 것)padding 영역content 와 border 영역 사이border 영역요소의 테두리가 지정되는 영역content보다 바깥쪽에서 content를 '감싸고' 있음.margin영역다른 요소와의 간격을 나타내는 영역  .box {      width: 100px;      height: 100px;      background-color: steelblue;  }  /* content 영역 */  .content {      width: 150px;      height: 150px;      /*           width / heght 속성은           기본적으로 content 영역에 크기를 지정하는 속성           */  }  /* border 영역*/  .border {      border: 10px solid red;  }  /* padding 영역 */  .padding {      padding: 30px;      /* 내용과 테두리 사이 간격을 상하좌우로 30px 벌림 */  }  .margin {      margin: 50px;      /* 다른 요소와의 간격을 상하좌우 50px 벌림 */  }  /* 서로 다른 요소의 margin이 곂칠 경우       더 큰 margin을 가진 요소의 값만큼 벌어진다 */  #m1 {      margin: 100px;  } padding , border , margin은 방향에 따라 크기를 지정할 수 있다.000-top 000-bottom000-left000-right000은 padding,border,margin중 선택padding을 margin으로 바꾸면 사용법 동일.padding-test{ /* padding-top: 20px;    padding-bottom: 50px;    padding-left: 15px;    padding-right: 30px;*/    /* padding 속성 : 작성법에 따라서 padding                 특정 방향에 크기를 지정할 수 있다. */    /* 값 1개 : 상하좌우 */    /* padding: 50px */    /* 값 2개 : 상하 , 좌우 */    /* padding: 50px 100px; */    /* 값 3개 : 상 , 좌우 , 하 (위쪽에서부터 아래로)*/    /* padding: 50px 100px 150px; */    /* 값 4개 : 상 , 우 , 하  , 좌 (시계 방향)*/    padding: 10px 20px 30px 40px;    }borderborder 속성은 상하좌우 방향을 지정하고 싶으면 각각 border-원하는 방향으로 별도 지정해줘야 한다..border-test{/* border 속성은 상하좌우 방향을 별도로 지정할 수 없음 */border: 4px solid red;/* 4 방향을 따로 지정하고 싶을 경우 border-원하는방향 으로 별도 지정 *//* 스타일 *//* 너비 | 스타일 *//* 스타일 | 색 *//* 너비 | 스타일 | 색 */border-top:1px solid black;border-bottom: 5px dashed yellow;border-left: 5px dotted magenta;border-right: 7px double brown;/* border의 크기(두깨)만을 선택하는 경우 상하좌우 한번에 처리 가능.*//* 1개 : 상하좌우 *//* 2개 : 상하 : 좌우 *//* 3개 : 상 : 좌우  :하 *//* 4개 : 상 :좌 :하 :좌 */border-width: 20px ;}box-siszing요소의 영역 중 실제로 화면 상에 보여지는 부분인content, padding, border는 각각 크기를 지정할 수 있음이 때 , 각각의 크기를 따로 지정하다 보니전체적인 크기를 한눈에 파악하고 설정하기 힘들다./* box-sizing */#box-sizing{    /* 테두리 10px ,패딩 20px 내용 나머지     전체 요소 크기가 가로/세로 300px인 정사각형 설정  */    border: 10px solid black;    width: 300px;    height: 300px;    /* width/height는 기본적으로 content 영역에 대한 크기를 지정  */    /* 이것을 변경하는 방법이 box-sizing */    box-sizing:border-box;    /*   content-box(기본값)             -width / heigth 지정시 content영역만  적용            border-box             -width / heigth 지정시  content+padding+border ~ 까지    */}* position : 요소 배치(위치)를 지정하는 속성* position 속성1) static(기본값)- 배치 불가능2) relative- 현재 요소를 내부요소의 기준점으로 지정3) absolute- 상위 요소를 기준으로 위치를 지정(겹치기 가능)- 위치 지정 시 top,bottom,left,right 사용 4) fixed- 뷰포트(브라우저에 보이는 화면)를 기준으로 위치를 지정(고정됨)- 위치 지정 시 top,bottom,left,right 사용"
149,"연산자 우선 순위CSS선택자의 우선순위기본적으로 CSS속성은 style 태그 또는 css파일에 작성된 순서(위,아래)대로 해석이 진행 되지만 같은 요소에 따라 css 속성이 설정되는 경우 우선 순위가 적용된다.알아둬야 될 것1) 동일한 우선 순위로 CSS속성이 설정된 경우그 중 제일 마지막에 작성된 CSS 속성이 반영된다.2) 여러 선택자를 이용해 같은 요소를 선택하더라도 지정되는 CSS 속성이     다르면 모두 반영된다.1 : css속성 : 속성값 !important;2 : inline-style 속성 (요소에 직접 작성되는 style속성)3 : 아이디 선택자( #아이디 속성명)4 : 클래스 선택자(.Class 속성명)5 : 태그 선택자( 태그명 )레이아웃 스타일사전적 의미 : 배치 , 정의기술적 의미 : 구성 요소를 제한된 공간에 효율적으로 배치하는 것을 의미 화면 배치 방법(형식) : display 속성 요소가 화면에 어떻게 보여질지 형식을 지정하는 속성-block : 화면 수직 분할 (행을 나눔)                    + width / height 속성 사용 O  -inline : 화면을 수평 분할(하나의 행에 컬럼 나눔 (떡 썰듯이))                    + width / height 속성 사용 X -inline-block : inline의 수평분할 + block의 크기조정을 합친 기능 -none : 화면에 요소가 표시되지는 않지만 존재는 하고 있는 상태 -flex : 요소의 정렬되는 방향 , 요소간의 간격을 유연하게 처리하는 형식.상하  2 분할    &lt;div id=&quot;container-1&quot;&gt;        &lt;!-- 내부에 영역을 분할할 요소 --&gt;        &lt;div class=&quot;div-1&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;div-1&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    #container-1{    border:3px solid black;    width: 300px;    height: 500px;    }    .div-1{    width: 100%;     }    #container-1 &gt; .div-1:first-of-type{    background-color: ivory;    height: 30%;    }    #container-1 &gt; .div-1:last-of-type{    background-color: grey;    height: 70%;    }1) 전체 영역을 선언 (300pxx500px + 검은 3px 외각선)2) 내부 공통 영역 선언 (둘 모두 가로 폭은 100)3) 각자 차지할 영역과 색을 지정 (퍼센티지로 구성) first-of-type / last-of-type를 이용해 타입의 처음과 마지막을 타겟팅 한다상하 3분할  &lt;div id=&quot;container-2&quot;&gt;      &lt;div class=&quot;div-2&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;div-2&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;div-2&quot;&gt;&lt;/div&gt;  &lt;/div&gt;  #container-2{    border: 1px solid black;    width: 300px;    height: 410px;  }  .div-2{      width:100%;  }  #container-2&gt; .div-2:nth-of-type(1){    height:20%;    background-color: antiquewhite;  }  #container-2&gt; .div-2:nth-of-type(2){    height:30%;    background-color: black;  }  #container-2&gt; .div-2:nth-of-type(3){      height:50%;      background-color: blueviolet;  }1) 내부 영역을 선언2) 공통적으로 가로폭은 동일하게 지정한다(100)3) nth-of-type을 이용해 3개의 공간을 각각 다르게 공간을 할당한다.display : inline-block좌우 2 분할    &lt;div id=&quot;container-3&quot;&gt;        &lt;div class=&quot;div-3&quot;&gt;&lt;/div&gt;&lt;div class=&quot;div-3&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  #container-3{      border:5px solid red;      width: 400px;      height: 200px;  }  .div-3{      width: 50%;      height: 100%;      display:inline-block;  }  #container-3&gt;.div-3:first-of-type{      background-color: red;  }  #container-3&gt;.div-3:last-of-type{      background-color: slateblue;  }1) 내부의 공간 크기 할당2) 공통적으로 공간을 할당한다 이때 좌우 수평 분할을 위해서 display의 inline-block(수평분할 + 사이즈 변경 가능)을 사용해서 하나의 반으로 블럭을 나눈다3) 이 때 요소 선언시 사이에 '띄어쓰기'가 있을 경우 1px이 부여되서 400px가 초과되어 밑으로 내려가는 일이 생김으로 주의하자."
150,": only-child특정 요소에 자식이 하나 밖에 없는 경우.: only-of-type특정 요소의 타입이 하나만 있는 경우: empty자식 요소가 '없는' 요소 선택&lt;!-- :empty에 해당하는 요소 예시 --&gt;&lt;div&gt;&lt;/div&gt;여러 선택자 동시 선택.같은 스타일을 지정하고 싶지만 요소를 선택하는 요소가 일치하지 않을 경우.   선택자1,선택자2,선택자3....{CSS코드}   ' , ' 으로 구분.특정 요소 내부에 있는 특정 클래스만 선택.특정 요소 내부에 있는 특정 클래스만 선택    &lt;ul id=&quot;test5-1&quot;&gt;        &lt;li class=&quot;c5&quot;&gt;1&lt;/li&gt;        &lt;li class=&quot;c5&quot;&gt;2&lt;/li&gt;        &lt;li class=&quot;c5&quot;&gt;3&lt;/li&gt;        &lt;li&gt;4&lt;/li&gt;        &lt;li&gt;5&lt;/li&gt;    &lt;/ul&gt;    &lt;ul id=&quot;test5-2&quot;&gt;        &lt;li class=&quot;c5&quot;&gt;6&lt;/li&gt;        &lt;li class=&quot;c5&quot;&gt;7&lt;/li&gt;        &lt;li class=&quot;c5&quot;&gt;8&lt;/li&gt;        &lt;li&gt;&lt;span class=&quot;c5&quot;&gt;9&lt;/span&gt;&lt;/li&gt;        &lt;li&gt;&lt;span class=&quot;c5&quot;&gt;10&lt;/span&gt;&lt;/li&gt;    &lt;p class=&quot;c5&quot;&gt;11&lt;/p&gt;    &lt;p class=&quot;c5&quot;&gt;12&lt;/p&gt;    &lt;/ul&gt;#test5-1 .c5{    background-color: aqua;}  //test5-1에 모든 후손(띄어쓰기)의 백그라운드 색을 지정.#test5-2&gt;li.c5{    /* #test5-2의 자식중        클래스가 c5인 li 요소만 선택 */    background-color: khaki;} //test5-2안의 li에 c5클래스에 백그라운드색을 지정클래스 요소가 여러개인 요소들 타겟팅&lt;h2&gt;클래스가 여러개인 요소만 선택&lt;/h2&gt;    &lt;div class=&quot;test6&quot;&gt;테스트&lt;/div&gt;    &lt;div class=&quot;test6 c6&quot;&gt;테스트&lt;/div&gt;    &lt;div class=&quot;c6&quot;&gt;테스트&lt;/div&gt;.test6.c6{    background-color: brown;} //test6 와 c6클래스를 가진 요소 선택"
151,"문자열 속성 선택자속성값의 문자열을 확인하여 스타일을 적용하는 방식의 선택자.1) 선택자 속성명 ~= &quot;특정값&quot; {CSS코드;}     -&gt; 띄어쓰기로 구분되어 있는 여러 속성 값이 작성된 속성 중          속성 값이 특정 값을 포함하는 요소를 선택자여러 속성 값중 '하나' 라도 일치하면 선택이때 속성 값 이름이 동일 해야함2) 선택자 속성명 |= &quot;특정값&quot; {CSS코드;}     -&gt; 속성 값이 특정 값을 단어로 포함하는 요소를 선택     단 , '-'기호로 구분, &quot;-&quot;앞의 내용이 동일해야 한다.이때 ' - ' (하이픈) 뒤에 str이 위치해 있음으로 3번은 적용되지 않는다.3) 선택자 속성명 ^= &quot;특정값&quot; {CSS코드;}   - (^ : 캐럿)   --&gt; 속성 값이 '특정 값'으로 _시작하는_ 태그를 선택4) 선택자 속성명 $= &quot;특정값&quot; {CSS코드;}  --&gt; 속성 값이 '특정 값'으로 _끝나는_ 태그를 선택5) 선택자 속성명 8= &quot;특정값&quot; {CSS코드;}    --&gt; 속성 값이 '특정 값'으로 _포함하는_ 태그를 선택일반 구조 선택자:first-child:last-child:nth-child(수열):nth-last-child(수열)    형태 구조 선택자일반 구조 선택자와 동일하지만 같은 타입만 취급함.:first-of-type : 같이 선택된 형제들 중에서 첫번째 요소:last-of-type : 같이 선택된 형제들 중에서 마지막 요소:nth-of-type(수열) : 같이 선택된 형제들 중에서 수열번째 모든 요소:nth-last-of-type(수열) : 같이 선택된 형제들 중에서 뒤에서부터  수열번째 모든 요소부정 선택자부정 선택자 ( 선택자1:not(선택자 )~를 제외한 나머지를 선택한다/* #test3의 자식  li 요소 중 3의 배수를 제외한 요소만 선택 */    #test3&gt;li:not(:nth-of-type(3n)){                background-color: pink;  }"
152,"하...자바가 훨씬 재밌다..CSS마크업 언어가 실제 화면에 표시되는 방법(모양,색상,크기,스타일)를 기술하는 언어W3C(웹 표준 지정 기관에서 CSS를 표준으로 지정함.1 ) &lt; Style &gt; 형식으로 열고 닫아 사용 할 수 있다.2 ) Link 태그를 이용해 외부 CSS 파일과 연결 시킬 수 있다.  &lt;link rel=&quot;stylesheet&quot; href=&quot;css/select2.css&quot; type=&quot;text/css&quot;&gt;  relation =&gt; rel (링크 태그에 달리는 링크가 현재 링크와 어떤 관계인지.) CSS Selector (선택자)seletor : 현재 html 문서 내부에서 특정한 요소를 선택하는 문자스타일를 적용하기 위한 요소 타겟팅을 위해 사용태그 선택자같은 태그를 선택하는 선택자작성법      태그명 { CSS 코드; }아이디 값 선택자html 문서 내에서 id 속성 값이 일치하는 요소를 선택하는 선택자(중요) id 속성 값은 페이지 내에서 '유일'해야 한다.작성법    # id속성값{ CSS 코드 };Class 선택자문서 내에서 같은 Class 속성 값을 가지는 태그를 '모두'선택  작성법         .class속성값 {CSS코드}모든 요소 선택자단독 혹은 다른 선택자와 함께 사용한 선택자로 모든 요소를 선택하는 선택자.작성법      * {CSS코드}기본 속성 선택자태그에 작성된 특정 속성을 선택(id , class 도 선택은 가능하지만 보통은 # , . 을 사용함)  작성법        선택자속성명=&quot;속성값&quot;{ CSS코드; }1 ) 선택자는 생략 할 수 있다.2 ) &quot;속성값&quot; 양쪽의 쌍따옴표(&quot;&quot;)는 홀따옴표('')으로 변경하거나 생략 가능/* 기본 속성 선택자 경우의 수 */ 1)    divname='name-1'{background-color: orangered;}2)    name=&quot;name-2&quot;{background-color:lightblue;}3)    pname=&quot;name-1&quot;{background-color: green;}자식 선택자 ( &gt; )지정된 요소 바로 하위에 존재하는 요소를 선택하는 선택자작성법   선택자1 &gt; 선택자2 {CSS 코드;}   -선택자 1: 부모요소    -선택자 2: 자식요소후손 선택자 ( ) 띄어쓰기지정된 요소의 하위에 존재하는 '모든'요소를 선택하는 선택자.작성법선택자1  선택자2 {CSS 코드;}-선택자 1: 조상요소 -선택자 2: 후손요소반응 선택자사용자의 움직임에 반응해서 스타일이 달라지는 선택자마우스 오버 / 클릭 유지 상태 요소를 클릭하고 있는 경우 :active  요소에 마우스가 올라가 있는 경우  :hover 상태 선택자입력 양식(input , input 관련 태그)의 상태에 따라 선택되는 선택자:focus : 요소에 초점이 맞쳐졌을 때.  :checked : 요소가 체크 된 상태일 때(radio , checkbox) :enabled / disabled:enabled - 사용 가능한 상태 일 때.:disabled - 사용 불가능한 상태 일 때.동위선택자동등한 관계(형제 관계)에서 바로 뒤에 위치한 요소를 선택```1) A 바로 뒤(다음)에 있는 B 요소 하나를 선택(+)      A선택자 + B선택자{CSS코드;}   2) A 바로 뒤에 있는 모든 B 요소를 선택(~틸드(titld)) A선택자 ~ B선택자{CSS코드;}checkbox의 모양 바꾸기.1.check1 바로 뒤에 있는 label을 모양을 설정한다1.1 : 사이즈를 지정한다 (가로 세로 30px)1.2 : 테두리를 만들어 준다 (1px 사이즈의 검은 실선)1.3 : 한 줄을 다 차지하지 않게 위해 수평분할과 크기조절이 가능하게 한 속성을 쓴다               (display : inline-block)1.4 : 마우스가 올라가면 마이스 아이콘이 손가락 모양으로 바뀌게 하면서 테두리 곡률을 높힌다2.Check가 된 상태의 라벨 태그체크가 된 상태에서의 label 상태를 지정한다 url 로 불러온 이미지를 설정한다 이때 사이즈를 확장해 꽉 채우고 이미지를 반복하지 않는대(non-repeat)3.모오옷 생긴 checkbox는 숨긴다/* ********************check box 모양 바꾸기*********************** *//* label 태그 스타일 지정 */#check1 + label{    width: 30px;    height: 30px;    border: 1px solid black;    /* 수평 분할 + 크기조절  */    display: inline-block;    cursor : pointer; /* 마우스 손가락 모양으로 변경. */    /* 모서리 라운딩 처리 */    border-radius:12%;   }/* 체크가 된 #check 뒤에 있는 라벨 태그*/#check1:checked + label{    background-image:url(../../images/check.png) ;    background-repeat: no-repeat;    background-size: cover;}/* #check1을 존재는 하지만 화면에 보이지 않게 하기 */#check1{    display : none;}"
153,"오늘 배운게 뭔가.... wtih _html 노잼영역 관련 태그block 형식공간을 수직 분할수직으로 되어있는 화면을 가로로 짤라 여러 행을 만드는 것크기를 조정 할 수 있음 ( witdh   /  height )p / pre : 글 영역 나누기h1 ~ h6  : 제목 영역 나누기hr   : 선으로 영역 구분div   : 영역 나누기 inline 형식공간을 수평으로 분할수평으로 되어있는 화면을 세로로 짤라 여러 열을 만든 것크기는 조절할 수 없음strogng/b  : 글자로 분할em/i  :  글자 기울기 mark  : 글자에 형광 효과sapn  : 한 줄을 나누는 용도block (div) 와 inline(span) 차이점줄바꿈block는 한 줄을 다 먹고inline은 필요한 부분만 먹는다영역 지정 방식div는 사각형 박스 형태로 영역을 지정한다inline은 내부에 작성된 내용(Content ) 단위로 영역을 지정한다크기 지정div 가능inline 불가능iframe웹 문서에서 다른 웹 문서를 추가하는 태그 (inline)형식&lt; iframe src= &quot; 링크 &quot; &gt; 이미지 관련 태그웹 문서에 사진 ,그림같은 이미지를 삽입하는 태그  속성src : 삽입할 이미지의 경로를 지정하는 속성( 파일 경로 / 웹 주소 )witdth / height : 이미지의 가로 ,세로 크기는 조정하는 속성alt : 웹접근성에 의거해 이미지의 설명을 추가하는 속성입력 관련 태그input / form태그웹 상에서  사용자가 입력할 수 있는 양식을 제공하는 태그value : input태그에  들어가는 기본 값을 지정text 관련 태그typetext 관련 태그들의 '공용'속성size   :  입력상자의 크기 maxlength : 입력받는 텍스트의 최대 길이placeholder : 입력 상자에 작성된 내용을 설명하는 속성text한줄짜리 문자열을 입력할 수 있는 입력 상자input 타입 생성 시 기본 값inline 형식(모든 text 태그들이)password비밀번호를 입력하는 타입입력받는 값을 가려줌단독 사용 시 기본 text 와 동일하지만 form 태그 내부에서 사용 시 입력된 값이 용도에 맞는지 유효성 검사를 간단하게 해준다url주소를 입력하는 타입email이메일 입력시 사용하는 타입tel전화번호 입력시 사용하는 타입search검색어 입력시 사용하는 타입숫자 관련 태그type number'숫자'만 입력 가능한 ranger슬라이드 바 단독 사용 불가 XX시간 관련 태그type- date- month- week- time- datetime-localradio   / check여러 값을 묶어서 선택하는 경우name 속성radio / checkBox 뿐 아니라 모든input 태그들 중 관련된 것들을 묶어서 부를 때 사용 (그룹 이름)서버쪽에 제출되는 input 태그 값의 이름을 지정( form 태그와 같이 사용)label 로 '?팀'을 묶고 label은 for '?-team'이라는 id를 매칭 시킨다그 다음 버튼을 생성 후 radio 타입의 team 그룹으로 묶고  id에 각각 '? - team ' 이라는 아이디 속성을 부여해준다radio 주어진 선택 값 중 '하나'만 선택 할 수 있다checkBox주어진 선택 값 중 여러가지 선택 가능form 태그div 와 같은 영역 (block 형식)내부에 작성된 input 태그의 값을 서버로 전달하는 역할을 한다속성action : 내부에 작성된 값을 전달할 서버 또는 페이지의 주소를 작성하는 속성method : 서버로 데이터를 전달하는 '방식'을 지정 하는 속성name : form 태그의 이름을 지정하여 각각의 form 태그 구분 (JS 사용 필요)targer : action 에 지정된 주소를 새창 / 현재탭 어디에서 열지 지정주소   주소 ?id = user01?            ? : 제출된 값을 나타내는 문자열의 시작부분            id : input태그의 name속성 값            user01 : input 태그에 입력한 값(value)            id = user01 : name속성 값이 id인 input 태그에 작성된 값이 user01이다.fieldeSet : 테두리를 만들어 그룹을 구분해주는 영역legend : fieledset으로 구분한 영역의 이름을 부여해주는 역할Buttonsubmit 버튼 버튼 의 기본 값  자동으로 submitreset resetinput 영역에 입력된 값들을 초기화 한다button그냥 버튼 js으로 기능을 부여해야 사용 가능하다Hyper Link하이퍼 링크 a 태그현재 HTML 문서와 다른 HTML문서를 연결해 페이지 이동을 할 수 있게 해주는 기능이다a 태그로 감싸진 문자열들이 하이퍼링크다른 HTML문서가 아닌 하나의 문서 안에서 ID값을 지정해 문서내에서 빠른 이동이 가능하다.Textarea여러 줄을 입력하기 위한 입력 상자rows cols 속성으로 상자의 크기를 조절 할 수 있다."
154,"HTML5인터넷모든 컴퓨터간 프로토콜을 이용하여 통신하는 것웹인터넷으로 연결된 컴퓨터를 통해 사람들이 정보를 공유할 수 있는 공간팀 버너스리가 하이퍼링크를 포함하는 문서의 개념 제안월드 와이드 웹 (www) 개발 / 배포웹 표준모든 브라우저에서 웹 서비스가 정상적으로 보여질 수 있도록 하는 것처리과정HTTP (Hyper Text Transfer Protocol )웹에 정보를 표현할 목적으로 만든 마크업 언어웹 브라우저에게 보일 '문자열'과 이를 감싸는 해석기호인 태그들로 이루어진다HTTP 5 특징구조적 설계 지원(시멘틱)그래픽 및 멀티미디어 기능 강화ccs3 및 js 지원다양한 API 제공모바일 웹 지원 및 장치 접근 가능(배터리 정보, 카메라 ,gps)웹 브라우저가 서버와 양뱡향 통신 가능인터넷이 연결되지 않은 상태에서도 어플리케이션 동작태그  , 요소 글자 관련 태그h1 / h2/ h3/ h4/ h5 /h6  태그제목을 입력할때 사용되는 태그 h 뒤의 숫자는 크기를 의미한다 ( 낮을 수록 글자 크기가 큼)p태그글을 작성하는 용도의 태그 종료시 줄바꿈pre태그p와 동일하지만 시작과 끝 사이에 작성된 문자열의 포멧 그대로 출력한다기타 태그들Strong 태그 :글자를 굵게하는 태그 (웹접근성)em  태그글자를 기울이는 태그(웹접근성)mark 태그형광 효과를 주는 태그u 태그밑줄을 긋는 태그s 태그글자 중간에 선을 긋는 태그small 태그글자를 작게 하는 태그sup : 위 첨자sub : 아래 첨자abbr 태그마우스 오버시 툴팁 출력하는 태그목록 관련 태그목차 출력을 위한 기능ul  순서가 없는 목록들을 작성하는 태그ol순서가 있는 목록들을 작성하는 태그li목록안에서 각각의 요소 역할을 하는 태그감싸는 태그( ol ) 의 옵션에 start 옵션을 추가해 원하는 표기법을 만들 수 있다          기본 값 : 1 부터 1씩 증가하는 숫자          ol태그의 type 속성 *           type =&quot;a&quot; --&gt;영어 소문자 순서          type =&quot;A&quot; --&gt;영어 대문자 순서          type =&quot;i&quot; --&gt;로마 소문자 순서          type =&quot;I&quot; --&gt;로마 대문자 순서          +추가 속성          start =&quot;5&quot;-&gt;  순서 5부터 시작          reversed  -&gt;  순서 반대로표 관련 태그 (테이블)table 웹 문서의 자료 정리를 위해 주로 사용행과 열로 이루어져 있어 DB에서 컬럼값이라 불렸던 교차지점이 Cell(셀)이라고 불림Table 태그는 테이블을 나타내는 행과 열이 작성 될 수 있는 영역을 지정한다tr Table Row 한행을 나타내는 태그내부에 tb나 tr로 값을 작성한다tbTable data  cell(==컬럼값) 을 입력하는 태그thtb와 동일하지만 추가적으로 b처리와 가운데 정렬 효과가 있다.caption테이블으 위 혹은 아래에서 제목이나 설명을 추가하는 태그행열 병합 : tb 나 th에 작성하는 속성rowspan : 행 (위아래)로 병합한다colspan : 열(양옆)을 병합한다이때 병합을 넣는 방식은 자기 자신도 포함한다.thead테이블의 상단(컬럼명 제목)tbody테이블의 실질적인 값(내용)tfoot 테이블의 하단(합계등 끝부분)"
155,kh 국비 교육중 수업 외 프로젝트로 진행 해본 프로젝트실질적으로 배운것들은 다 써본 느낌이다JDBC / SQL을 이용해 사용법 숙달에 매우 큰 의미를 두었다처음 해본 혼자만의 힘으로 만든 프로그램인데 만들고 나서 보니깐 개선할 점 밖에 안보인다 나중에 그래픽도 추가하면 더 재미있을 것 같다.
156,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 몰입 상태를 기술함으로써 하루를 파악하기🧨 오늘의 공부 ✅ 알고 있던 기능(내 블로그 링크) ✅ 새로 알게 된 기능(레퍼런스 링크)🎢 학습 소감 ✅ 왜 이런 공부를 하게 되었는지? ✅ 공부한 내용의 난이도는 어땠는지? ✅ 공부한 것을 내 것으로 만들 수 있었는지? ✅ 오늘 다한것과 하지 못한 것, 내일 해야할 것을 적어보기🟠 작성 상태🟠 작성 날짜 : 0429, 2022🟠 작성 프로젝트 : 기획 - Instagram UI 클론코딩🟠 몰입 상태 : ⭐⭐⭐⭐ 매우 몰입함🧨 Today I Learned🧨 알고 있던 기능✍ 2차 목업 작성 : body &gt; main 파트코딩을 최대한 효율적으로 진행하고, 내 생각이 아닌 기획서에 적힌 내용만을 지키면서 코딩하는 연습 계속기획서는 뼈대구조를 착실하게 작성하고 세세한 기능과 UI의 부분은 기능마다 떼어서 작성하기와이어프레임은 큰 틀에서 뼈대를 다 붙여놓고, 세세한 기능을 떼어서 추가하기효율을 위한 작업이므로, 이를 항상 기억하고 코딩효율을 떨어뜨리지 않기🧨 새로 알게 된 기능🔮 HTML 뼈대 구조 작성단순히 정해진 위치에 배치하는 것이 아닌 뼈대 구조를 파악해서 정해진 자리에 정해진 픽셀을 사용해서 배치하기🎢 학습 소감🎢 왜 이런 공부를 하게 되었는가?💋🎶😁🎢 공부한 내용의 난이도는 어땠는가?🎢 공부한 것을 내 것으로 만들 수 있었는가?🎢 오늘 마친 것, 마치지 못한 것, 해야할 것"
157,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 작성 상태를 기술함으로써 수정된 이력 버전과 완성여부를 확인    🖋 기능 설명 ✅ 레퍼런스 링크 ✅ 사용된 기술에 대해 스스로 설명  🔨 프로젝트 적용 ✅ 기획내용 작성, 작성한 계기를 기술 ✅ 프로젝트에 사용한 코드를 한 줄씩 리뷰하는 것으로 코드 전체 이해 증명 ✅ 코드를 설계한 내용과 왜 이렇게 작성했는지 ✅ 완성 코드를 코드펜으로 보여주기🟠 작성 상태🟠 작성 날짜 : 0428, 2022🟠 적용 프로젝트 : 인스타그램 UI 클론코딩🟠 작성 상태 : 작성중🖋 기능 설명🖋 레퍼런스 링크👁‍🗨 파일분리 REF🖋 기능에 대해 설명▶ 파일분리css파일의 경우 &lt;style&gt; 태그, javascript파일의 경우 &lt;script&gt; 태그를 제거한 뒤, 코드를 옮긴다옮긴 파일의 이름을 html파일에 링크로 임포트한다CSS&lt;link rel=&quot;stylesheet&quot; href=&quot;header.css&quot;&gt;Javascript&lt;script src=&quot;placeholder_focus.js&quot;&gt;&lt;/script&gt;🔨 프로젝트 적용🔨 프로젝트 기획, 작성 계기🔨 코드 리뷰👁‍🗨 ver.1.0🔨 완성 코드(CodePen)"
158,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 작성 상태를 기술함으로써 수정된 이력 버전과 완성여부를 확인    🖋 기능 설명 ✅ 레퍼런스 링크 ✅ 사용된 기술에 대해 스스로 설명  🔨 프로젝트 적용 ✅ 기획내용 작성, 작성한 계기를 기술 ✅ 프로젝트에 사용한 코드를 한 줄씩 리뷰하는 것으로 코드 전체 이해 증명 ✅ 코드를 설계한 내용과 왜 이렇게 작성했는지 ✅ 완성 코드를 코드펜으로 보여주기🟠 작성 상태🟠 작성 날짜 : 0428, 2022🟠 적용 프로젝트 : 인스타그램 UI 클론코딩🟠 작성 상태 : 작성중🖋 기능 설명🖋 레퍼런스 링크👁‍🗨 css-tricks REF👁‍🗨 onfocus 기능 REF👁‍🗨 input::placeholder CSS REF👁‍🗨 w3school REF🖋 기능에 대해 설명▶ HTML input taginput tag 는 데이터를 입력할 수 있는 특정한 입력 필드 태그form 엘리멘트인 것이 가장 중요함▶ placeholderinput tag 의 속성 중 하나인 placeholder는 입력할 데이터를 설명하는 힌트 역할을 수행한다.placeholder=&quot;값을 넣어주세요&quot; 와 같이 설정하면 input태그 내용을 넣는 부분에 표시된다.▶ placeholder -&gt; onfocusinput tag 의 속성 중 하나인 onfocus는 placeholder와 함께 적용한다onfocus는 input tag를 클릭하여 커서가 깜빡이는 focus 상태를 의미한다onfocus=&quot;this.placeholder='change text'&quot; 와 같은 형태로 입력하면, 포커스 상태에서의 placeholder 표시 문자열이 변경된다🔨 프로젝트 적용🔨 프로젝트 기획, 작성 계기🔨 코드 리뷰👁‍🗨 ver.1.0🔨 완성 코드(CodePen)"
159,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 몰입 상태를 기술함으로써 하루를 파악하기🧨 오늘의 공부 ✅ 알고 있던 기능(내 블로그 링크) ✅ 새로 알게 된 기능(레퍼런스 링크)🎢 학습 소감 ✅ 왜 이런 공부를 하게 되었는지? ✅ 공부한 내용의 난이도는 어땠는지? ✅ 공부한 것을 내 것으로 만들 수 있었는지? ✅ 오늘 다한것과 하지 못한 것, 내일 해야할 것을 적어보기🟠 작성 상태🟠 작성 날짜 : 0428, 2022🟠 작성 프로젝트 : 기획 - Instagram UI 클론코딩🟠 몰입 상태 : ⭐⭐⭐⭐⭐ 완전히 몰입함🧨 Today I Learned🧨 알고 있던 기능✍ 프로젝트 기획 : 인스타 UI 클론코딩프로젝트에서 작성에 필요한 뼈대 설계 구조부터 필수적인 CSS 속성에 관련한 정보를 대략적으로 작성하기🎨 피그마 와이어프레임 작성 : 인스타 UI 클론코딩기획서와 클론코딩할 프로젝트를 보면서 목업을 작성한다. 각 개체의 크기와 여백을 보면서 따라한다.💾 파일분리 CSS, JavascriptCSS 파일 : link rel=&quot;stylesheet&quot; href=&quot;header.css&quot;JS 파일 : script src=&quot;placeholder_focus.js&quot;&gt;&lt;/script🧨 새로 알게 된 기능🔮 클론코딩 : 기획서를 작성하기 위한 코드 뜯어보기인스타그램 사이트에서 개발자 도구를 열어 요소의 HTML 뼈대구조 확인하기상위, 하위 태그를 보면서 어떻게 작성할 지 확인하기각각 태그를 눌러서 스타일 속성을 확인하기마찬가지로 대략적이지만 해당 태그마다 중요하게 사용된 속성(flex, 크기, 여백, 위치) 확인하기🧩 HTML input tag placeholder 와 onfocus 옵션placeholder는 인풋태그 안에 보여주는 부분onfocus=&quot;this.placeholder='text'&quot; 를 태그 안에 작성하는 것으로 인풋태그를 클릭하면 나오는 문자열 변경 가능😈 자바스크립트 getElement자바스크립트에서 getElement 메서드를 사용하여 html 엘리먼트 값 가져오기엘리먼트값을 활용하여 html 요소를 조작할 수 있음😈 자바스크립트 다른 div를 겹치게 하기요소1과 2가 같은 자리에 위치해야한다면, 둘 다 position: absolute를 사용해야함z-index 값을 올려줘서 원하는 요소를 위로 올림😈 자바스크립트 querySelector자바스크립트에서 querySelector 메서드를 사용하여 html 태그를 값으로 가져올 수 있음태그 안의 값을 상세하게 선택할 수 있음😈 자바스크립트 style.display자바스크립트 style.display() 메서드를 사용하여 태그의 css 값을 수정할 수 있음💾 폰트어썸 라이브러리 임포트폰트어썸 웹사이트에서 아이콘을 사용하기 위해 임포트 코드를 입력하고, 아이콘을 선택해 i 태그 가져오기🎢 학습 소감🎢 왜 이런 공부를 하게 되었는가?💋 탄탄한 기획서와 와이어프레임은 계속 강조해도 지나치지 않았다작성하는것 만으로도 프로젝트를 진행하는데 필요한 목업을 작성하는데 조금 더 망설이는 시간이 줄어들었다.이 후 만들어진 와이어 프레임을 바탕으로 코딩을 시작할 때, 다시 기획서를 들여다 보면서 부족한 부분을 수정하거나 새로 채워넣는 등의 작업이 즐겁고 체계적일 수 있었다.작성한 와이어 프레임을 보면(물론 클론코딩이라는 이미 만들어진 결과물이 있지만) 내가 어떻게 코드를 짜야할 지 감이 온다.와이어 프레임에 공을 들이는 시간이 조금은 아깝다고 생각했지만, 더 세세할 수록 코딩할 때 작업 속도가 확실히 빨라졌다.🎶 자바스크립트로 html의 요소를 자유자재로 조작하기자바스크립트의 기본기를 잘 익혀두어야만 백엔드 프로그래머로서 공부하는데에도 프론트엔드를 프레임워크를 새로 공부하는 일 없이 앞으로도 잘 진행해야한다고 생각했기 때문. 더욱 매끄러운 웹을 사용하는데 있어, 잘 짜여진 뼈대와 미적인 스타일 이외에도 사용자에게 편리한 조작을 제공해야 한다고 생각한다. 개발자가 아닌 사람이 보아도 괜찮을 정도로 잘 다듬어져야 한다고 생각한다.😁 파일분리를 통한 코드 가독성 올리기css, javascript 파일을 분리함으로써, 확인하고 싶은 코드를 더 적은 줄을 스크롤해가면서 원하는 부분을 조금 더 쉽게 찾기 위함파일을 체계적으로 관리하여 프로젝트 파일전체도 직관적이게 하려는 노력🎢 공부한 내용의 난이도는 어땠는가?자바스크립트는 확실히 어려웠고 일부는 실패했지만, 대체적으로 스스로 얻어갈 수 있을 정도는 되었다.🎢 공부한 것을 내 것으로 만들 수 있었는가?오늘은 그래도 내 것으로 만들기 위한 노력을 제대로 완수한 것 같다. 🎢 오늘 마친 것, 마치지 못한 것, 해야할 것오늘 마친것: 기획, 와이어프레임, 헤더 홈버튼, 검색부분마치치 못한것: 헤더 아이콘 부분해야할 것: 바디부분, 미디어쿼리를 활용한 반응형웹, 푸터"
160,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 작성 상태를 기술함으로써 수정된 이력 버전과 완성여부를 확인    🖋 기능 설명 ✅ 레퍼런스 링크 ✅ 사용된 기술에 대해 스스로 설명  🔨 프로젝트 적용 ✅ 기획내용 작성, 작성한 계기를 기술 ✅ 프로젝트에 사용한 코드를 한 줄씩 리뷰하는 것으로 코드 전체 이해 증명 ✅ 코드를 설계한 내용과 왜 이렇게 작성했는지 ✅ 완성 코드를 코드펜으로 보여주기🟠 작성 상태🟠 작성 날짜 : 0428, 2022🟠 적용 프로젝트 : 클론코딩 - 인스타그램 UI, 반응형 웹 - 미디어 쿼리🟠 작성 상태 : 작성중🖋 기능 설명🖋 레퍼런스 링크🖋 기능에 대해 설명▶🔨 프로젝트 적용🔨 프로젝트 기획, 작성 계기🙄 HTML 헤더 기획서🧿 하위구조 (괄호안의 문자열조합은 인스타그램에서 사용되는 클래스로 레퍼런스 참조를 위해 작성)```뼈대 구조 역기획헤더 header헤더 전체로 묶어 가독성 올리기헤더 내부 묶음 div헤더에서 내부 전체를 묶는 용도내비게이션 바 navnav 태그를 적어서 가독성을 올려주기내비게이션 바 div내비게이션 바의 크기, 안쪽/바깥 여백4.1. 내비게이션 바 랩 flex div내비게이션 바 하위 태그의 아이템을 가운데로 정렬헤더 홈버튼 div5.1. 페이지를 이동할 주소가 들어간 a 태그5.2. 아이콘과 검색까지의 간격을 나누는 flex div5.3. 아이콘 이미지를 넣는 div헤더 검색 div5.1. 검색 아이콘, 글자 padding div5.2. 검색 input tag5.2. 가짜 검색 input tag5.3. 가짜검색 인풋 flex div5.4. 검색 아이콘 i5.4. 검색 가짜 플레이스홀더 span5.2. 검색 이후 내용 지우기 아이콘 div5.2. 최근 검색항목 div5.3. 최근 검색항목 뼈대 div헤더 아이콘즈 div5.1. 아이콘 flex div5.2. home 아이콘 div5.3. home 아이콘 i5.2. explore 아이콘 div5.3. explore 아이콘 i5.2. plus 아이콘 div5.3. plus 아이콘 i5.2. heart 아이콘 div5.3. heart 아이콘 i5.2. profile 아이콘 div5.3. profile 아이콘 i✅ CSS 스타일백그라운드 (윈도우 데스크탑 1920.1080세팅)헤더 파트+++가로 100%, 세로 60px+++흰색의 배경+++위아래로 연회색의 보더 실선 1px 2.내비게이션 바+++max-width : 975 px+++padding : 20 px+++display: flex+++flex-direction : row3.홈버튼 div+++width : 333.5 px+++height : 39 px+++disply : flex3.1.홈버튼 아이콘 이미지 div+++가로세로 3.검색버튼 div+++width : 268 px+++height : 36 px4.검색인풋 태그+++가로 268 세로 36+++fontsize : 16px+++padding : 0 16px5.검색인풋내부 6.검색인풋내부 내부 아이콘 배치 부분+++display:flex7.검색 아이콘+++box-sizing : border-box+++align-items : stretch7.검색내용 지우기 아이콘+++가로세로 20!! 그만 더 길게 작성하기. 물고 늘어지지 말고 최대한 간결하게3.아이콘 div+++width : 333.5px+++height : 24px4.아이콘배치+++아이콘 크기는 24x24+++아이콘 마다 왼쪽 바깥여백 24px✨ 내가 느낀 특이점헤더 부분에서 아이콘을 포함한 상위 태그에서 간격까지 잡음 + FLEX 설정간격 안에서 하위태그(이미지, 아이콘)가 오른쪽, 왼쪽으로 딱 붙는 CSS 설정HTML 바디 기획서하위구조```메인 body스토리필드 field_story프레젠테이션 div   wrap_presentation프레젠테이션 프로필 div   presentation_profile프로필 이미지 div   presentation_profile_image프로필 이름 a     presentation_profile_name스토리카드 div    wrap_storycards스토리카드 상단 div   storycards_top스토리카드 상단 flex div    storycards_flex스토리카드 상단 프로필 div    storycards_profile스토리카드 프로필 이미지 div    stroycards_profile_image스토리카드 프로필 이름 div     storycards_profile_name스토리카드 상단 옵션 div     storycards_option스토리카드 중단 div     storycards_middle스토리카드 중단 캐러셀 div     storycards_carresel스토리카드 캐러셀 이미지 div storycards_carresel_image스토리카드 중단 이미지 넘기기 아이콘 div     storycards_nextimage스토리카드 중단 태그 유저 아이콘 div       storycards_taguser스토리카드 중단 음소거 아이콘 div     storycards_muteicon스토리카드 중단 아이콘즈 div        storycards_icons스토리카드 아이콘즈 flex div      storycards_icons_flex스토리카드 레프트 아이콘 div        storycards_icons_left스토리카드 레프트 아이콘 하트 div     storycards_icons_left_heart스토리카드 레프트 아이콘 코멘트 div    storycards_icons_left_comment스토리카드 레프트 아이콘 익스플로어 div      storycards_icons_left_explore스토리카드 미들 아이콘 div         storycards_icons_middle스토리카드 미들 아이콘 스테이터스 div   storycards_icons_middle_status스토리카드 라이트 아이콘 div        storycards_icons_right스토리카드 라이트 아이콘 북마크 div        storycards_icons_right_bookmark스토리카드 하단 div     storycards_bottom스토리카드 하단 좋아요 div     storycards_bottom_likes스토리카드 하단 좋아요 스팬      storycards_bottom_likes_span스토리카드 하단 좋아요 개수      storycards_bottom_likes_count스토리카드 하단 스토리 div     storycards_bottom_story스토리카드 하단 스토리 아이디 div     storycards_bottom_story_user스토리카드 하단 스토리 내용 div      storycards_bottom_story_simple스토리카드 하단 스토리 더보기 버튼 div      storycards_bottom_story_morebtn스토리카드 하단 스토리 작성일자 div    storycards_bottom_story_post스토리카드 하단 댓글 div      storycards_bottom_comment스토리카드 하단 댓글 이모지 추가 div       storycards_bottom_comment_emoji스토리카드 하단 댓글 인풋 div           storycards_bottom_comment_input스토리카드 하단 댓글 게시버튼 div     storycards_bottom_comment_postbtn푸터필드 field_footer푸터 flex div  footer_flex푸터 프로필 div       footer_profile푸터 프로필 flex div  fotter_profile_flex푸터 프로필 이미지 div       footer_profile_image푸터 프로필 유저 div    footer_profile_user푸터 프로필 유저 닉네임    footer_profile_user_nickname푸터 프로필 유저 이름     footer_profile_user_name푸터 프로필 전환 div        footer_profile_user_change푸터 추천 div        footer_recommend푸터 추천 상단부    footer_recommend_top푸터 추천 소개     footer_recommend_top_intro푸터 추천 보기     footer_recommend_top_view푸터 추천 중단부    footer_recommend_middle푸터 추천 플렉스 div    footer_recommend_middle_flex푸터 추천 리스트 묶음 div     footer_recommend_middle_list푸터 추천 리스트 이미지 div       footer_recommend_middle_list_image푸터 추천 리스트 유저 div     footer_recommend_middle_list_user푸터 추천 리스트 유저 닉네임     footer_recommend_middle_list_user_nickname푸터 추천 리스트 유저 추천이유        footer_recommend_middle_list_user_reason푸터 추천 리스트 팔로우 div        footer_recommend_middle_list_follow푸터 정보 div        footer_info푸터 정보 내비게이션 div          footer_info_nav푸터 내비게이션 리스트         footer_info_list푸터 정보 회사이름 div           footer_info_corp```와이어프레임코딩🎨 피그마 헤더 목업 Figma Mockup🔨 코드 리뷰👁‍🗨 ver.1.0🔨 완성 코드(CodePen)!codepenmigdracios/embed/ExoqJKG?default-tab=html%2Cresult"
161,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 몰입 상태를 기술함으로써 하루를 파악하기🧨 오늘의 공부 ✅ 알고 있던 기능(내 블로그 링크) ✅ 새로 알게 된 기능(레퍼런스 링크)🎢 학습 소감 ✅ 왜 이런 공부를 하게 되었는지? ✅ 공부한 내용의 난이도는 어땠는지? ✅ 공부한 것을 내 것으로 만들 수 있었는지? ✅ 오늘 다한것과 하지 못한 것, 내일 해야할 것을 적어보기🟠 작성 상태🟠 작성 날짜 : 0427, 2022🟠 작성 프로젝트 : 배틀체스🟠 몰입 상태 : ⭐⭐⭐⭐⭐ 완전히 몰입함🧨 Today I Learned🧨 알고 있던 기능✍ 프레젠테이션 자료 조사 및 작성🧐 프로젝트 배틀체스 프레젠테이션 링크🎅 깃허브 특강깃허브를 왜 써야 하는가? : 🐱‍🚀버전관리/협업현업에서 깃허브를 한다고 하면 어딜 볼까? : README.md, 커밋 히스토리, 깃허브위키커밋 메시지 작성의 중요성파일, 날짜, 작성자 등의 정보는 이미 나온다! 작성하면 오히려 '신경을 안썼다' 라고 느끼게 된다!파일을 자세하게 어떻게 추가했는지 작성하자6개월 뒤에 커밋 메시지를 봐도 이해할 수 있게끔브로큰 잉글리시로 작성할거면 한글로 써라확실하게 적거나, 영어 베이스에서 협업할 것이 아니라면 추천함🧨 새로 알게 된 기능🤔 프로젝트 배틀체스의 KPT🧐 프로젝트 배틀체스 프레젠테이션 링크🎢 학습 소감🎢 왜 이런 공부를 하게 되었는가?프로젝트를 진행하고 취합해 발표하면서 자연스럽게 내가 지나왔던 개발의 시간들, 노력들을 리마인드하게 됨깃허브 특강을 통해서 깃허브에 대한 기본기를 리마인드🎢 공부한 내용의 난이도는 어땠는가?객관적인 피드백에 대한 내용은 그렇게 어렵지 않았다. 시간 안에 결과물을 해결했는가, 기획과 목업 작성의 기반을 잘 해결했는가로 판단할 수 있었음🎢 공부한 것을 내 것으로 만들 수 있었는가?오늘 결과물은 개발일지를 정리함으로써 내 것으로 만들 수 있었던 것 같다. 그러나 전체 프로젝트와는 별개의 이야기로, 코드를 리뷰하는 시간으로 전체 프로젝트를 더 내 것으로 만들기 위한 노력을 계속해야 한다🎢 오늘 마친 것, 마치지 못한 것, 해야할 것오늘 마친 것: 프로젝트 프레젠테이션마치지 못한 것: 개발일지 정리해야할 것: 개발일지 마무리"
162,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 작성 상태를 기술함으로써 수정된 이력 버전과 완성여부를 확인    🖋 기능 설명 ✅ 레퍼런스 링크 ✅ 사용된 기술에 대해 스스로 설명  🔨 프로젝트 적용 ✅ 기획내용 작성, 작성한 계기를 기술 ✅ 프로젝트에 사용한 코드를 한 줄씩 리뷰하는 것으로 코드 전체 이해 증명 ✅ 코드를 설계한 내용과 왜 이렇게 작성했는지 ✅ 완성 코드를 코드펜으로 보여주기🟠 작성 상태🟠 작성 날짜 : 0427, 2022🟠 적용 프로젝트 : 아침 퀴즈, 전력계산기🟠 작성 상태 : 수정됨 (0428, 2022)🖋 기능 설명🖋 레퍼런스 링크✍ 퀴즈 설명😁 해설🖋 기능에 대해 설명▶ 파이썬의 함수▶ 리팩터링에 대해서🔨 프로젝트 적용🔨 프로젝트 기획, 작성 계기🔨 코드 리뷰👁‍🗨 ver.1.0🔨 완성 코드(CodePen)# 전기 사용량# 전기 사용량 별 요금을 계산하기#   100이하, 100초과, 200초과, 400초과 500초과# 설계#   전력 사용량의 가격책정#   만약 전력이 150Kwh라면 (100*60.7)+(50*125.9)과 같이 수식을 작성하고 이를 그대로 코드로 옮겨주기기# 출력# =========================#  주택용 전기요금(저압) 계산기# =========================# 99kWh의 전기 요금은 6009.3원 입니다.# 150kWh의 전기 요금은 12365.0원 입니다.# 저압의 경우 100kWh 이하는 kWh당 60.7원,# 100kWh 초과는 125.9원,# 200kWh 초과는 187.9원,# 300kWh 초과는 280.6원,# 400kWh 초과는 417.7원,# 500kWh초과는 670.6원의 전력량 요금을 내야한다.use = 99,150rate = 0print('=========================')print('주택용 전기요금(저압) 계산기')print('=========================')def CalcFee(use):    global rate    if use &lt;= 100:        rate = use * 60.7    elif use &gt; 100:        rate = 100 * 60.7 + (use - 100) * 125.9    elif use &gt; 200:        rate = 100 * 60.7 + 100 * 125.9 + (use - 200) * 187.9    elif use &gt; 300:        rate = 100 * 60.7 + 100 * 125.9 + 100 * 187.9 + (use - 300) * 280.6    print(f'{use}kWh의 전기 요금은 {rate}원 입니다.')for i in use:    CalcFee(i)"
163,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 몰입 상태를 기술함으로써 하루를 파악하기🧨 오늘의 공부 ✅ 알고 있던 기능(내 블로그 링크) ✅ 새로 알게 된 기능(레퍼런스 링크)🎢 학습 소감 ✅ 왜 이런 공부를 하게 되었는지? ✅ 공부한 내용의 난이도는 어땠는지? ✅ 공부한 것을 내 것으로 만들 수 있었는지? ✅ 오늘 다한것과 하지 못한 것, 내일 해야할 것을 적어보기🟠 작성 상태🟠 작성 날짜 : 0426, 2022🟠 작성 프로젝트 : 나도코딩 메모리게임, 나도코딩 오락실게임🟠 몰입 상태 : ⭐⭐⭐⭐ 매우 몰입함🧨 Today I Learned🧨 알고 있던 기능pygame 캐릭터 위치 지정pygame 오브젝트 추가 blit🧨 새로 알게 된 기능pygame 로직 설계🎢 학습 소감🎢 왜 이런 공부를 하게 되었는가?pygame을 활용한 본격적인 프로젝트 안에서 함수 및 기능을 추가하고, 보수하는 작업을 지속적으로 이어나갔다.🎢 공부한 내용의 난이도는 어땠는가?어려웠다. 머리를 잡아가며, 몇시간이고 로직에만 끙끙댔던 기억이 있다.🎢 공부한 것을 내 것으로 만들 수 있었는가?🎢 오늘 마친 것, 마치지 못한 것, 해야할 것"
164,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 작성 상태를 기술함으로써 수정된 이력 버전과 완성여부를 확인    🖋 기능 설명 ✅ 레퍼런스 링크 ✅ 사용된 기술에 대해 스스로 설명  🔨 프로젝트 적용 ✅ 기획내용 작성, 작성한 계기를 기술 ✅ 프로젝트에 사용한 코드를 한 줄씩 리뷰하는 것으로 코드 전체 이해 증명 ✅ 코드를 설계한 내용과 왜 이렇게 작성했는지 ✅ 완성 코드를 코드펜으로 보여주기🟠 작성 상태🟠 작성 날짜 : 0427, 2022🟠 적용 프로젝트 : python project - Battle Chess🟠 작성 상태 : 수정됨 (0428, 2022)🖋 기능 설명🖋 레퍼런스 링크나도코딩 기억력게임나도코딩 오락실게임🖋 기능에 대해 설명▶ Pygame 초기 세팅▶ Pygame 러닝 루프문▶ Pygame 오브젝트 위치 지정▶ Pygame 오브젝트 충돌🔨 프로젝트 적용🔨 프로젝트 기획, 작성 계기🔨 코드 리뷰🔨 완성 코드(CodePen)🛠 피그마 목업 LINK"
165,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 작성 상태를 기술함으로써 수정된 이력 버전과 완성여부를 확인    🖋 기능 설명 ✅ 레퍼런스 링크 ✅ 사용된 기술에 대해 스스로 설명  🔨 프로젝트 적용 ✅ 기획내용 작성, 작성한 계기를 기술 ✅ 프로젝트에 사용한 코드를 한 줄씩 리뷰하는 것으로 코드 전체 이해 증명 ✅ 코드를 설계한 내용과 왜 이렇게 작성했는지 ✅ 완성 코드를 코드펜으로 보여주기🟠 작성 상태🟠 작성 날짜 : 0427, 2022🟠 적용 프로젝트 : python project - Battle Chess🟠 작성 상태 : 수정됨 (0428, 2022)🖋 기능 설명🖋 레퍼런스 링크🖋 기능에 대해 설명▶🔨 프로젝트 적용기본초기화사용자 게임초기화게임 캐릭터 위치 정의충돌 처리화면에 그리기🔨 프로젝트 기획, 작성 계기기본초기화사용자 게임 초기화배경화면1200*1000 크기의 격자 체스판과 좌측 및 상단의 여백 대시보드게임이미지배경화면 이미지 1000*1000체스 셀 크기 100*100플레이어 피스 이미지 85*85에너미 피스 이미지 85*85에너미 킹 피스 이미지 85*85일시정지 이미지 85*85타이틀 바, 남은턴, 아이템 이미지 200*200스테이지, 남은턴설명, 아이템설명, 일시정지 테두리 이미지 200*100좌표격자크기 : 100격자 이미지 위치 : (200,0)타이틀 테두리 위치 : (0,0)스테이지 테두리 위치 : (0,200)남은턴 테두리 위치 : (0,300)남은턴설명 테두리 위치 : (0,500)아이템 테두리 위치 : (0,600)아이템설명 테두리 위치 : (0,800)일시정지 테두리 이미지 위치 : (0,900)타이틀 위치스테이지 위치남은턴 위치남은턴 설명 위치아이템 위치아이템 설명 위치일시정지 위치x좌표: 여백(100) + 격자크기(100)*column(a)y좌표: 여백(100) + 격자크기(100)*row(b)폰트없음 기본속도100만큼 1초에 1번 움직일것(체스피스가 움직이듯이 딱딱한 모션)색상값갈색(타이틀이미지) : (206,135,87)검정색 : (0,0,0)진회색 : (49,49,49)회색 : (196,196,196)녹색 : (43,255,51)푸른색 : (0,71,255)빨간색 : (255,0,0)흰색 : (255,255,255)게임 캐릭터 위치 정의플레이어 피스와 에너미 피스는 레벨에 따라 자리 잡아주기턴에 따라 에너미 피스는 정해진 움직임으로 이동충돌 처리플레이어 피스는 상하좌우로 맞닿은 에너미 피스의 방향을 향해 이동하는 것으로 에너미 피스를 공격할 수 있다.플레이어 피스에 공격을 당한 에너미 피스는 방어력 - 공격력 만큼 피해를 받으며, 방어력 수치가 0이 되면 파괴된다.플레이어 피스가 에너미 피스를 공격하면 공격 사운드가 나온다에너미 피스의 방어력 수치가 0이되면 파괴 사운드가 나오며 에너미 피스를 화면에서 지운다.화면에 그리기배경이미지 그리기대시보드 그리기(스테이지, 제한 이동수, 일시정지)플레이어 피스 그리기에너미 피스 그리기조건 - 이동 시 피스 그린 것을 지웠다가 이동된 위치로 다시 그리기조건 - 파괴된 피스를 지우기스테이지 클리어 화면 그리기조건 - 스테이지 클리어 화면 이후 다음 스테이지를 보여주기(1,2,3,4)규칙 정의플레이어는 10*10의 보드 위에서 제한 이동 수 내에 킹 피스를 공격해야 함플레이어 피스는 한 칸씩 움직일 수 있음플레이어 피스는 공격력이 있고, 에너미 피스는 방어력이 있음에너미 피스는 킹 피스를 방어하려 둘러쌈플레이어 피스는 보드에 랜덤으로 배치된 아이템 격자로 이동해 특수한 효과를 일시적으로 얻을 수 있다.결론 : 플레이어는 캐릭터 피스와 아이템을 활용하여 제한 이동 수 내에 킹 피스를 쓰러뜨려야 한다!🔨 코드 리뷰🔨 완성 코드(CodePen)🛠 피그마 목업 LINK"
166,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 몰입 상태를 기술함으로써 하루를 파악하기🧨 오늘의 공부 ✅ 알고 있던 기능(내 블로그 링크) ✅ 새로 알게 된 기능(레퍼런스 링크)🎢 학습 소감 ✅ 왜 이런 공부를 하게 되었는지? ✅ 공부한 내용의 난이도는 어땠는지? ✅ 공부한 것을 내 것으로 만들 수 있었는지? ✅ 오늘 다한것과 하지 못한 것, 내일 해야할 것을 적어보기🟠 작성 상태🟠 작성 날짜 : 0425, 2022🟠 작성 프로젝트 : 나도코딩 메모리게임, 나도코딩 오락실게임🟠 몰입 상태 : ⭐⭐⭐⭐ 매우 몰입함🧨 Today I Learned🧨 알고 있던 기능🧨 새로 알게 된 기능pygame 라이브러리🎢 학습 소감🎢 왜 이런 공부를 하게 되었는가?본격적으로 파이썬을 공부하기 앞서 파이썬의 문법 기본기와 파이썬 라이브러리 중 하나인 파이게임을 임포트 해서 끌어다 쓰는 법을 연마하기로 했다.🎢 공부한 내용의 난이도는 어땠는가?확실한 건, 어제보다 머리가 제대로 쪼개졌고, 오늘의 나는 파이썬에게 제대로 졌다...아직까지도 이유를 파악하기 어렵다. 파이썬이 제대로 머리에 안 들어왔거나, 내가 로직을 제대로 설계할 수 없을 정도로 사고력이 약하다고 밖에는...🎢 공부한 것을 내 것으로 만들 수 있었는가?어제의 답을 한다면, 역시 그렇지 않다. 더 많은 시간을 몰입하는 것으로 우선은 도전해야 겠다.🎢 오늘 마친 것, 마치지 못한 것, 해야할 것마친것 나도코딩 기억력 게임 마치지 못한 것 나도코딩 아케이드 게임해야할 것 미니프로젝트 기획, 설계, 목업"
167,링크
168,"정적 사이트 배포 사이트인 Netlify를 알게 되었고, HTML/CSS/JS 파일 만을 올려서 배포할 수 있지만, 기본적으로 무료라는 이유로 한번 배포를 시도해보게 되었다. 로컬 업로드 이슈로컬로 업로드를 시도하면 Uploding 이라는 메시지와 함께, 30분을 넘게 기다려도 배포는 커녕 사이트를 열어도 묵묵부답이라, 나는 프로젝트를 저장한 github 저장소를 링크하여 배포를 시도했다.업로드 폴더 구조넷리파이는 html 파일이 포함된 폴더를 업로드 해야 제대로 구동한다.🗂업로드할 프로젝트 폴더---🧩HTML 파일---🗂static 폴더---------🗂css 폴더---------------🧩css 파일---------🗂js 폴더---------------🧩js 파일---------🗂img 폴더---------------🧩img 파일깃허브 권한설정 및 연결넷리파이 디플로이 설정에서 깃허브 연결권한 설정 및 레포지토리 선택 - all reponetlify deploy settingsbase directory : templates/build command : (공백)publish directory : templates/디플로이 트라이 및 연결 확인"
169,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 작성 상태를 기술함으로써 수정된 이력 버전과 완성여부를 확인    🖋 기능 설명 ✅ 레퍼런스 링크 ✅ 사용된 기술에 대해 스스로 설명  🔨 프로젝트 적용 ✅ 기획내용 작성, 작성한 계기를 기술 ✅ 프로젝트에 사용한 코드를 한 줄씩 리뷰하는 것으로 코드 전체 이해 증명 ✅ 코드를 설계한 내용과 왜 이렇게 작성했는지 ✅ 완성 코드를 코드펜으로 보여주기🟠 작성 상태🟠 작성 날짜 : 0422, 2022🟠 적용 프로젝트 : 파이썬 기본문법 뽀개기 깃허브 링크🟠 작성 상태 : 작성 중🖋 기능 설명🖋 레퍼런스 링크🖋 기능에 대해 설명▶ 튜플 자료형리스트와 같은데 불변형이다!()괄호형태a_tuple = ('사과', '감', '배')a1 = '수박'print(a_tuple)▶ 집합 자료형중복을 허용하지 않는 자료형문자열 등을 set()을 통해 중복 없는 문자 집합으로 구성할 수 있음교집합, 차집합, 합집합 등을 구할 수 있음!교집합 &amp;차집합 - 합집합 |a = 1,2,3,4,5,1,2,3b = 5,6,7,8,9,5,6,7print(set(a), set(b))c = set(a) &amp; set(b)d = set(a) - set(b)e = set(a) | set(b)print(c,d,e)▶ f-string변수와 문자를 한 번에 작성할 수 있음f'문자열 내용' 의 형태로 작성함변수의 경우 f'{변수}문자열' 와 같은 형태로 넣어줌scores =   {'name':'영수','score':70},  {'name':'영희','score':65},  {'name':'기찬','score':75},  {'name':'희수','score':23},  {'name':'서경','score':99},  {'name':'미주','score':100},  {'name':'병태','score':32}for s in scores:  name = s'name'  score = s'score'  # print(name+' 의 점수는 '+str(score)+' 점 입니다')  print(f'{name}(이)의 점수는 {str(score)}점 입니다!!!')▶ try-except코드에서 에러가 발생할 경우를 상정하고 작성try, except 마다 각각 코드 작성  try:      if s'age' &lt; 20:          print(s'name')  except:      print(s'name'+': Error')▶ 파이썬 파일 임포트분리해 작성한 파이썬 파일을 메인으로 실행할 파일에 넣고 싶을 때 사용라이브러리 임포트와 형식이 비슷하다from (파일 이름) import (내용)def say_hi():  print('안녕')def say_hi_to(name):    print(f'{name}님 안녕하세요!')from side_func import *say_hi_to('철수')### ▶ 삼항연산자- 코드를 한 줄로 작성할 수 있게함num = 3미적용if num % 2 == 0:    result = '짝수'else:    result = '홀수'삼항연산자result = ('짝수' if num%2==0 else '홀수')print(f'{num}은 {result}입니다')a_list = 1,3,5,7,9b_list =a*2 for a in a_listprint(b_list)### ▶ map- 반복문이 선언되지 않은 리스트데이터를 인자로 받아 반복문처럼 리스트 내부를 돌면서 값을 반환함- 리스트로 묶어주어야 프린트 할 수 있음def is_adult(person):    return ('성인' if person'age'&lt; 20 else '미성년')result = map(is_adult, people)print(list(result))### ▶ lambda- 함수를 def로 선언하지 않고 임시로 작성할 수 있게하는 함수- 위의 map, 삼항연산자와 혼용하여 반복문, 함수 선언 없이 한 줄로 작성 가능result = map(lambda person: ('성인' if person'age'&lt; 20 else '미성년'), people)### ▶ filter- map과 유사한 방식으로, 필터 조건이 참인 값만 돌려줌result = filter(lambda person: person'age'&gt;20, people)### ▶ class- 게임예시: 몬스터의 HP를 프로그램으로 관리할 때, 전부 일괄적으로 보여줘야 할까, 몬스터 마다 HP를 달아줘야 할까?- 100, 1000개의 데이터를 관리한다면 하나씩 붙여주는 것이 직관적이다. 이를 객체 지향이라고 함- 클래스는 효과적으로 객체 지향 코딩을 할 수 있게 해주는 것- 클래스 밖에서 사용되는 변수를 인스턴스라고 부름 class Monster():    hp = 100    alive = Truedef damage(self, attack):    self.hp = self.hp - attack    if self.hp == 0:        self.alive = Falsedef status(self):    if self.alive:        print('살아있음')    else:        print('죽었음')m1 = Monster()m1.damage(150)m1.status()# 🔨 프로젝트 적용---## 🔨 프로젝트 기획, 작성 계기## 🔨 코드 리뷰### 👁‍🗨 ver.1.0## 🔨 완성 코드(CodePen)"
170,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 몰입 상태를 기술함으로써 하루를 파악하기🧨 오늘의 공부 ✅ 알고 있던 기능(내 블로그 링크) ✅ 새로 알게 된 기능(레퍼런스 링크)🎢 학습 소감 ✅ 왜 이런 공부를 하게 되었는지? ✅ 공부한 내용의 난이도는 어땠는지? ✅ 공부한 것을 내 것으로 만들 수 있었는지? ✅ 오늘 다한것과 하지 못한 것, 내일 해야할 것을 적어보기🟠 작성 상태🟠 작성 날짜 : 0424, 2022🟠 작성 프로젝트 : 파이썬 기본기🟠 몰입 상태 : ⭐⭐⭐⭐ 매우 몰입함🧨 Today I Learned🧨 알고 있던 기능▶ len()문자열의 길이를 알려주는 코드.text = 'abcdefg'a = len(text)print(a = 7)▶ split()문자열을 특정 문자를 기준으로 잘라 리스트로 출력하는 코드text = 'abc123@gmail.com'email = text.split('@')print(email = '{'abc123','gmail.com'})### ▶ append()- 리스트 자료형의 데이터를 추가하는 코드a_list = 1,2,3a_list.append(4)print(a_list = '1,2,3,4')### ▶ 파이썬 ## 🧨 새로 알게 된 기능 ### ▶ str()- 문자열로 만들어주는 코드.a = '2'b = str(2)print(a+b = '22')### ▶ 텍스트 슬라이스 texta:b- 문자열을 원하는 부분만큼 잘라내는 기능- 몇번째부터 몇번째까지 선언할 숫자가 필요함text = 'abcdefg'result = text:3print(result = 'abc')result2 = text3:print(result = 'defg')### ▶ sort()- 데이터의 내용을 정렬하는 기능- 기본 오름차순으로 정렬하며, 내림차순으로 정렬 할 때는 reverse=Truea_list = 1,2,5,7,3asc = a_list.sort()desc = a_list.sort(reverse=True)print(asc, desc)### ▶ (a in b)- b 자료형 안에 a라는 값이 있다면 ... 참, 거짓 값을 되돌려줌a_list = 1,2,3b = 4result = (b in a_list)print(result,'False')### ▶ Netlify 배포(https://velog.io/@migdracios/%EB%B0%B0%ED%8F%AC-Netlify-%EB%B0%B0%ED%8F%AC-%EC%8B%9C%EB%8F%84%ED%95%98%EA%B8%B0)### ▶ enumerate, break- 반복문을 사용하는 중, enumerate를 사용하여 요소의 순서를 지정해 줄 수 있음- break를 이용해 반복문 중의 요소를 중간에 끊어줄 수 있음# 🎢 학습 소감---## 🎢 왜 이런 공부를 하게 되었는가?- Django AI 를 공부해야하는 커리큘럼에서 python의 기본기는 몇 번을 강조하더라도 지나칠 수 없다. 따라서, 알고 있는 기본기를 더욱 단단하게 다지는 시간을 가지면서, 단순히 구현할 수 있다 없다 수준을 넘는, 스스로 이해하고 코드를 짤 수 있는 기반 마련이 중요하다고 생각했다.## 🎢 공부한 내용의 난이도는 어땠는가?  - 전체적으로 아는 내용과 조금 더 심화된 내용이 섞인 구성의 공부였기에, 조금은 머리를 싸매가면서 공부했던 시간이었다. 하나도 모르는 소리는 아니었기에, 몰입을 즐기면서 할 수 있었다.## 🎢 공부한 것을 내 것으로 만들 수 있었는가?- 정확하게는 아직은 그렇지 않은 것 같다. 기본적인 기능에 대한 추가적인 설명을 이해했을 뿐, 오늘 하루에 걸쳐서는 여러 방편으로 적용해 보지 못했기 때문이다.## 🎢 오늘 마친 것, 마치지 못한 것, 해야할 것- 마친것 파이썬 기본기 강의 완강- 마치지 못한 것 사전과제 프로젝트 수행- 사전과제 프로젝트 수행 및 코드리뷰"
171,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 몰입 상태를 기술함으로써 하루를 파악하기🧨 오늘의 공부 ✅ 알고 있던 기능(내 블로그 링크) ✅ 새로 알게 된 기능(레퍼런스 링크)🎢 학습 소감 ✅ 왜 이런 공부를 하게 되었는지? ✅ 공부한 내용의 난이도는 어땠는지? ✅ 공부한 것을 내 것으로 만들 수 있었는지? ✅ 오늘 다한것과 하지 못한 것, 내일 해야할 것을 적어보기🟠 작성 상태🟠 작성 날짜 : 0423, 2022🟠 작성 프로젝트 : Team Oldboy - Team Intro Web🟠 몰입 상태 : ⭐⭐⭐ 적당히 몰입함🧨 Today I Learned🧨 알고 있던 기능▶ TIL 작성 수정한번에 작성할 수 있게끔, 프레임을 만들어 두었다.🧨 새로 알게 된 기능▶ 벨로그 Codepen embed레퍼런스 링크코드펜에 로그인 한 뒤 새 코드펜을 만들고 iFrame으로 embed 링크를 적어주면 된다.🎢 학습 소감🎢 왜 이런 공부를 하게 되었는가?🤔 확실하게 블로그에 작성한 코드를 나조차도 다시 훑어볼 수 있는 일목요연한 구성이 필요했다. 한 번 정성들여 써도 다시 읽지 못한다면 무용지물 아니겠는가.🎢 공부한 내용의 난이도는 어땠는가?🤣 초고에서 아주 여러번 수정하긴 했지만 블로그를 작성하는 것 자체는 시간이 드는 것을 제외하면 그렇게 어렵지 않았다. 🎢 공부한 것을 내 것으로 만들 수 있었는가?👍 그렇다. 개발일지 작성프레임을 만들어 블로그에 포스팅하는 노력을 최소한으로 줄이고, 공부하는 데에 더욱 집중할 수 있도록 해 보았다.🎢 오늘 마친 것, 마치지 못한 것, 해야할 것🎯 마친 것 : 블로그 작성 프레임 만들기🎯 마치치 못한 것 : 모든 프로젝트 기능 설명에 적용하지 못했음🎯 해야할 것 : 주말까지 파이썬 강의 수강 완료 및, 사전 과제 제출하기"
172,작성 중
173,작성 중
174,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 몰입 상태를 기술함으로써 하루를 파악하기🧨 오늘의 공부 ✅ 알고 있던 기능(내 블로그 링크) ✅ 새로 알게 된 기능(레퍼런스 링크)🎢 학습 소감 ✅ 왜 이런 공부를 하게 되었는지? ✅ 공부한 내용의 난이도는 어땠는지? ✅ 공부한 것을 내 것으로 만들 수 있었는지? ✅ 오늘 다한것과 하지 못한 것, 내일 해야할 것을 적어보기🟠 작성 상태🟠 작성 날짜 : 0421, 2022🟠 작성 프로젝트 : 프로젝트 링크🟠 몰입 상태 : ⭐⭐⭐⭐⭐ 완전 몰입함🧨 Today I Learned🧨 알고 있던 기능▶ 기능 1 내 블로그 링크🧨 새로 알게 된 기능▶ 기능 2 레퍼런스 링크🎢 학습 소감🎢 왜 이런 공부를 하게 되었는가?🎢 공부한 내용의 난이도는 어땠는가?🎢 공부한 것을 내 것으로 만들 수 있었는가?🎢 오늘 마친 것, 마치지 못한 것, 해야할 것"
175,"작성 규칙🟠 작성 상태 ✅ 작성한 날짜를 기록함으로써 리마인드 ✅ 작성한 프로젝트를 기록함으로써 프로젝트를 찾아볼 수 있음 ✅ 작성 상태를 기술함으로써 수정된 이력 버전과 완성여부를 확인    🖋 기능 설명 ✅ 레퍼런스 링크 ✅ 사용된 기술에 대해 스스로 설명  🔨 프로젝트 적용 ✅ 기획내용 작성, 작성한 계기를 기술 ✅ 프로젝트에 사용한 코드를 한 줄씩 리뷰하는 것으로 코드 전체 이해 증명 ✅ 코드를 설계한 내용과 왜 이렇게 작성했는지 ✅ 완성 코드를 코드펜으로 보여주기🟠 작성 상태🟠 작성 날짜 : 0421, 2022🟠 적용 프로젝트 : Team Oldboy - Team Intro Web🟠 작성 상태 : 수정됨 (0422, 2022)🖋 기능 설명🖋 레퍼런스 링크🖋 기능에 대해 설명▶ querySelector().offsetTop 활용🔨 프로젝트 적용🔨 프로젝트 기획, 작성 계기🔨 코드 리뷰👁‍🗨 ver.1.0🔨 완성 코드(CodePen)"
176,"구현 하는데는 어렵지 않았는데, 마지막 엣지케이스를 생각을 못해서 애먹었다. 실제 시험장에선 발견 못했을 엣지케이스..def explode():    global ans    stack = 0    prev_val = 0    boom = False    for i in range(0, N*N):        pos = number_posi        y, x = pos // N, pos % N        val = boardyx        if val == 4: continue        if val == 0: # 이 부분이 틀림!            break        if prev_val == val:            stack += 1        else:            if stack &gt;= 4:                # i-stack ~ i-1 boom                boom = True                for j in range(i-stack, i):                    boom_pos = number_posj                    by, bx = boom_pos // N, boom_pos % N                    boardbybx = 0                ans += (stack) * prev_val            prev_val = val            stack = 1    return boom틀린 explode 함수이다.내가 놓친 것0이 등장하면 끝나야하는건 맞다. 그러나, 폭발을 하고 끝나야 한다.만약 끝까지 같은 번호의 구슬들이 존재한다면, 마지막 점에서 폭발을 해주어야 한다.def explode():    global ans    stack = 0    prev_val = 0    boom = False    for i in range(0, N*N):        pos = number_posi        y, x = pos // N, pos % N        val = boardyx        if val == 4: continue        if val == 0:            # 폭발하고 BREAK!            if stack &gt;= 4:                # i-stack ~ i-1 boom                boom = True                for j in range(i-stack, i):                    boom_pos = number_posj                    by, bx = boom_pos // N, boom_pos % N                    boardbybx = 0                ans += (stack) * prev_val            stack = 0            break        else:            if prev_val == val:                stack += 1            else:                if stack &gt;= 4:                    # i-stack ~ i-1 boom                    boom = True                    for j in range(i-stack, i):                        boom_pos = number_posj                        by, bx = boom_pos // N, boom_pos % N                        boardbybx = 0                    ans += (stack) * prev_val                prev_val = val                stack = 1    # if stack left    if stack &gt;= 4:        boom = True        for j in range(N*N-1-stack, N*N):            boom_pos = number_posj            by, bx = boom_pos // N, boom_pos % N            boardbybx = 0        ans += (stack) * prev_val    return boom앞선 단계에서 이동을 해서 중간에 위치하는 0들을 다 밀어냈기 때문에, 0이 나오면 끝나야 하는 것은 맞다. 그러나! 폭발을 하고 끝내야 하므로 if문을 추가해주었다. 0이 나와서 루프문을 빠져나왔을 땐 끝까지 진행하고 나왔을 때와 구별하기 위해 스택을 비워주었다.또한 stack의 값만큼 같은 번호들이 존재하므로 만약 스택이 남아있으며 스택 카운팅 값이 4이상이면 폭발이 안일어나고 끝 점까지 같은 번호인 구슬들이 존재해서 나온 것이므로, 마지막에서 스택을 뺀 점부터 마지막 점까지 폭발을 일으켜준다.이렇게 진행하는 유형의 구현 문제는 마지막 점을 항상 신경써야겠다!!!"
177,"온풍기 안녕! 문제를 풀면서 새롭게 알게된 것이다..벽으로 막고 있는지 따지는 것이 키 포인트였다. 이걸 일반화하기가 너무 어려울 것 같아서 방향을 나누어서 각자 구현했다. 실제 시험장에선 예쁘게 짜려고 생각 안하고 바로 이렇게 해야할듯decrease 함수를 구현하면서 내가 놓쳤던 부분들은, 꼭짓점의 온도를 두 번 감소시킨 것........'동시에' 라는 키워드가 나오면 lazy를 떠올리듯 '가장자리' 키워드가 나오면 꼭짓점을 항상 신경써야겠다.global ansR, C, K = map(int, input().split())room = 0 for row in range(R*C)board = 0 for col in range(R*C)wall = False for col in range(2) for row in range(R*C)test_pos = warm_pos = for i in range(R):    r = list(map(int, input().split()))    for j in range(C):        roomi*C+j = rj        if rj == 0: continue        if rj == 5:            test_pos.append(i*C+j)        else:            warm_pos.append(i*C+j)W = int(input())for i in range(W):    # 0 -&gt; 세로를 막는벽 1 -&gt; 가로를 막는벽    y, x, t = map(int, input().split())    wall(y-1)*C+(x-1)t = True# right left up downdy = 0, 0, -1, 1dx = 1, -1, 0, 0vy = -1, 0, 1, -1, 0, 1, -1, -1, -1, 1, 1, 1vx = 1, 1, 1, -1, -1, -1, -1, 0, 1, -1, 0, 1'''1. 집에 있는 모든 온풍기에서 바람이 한 번 나옴2. 온도가 조절됨3. 온도가 1 이상인 가장 바깥쪽 칸의 온도가 1씩 감소4. 초콜릿을 하나 먹는다.5. 조사하는 모든 칸의 온도가 K 이상이 되었는지 검사. 모든 칸의 온도가 K이상이면 테스트를 중단하고, 아니면 1부터 다시 시작한다.'''def debug_board():    for i in range(R):        print(boardi*C:i*C+C)    print('#####')def debug_lazy(lazy):    print(&quot;LAZYYYYY&quot;)    for i in range(R):        print(lazyi*C:i*C+C)    print('#####')def is_valid(y, x):    return 0 &lt;= y &lt; R and 0 &lt;= x &lt; Cdef is_valid_pos(pos):    return is_valid(pos//C, pos%C)def is_wall(y, x, dir):    # y, x 에서 dir로 가는 길에 벽이 막고있나요?    right = y*C+(x+1)    left = y*C+(x-1)    up = (y-1)*C+x    down = (y+1)*C+x    pos = y*C+x    if dir == 0:        if wallpos1:            return True    elif dir == 1:        if wallright1:            return True    elif dir == 2:        if wallpos0:            return True    elif dir == 3:        if walldown0:            return True    return Falsedef is_done():    global ans    ans += 1    if ans &gt; 100:        ans = 101        return True    for t in test_pos:        if boardt &lt; K:            return False    return Truedef right_move(y, x, state):    right = y*C+(x+1)    left = y*C+(x-1)    up = (y-1)*C+x    down = (y+1)*C+x    pos = y*C+x    up_right = (y-1)*C+(x+1)    up_left = (y-1)*C+(x-1)    down_right = (y+1)*C+(x+1)    down_left = (y+1)*C+(x-1)    if state == 0:        if is_valid_pos(up):            if not wallpos0 and not wallup1:                return True    elif state == 1:        if not wallpos1:            return True    else:        if is_valid_pos(down):            if not walldown0 and not walldown1:                return True    return Falsedef left_move(y, x, state):    right = y*C+(x+1)    left = y*C+(x-1)    up = (y-1)*C+x    down = (y+1)*C+x    pos = y*C+x    up_right = (y-1)*C+(x+1)    up_left = (y-1)*C+(x-1)    down_right = (y+1)*C+(x+1)    down_left = (y+1)*C+(x-1)    if state == 0:        if is_valid_pos(up_left):            if not wallpos0 and not wallup_left1:                return True    elif state == 1:        if is_valid_pos(left):            if not wallleft1:                return True    else:        if is_valid_pos(down) and is_valid_pos(down_left):            if not walldown0 and not walldown_left1:                return True    return Falsedef down_move(y, x, state):    right = y*C+(x+1)    left = y*C+(x-1)    up = (y-1)*C+x    down = (y+1)*C+x    pos = y*C+x    up_right = (y-1)*C+(x+1)    up_left = (y-1)*C+(x-1)    down_right = (y+1)*C+(x+1)    down_left = (y+1)*C+(x-1)    if state == 0:        if is_valid_pos(left) and is_valid_pos(down_left):            if not wallleft1 and not walldown_left0:                return True    elif state == 1:        if is_valid_pos(down):            if not walldown0:                return True    else:        if is_valid_pos(down_right):            if not wallpos1 and not walldown_right0:                return True    return Falsedef up_move(y, x, state):    right = y*C+(x+1)    left = y*C+(x-1)    up = (y-1)*C+x    down = (y+1)*C+x    pos = y*C+x    up_right = (y-1)*C+(x+1)    up_left = (y-1)*C+(x-1)    down_right = (y+1)*C+(x+1)    down_left = (y+1)*C+(x-1)    if state == 0:        if is_valid_pos(left):            if not wallleft1 and not wallleft0:                return True    elif state == 1:        if not wallpos0:            return True    else:        if is_valid_pos(right):            if not wallpos1 and not wallright0:                return True    return Falsedef inc_temp(y, x, dir):    '''    어떤 칸 (x, y)에 온풍기 바람이 도착해 온도가 k (&gt; 1)만큼 상승했다면,     (x-1, y+1), (x, y+1), (x+1, y+1)의 온도도 k-1만큼 상승하게 된다.    이때 그 칸이 존재하지 않는다면, 바람은 이동하지 않는다.     온풍기에서 바람이 한 번 나왔을 때, 어떤 칸에 같은 온풍기에서 나온 바람이 여러 번 도착한다고 해도 온도는 여러번 상승하지 않는다.    '''    '''    일부 칸과 칸 사이에는 벽이 있어 온풍기 바람이 지나갈 수 없다.     바람이 오른쪽으로 불었을 때 어떤 칸 (x, y)에서 (x-1, y+1)로 바람이 이동할 수 있으려면,     (x, y)와 (x-1, y) 사이에 벽이 없어야 하고, (x-1, y)와 (x-1, y+1) 사이에도 벽이 없어야 한다.     (x, y)에서 (x, y+1)로 바람이 이동할 수 있으려면 (x, y)와 (x, y+1) 사이에 벽이 없어야 한다.     마지막으로 (x, y)에서 (x+1, y+1)로 바람이 이동할 수 있으려면,     (x, y)와 (x+1, y), (x+1, y)와 (x+1, y+1) 사이에 벽이 없어야 한다.    '''    lazy = 0 for _ in range(R*C)    lazyy*C+x += 5    q =     q.append(y*C+x)    while q:        pos = q.pop(0)        cy, cx = pos // C, pos % C        k = lazypos        for i in range(0, 3):            ny, nx = cy + vydiri, cx + vxdiri            npos = ny*C+nx            if is_valid(ny, nx) and lazynpos == 0 and k &gt; 0:                # right left up down                if dir == 0 and right_move(cy, cx, i):                    q.append(npos)                    lazynpos += (k-1)                elif dir == 1 and left_move(cy, cx, i):                    q.append(npos)                    lazynpos += (k-1)                elif dir == 2 and up_move(cy, cx, i):                    q.append(npos)                    lazynpos += (k-1)                elif dir == 3 and down_move(cy, cx, i):                    q.append(npos)                    lazynpos += (k-1)    for i in range(R*C):        boardi += lazyidef control():    '''    모든 인접한 칸에 대해서, 온도가 높은 칸에서 낮은 칸으로 ⌊(두 칸의 온도의 차이)/4⌋만큼 온도가 조절된다.    온도가 높은 칸은 이 값만큼 온도가 감소하고, 낮은 칸은 온도가 상승한다.    인접한 두 칸 사이에 벽이 있는 경우에는 온도가 조절되지 않는다.    이 과정은 모든 칸에 대해서 동시에 발생한다.    '''    lazy = 0 for _ in range(R*C)    for pos in range(R*C):        y, x = pos // C, pos % C        for dir in 0, 3:            ny, nx = y + dydir, x + dxdir            npos = ny*C+nx            if is_valid(ny, nx) and not is_wall(y, x, dir):                diff = 0                if boardpos &gt; boardnpos:                    diff = int((boardpos - boardnpos) / 4)                    if boardpos &gt; 0:                        lazypos -= diff                    lazynpos += diff                else:                    diff = int((boardnpos - boardpos) / 4)                    lazypos += diff                    if boardnpos &gt; 0:                        lazynpos -= diff    for i in range(R*C):        boardi += lazyidef exec_warmer():    for warm in warm_pos:        dir = roomwarm - 1        y, x = warm//C + dydir, warm%C + dxdir        inc_temp(y, x, dir)def decrease():    for j in range(1, C-1):        if board0*C+j &gt;= 1:            board0*C+j -= 1        if board(R-1)*C+j &gt;= 1:            board(R-1)*C+j -= 1    for i in range(1, R-1):        if boardi*C+0 &gt;= 1:            boardi*C+0 -= 1        if boardi*C+(C-1) &gt;= 1:            boardi*C+(C-1) -= 1    if board0 &gt;= 1:        board0 -= 1    if boardC-1 &gt;= 1:        boardC-1 -= 1    if board(R-1)*C &gt;= 1:        board(R-1)*C -= 1    if board(R-1)*C+(C-1) &gt;= 1:        board(R-1)*C+(C-1) -= 1ans = 0while 1:    exec_warmer()    control()    decrease()    if is_done():        breakprint(ans)"
178,"https://www.acmicpc.net/problem/21609이 문제 풀때, 환우가 알려준 방법크기가 가장 큰 블록 그룹을 찾는다. 그러한 블록 그룹이 여러 개라면 포함된 무지개 블록의 수가 가장 많은 블록 그룹, 그러한 블록도 여러개라면 기준 블록의 행이 가장 큰 것을, 그것도 여러개이면 열이 가장 큰 것을 찾는다.이렇게 복잡한 조건문을 if문으로 하면이렇게 될 수도 있다..heapq를 이용해보자.for i in range(N):        for j in range(N):            if boardij &gt; 0:                a, b, y, x = bfs(i, j)                heapq.heappush(h, -a, -b, -y, -x)굉장히 간단하지만 파워풀한 방법이다!!!!!!!2개정도라면 if문으로 해결할 수 있겠지만 저런건 힙큐를 애용해보자 애용애용~"
179,"문제맥에는 기본적으로 파이썬 2.7 버전이 설치되어있다.&gt; brew install python명령어를 이용해 파이썬 3.8.5를 설치하였다. 그런데 버전 확인을 하면 위의 그림처럼 기존에 설치되어있는 파이썬의 버전이 등장한다.터미널에 python 명령어를 입력하면 2.7이 실행되고, python3을 입력해야만 내가 설치한 3.8.5가 실행이 되는 것을 확인하였다.해결나는 zsh를 사용하고 있기 때문에, 터미널에 다음 명령어를 이용하여 zsh 설정파일을 수정하였다.&gt; vi ~/.zshrc위 명령어를 입력하면 zsh 설정파일이 열리게 되는데, 맨 아래에 다음 문장을 추가해주자.&gt; alias python=&quot;python3&quot;esc + :wq 을 입력하여 저장 후 닫기를 한 뒤, 설정된 것을 적용하기 위해 다음 명령어를 입력한다.&gt; source ./zshrc그 뒤 아까와 같이 터미널에 python을 입력하게 되면?새로 설치한 파이썬이 열리는 것을 확인할 수 있다 !"
180,"https://www.acmicpc.net/problem/11066문제를 대충 읽어서 바로 옆에있는 파일들만 합칠 수 있다는 것을 못보고 우선순위큐로 풀었다가 예제 2번이 이상하게 나와서 다시 꼼꼼하게 읽어보았다..1. 접근예제 1번을 먼저 보자.0123403030507080150$70 + 80 + 150 = 300$40, 30, 30, 50 을 두 그룹으로 나눈 뒤, 더한 값이 최소가 되어야 한다.{40, 30, 30}, 50 으로 나눈다면, {40, 30}, 50 or 40, {30, 50} 두가지의 방법으로 다시 앞의 그룹을 나눌 수 있다.전체 비용이 최소가 되기 위해선 소 그룹인 {40, 30, 30} 에서 사용된 비용도 최소가 되어야 한다.2. 풀이dpij = '인덱스 i에서 j 범위의 파일들을 합쳤을 때 발생하는 최소 비용'이렇게 설정을 하면, 풀이가 간단해진다.i = 0, j = 3으로 예시를 들어보자.dp03 = '인덱스 0부터 3까지의 파일들을 합쳤을 때 발생하는 최소 비용' 이다.접근에서 말한 것과 같이 그룹을 나눈 뒤, 나뉘어진 각 그룹들의 최솟값을 더해야 전체 그룹의 최소가 될 것이다.따라서 0부터 3까지를 그룹을 나눠보면, 0, {1,2,3}, {0, 1}, {2, 3}, {0, 1, 2}, 3 으로 나눌 수 있고,첫번째 그룹을 보면, {1, 2, 3} 에서의 최솟값이 나와야 0과 합쳤을 때도 최소가 된다는 것을 알 수 있다.따라서 첫번째 그룹을 수식으로 나타낸다면 다음과 같이 나타낼 수 있다.$$dp03=dp00+dp13$$이 때, 병합 되는 과정 뿐만 아니라 결과도 더해줘야 한다. 이 결과는 직접 더해서 알 수도 있지만, 어차피 범위 내 수의 부분합 이므로 미리 배열을 만들어 구해놓았다. dp03을 구하는 전체 그룹을 포함하는 식은 다음과 같이 나타낼 수 있다.$$dp03=\min (dp00+dp13,dp01+dp23,dp02+dp33)+psum$$여기까지만 생각하고, 무지성 거인처럼 코드 때려박았다가 답이 안나와서 왜 안나오지? 하고 아무 잘못없는 점화식을 건드렸었다.....문제는 갱신되는 순서였다.원소가 3개인 그룹이 존재할 때, 이미 그룹 내 작은 그룹들의 최솟값이 구해져 있어야 한다.그러므로...범위가 작을수록, 먼저 갱신이 되어야 한다.그렇지 않으면 잘못된 값이 도출,,,,,,소스코드 의 for문에 있는 r은 원소의 범위를 의미한다. 범위를 작은 것 부터 큰 것 까지 갱신을 순서대로 해야 큰 범위의 그룹의 최솟값을 계산할 수 있다.3. 소스코드// https://www.acmicpc.net/problem/11066// 11066번 파일 합치기#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 987654321;int tc, k, dp501501, sum501;int main() {    for(scanf(&quot;%d&quot;, &amp;tc); tc--;) {        scanf(&quot;%d&quot;, &amp;k);        memset(sum, 0, sizeof(sum));        memset(dp, 0, sizeof(dp));        for(int s, i = 0; i &lt; k; i++) {            scanf(&quot;%d&quot;, &amp;s);            if(i == 0) {                sumi = s;                continue;            }            sumi = sumi-1 + s;        }        // range        for(int r = 1; r &lt; k; r++)            // start            for(int s = 0; s + r &lt; k; s++) {                // end                int e = s + r;                int psum = sume - sums-1;                dpse = INF;                for(int k = s; k &lt; e; k++)                    dpse = min(dpse, dpsk + dpk+1e + psum);            }        printf(&quot;%d\n&quot;, dp0k-1);    }}"
181,"https://www.acmicpc.net/problem/3653세그먼트 트리로 풀 수 있는 문제다. 하지만 나는 간결한게 좋으므로 펜윅트리로 풀었다!1. 접근'm개의 보고싶은 dvd가 있고, dvd를 볼때마다 맨 위로 쌓아놓는다.'매 번 n개의 배열의 위치를 갱신하여 풀게되면 O(nm) 의 시간복잡도를 나타내게 된다.n, m &lt;= 100,000 이므로 시간초과가 발생할 수 밖에 없다.따라서 다른 방법을 찾아보아야 한다.2. 풀이각 인덱스에, dvd가 존재한다면 1. 존재하지 않는다면 0 을 ai 배열에 저장하여 나타내고, 각 인덱스까지의 부분합을 psum이라는 값으로 나타내보자.다음 표와 같이 상태를 표현할 수 있다.i1234ai1111psum01233번 dvd의 위치는 3번 dvd보다 위에있는 dvd 갯수가 2개이므로 2이다. 이 때, 1번과 2번이 존재하므로 위치가 2라는 것을 알 수 있다.그러므로 i번째 dvd의 위치를 알기 위해서 필요한 것은 i보다 작은 인덱스가 몇개 존재하는지, 즉 -∞부터 i까지의 존재 여부의 구간 합 이라고 생각할 수 있다. 구간합을 구하는 문제이므로 펜윅트리를 이용해 풀 수 있다.DVD는 다 본 뒤 맨 위에 올려놓는다.한번 본 dvd는 맨 위로 올라가게 되는데, 이 올라간 dvd의 존재 여부도 카운팅이 되어야 제대로 된 정답을 도출할 수 있다. -∞부터 i까지의 구간합을 앞서 위치로 정의하였다. 보고 난 뒤의 올라간 dvd들은 -∞에 위치하면 되는 것이다.m개의 보고싶은 dvd가 있으므로, 초기의 1번 dvd위에 올라가는 dvd의 갯수는 최대 m개이다.n = 3, m = 3의 경우i012345ai0001112번 시청 뒤 ai0011013번 시청 뒤 ai011100m = 3 이므로 i = 0, 1, 2 는 한 번 이상 본 dvd들이 존재하는 위치이다.이 때 조심해야 할 점은, dvd를 한 번 보고 나면, 그 dvd의 원래의 위치가 새로운 위치로 변한다는 점이다.그래서 추가적인 배열 pos를 생성하여 각 인덱스의 마지막 위치를 저장하였다.새로운 위치인 newPos에는 1을 더해 트리를 업데이트 해주고, 원래의 위치인 oldPos에는 -1을 더해 트리를 업데이트 해주었다.펜윅트리의 sum(num) 함수는 num 인덱스 까지의 합을 구해주는 함수이다.자기 자신까지 카운팅이 되므로, 정답을 출력할때는 1을 빼주어야 한다.3. 소스코드#include &lt;bits/stdc++.h&gt;using namespace std;int tc, n, m, tree4 * 100001;int sum(int pos) {    int ret = 0;    while(pos) {        ret += treepos;        pos &amp;= (pos - 1);    }    return ret;}void update(int pos, int val) {    while(pos &lt;= n + m) {        treepos += val;        pos += (pos &amp; -pos);    }}int main() {    for(scanf(&quot;%d&quot;, &amp;tc); tc--;) {        int pos100001;        memset(pos, 0, sizeof(pos));        memset(tree, 0, sizeof(tree));        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        for(int i = 0; i &lt; n; i++) {            update(i + m + 1, 1);            posi + 1 = i + m + 1;        }        for(int s, i = 0; i &lt; m; i++) {            scanf(&quot;%d&quot;, &amp;s);            printf(&quot;%d &quot;, sum(poss) - 1);            int newPos = m - i;            int oldPos = poss;            poss = newPos;            update(newPos, 1);            update(oldPos, -1);        }        printf(&quot;\n&quot;);    }}"
182,"TIL Day4SEB FE Day51️⃣ HTML (HyperText Markup Language)   : 웹 페이지의 뼈대(틀)를 구성하는 마크업 언어. (구조를 표현하는 언어) / tag들의 집한&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Page title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;Hello world&lt;/h1&gt;        &lt;div&gt;Contents here            &lt;span&gt;Here too!&lt;/span&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;HTMLCSSJSStructure(구조)Presentation(스타일)Interaction(상호작용)TagRole&lt;div&gt;Division (한 줄 전체 차지)&lt;span&gt;Span (컨텐츠 크기만큰 공간 차지)&lt;img src=”url”&gt;Image&lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;*Link&lt;ul&gt; &amp; &lt;li&gt;Unordered List &amp; List Item&lt;ol&gt;Ordered List&lt;input type=&quot;checkbox&quot; checked&gt;Input(Text, Radio, Checkbox)&lt;textarea&gt;Multi-line Text Input&lt;button&gt;Button&lt;p&gt;하나의 문단 표현 *&lt;a target=”_blank”&gt; : 새 탭으로 링크 페이지 이동📎 Input// placeholder 속성: 입력폼 안에 작성해야 하는 내용 힌트 제공 가능&lt;input type=&quot;text&quot; placeholder=&quot;ID&quot;&gt;&lt;/input&gt;&lt;input type=&quot;password&quot;&gt;&lt;/input&gt;// name이 같은 Checkbox 타입 중 여러 개 체크 가능&lt;input type=”checkbox” name=”fruits”&gt;// name이 같은 Radio 타입 중 하나만 체크 가능&lt;input type=”radio” name=”subject”&gt;📎 시맨틱(semantic) 요소: Semantic 이란 ‘의미가 있는, 의미론적인'. → 의미를 가진 요소&lt;article&gt;독립적이고 자체 포함된 콘텐츠 지정&lt;aside&gt;본문의 주요 부분을 표시하고 남은 부분을 설명하는 요소. (사이드바, 광고창)&lt;footer&gt;페이지나 해당 파트의 가장 아랫부분에 위치 (사이트 라이선스, 주소 ...)&lt;header&gt;페이지나 해당 섹션의 가장 윗부분에 위치 (사이트 제목)&lt;nav&gt;상단바 등 사이트를 안내하는 요소에 사용 (보통 &lt;ul&gt;을 넣어 목록 형태로 사용)&lt;main&gt;문서의 주된 콘텐츠 표시&lt;section&gt;제목, 콘텐츠가 포함된 구획을 나눌 때 사용. (&lt;div&gt;와 역할 비슷)&lt;form&gt;사용자가 입력한 값을 다른 페이지로 전송하는 역할 (보통 &lt;input&gt;, &lt;button&gt; 요소 등의 자식 요소를 감싸는 경우에 자주 사용)✋ &lt;div&gt;, &lt;span&gt; 요소는 시멘틱 요소로 분류 X📎 id &amp; classid : 고유한 이름을 붙일 때 사용 (# 으로 표시) ⇒ 중복 허용 Xclass : 반복되는 영역을 유형별로 분류할 때 사용 (. 으로 표시)  ✋ 읽기 영역 자체는 고유 ⇒ id로 이름 표시  ✋ 반복되는 항목 ⇒ class로 지정 (같은 class 값을 지정 → 동일한 유형)  HTML tagSelector&lt;div id=”writing-section”&gt;div#writing-section&lt;li class=”comment”&gt;li.comment  // 아래의 class value와 같이 하나의 태그에 여러 개의 class를 작성하고 싶을 땐 띄어쓰기로 구분   // id, class, type : attribute name(속성 이름)  // &quot;id-input&quot;, &quot;input focus&quot; ... : attribute value(속성 값)  &lt;input id=&quot;id-input&quot; class=&quot;input focus&quot; type=&quot;text&quot; placeholder=&quot;ID&quot;&gt;&lt;/input&gt;&lt;script&gt; 요소: Javascript 실행을 위해 사용  &lt;script src=&quot;my-java-script.js&quot;&gt;&lt;/script&gt;  // document.querySelector(’.title’).textContent;"
183,"TIL Day3SEB FE Day4 (반복문; 연습문제 21개)1️⃣ 반복문(Iteration)  : 같거나 비슷한 코드를 여러 번 실행시켜야 할 경우에 쓰는 구문📎 for 구문// 반복할 조건을 초기화, 조건식, 증감문 순으로 작성let sum = 1;for(let n=2; n&lt;=4; n=n+1) {    sum = sum + n; // 반복할 내용}📎 while 구문let sum = 1;let n = 2;while(n &lt;= 4) {    sum = sum + n;    n = n + 1;}➕ etc (연습 문제 풀다가 기억해야 할 기타 개념들)오늘 연습문제는 어떻게 접근해야 할 일 막막한 문제들이 꽤 있었다.😱  특히, 이중반복문 연습을 많이 해야할듯!for문에서 index를 활용하는 문제// 아래와 같은 조건을 기본으로 문제 생각하기!// 여기서 i를 index 번호라고 생각하자// index는 0부터 시작해서 마지막 index 번호는 문자열 길이-1.for(let i=0; i &lt; str.length; i++) {    ~~~}"
184,"1️⃣ 조건문어떠한 조건을 판별하는 기준을 만드는 것으로 비교연산자가 필요!if (조건A) {    return ~} else if (조건B) {    return ~} else {    return ~}📎 비교연산자연산자의미&gt;초과&lt;미만&gt;=이상&lt;=이하===같다!==다르다✋ ==, != 사용 지양 (why? 엄격히 타입 비교 X)📎 논리 연산자두가지 조건을 한번에 적용하는 경우 사용AND연산결과true &amp;&amp; truetruetrue &amp;&amp; falsefalsefalse &amp;&amp; falsefalse✋ AND 연산자는 falsy한 값을 만나면, 그 값 출력연산결과undefined &amp;&amp; 10undefined5 &amp;&amp; falsefalse✋ 둘다 truthy할 경우, 뒤에 있는 값 출력연산결과5 &amp;&amp; 1010OR연산결과true || truetruetrue || falsetruefalse || falsefalse✋ OR 연산자는 truthy한 값을 만나면, 그 값 출력 (그 이후는 평가 x)연산결과이유undefined || 1010undefined이 false 취급이므로 10 출력5 || 105앞에서 부터 평가하기 때문에 5 출력✋ 둘 다 falsy할 경우, 뒤에 있는 값 출력연산결과undefined || falsefalseNOT!falsetrue!(3&gt;2)false!undefinedtrue!’Hello’false✋ undefined: false 취급(falsy)✋ ‘abc’ 비어 있지 않은 문자열: true 취급(truthy))📎 falsy 값(if문에서 false로 변환되므로, if 구문 실행 X)if(false)if(null)if(undefined)if(0)if(NaN)if(’ ‘)2️⃣ 문자열strindex : index에 해당하는 문자 출력 (read-only)  str1 = 'Code';  str2 = 5;  str3 = 'Happy';  console.log(str1 + str2 + str3) // Code5Happy  // = str1.concat(str2, str3 ...)  👉🏻 toString: string 타입과 다른 타입 사이에 + 연산자를 쓰면, string 형식으로 변환  str.length: 문자열 str의 전체 길이 returnstr.indexOf(searchValue): 찾고자 하는 문자열이 위치하는 index return  // 처음으로 일치하는 index return  // 공백도 하나의 index를 가진다고 생각하기!  'Hard Coding Coding'.indexOf('Hard'); // 6  // 찾고자 하는 문자열이 없으면 -1 return  'Hard Coding'.indexOf('hard'); // -1  // lastIndexOf: 문자열 뒤부터 찾기  'apple'.lastIndexOf('p'); // 2str.includes(searchValue): 찾고자 하는 문자열이 포함되어 있는지 판별 (true / false)str.split(seperator): seperator 문자를 기준으로 문자열을 쪼갬 (csv 형식 처리시 유용)  A.  var str = 'Nice to meet you';  str.split(' ');  // str.split('\n') =&gt; 줄단위로 문자열을 쪼갬  // 'Nice', 'to', 'meet', 'you'  B.  let alphabet = 'abcedf';  alphabet.split('');  // 'a', 'b', 'c', 'e', 'd', 'f'  str.substring(start index, end index): 시작과 끝 index 사이의 문자열 retrun  cf. = str.slice(start, end)  var str = 'abcdefg';  str.substring(0,3); // 'abc'  // index가 0~3이 아니라 0~2인 문자를 return함을 주의!  // parameter가 (end index, start index)처럼 순서가 바뀌어도 OK  // parameter가 음수일 경우 0으로 취급  str.toLowerCase(): 소문자로 변환str.toUpperCase(): 대문자로 변환  👉🏻 str 문자열 자체가 변환되는 것은 아님 (Immutable)📎 템플릿 리터럴(Template literals)문자열을 + 연산자를 사용하지 않고 편리하게 여러 타입의 문자열 혼합 가능👉🏻 지금은 ${hour}시 ${minute}분 ${second}초 입니다.➕ etc연습 문제 풀다가 기억해야 할 기타 개념들짝수 구하는 조건: num % 2 === 0    (%: 나머지 구하는 연산자)제곱근 구하는 방법a * aa ** 2Math.pow(a, 2)내림 연산: Math.floor()최소값: Math.min(num1, num2 ...)최대값: Math.max(num1, num2 ...)절대값 연산: Math.abs(num1 - num2)➕ Advanced📎 substr() &amp; substring() &amp; slice() 차이str.substr(start index, length): start index부터 length 길이만큼 잘라내어 return|  | substring(start, end) | slice(start, end) || --- | --- | --- || start&gt;end일 경우 | start, end 서로 바꿔서 처리 | 빈 문자열 return || index가 음수일 경우 | index를 0으로 취급 | 문자열 맨 끝에서 음수의 절대값만큼 내려온 index로 취급 |```jsxlet str = Carpediemstr.slice(-3, 9)// 맨뒤의 'm'을 -1 기준으로, index -3는 'i'// 즉, str.slice(-3, 9) === str.splice(6, 9)// 'iem'```"
185,"1️⃣ 변수변수 선언 : 데이터 보관함에 데이터를 넣을 공간을 확보하는 것 / 변수는 let 키워드와 변수명을 사용하여 선언변수 할당 : 선언한 변수명에 =를 사용하여 넣고자 하는 값을 넣어주는 것✋ ‘같다'라는 의미의 연산자: ===✋ 변수 선언과 할당 혼동하지 않기👉 변수를 선언하고 할당하는 가장 큰 이유는 반복적으로 사용하는 값을 데이터 보관함에 넣어 두었다가 편하게 꺼내서 사용하기 위함여기서 말하는 ‘데이터 보관함' 즉, 메모리의 크기는 동일하며, 변수는 각 보관함에 붙인 이름을 의미📎 변수 선언 및 할당 방법⭕️❌let thing = 'Apple'; let num = 5;let thing, num = ('Apple', 5);let thing = 'Apple', num = 5;let thing = 'Apple', let num = '5';2️⃣ 타입Undeifined, function 모두 자바스크립트의 타입Null 타입은 null 하나의 값만 가질 수 있음값을 할당하지 않은 변수는 null이 아닌 undefined 값을 가짐typeof 를 통해 특정 값의 타입을 알 수 있음3️⃣ 함수함수는 기능의 단위함수는 반복적인 기능을 저장해 두었다가 필요할 때마다 호출해서 사용 가능 (⭐️즐겨찾기 기능)함수는 반드시 돌아옴 (return)함수에는 구체적인 입력값과 출력값 존재매개변수(parameter): 함수를 실행할 때 입력에 따라서 바뀔 수 있는 변수전달인자(argument): 함수를 호출할 때 매개변수에 할당되는 값📎 함수 선언 방법함수 선언식function getRectangleArea(width, height) {   let rectangleArea = width * height;   return rectangleArea함수 표현식: 변수 선언 후 함수 작성let getRectangleArea = function (width, height) {   let rectangleArea = width * height;   return rectangleArea}화살표 함수let getRectangleArea = (width, height) =&gt; {   let rectangleArea = width * height;   return rectangleArea}// 한줄일 떈 {}, return 생략 가능let getRectangleArea = (width, height) =&gt; width * height;"
186,"'파이썬 알고리즘 인터뷰' 책으로 코딩테스트 공부하다가 풀이를 봐도 이해가 가지 안하는 부분이 있어 일단 기록해두고 나중에 다시 차근차근 이해하려고 남겨두기!Trapping Rain Water높이를 입력받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라.1번째 방법. 투 포인터를 최대로 이동이 방법 다른 블로그 글을 통해 이해가 되었다.class Solution:    def trap(self, height: Listint) -&gt; int:        if not height:            return 0        volume = 0        left, right = 0, len(height)-1        left_max, right_max = heightleft, heightright        while left &lt; right:            left_max, right_max = max(heightleft, left_max), max(heightright, right_max)            # 더 높은 쪽을 향해 투 포인터 이동            if left_max &lt;= right_max:                volume += left_max - heightleft                left += 1            else:                volume += right_max -heightright                right -= 1        return volume2번째 방법. 스택 쌓기이 방법은 다른 블로그 글을 봐도 잘 이해가 되지 않는다...```pythonclass Solution:    def trap(self, height: Listint) -&gt; int:        stack =         volume = 0  # 채워지는 물 눞이    for i in range(len(height)):        # 변곡점을 만나는 경우        while stack and heighti &gt; heightstack-1:  # stack-1: 스택에서 원소를 제거하지 않고 가져오기만 할 때 사용            # 스택에서 꺼낸다            top = stack.pop()            if not len(stack):                break            # 이전과의 차이만큼 물 높이 처리            distance = i - stack-1 -1            waters = min(heighti, heightstack-1) - heighttop            volume += distance * waters        stack.append(i)    return volume"
187,"백준-단계별로 풀어보기-'기본 수학 2' 파트 문제들 중 기억해야 할 개념 및 문제들을 기록합니다.2022.01.17Baekjoon 1978. 소수찾기:2부터 X-1까지 모두 나눠서 X가 소수인지 판별하는 문제 1📘 1978 문제 링크n = int(input())num_list = list(map(int, input().split()))cnt = 0for i in num_list:    if i != 1:  # 1은 소수 아님        for j in range(2, i):  # range: 2 ~ i-1            if i % j == 0:  # 소수 아닌 경우                break        else:  # i가 1과 자신 i를 제외한 어떠한 j로도 나눠지지 않는 경우 = 소수            cnt += 1print(cnt)2022.01.17Baekjoon 2581. 소수:2부터 X-1까지 모두 나눠서 X가 소수인지 판별하는 문제 2📘 2581 문제 링크m = int(input())n = int(input())arr =   # 빈 배열for i in range(m, n+1):  # range: m ~ n    if i == 1:  # 1은 소수 아님        pass    elif i == 2:  # 2는 소수임        arr.append(i)    else:        for j in range(2, i):  # range: 2 ~ i-1            if i % j == 0:  # 무언가로 나눠지는 i는 소수가 아님                break            elif j == i-1:  # j가 범위 끝인 i-1까지 도달했다면                arr.append(i)  # i를 소수 배열에 추가if len(arr) == 0:    print('-1')else:    print(sum(arr))    print(min(arr))2022.01.17Baekjoon 11653. 소인수분해:N을 소인수분해하는 문제📘 11653 문제 링크n = int(input())while n != 1:  # n이 1이 될 때 까지 반복    for i in range(2, n+1):  # 범위: 2 ~ n        if(n % i == 0):  # n을 2부터 순차적으로 나누기            print(i)  # n이 나머지 없이 나눠지면 출력            n = n // i            break2022.01.20Baekjoon 1929. 소수 구하기:에라토스테네스의 체로 풀어 봅시다.📘 1929 문제 링크m, n = map(int, input().split())for i in range(m, n+1):    if i == 1:        continue    for j in range(2, int(i ** 0.5)+1):  # range(2, i) -&gt; 시간초과 뜸.        if i % j == 0:            break    else:        print(i)이렇게 풀었을 경우에 맞긴 하지만 시간이 너무 오래걸린다😢 (5840ms)--&gt;➰ 그래서 '에라토스테네스의 체'를 활용하여 문제를 풀면 시간이 많이 단축된다. (260ms)에라토스테네스의 체: 고대 그리스 수학자 에라토스테네스가 발견한 소수를 찾는 방법.소수를 구해야 하는 구간의 수(m~n) 가운데 n의 제곱근보다 작은 소수의 배수를 지우고 남는 수는 모두 소수가 됨.예를 들어 가장 작은 소수인 2부터 시작해서, 2의 배수(2, 4, 6 ...)를 모두 지우고, 지워지지 않은 남은 수 중에서 다음 소수인 3의 배수(3, 9, 15 ...)를 지움 -&gt; 범위 내에서 계속 반복해 나가면 소수만 남음.m, n = map(int, input().split())def isprime(m, n):    n += 1    prime = True * n   # 초기화: n개 요소에 True 설정(소수로 간주)    # n의 최대 약수가 sqrt(n) 이하이므로 i=sqrt(n)까지 검사    for i in range(2, int(n**0.5)+1):        if primei:   # i가 소수인 경우            for j in range(2*i, n, i):   # i 이후 i의 배수들을 False 판정                primej = False    for i in range(m, n):        if i &gt; 1 and primei == True:            print(i)isprime(m, n)2022.01.21Baekjoon 4948. 베르트랑 공준:소수 응용 문제 1📘 4948 문제 링크def sosu(num):    if num == 1:        return False    for i in range(2, int(num**0.5)+1):        if num % i == 0:            return False    return True# 문제에서 제한한 범위: n &lt;= 123,456 -&gt; 최대를 범위를 2n &lt;= 246,912로 미리 계산sosu_range = list(range(2, 246912))sosu_list =    # 소수담을 빈 리스트for i in sosu_range:   # 2 &lt;= n &lt;= 246,912    if sosu(i):   # 소수에 해당하면 소수 리스트에 추가        sosu_list.append(i)while(1):    cnt = 0    n = int(input())    if n == 0:   # 0 입력시 입력 종료        break    for i in sosu_list:        if n &lt; i &lt;= 2*n:   # 소수를 담은 리스트가 범위 내에 있으면 카운트            cnt += 1    print(cnt)전에 소수 구하는 방식으로 비슷하게 푸니까 계속 시간 초과가 떴다.😢시간초과 문제를 해결하기 위해  n의 최대 범위를 미리 계산하여 지정해주었다.또한, 소수를 구하는 함수를 따로 만들었고, 빈 리스트를 선언하여 소수로 판단했을 때 마다 빈 리스트에 값을 추가해주고 이를 카운트해주었다.2022.01.24Baekjoon 9020. 골드바흐의 추측:소수 응용 문제 2📘 9020 문제 링크import sysdef sosu(num):    for i in range(2, int(pow(num, 0.5)) + 1):  # pow(num, 0.5) = num**0.5        if num % i == 0:  # 소수가 아닌 경우            return False    if num == 1:  # 1은 항상 소수가 아님        return False    return True  # 위의 경우 외에는 소수라고 판단T = int(sys.stdin.readline())for i in range(T):    n = int(sys.stdin.readline())    for num in range(n // 2, 0, -1):  # n//2 ~ 0 까지, -1씩 작아지도록        if sosu(num) and sosu(n-num):            print(num, n-num)            break값 입력받을 때 int(input()) 보다 int(sys.stdin.readline() 사용하는게 시간 3배정도 더 단축됨.pow(): pow(num, 0.5) = num**0.5 즉, 제곱을 표현할 때 사용하는 함수."
188,"백준-단계별로 풀어보기-'기본 수학 1' 파트 문제들 중 기억해야 할 개념 및 문제들을 기록합니다.Baekjoon 1712. 손익분기점: 이익이 발생하는 지점을 찾는 문제📘 1712 문제 링크A, B, C = map(int, input().split())n = 0  //판매량으로써 0으로 초기화 (구하고자 하는 값)if B &gt;= C:    print(-1)else:     print(int(A/(C-B)+1))코드는 간단하지만 파이썬을 배운지 오래되어서 은근 수학적으로 이해하는게 간단하지 않았다.A + Bn = Cn 이면 총 수입과 총 비용이 같아지게 된다.손익분기점이 존재하려면 오른쪽 식이 커지기 시작해야 하므로B가 C보다 같거나 커질 경우 (B &gt;= C), 식이 성립할 수 없게 된다.그러므로 이 경우엔 -1을 출력한다.그 외의 경우엔 손익분기점(최초로 이익이 발생하는 판매량)을 출력한다.A + Bn = CnA = (C-B)nA / (C-B) = n위에서 구한 n은 수입과 비용이 같아지게 되는 지점이므로A / (C-B) 에 + 1을 해야 최초로 이익이 발생하게 된다. Baekjoon 2292. 벌집: 벌집이 형성되는 규칙에 따라 벌집의 위치를 구하는 문제📘 2292 문제 링크n = int(input())room = 1  # 벌집 개수plus = 6  # 벌집 단계가 6의 배수로 증가count = 1  # 벌집 번호while n &gt; room:    room += plus    plus += 6    count += 1print(count)가장자리에 해당되는 벌집 개수가 몇개인지 파악한다면 6의 배수씩 단계에 따라 벌집 개수가 증가함을 파악할 수 있다.2022.01.05Baekjoon 1193. 분수찾기: 분수의 순서에서 규칙을 찾는 문제📘 1193 문제 링크x = int(input())line = 0  # 해당 줄 번호end_index = 0  # 해당 line의 마지막 num의 인덱스번호while end_index &lt; x:    line += 1    end_index += linenum = end_index - line  # line=짝수: x와 top의 차, line=홀수: x와 bottom의 차if line % 2 == 0:  # line이 짝수일 때    top = x - num    bottom = line - top + 1else:  # line이 홀수일 때    bottom = x - num    top = line - (bottom) + 1print(f&quot;{top}/{bottom}&quot;)규칙찾는게 너무 어려웠다,, line별로 나열까지는 그래도 찾았는데 분모, 분자 숫자를 구하는 걸 식으로 나타나는게 다른 사람들 풀이를 참고해도 어려웠다,,2022.01.06Baekjoon 2869. 달팽이는 올라가고 싶다: 달팽이의 움직임을 계산하는 문제📘 2869 문제 링크import sysimport matha, b, v = map(int, input().split())day = 0day = (v-b) / (a-b)print(math.ceil(day))day= (v-b) / (a-b) 이 식이 나오기까지의 과정은 메모장에 끄적이면서 풀어갔다.정상에 올라가면 더이상 내려오지 않기 때문에 +a가 한번 더 있어야 한다.(day-1)(a-b)+a = vdaya - dayb - a + b + a = vdaya - dayb + b = vday(a-b) + b = vday = (v-b) / (a-b)'/'는 나눗셈 몫을 구하는 것이기 때문에 5.4 이런 식으로 나오면 6일 되는 것이다. 그러므로 math.ceil()를 이용해서 day 값을 올림해주어야 함.2022.01.06Baekjoon 10250. ACM 호텔: 호텔 방 번호의 규칙을 찾아 출력하는 문제📘 10250 문제 링크import syst = int(input())for i in range(t):    h, w, n = map(int, input().split())    num = n // h + 1  # 몫    floor = n % h  # 나머지    if n % h == 0:        num = n // h        floor = h    print(f'{floor*100+num}')// : 나눗셈 몫% : 나눗셈 나머지호텔의 맨 위층일 경우엔 나눗셈 값이 딱 떨어지기 때문에 호를 구할 때+1을 하지 않아도 된다. 그러므로 이 경우는 if문으로 따로 조건을 설정해주어야 함.2022.01.06Baekjoon 2775. 부녀회장이 될테야: 층과 거주자 수의 규칙을 찾는 문제📘 2775 문제 링크import syst = int(input())for i in range(t):    k = int(input())  # 층    n = int(input())  # 호    base = i for i in range(1, n+1)  # 0층에 대한 호    for j in range(k):        for i in range(1, n):            basei += basei-1    print(base-1)2022.01.10Baekjoon 2839. 설탕 배달: 5와 3을 최소 횟수로 합하여 N을 만드는 문제📘 2839 문제 링크n = int(input())count = 0while n &gt;= 0: # n이 5로 나눠질 때 까지 반복    if n % 5 == 0: # 5로 바로 나눠지면 5로 나눈 몫을 바로 출력한다.        count += (n // 5)        print(count)        break    n -= 3  # 바로 5로 나눠지는 것이 아니라면 3kg를 빼주고 봉지 개수 +1    count += 1else:    print(-1)2022.01.10Baekjoon 10757. 큰 수 A+B: 파이썬 같은 언어는 10,000자리 정도의 자연수도 자유롭게 다룰 수 있습니다. 하지만 C/C++이라면 이 문제를 어떻게 풀까요?📘 10757 문제 링크a, b = map(int, input().split())print(a+b)#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void reverse(char arr) // 역순 정렬{    int len = strlen(arr);    for (int i = 0; i &lt; len / 2; i++)    {        char temp = arri;        arri = arrlen - i - 1;        arrlen - i - 1 = temp;    }}int main(void){    char A10002 = {0}, B10002 = {0}, res10003 = {0}; // 자리수를 뜻함    int carry = 0, i;                                      //carry: 받아올림    scanf(&quot;%s%s&quot;, A, B);    reverse(A);    reverse(B);    int len = strlen(A) &gt; strlen(B) ? strlen(A) : strlen(B);    for (i = 0; i &lt; len; i++)    {        int sum = Ai - '0' + Bi - '0' + carry;        while (sum &lt; 0)            sum += '0';        if (sum &gt; 9)            carry = 1;        else            carry = 0;        resi = sum % 10 + '0'; //받아올림 후 남은 1의 자리 수의 아스키코드 저장    }    if (carry == 1)        reslen = '1'; //가장 큰 자릿수에서 받아올림이 발생하면 배열의 마지막에 1을 추가    reverse(res);       //역순으로 정렬해 원하는 값으로 복원    printf(&quot;%s&quot;, res);    return 0;}파이썬은 달랑 2줄이면 되지만, C로는 긴 코드가 필요하다...C를 잘 안 쓰다 보니까 문법도 헷갈리고 접근법을 모르겠어서 구글링해서 완성 코드를 이해하려고 했는데 그것도 쉽지 않음 .. 이해가 더 필요함!2022.01.10Baekjoon 1011. Fly me to the Alpha Centauri: 거리에 따른 장치 사용 횟수를 출력하는 문제📘 1011 문제 링크import syst = int(input())for i in range(t):    x, y = map(int, input().split())    distance = y - x    count = 0  # 이동 횟수    move = 1   # count별 최대 가능 이동 거리    total = 0  # 이동 거리 합    while total &lt; distance:        count += 1        total += move        if count % 2 == 0:            move += 1    print(count)이동 횟수의 규칙을 알아내야만 풀 수 있는 문제이다.count: (1, 2), (3, 3, 4, 4), (5, 5, 5, 6, 6, 6) ...이 문제도 확실하게 이해는 하지 못 했다,, 나중에 더 이해가 필요한 문제!"
189,"백준-단계별로 풀어보기-'문자열' 파트 문제들 중 기억해야 할 개념 및 문제들을 기록합니다.Baekjoon 11654. 아스키 코드: 아스키 코드에 대해 알아보는 문제📘 11654 문제 링크a = input()print(ord(a))ord(문자) : 아스키 코드를 반환chr(숫자) : 숫자에 맞는 아스키 코드 반환Baekjoon 11720. 숫자의 합: 정수를 문자열로 입력받는 문제.📘 11720 문제 링크n = int(input())num = list(map(int, input()))  # ex) 123 -&gt; 1, 2, 3result = 0for i in range(n):    result += numi print(result)Baekjoon 10809. 알파벳 찾기: 한 단어에서 각 알파벳이 처음 등장하는 위치를 찾는 문제📘 10809 문제 링크S = input()for i in range(97, 123):    print(S.find(chr(i)), end=' ')ASCII CODE로 소문자 az = 97122 의미find() : 특정 문자를 찾고 위치 반환 (뒤에 index를 명시하지 않을 경우 index 0부터 시작), 찾는 문자가 없을경우 -1 returnend=' ' : 반복 출력될 때마다 한 줄씩 출력이 아닌 같은 줄에 한 칸 공백 후 출력하게 해 줌. Baekjoon 2675. 문자열 반복: 각 문자를 반복하여 출력하는 문제📘 2675 문제 링크T = int(input())for i in range(T):    num, string = input().split()    result = ''    for j in string: # string=abc -&gt; j : a, b, c         result += j * int(num)    print(result)Baekjoon 1157. 단어 공부: 주어진 단어에서 가장 많이 사용된 알파벳을 출력하는 문제📘 1157 문제 링크a = input().upper()  # 대문자로 변경lists = list(set(a))  # 중복된 문자를 정렬c = for i in lists:    counts = a.count(i)  # 입력한 알파벳의 개수를 count    c.append(counts)if c.count(max(c)) &gt;= 2:  # 리스트 중 많이 나온 문자가 2개 이상일 경우    print(&quot;?&quot;)else:    print(lists(c.index(max(c))))Baekjoon 1152. 단어의 개수: 단어의 개수를 구하는 문제📘 1152 문제 링크a = input().split()print(len(a))a를 공백으로 몇 개인지 구분하기 때문에 len() 함수를 통해 단어가 몇 개 인지 판별할 수 있다.❗ 정답 비율이 27퍼로 낮아서 어려운 문제인 줄 알았는데 정말 간단한 문제였다.Baekjoon 2908. 상수: 숫자를 뒤집어서 비교하는 문제📘 2908 문제 링크no.1처음으로 풀었던 코드는 for문을 사용한 방법이다.a, b = list(input().split())re_a = ''re_b = ''for i in str(a):    re_a = i + re_a  for j in str(b):    re_b = j + re_bif int(re_a) &gt; int(re_b):    print(re_a)elif int(re_b) &gt; int(re_a):    print(re_b)아래는 for문이 돌아가는 원리이다.for i in str(a):    re_a = i + re_a  # ex) a = 123 re_a = 1 + '' → 1 re_a = 2 + 1 → 21 re_a = 3 + 21 → 321no.2풀 다른 방법이 있나 찾아보다가 비교적 더 간단한 코드를 발견했다.a, b = input().split()a = int(a::-1)b = int(b::-1)result = max(a, b)print(result)aA::B::C : index A ~ B 까지 C 간격으로 배열 설정.  ex) a::-1 : 처음부터 끝까지 -1칸 간격으로 배열 설정 (= 역순으로 설정)Baekjoon 5622. 다이얼: 규칙에 따라 문자에 대응하는 수를 출력하는 문제📘 5622 문제 링크word = input().lower()  #입력한 문자를 소문자로 변환s = 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'time = 0for i in range(len(word)):    for j in s:        if(wordi in j):             time += s.index(j) + 3  # (index는 0부터 시작하므로 +1) + (다이얼 숫자 하나에 2초) = 3초print(time)Baekjoon 2941. 크로아티아 알파벳: 크로아티아 알파벳의 개수를 세는 문제📘 2941 문제 링크words = input()changes = 'c=', 'c-', 'dz=', 'd-', 'lj', 'nj', 's=', 'z='for i in changes:    words = words.replace(i, '*')  #크로아티아 알파벳 변경 문자(changes)에 포함이 되면 해당 문자열을 *로 변경print(len(words))replace(&quot;찾을값&quot;, &quot;바꿀값&quot;) : 문자열 변경Baekjoon 1316. 그룹 단어 체커: 조건에 맞는 문자열을 찾는 문제📘 1316 문제 링크n = int(input())for i in range(n):    word = input()    for j in range(1, len(word)):        if word.find(wordj-1) &gt; word.find(wordj):            n -= 1            breakprint(n)find() : 찾고자 하는 단어를 찾아서 index를 알려줌. (값을 따로 지정해주지 않으면 그 단어가 첫 번째로 등장한 위치를 알려줌.)만약 뒤에 있는 단어의 index가 앞에 있는 단어의 index보다 작다면 앞에서 이미 등장했던 것이므로 그룹 단어가 아님."
190,"백준-단계별로 풀어보기-'함수' 파트 문제들 중 기억해야 할 개념 및 문제들을 기록합니다.Baekjoon 15596. 정수 N개의 합: 함수를 구현해 봅시다.📘 15596 문제 링크def solve(a):    result = sum(a)    return resultsum() 함수를 통해 완전 간단히 함수를 작성할 수 있다.⬇ for문을 사용한 아래 코드는 위 코드 보다 시간이 5배는 더 걸린다.def solve(a) :    result = 0    for i in a:        result += i    return resultBaekjoon 4673. 셀프 넘버: 함수 d를 정의하여 문제를 해결해 봅시다.📘 4673 문제 링크# 1~10000까지의 숫자 저장all_num = set(range(1, 10001))# 셀프 넘버가 아닌 수 저장not_self_num = set()for i in range(1, 10001):    for j in str(i):  # 문자열로 반환하면 예를 들어 123을 1, 2, 3으로 접근 가능        i += int(j)  # ex) 123 + 1 + 2 + 3 =    not_self_num.add(i)  # 셀프 넘버가 아닌 수를 계속 저장# 셀프 넘버 set = 전체 수 set - 셀프 넘버가 아닌 수 setself_num = sorted(all_num - not_self_num)for i in self_num:    print(i)❗ 어떻게 접근할지 막막해서 다양한 코드들을 찾아보고 그 중 제일 괜찮다고 생각하는 코드를 참고하여 이해했다.set() : 중복이 없는 요소들로만 구성된 집합 컬렉션 (순서 x)for문에서 범위를 문자열로 지정 가능하다 .#ex)for i in str(123):    print(i)#output123❗ 이 문제 분류가 함수인 만큼 다음 번에는 def d(n):  함수를 만들어 다른 코드를 작성해봐야 겠다.Baekjoon 1065. 한수: X가 한수인지 판별하는 함수를 정의하여 문제를 해결해 봅시다.📘 1065 문제 링크N = int(input())hansu = 0for i in range(1, N+1):    if i &lt;= 99: #100 미만의 수는 하나 또는 두 수만 비교하므로 모든 수가 등차수열 즉, 한수가 될 수 있다.        hansu += 1    else:        num = list(map(int, str(i)))  #ex) 123 -&gt; 1, 2, 3        if num0 - num1 == num1 - num2:            hansu += 1print(hansu)❗ 등차수열 구하는 방법을 어렵게 생각했는데 알고 보니 별 거 아니었다..."
191,"백준-단계별로 풀어보기-'1차원 배열' 파트 문제들 중 기억해야 할 개념 및 문제들을 기록합니다.Baekjoon 10818. 최소, 최대: 최솟값과 최댓값을 찾는 문제📘 10818 문제 링크import sysN = int(sys.stdin.readline())num = list(map(int, sys.stdin.readline().split()))print(min(num), max(num))min(), max() 함수를 쓰면 따로 함수를 정의하지 않아도 최소값, 최대값을 구할 수 있음.N개의 정수 개수를 정확히 입력하지 않아도 오류가 나지 않음.❔ 이 부분에 대해서는 오류가 나지 않아도 조건에 부합하도록 코드 업데이트 필요.Baekjoon 2562. 최댓값: 최댓값이 어디에 있는지 찾는 문제📘 2562 문제 링크import sysnum_list = for i in range(9):    num_list.append(int(sys.stdin.readline()))print(max(num_list))print(num_list.index(max(num_list))+1)입력하는 list가 for문 안에 있으므로 지역변수로 선언되어 있음.↳ 그렇기 때문에 list 형식의 전역변수로 또 선언해주어야 함.index() : list의 순서를 출력. (list 번호는 0부터 시작이므로 +1을 해주어야 몇 번째인지 정확하게 출력 가능)Baekjoon 2577. 숫자의 개수: 각 숫자가 몇 번 나왔는지 저장하기 위해 일차원 배열을 만드는 문제📘 2577 문제 링크import sysA = int(sys.stdin.readline())B = int(sys.stdin.readline())C = int(sys.stdin.readline())num = str(A * B * C)for i in range(10):    print(num.count(str(i)))1) num 변수 값을 문자열로 변환.2) 변수.count(특정 값) → 변수 안에 들어있는 특정 값이 몇 개 인지 출력.Baekjoon 3052. 나머지📘 3052 문제 링크import sysn_list = for i in range(10):    n = int(sys.stdin.readline())    n_list.append(n % 42)sort = set(n_list)print(len(sort))입력한 수들을 42로 나눈 나머지를 리스트로 입력한 순서대로 저장.set() : list 값들 중 중복된 값 제거 후 정렬해주는 함수.중복된 값 제거 후 길이를 출력하면 서로 다른 나머지 값들이 몇 개인지 출력 가능.Baekjoon 1546. 평균: 평균을 조작하는 문제📘 1546 문제 링크N = int(input())score = list(map(int, input().split()))result = 0for i in range(N):    result += scorei/int(max(score)) * 100print(result/N)Baekjoon 8958. OX퀴즈: OX 퀴즈의 결과를 일차원 배열로 입력받아 점수를 계산하는 문제📘 8958 문제 링크N = int(input())for i in range(N):    ox = input()    ox_list = list(ox)    score = 0    result = 0    for j in range(len(ox)):        if ox_listj == 'O':            score += 1            result += score        elif ox_listj == 'X':            score = 0    print(result)입력한 값을 리스트에 저장하고,각 O,X 마다 일회성 점수를 부여할 변수를 score로 지정.일회성 점수를 누적시켜 저장시킬 변수를 result로 지정.for문 안에 다른 for문을 두어 중첩 for문 사용.❗ 각각의 입력 값에 대해 점수가 누적되서 출력되어 원하는 출력 결과가 나오지 않았다,,, 그래서 푸는데 시간이 오래 걸림.❗ 주의 ❗ print(result)를 어디에 두는지에 따라 출력 값이 달라짐. 주의하자!Baekjoon 4344. 평균은 넘겠지📘 4344 문제 링크C = int(input())for i in range(C):    inputs = list(map(int, input().split()))    num = int(inputs0)    del inputs0    inputs_sum = int(sum(inputs))    mean = inputs_sum / num    person = 0    result = 0    for j in range(num):        if inputsj &gt; mean:            person += 1    result = (person/num) * 100    final = format(result, &quot;.3f&quot;)    print(final + &quot;%&quot;)del 리스트원소 : 리스트에서 입력한 원소 삭제.round()는 소수점 아래 자리에 0으로 끝날 경우 표시되지 않음.  ex) round(3.10159, 2) → 3.10이 아닌 3.1 출력.위의 문제 해결을 위해 format() 함수 사용.  ➡ format(수, &quot;.3f&quot;) : 반올림하여 소수점 셋째 자리까지 실수로 출력."
192,"백준-단계별로 풀어보기-'while문' 파트 문제들 중 기억해야 할 개념 및 문제들을 기록합니다.Baekjoon 10951. A+B - 4: 입력이 끝날 때까지 A+B를 출력하는 문제.📘 10951 문제 링크try:    while True:        a, b = map(int, input().split())        print(a+b)except:    exit()⬇ 아래의 경우, 런타임 하는데 4ms 더 걸림.while True:    try:        a, b = map(int, input().split())        print(a+b)    except:        break테스트 케이스가 주어지지 않았으므로 예외 발생 코드를 작성해주어야 함.try :    실행 코드except :    예외 발생시 처리 코드exit() : 프로그램 종료Baekjoon 10952. A+B - 5: 0 0이 들어올 때까지 A+B를 출력하는 문제📘 10952 문제 링크while True:    a, b = map(int, input().split())    if a == 0 and b == 0:        break    print(a+b)while이 참(True)일때까지 반복.입력한 a, b가 모두 0일 때, 반복문 종료.Baekjoon 1110. 더하기 사이클: 원래 수로 돌아올 때까지 연산을 반복하는 문제📘 1110 문제 링크N = num = int(input())cycle = 0while True:    ten = N // 10    one = N % 10    total = ten + one    cycle += 1    N = int(str(one) + str(total % 10))    if (num == N):        breakprint(cycle)2 + 6 = 8 → int로 계산.2 + 6 = 26 → str로 변환하여 계산."
193,"백준-단계별로 풀어보기-'for문' 파트 문제들 중 기억해야 할 개념 및 문제들을 기록합니다.Baekjoon 2739. 구구단: 구구단을 출력하는 문제📘 2739 문제 링크N = int(input())for i in range(1, 10):    print(N, &quot;*&quot;, i, &quot;=&quot;, N*i)C언어랑 헷갈려서 처음에 for (i=1;i&lt;=9;i++)로 반복문 썼다가 오류남.↳ 파이썬 반복문 개념 까먹지 말기!Baekjoon 8393. 합: 1부터 N까지의 합을 구하는 문제. 물론 반복문 없이 풀 수도 있습니다.📘 8393 문제 링크n = int(input())result = 0for i in range(1, n+1):    result += iprint(result)합을 저장해 놓을 변수 result를 지정해주어 합 출력.파이썬에서 for문의 범위를 지정할 때 n+1이라고 해주어야 n 범위까지 반복.Baekjoon 15552. 빠른 A+B: 빠르게 입력받고 출력하는 문제📘 15552 문제 링크import sysT = int(sys.stdin.readline())for i in range(T):    a, b = map(int, sys.stdin.readline().split())    print(a + b)input()을 사용하는 대신 sys.stdin.readline()을 사용하면 속도가 더 빨라진다.sys.stdin.readline()를 사용하려면 import sys로 모듈을 생성해준다.sys.stdin.readline : 한 라인 입력시 사용sys.stdin : 여러 줄 입력시 사용Baekjoon 2742. 기찍 N: 제문 는하력출 지까N 터부1📘 2742 문제 링크N = int(input())for i in range(1, N+1):    print(N)    N -= 1Baekjoon 11022. A+B - 8: A+B를 바로 위 문제보다 아름답게 출력하는 문제📘 11022 문제 링크import sysT = int(sys.stdin.readline())for i in range(1, T+1):    a, b = map(int, sys.stdin.readline().split())    print(&quot;Case #%d: %d + %d = %d&quot; % (i, a, b, a+b))문자열과 변수에 지정한 수를 함께 출력시 print(&quot;case %d&quot; %(a))와 같은 형식으로 작성.문자열 출력시 띄어쓰기 해서 계속 오류남. 띄어쓰기 주의하기!%s  → 문자열%d → 정수%f → 실수Baekjoon 2438. 별 찍기 - 1: 별을 찍는 문제 1📘 2438 문제 링크import sysT = int(sys.stdin.readline())for i in range(1, T+1):    print(&quot;*&quot; * i)for i in range(T) 입력시 i는 0 ~ T-1까지 범위.for i in range(1, T+1) 입력시 i는 1 ~ T까지 범위이므로i를 해주면 &quot;*&quot; 문자열이 증가하는 i 만큼 증가되어서 출력.Baekjoon 2439. 별 찍기 - 2: 별을 찍는 문제 2📘 2439 문제 링크import sysT = int(sys.stdin.readline())for i in range(1, T+1):    print(&quot; &quot; * (T-i) + &quot;*&quot; * i)&quot;*&quot; 앞에 T에서 출력될 * 개수를 뺀 만큼 공백을 넣어주어야 함. → &quot; &quot; * (T-i)print문에서 T-i를 괄호로 묶어주지 않으면 오류 발생.Baekjoon 10871. X보다 작은 수: for와 if를 같이 쓰는 문제📘 10871 문제 링크N, X = map(int, input().split())A = list(map(int, input().split()))for i in range(N):    if X &gt; Ai:        print(Ai,  end=&quot; &quot;)list() : 입력한 수들을 list로 변수에 저장.end=&quot; &quot; : print가 끝난 후 줄을 바꿔주는 것이 아니라 공백 한 칸 후, 같은 줄에 다음 print문이 출력."
194,"백준-단계별로 풀어보기-'if문' 파트 문제들 중 기억해야 할 개념 및 문제들을 기록합니다.Baekjoon 2884. 알람 시계: 시간 뺄셈 문제📘 2884 문제 링크H, M = map(int, input().split())if M &gt;= 45:    print(H, M-45)elif M &lt; 45 and H &gt; 0:    print(H-1, M+15)else:    print(23, M+15)1) '분'이 45분 이상일 때2) '분'이 45분 미만이며 '시'가 0보다 클 때3) 나머지 조건('분'이 45분 미만이면서 '시'가 0일때)⇒ 3가지 조건으로 나누어 출력 조건을 설정하기."
195,"백준-단계별로 풀어보기-'입출력과 사칙연산' 파트 문제들 중 기억해야 할 개념 및 문제들을 기록합니다.Baekjoon 1000. A+B: 두 수를 입력받고 합을 출력하는 문제📘 1000 문제 링크Q: 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.a, b = map(int, input().split())print(a + b)map() : a와 b 변수를 한번에 int로 타입 변환해 주는 함수.input() : 값을 입력받는 함수.split() : 공백으로 a와 b 변수를 구분하여 한번에 두 변수를 입력 받을 수 있는 함수.Baekjoon 10171. 고양이: 주어진 예제처럼 출력하는 문제 3📘 10171 문제 링크Q: 아래 예제와 같이 고양이를 출력하시오.\    /\ )  ( ')(  /  ) \(__)|print(&quot;&quot;&quot;\\    /\\ )  ( ')(  /  ) \\(__)|&quot;&quot;&quot;)&quot;&quot;&quot; &quot;&quot;&quot; : &quot; 3개 사용시 여러 줄에 걸친 문자열 출력 가능.\를 문자열로 출력시 \ 즉, \를 2번 입력해야 함.Baekjoon 10172 개: 주어진 예제처럼 출력하는 문제 4📘 10172 문제 링크Q: 아래 예제와 같이 개를 출력하시오.|\_/||q p|   /}( 0 )&quot;&quot;&quot;\|&quot;^&quot;`    |||_/=\\__|print(&quot;|\_/|&quot;)print(&quot;|q p|   /}&quot;)print('( 0 )&quot;&quot;&quot;\\')print('|&quot;^&quot;`    |')print(&quot;||_/=\\\__|&quot;)출력할 문자 중에 &quot;&quot;&quot; 가 있기 때문에 print(&quot;&quot;&quot; &quot;&quot;&quot;) 를 사용하면 오류 발생.\ 앞에 \를 붙여서 출력 cf. \ 출력시 \.Baekjoon 2588. 곱셈: 빈 칸에 들어갈 수는?📘 2588 문제 링크Q: (세 자리 수) × (세 자리 수)는 다음과 같은 과정을 통하여 이루어진다.(1)과 (2)위치에 들어갈 세 자리 자연수가 주어질 때 (3), (4), (5), (6)위치에 들어갈 값을 구하는 프로그램을 작성하시오.Input첫째 줄에 (1)의 위치에 들어갈 세 자리 자연수가, 둘째 줄에 (2)의 위치에 들어갈 세자리 자연수가 주어진다.Output첫째 줄부터 넷째 줄까지 차례대로 (3), (4), (5), (6)에 들어갈 값을 출력한다.a = int(input())b = int(input())print(a * (b % 10))print(a * ((b // 10) % 10))print(a * (b // 100))print(a * b)b에서 각 자리에 알맞는 숫자를 출력하여 a와 곱해야 함. ← //, % (나눗셈 몫과 나머지) 이용하기."
196,"스파르팅코딩클럽 '프론트엔드의 꽃, 리액트' 5주차 강의를 듣고 작성한 글입니다.Redux에서 FireStore 데이터 주고받기먼저 비동기 통신하기 위해 필요한 미들웨어를 설치한다.yarn add redux-thunkredux-thunk : 객체 대신 함수를 생성하는 액션 생성함수를 작성할 수 있도록 해줌.configStore.jsimport { createStore, combineReducers, applyMiddleware } from &quot;redux&quot;;import thunk from &quot;redux-thunk&quot;;import bucket from &quot;./modules/bucket&quot;;import { createBrowserHistory } from &quot;history&quot;;export const history = createBrowserHistory();const middlewares = thunk;const enhancer = applyMiddleware(...middlewares);const rootReducer = combineReducers({ bucket });const store = createStore(rootReducer, enhancer);export default store;&gt;- firestore 적용하는 순서1) load할 때 데이터 가지고 오기 (firebase와 통신하는 함수 생성하고 reducer 수정)2) create에 firebase 적용 (firebase랑 통신하는 함수 생성하고 reducer 수정 → 불러다가 쓰기)3) update에 firestore 적용4) delete에 firestore 적용- bucket.js```javascriptimport { firestore } from &quot;../../firebase&quot;;const bucket_db = firestore.collection(&quot;bucket&quot;);// Actionsconst LOAD = &quot;bucket/LOAD&quot;;const CREATE = &quot;bucket/CREATE&quot;;const DELETE = &quot;bucket/DELETE&quot;;const UPDATE = &quot;bucket/UPDATE&quot;;const LOADED = &quot;bucket/LOADED&quot;;const initialState = {  list:     { text: &quot;영화관 가기&quot;, completed: false },    { text: &quot;매일 책읽기&quot;, completed: false },    { text: &quot;기타 배우기&quot;, completed: false },  ,  is_loaded: false,};// Action Creatorsexport const loadBucket = (bucket) =&gt; {  return { type: LOAD, bucket };};export const createBucket = (bucket) =&gt; {  // bucket = text  return { type: CREATE, bucket };};export const deleteBucket = (bucket) =&gt; {  return { type: DELETE, bucket };};export const updateBucket = (bucket) =&gt; {  return { type: UPDATE, bucket };};export const isLoaded = (loaded) =&gt; {  return { type: LOADED, loaded };};export const loadBucketFB = () =&gt; {  return function (dispatch) {    bucket_db.get().then((docs) =&gt; {      let bucket_data = ;      docs.forEach((doc) =&gt; {        if (doc.exists) {          bucket_data = ...bucket_data, { id: doc.id, ...doc.data() };        }      });      console.log(bucket_data);      dispatch(loadBucket(bucket_data));    });  };};export const addBucketFB = (bucket) =&gt; {  return function (dispatch) {    let bucket_data = { text: bucket, completed: false };    dispatch(isLoaded(false));    bucket_db.add(bucket_data).then((docRef) =&gt; {      bucket_data = { ...bucket_data, id: docRef.id };      dispatch(createBucket(bucket_data));      dispatch(isLoaded(true));    });  };};export const updateBucketFB = (bucket) =&gt; {  return function (dispatch, getState) {    const _bucket_data = getState().bucket.listbucket;    let bucket_data = { ..._bucket_data, completed: true };    if (!bucket_data.id) {      return;    }    bucket_db      .doc(bucket_data.id)      .update(bucket_data)      .then((docRef) =&gt; {        dispatch(updateBucket(bucket));      })      .catch((error) =&gt; {        console.log(error);      });  };};export const deleteBucketFB = (bucket) =&gt; {  return function (dispatch, getState) {    const _bucket_data = getState().bucket.listbucket;    if (!_bucket_data.id) {      return;    }    bucket_db      .doc(_bucket_data.id)      .delete()      .then((docRef) =&gt; {        dispatch(deleteBucket(bucket));      })      .catch((error) =&gt; {        console.log(error);      });  };};// Reducerexport default function reducer(state = initialState, action = {}) {  switch (action.type) {    case &quot;bucket/LOAD&quot;: {      if (action.bucket.length &gt; 0) {        return { list: action.bucket, is_loaded: true };      }      return state;    }    case &quot;bucket/CREATE&quot;: {      const new_bucket_list = ...state.list, action.bucket;      return { list: new_bucket_list };    }    case &quot;bucket/DELETE&quot;: {      const bucket_list = state.list.filter((l, idx) =&gt; {        if (idx !== action.bucket) {          return l;        }      });      return { list: bucket_list };    }    case &quot;bucket/UPDATE&quot;: {      const bucket_list = state.list.map((l, idx) =&gt; {        if (idx === action.bucket) {          return { ...l, completed: true };        } else {          return l;        }      });      return { list: bucket_list };    }    case &quot;bucket/LOADED&quot;: {      return { ...state, is_loaded: action.loaded };    }    default:      return state;  }}material-ui 사용설치 : yarn add @material-ui/core @material-ui/iconsmaterial-ui 사용해서 Detail.js 페이지 버튼 수정하기Detail.jsimport React from &quot;react&quot;;import Button from &quot;@material-ui/core/Button&quot;;import ButtonGroup from &quot;@material-ui/core/ButtonGroup&quot;;import { useSelector, useDispatch } from &quot;react-redux&quot;;import { updateBucketFB, deleteBucketFB } from &quot;./redux/modules/bucket&quot;;const Detail = (props) =&gt; {  const dispatch = useDispatch();  const bucket_list = useSelector((state) =&gt; state.bucket.list);  console.log(bucket_list, props);  const bucket_index = parseInt(props.match.params.index);  return (          {bucket_listbucket_index.text}              &lt;Button          color=&quot;secondary&quot;          onClick={() =&gt; {            dispatch(deleteBucketFB(bucket_index));            props.history.goBack();          }}        &gt;          삭제하기                &lt;Button          color=&quot;primary&quot;          onClick={() =&gt; {            dispatch(updateBucketFB(bucket_index));            props.history.goBack();          }}        &gt;          완료하기                    );};export default Detail;### Spinner 띄우기&gt;* 새로고침시 redux에 넣어둔 데이터인 가짜 데이터가 먼저 보임.→ firestore의 data만 제대로 보여주고 싶을 때 데이터를 가져올 때까지 페이지를 가려버림.- Spinner.js```javascriptimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import { Eco } from &quot;@material-ui/icons&quot;;const Spinner = (props) =&gt; {  return (    &lt;Outter&gt;      &lt;Eco style={{ color: &quot;#673ab7&quot;, fontSize: &quot;150px&quot; }} /&gt;    &lt;/Outter&gt;  );};const Outter = styled.div`  position: fixed;  top: 0;  left: 0;  width: 100vw;  height: 100vh;  display: flex;  align-items: center;  justify-content: center;  background-color: #ede2ff;`;export default Spinner;App.jsimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import { withRouter } from &quot;react-router&quot;;import { Route, Switch } from &quot;react-router-dom&quot;;import BucketList from &quot;./BucketList&quot;;import Detail from &quot;./Detail&quot;;import NotFound from &quot;./NotFound&quot;;import { connect } from &quot;react-redux&quot;;import { loadBucketFB, addBucketFB } from &quot;./redux/modules/bucket&quot;;import Progress from &quot;./Progress&quot;;import Spinner from &quot;./Spinner&quot;;import { firestore } from &quot;./firebase&quot;;const mapStateToProps = (state) =&gt; ({  bucket_list: state.bucket.list,  is_loaded: state.bucket.is_loaded,});const mapDispatchToProps = (dispatch) =&gt; {  return {    load: () =&gt; {      dispatch(loadBucketFB());    },create: (new_item) =&gt; {  dispatch(addBucketFB(new_item));},  };};class App extends React.Component {  constructor(props) {    super(props);    this.state = {};this.text = React.createRef();  }  componentDidMount() {    this.props.load();// const bucket = firestore.collection(&quot;bucket2&quot;);// bucket.doc(&quot;bucket_item1&quot;).set({ text: &quot;수영 배우기&quot;, completed: false });// bucket//   .doc(&quot;bucket_item&quot;)//   .get()//   .then((doc) =&gt; {//     if (doc.exists) {//       console.log(doc);//       console.log(doc.data());//       console.log(doc.id);//     }//     console.log(doc.exists);//   });// bucket.get().then((docs) =&gt; {//   let bucket_data = ;//   docs.forEach((doc) =&gt; {//     if (doc.exists) {//       bucket_data = ...bucket_data, { id: doc.id, ...doc.data() };//     }//   });//   console.log(bucket_data);// });// // bucket.add({ text: &quot;드럼 배우기&quot;, completed: false }).then((docRef) =&gt; {// //   console.log(docRef);// //   console.log(docRef.id);// // });// // bucket.doc(&quot;bucket_item&quot;).update({ text: &quot;기타 배우기2&quot; });// bucket//   .doc(&quot;bucket_item2&quot;)//   .delete()//   .then((docRef) =&gt; {//     console.log(&quot;지웠어요!&quot;);//   });  }  addBucketList = () =&gt; {    const new_item = this.text.current.value;    this.props.create(new_item);  };  render() {    return (              {!this.props.is_loaded ? (                  ) : (          &lt;React.Fragment&gt;                          My BucketList                                                                                                                                                            추가하기                        &lt;button              onClick={() =&gt; {                window.scrollTo({ top: 0, left: 0, behavior: &quot;smooth&quot; });              }}            &gt;              위로가기                      &lt;/React.Fragment&gt;        )}          );  }}const Input = styled.div`  max-width: 350px;  min-height: 10vh;  background-color: #fff;  padding: 16px;  margin: 20px auto;  border-radius: 5px;  border: 1px solid #ddd;  display: flex;  align-items: center;  justify-content: center;  &amp; &gt; * {    padding: 10px;  }  &amp; input {    border-radius: 5px;    margin-right: 10px;    border: 1px solid #5d5d5d;    width: 60%;    &amp;:focus {      border: 1px solid #a673ff;    }  }  &amp; button {    width: 25%;    color: #fff;    border-radius: 5px;    border: 1px solid #6799ff;    background-color: #6799ff;  }`;const Container = styled.divmax-width: 350px;  min-height: 70vh;  background-color: #fff;  padding: 16px;  margin: 20px auto;  border-radius: 5px;  border: 1px solid #ddd;;const Title = styled.h1color: #5587ed;  text-align: center;;const Line = styled.hrmargin: 16px 0px;  border: 1px dotted #ddd;;export default connect(mapStateToProps, mapDispatchToProps)(withRouter(App));&lt;br/&gt;----### 1. AWS S3 버킷으로 배포하기&gt;- S3(Simple Storage Service) 버킷 : 스토리지 서비스로, 이미지나 파일 저장.- S3 버킷을 생성 후 설정까지 해준 뒤,`yarn build`- build 한후, 버킷에 build 폴더 내의 모든 파일을 업로드함.#### 도메인 연결&gt;- route 53에서 호스팅 영역 생성 후, 네임서버를 가비아에 등록(4개 순서대로 / 맨 뒤 .빼고 등록)→ 레코드 생성 → 내 도메인 주소로 들어가 확인----### 2. Firebase로 배포하기&gt;1) firebase 호스팅```shell// cli 설치yarn add global firebase-tools// firebase에 로그인yarn firebase login// init 실행yarn firebase init2) 호스팅 선택 후,// 빌드한 결과물 올리기yarn firebase deploy3) firebase  대시보드-호스팅에서 도메인에 들어가 화면 확인.모바일에서 도메인 접속 후, 확인 결과 화면 ❓ 수정할 점 : 스피너 화면에서 자동으로 안 넘어가고 새로고침을 해야 다음 화면으로 넘어가는데 이유는 모르겠다...HW FriendTest ProjectSpinner.jsimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import img from &quot;./spinner.png&quot;;const Spinner = (props) =&gt; {  return (                );};const Outter = styled.divbackground-color: #df402c88;  width: 100vw;  height: 100vh;  display: flex;  align-items: center;  justify-content: center;  &amp; img {    width: 400px;  };export default Spinner;- redux/modules/rank.js```javascriptimport { firestore } from &quot;../../firebase&quot;;const rank_db = firestore.collection(&quot;rank&quot;);// Actionsconst ADD_USER_NAME = &quot;rank/ADD_USER_NAME&quot;;const ADD_USER_MESSAGE = &quot;rank/ADD_USER_MESSAGE&quot;;const ADD_RANK = &quot;rank/ADD_RANK&quot;;const GET_RANK = &quot;rank/GET_RANK&quot;;const IS_LOADED = &quot;rank/IS_LOADED&quot;;const initialState = {  user_name: &quot;&quot;,  user_message: &quot;&quot;,  user_score: &quot;&quot;,  score_text: {    60: &quot;우린 친구! 앞으로도 더 친하게 지내요!&quot;,    80: &quot;우와! 우리는 엄청 가까운 사이!&quot;,    100: &quot;우린 둘도 없는 단짝! :)&quot;,  },  ranking:     { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },    { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },    { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },    { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },    { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },    { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },    { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },    { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },    { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },    { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },    { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },  ,  is_loadad: false,};export const addUserName = (user_name) =&gt; {  return { type: ADD_USER_NAME, user_name };};export const addUserMessage = (user_message) =&gt; {  return { type: ADD_USER_MESSAGE, user_message };};export const addRank = (rank_info) =&gt; {  return { type: ADD_RANK, rank_info };};export const getRank = (rank_list) =&gt; {  return { type: GET_RANK, rank_list };};export const isLoaded = (loaded) =&gt; {  return { type: IS_LOADED, loaded };};export const addRankFB = (rank_info) =&gt; {  return function (dispatch) {    dispatch(isLoaded(false));    let rank_data = {      message: rank_info.message,      name: rank_info.name,      score: rank_info.score,    };    rank_db.add(rank_data).then((doc) =&gt; {      console.log(doc.id);      rank_data = { ...rank_data, id: doc.id, current: true };      dispatch(addRank(rank_data));    });  };};export const getRankFB = () =&gt; {  return function (dispatch) {    dispatch(isLoaded(false));    rank_db.get().then((docs) =&gt; {      let rank_data = ;      docs.forEach((doc) =&gt; {        console.log(doc.data());        rank_data = ...rank_data, { id: doc.id, ...doc.data() };      });      dispatch(getRank(rank_data));      dispatch(isLoaded(true));    });  };};//Reducerexport default function reducer(state = initialState, action = {}) {  switch (action.type) {    case &quot;rank/ADD_USER_NAME&quot;: {      return { ...state, user_name: action.user_name };    }    case &quot;rank/ADD_USER_MESSAGE&quot;: {      return { ...state, user_message: action.user_message };    }    case &quot;rank/ADD_RANK&quot;: {      return { ...state, ranking: ...state.ranking, action.rank_info };    }    case &quot;rank/GET_RANK&quot;: {      let ranking_data = ...state.ranking;      const rank_ids = state.ranking.map((r, idx) =&gt; {        return r.id;      });      console.log(rank_ids);      const rank_data_fb = action.rank_list.filter((r, idx) =&gt; {        if (rank_ids.indexOf(r.id) === -1) {          ranking_data = ...ranking_data, r;        }      });      console.log(ranking_data);      return { ...state, ranking: ranking_data };    }    case &quot;rank/IS_LOADED&quot;: {      return { ...state, is_loaded: action.loaded };    }    default:      return state;  }}Ranking.jsimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import { useSelector, useDispatch } from &quot;react-redux&quot;;import { resetAnswer } from &quot;./redux/modules/quiz&quot;;import { getRankFB } from &quot;./redux/modules/rank&quot;;import Spinner from &quot;./Spinner&quot;;const Ranking = (props) =&gt; {  const dispatch = useDispatch();  const _ranking = useSelector((state) =&gt; state.rank.ranking);  const is_loaded = useSelector((state) =&gt; state.rank.is_loaded);  const user_rank = React.useRef(null);  React.useEffect(() =&gt; {    dispatch(getRankFB());    if (!user_rank.current) {      return;    }window.scrollTo({  top: user_rank.current.offsetTop,  left: 0,  behavior: &quot;smooth&quot;,});  }, );  const ranking = _ranking.sort((a, b) =&gt; {    return b.score - a.score;  });  if (!is_loaded) {    return ;  }  return (                            {ranking.length}명의 사람들 중 당신은?                &lt;RankWrap&gt;    {ranking.map((r, idx) =&gt; {      if (r.current) {        return (          &lt;RankItem key={idx} highlight={true} ref={user_rank}&gt;            &lt;RankNum&gt;{idx + 1}등&lt;/RankNum&gt;            &lt;RankUser&gt;              &lt;p&gt;                &lt;b&gt;{r.name}&lt;/b&gt;              &lt;/p&gt;              &lt;p&gt;{r.message}&lt;/p&gt;            &lt;/RankUser&gt;          &lt;/RankItem&gt;        );      }      return (        &lt;RankItem key={idx}&gt;          &lt;RankNum&gt;{idx + 1}등&lt;/RankNum&gt;          &lt;RankUser&gt;            &lt;p&gt;              &lt;b&gt;{r.name}&lt;/b&gt;            &lt;/p&gt;            &lt;p&gt;{r.message}&lt;/p&gt;          &lt;/RankUser&gt;        &lt;/RankItem&gt;      );    })}  &lt;/RankWrap&gt;  &lt;Button    onClick={() =&gt; {      dispatch(resetAnswer());      window.location.href = &quot;/&quot;;    }}  &gt;    다시 하기  &lt;/Button&gt;&lt;/RankContainer&gt;  );};const RankContainer = styled.divwidth: 100%;  padding-bottom: 100px;;const Topbar = styled.div`  position: fixed;  top: 0;  left: 0;  width: 100vw;  min-height: 50px;  border-bottom: 1px solid #ddd;  background-color: #fff;  &amp; &gt; p {    text-align: center;  }  &amp; &gt; p &gt; span {    border-radius: 30px;    background-color: #fef5d4;    font-weight: 600;    padding: 4px 8px;  }`;const RankWrap = styled.divdisplay: flex;  flex-direction: column;  width: 100%;  margin-top: 58px;;const RankItem = styled.divwidth: 80vw;  margin: 8px auto;  display: flex;  border-radius: 5px;  border: 1px solid #ddd;  padding: 8px 16px;  align-items: center;  background-color: ${(props) =&gt; (props.highlight ? &quot;#ffd6aa&quot; : &quot;#ffffff&quot;)};;const RankNum = styled.divtext-align: center;  font-size: 2em;  font-weight: 600;  padding: 0px 16px 0px 0px;  border-right: 1px solid #ddd;;const RankUser = styled.divpadding: 8px 16px;  text-align: left;  &amp; &gt; p {    &amp;:first-child &gt; b {      border-bottom: 2px solid #212121;    }    margin: 0px 0px 8px 0px;  };const Button = styled.buttonposition: fixed;  bottom: 5vh;  left: 0;  padding: 8px 24px;  background-color: ${(props) =&gt; (props.outlined ? &quot;#ffffff&quot; : &quot;#dadafc&quot;)};  border-radius: 30px;  margin: 0px 10vw;  border: 1px solid #dadafc;  width: 80vw;;export default Ranking;```모바일에서 확인한 결과 화면❗ 수정할 점:1) 문제 스와이프에서 한번의 스와이프 행동에 문제가 두개씩 넘어가는 오류 해결하기2) rank 데이터 값 제대로 firebase와 연결하기"
197,"스파르팅코딩클럽 '프론트엔드의 꽃, 리액트' 3주차 강의를 듣고 작성한 글입니다.keyframes: styled-components 안에 포함되어 있는 라이브러리.여러 animation을 통해 좀 더 dynamic하게 움직임을 표현 가능하다..box { width: 100px; height: 100px; background: #444;}.box.active { animation: boxFade 2s 1s infinite linear alternate;}@keyframes boxFade { 0% {  opacity: 1; } 50% {  opacity: 0; } 100% {  opacity: 1; } Toy Project BucketListProgressbar 추가하기Scrollbar 추가하기Css 수정해서 더 예쁘게 꾸며보기Progress.jsimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import { useSelector } from &quot;react-redux&quot;;const Progress = (props) =&gt; {  const bucket_list = useSelector((state) =&gt; state.bucket.list);  let count = 0;  let goal_per = bucket_list.map((l, idx) =&gt; {    if (l.completed) {      count++;    }  });  return (          &lt;HighLight width={(count / bucket_list.length) * 100 + &quot;%&quot;}&gt;            );};const ProgressBar = styled.divbackground: #eee;  width: 100%;  height: 20px;  display: flex;  border-radius: 10px;  align-items: center;;const HighLight = styled.divbackground: #a566ff;  width: ${(props) =&gt; props.width};  height: 20px;  border-radius: 10px;  transition: 2s;;const Dot = styled.divbackground: #fff;  border: 5px solid #a566ff;  box-sizing: border-box;  margin: 0px 0px 0px -10px;  width: 40px;  height: 40px;  border-radius: 20px;;export default Progress;- 결과 화면!(https://images.velog.io/images/tnqls1211v/post/f39e2a7c-d1f5-4886-9a0f-f06450ef7ffa/11.jpg)----### Firebase: realtime-database (실시간 데이터베이스)를 제공하는 서비스- BaaS(Backend as a Service) : 데이터베이스, 소셜 서비스 연동, 파일시스템 등을 API 형태로 제공#### React에 Firebase 연동&gt; 프로젝트에 Firebase 추가 : yarn add firebase- ./src/firebase.js```javascriptimport firebase from &quot;firebase/app&quot;;import &quot;firebase/firestore&quot;;const firebaseConfig = {    // firebase 설정과 관련된 개인 정보};firebase.initializeApp(firebaseConfig);const firestore = firebase.firestore();export { firestore };➰ componentDidMount()를 통해 값을 추가, 삭제, 변경하여 Cloud Firestore 안의 값들이 변경하는지 확인한다.App.js ...componentDidMount() {  const bucket = firestore.collection(&quot;bucket2&quot;);  bucket.doc(&quot;bucket_item1&quot;).set({ text: &quot;수영 배우기&quot;, completed: false });  bucket    .doc(&quot;bucket_item&quot;)    .get()    .then((doc) =&gt; {      if (doc.exists) {        console.log(doc);        console.log(doc.data());        console.log(doc.id);      }      console.log(doc.exists);    });  bucket.get().then((docs) =&gt; {    let bucket_data = ;    docs.forEach((doc) =&gt; {      if (doc.exists) {        bucket_data = ...bucket_data, { id: doc.id, ...doc.data() };      }    });    console.log(bucket_data);  });  // bucket.add({ text: &quot;드럼 배우기&quot;, completed: false }).then((docRef) =&gt; {  //   console.log(docRef);  //   console.log(docRef.id);  // });  // bucket.doc(&quot;bucket_item&quot;).update({ text: &quot;기타 배우기2&quot; });  bucket    .doc(&quot;bucket_item2&quot;)    .delete()    .then((docRef) =&gt; {      console.log(&quot;지웠어요!&quot;);    });}➰ 연동해주었으면 아래와 같이 자동으로 Cloud Firestore에 값이 들어간다.HW FriendTestProgressbar 추가약간의 css 수정Ranking 페이지에서 내 랭킹으로 자동 스크롤 기능 추가Progress.jsimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import { useSelector } from &quot;react-redux&quot;;const Progress = (props) =&gt; {  const quiz_list = useSelector((state) =&gt; state.quiz.quiz);  const answers = useSelector((state) =&gt; state.quiz.answers);  let count = answers.length;  return (          &lt;HighLight width={(count / quiz_list.length) * 100 + &quot;%&quot;}&gt;            );};const ProgressBar = styled.divwidth: 80%;  margin: 40px auto;  margin-bottom: 80px;  background: #eee;  height: 20px;  display: flex;  align-items: center;  border-radius: 10px;;const HighLight = styled.divbackground: #df402c88;  width: ${(props) =&gt; props.width};  height: 20px;  border-radius: 10px;  transition: width 1s;;const Dot = styled.divbackground: #fff;  border: 5px solid #df402c88;  box-sizing: border-box;  margin: 0px 0px 0px -10px;  width: 40px;  height: 40px;  border-radius: 20px;;export default Progress;- Ranking.js```javascriptimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import { useSelector, useDispatch } from &quot;react-redux&quot;;import { resetAnswer } from &quot;./redux/modules/quiz&quot;;const Ranking = (props) =&gt; {  const dispatch = useDispatch();  const _ranking = useSelector((state) =&gt; state.rank.ranking);  const user_rank = React.useRef(null);  React.useEffect(() =&gt; {    if (!user_rank) {      return;    }    window.scrollTo({      top: user_rank.current.offsetTop,      left: 0,      behavior: &quot;smooth&quot;,    });  });  const ranking = _ranking.sort((a, b) =&gt; {    return b.score - a.score;  });  return (    &lt;RankContainer&gt;      &lt;Topbar&gt;        &lt;p&gt;          &lt;span&gt;{ranking.length}명&lt;/span&gt;의 사람들 중 당신은?        &lt;/p&gt;      &lt;/Topbar&gt;      &lt;RankWrap&gt;        {ranking.map((r, idx) =&gt; {          if (r.current) {            return (              &lt;RankItem key={idx} highlight={true} ref={user_rank}&gt;                &lt;RankNum&gt;{idx + 1}등&lt;/RankNum&gt;                &lt;RankUser&gt;                  &lt;p&gt;                    &lt;b&gt;{r.name}&lt;/b&gt;                  &lt;/p&gt;                  &lt;p&gt;{r.message}&lt;/p&gt;                &lt;/RankUser&gt;              &lt;/RankItem&gt;            );          }          return (            &lt;RankItem key={idx}&gt;              &lt;RankNum&gt;{idx + 1}등&lt;/RankNum&gt;              &lt;RankUser&gt;                &lt;p&gt;                  &lt;b&gt;{r.name}&lt;/b&gt;                &lt;/p&gt;                &lt;p&gt;{r.message}&lt;/p&gt;              &lt;/RankUser&gt;            &lt;/RankItem&gt;          );        })}      &lt;/RankWrap&gt;      &lt;Button        onClick={() =&gt; {          dispatch(resetAnswer());          window.location.href = &quot;/&quot;;        }}      &gt;        다시 하기      &lt;/Button&gt;    &lt;/RankContainer&gt;  );};결과"
198,"스파르팅코딩클럽 '프론트엔드의 꽃, 리액트' 3주차 강의를 듣고 작성한 글입니다.SPA(Single Page Application): 서버에서 주는 html이 1개 뿐인 어플리케이션라우팅: 브라우저 주소에 따라 다른 페이지를 보여주는 것설치 : yarn add react-router-domindex.js에 추가import { BrowserRouter } from &quot;react-router-dom&quot;;ReactDOM.render(        ,  document.getElementById(&quot;root&quot;));- App.js```javascriptimport { Route } from &quot;react-router-dom&quot;;import { withRouter } from &quot;react-router&quot;;...    return (      &lt;div className=&quot;App&quot;&gt;        &lt;div&gt;          // 링크 연결          &lt;Link to=&quot;/&quot;&gt;Home으로 가기&lt;/Link&gt;          &lt;Link to=&quot;/cat&quot;&gt;Cat으로 가기&lt;/Link&gt;        &lt;/div&gt;        // 아래와 같이 Route 사용        &lt;Route path=&quot;/&quot; exact component={Home} /&gt;        &lt;Route path=&quot;/cat&quot; component={Cat} /&gt;        &lt;button onClick={() =&gt; {          //push() : 페이지 이동          this.props.history.push('/cat');        }}&gt;          /cat으로 가기        &lt;/button&gt;        &lt;button onClick={()=&gt;{          // goBack(): 뒤로가기          this.props.history.goBack();        }}&gt;뒤로가기        &lt;/button&gt;      &lt;/div&gt;    );  }}export default withRouter(App);exact 추가하면 Home 컴포넌트 중복 제거history 객체를 props로 받아오려면, withRouter 설정리덕스(Redux): 데이터를 한 군데 몰아넣고, 여기저기에서 꺼내볼 수 있게 해주는 것.설치 : yarn add redux react-redux1) State : 저장하고 있는 상태값 (= 데이터)2) Action : 상태에 변화가 필요할 때 발생하는 것3) ActionCreator : 액션 생성 함수. 액션을 만들기 위해 사용4) Reducer : 리덕스에 저장된 상태를 변경하는 함수5) Store : 리덕스를 적용하기 위해 만드는 것6) dispatch : 애션을 발생시키는 역할리덕스의 특징1) store는 1개만 사용2) store의 state(데이터)는 오직 action으로만 변경 가능3) 어떤 요청이 와도 리듀서는 같은 동작을 해야 함상태관리 흐름리덕스 Store를 Component에 연결한다.Component에서 상태 변화가 필요할 때 Action을 부른다.Reducer를 통해서 새로운 상태 값을 만들고,새 상태값을 Store에 저장한다.Component는 새로운 상태값을 받아온다.Toy Project BucketList리덕스 사용해서 버킷 리스트 데이터 삭제하기./redux/modules/bucket.js// Actionsconst LOAD = &quot;bucket/LOAD&quot;;const CREATE = &quot;bucket/CREATE&quot;;const DELETE = &quot;bucket/DELETE&quot;;const initialState = {  list: &quot;영화관 가기&quot;, &quot;매일 책읽기&quot;, &quot;수영 배우기&quot;,};// Action Creatorsexport const loadBucket = (bucket) =&gt; {  return { type: LOAD, bucket };};export const createBucket = (bucket) =&gt; {  // bucket = text  return { type: CREATE, bucket };};export const deleteBucket = (bucket) =&gt; {  return { type: DELETE, bucket };};// Reducerexport default function reducer(state = initialState, action = {}) {  switch (action.type) {    // do reducer stuff    case &quot;bucket/LOAD&quot;:      return state;case &quot;bucket/CREATE&quot;: {  const new_bucket_list = ...state.list, action.bucket;  return { list: new_bucket_list };}case &quot;bucket/DELETE&quot;: {  const bucket_list = state.list.filter((l, idx) =&gt; {    if (idx !== action.bucket) {      return l;    }  });  return { list: bucket_list };}default:  return state;  }}- ./redux/configStore.js```javscriptimport { createStore, combineReducers } from &quot;redux&quot;;import bucket from &quot;./modules/bucket&quot;;import { createBrowserHistory } from &quot;history&quot;;export const history = createBrowserHistory();const rootReducer = combineReducers({ bucket });const store = createStore(rootReducer);export default store;App.jsimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import { withRouter } from &quot;react-router&quot;;import { Route, Switch } from &quot;react-router-dom&quot;;import BucketList from &quot;./BucketList&quot;;import Detail from &quot;./Detail&quot;;import NotFound from &quot;./NotFound&quot;;import { connect } from &quot;react-redux&quot;;import { loadBucket, createBucket } from &quot;./redux/modules/bucket&quot;;const mapStateToProps = (state) =&gt; {  return { bucket_list: state.bucket.list };};const mapDispatchToProps = (dispatch) =&gt; {  return {    load: () =&gt; {      dispatch(loadBucket());    },create: (bucket) =&gt; {  dispatch(createBucket(bucket));},  };};class App extends React.Component {  constructor(props) {    super(props);    this.state = {      list: &quot;영화관 가기&quot;, &quot;매일 책읽기&quot;, &quot;수영 배우기&quot;,    };this.text = React.createRef();  }  componentDidMount() {    console.log(this.text);  }  addBucketList = () =&gt; {    const new_item = this.text.current.value;    this.props.create(new_item);  };  render() {    return (                        내 버킷리스트                                &lt;Route              path=&quot;/&quot;              exact              render={(props) =&gt; (                              )}            /&gt;                        &lt;Route              render={(props) =&gt; }            /&gt;                                              추가하기                  );  }}const Input = styled.divmax-width: 350px;  min-height: 10vh;  background-color: #fff;  padding: 16px;  margin: 20px auto;  border-radius: 5px;  border: 1px solid #ddd;;const Container = styled.divmax-width: 350px;  min-height: 80vh;  background-color: #fff;  padding: 16px;  margin: 20px auto;  border-radius: 5px;  border: 1px solid #ddd;;const Title = styled.h1color: slateblue;  text-align: center;;const Line = styled.hrmargin: 16px 0px;  border: 1px dotted #ddd;;export default connect(mapStateToProps, mapDispatchToProps)(withRouter(App));- Detail.js```javascriptimport React from &quot;react&quot;;import { useSelector, useDispatch } from &quot;react-redux&quot;;import { deleteBucket } from &quot;./redux/modules/bucket&quot;;const Detail = (props) =&gt; {  const dispatch = useDispatch();  const bucket_list = useSelector((state) =&gt; state.bucket.list);  console.log(bucket_list, props);  const bucket_index = parseInt(props.match.params.index);  return (    &lt;div&gt;      &lt;h1&gt;{bucket_listbucket_index}&lt;/h1&gt;      &lt;button        onClick={() =&gt; {          dispatch(deleteBucket(bucket_index));          props.history.goBack();        }}      &gt;        삭제하기      &lt;/button&gt;    &lt;/div&gt;  );};export default Detail;BucketList.jsimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import { useDispatch, useSelector } from &quot;react-redux&quot;;const BucketList = (props) =&gt; {  const bucket_list = useSelector((state) =&gt; state.bucket.list);  console.log(bucket_list);  return (          {bucket_list.map((list, index) =&gt; {        return (          &lt;ItemStyle            className=&quot;list_item&quot;            key={index}            onClick={() =&gt; {              props.history.push(&quot;/detail/&quot; + index);            }}          &gt;            {list}                  );      })}      );};const ListStyle = styled.divdisplay: flex;  flex-direction: column;  height: 100%;  overflow-x: hidden;  overflow-y: auto;;const ItemStyle = styled.divpadding: 16px;  margin: 8px;  background-color: aliceblue;;export default BucketList;- Quiz.js```javascriptimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import img from &quot;./ponyo.jpg&quot;;import TinderCard from &quot;react-tinder-card&quot;;import SwipeItem from &quot;./SwiptItem&quot;;import Score from &quot;./Score&quot;;import { useSelector, useDispatch } from &quot;react-redux&quot;;import { addAnswer } from &quot;./redux/modules/quiz&quot;;const Quiz = (props) =&gt; {  const dispatch = useDispatch();  const answers = useSelector((state) =&gt; state.quiz.answers);  const quiz = useSelector((state) =&gt; state.quiz.quiz);  const num = answers.length;  const onSwipe = (direction) =&gt; {    let _answer = direction === &quot;left&quot; ? &quot;O&quot; : &quot;X&quot;;    if (_answer === quiznum.answer) {      // 정답일 경우,      dispatch(addAnswer(true));    } else {      // 오답일 경우,      dispatch(addAnswer(false));    }  };  if (num &gt; quiz.length - 1) {    return &lt;Score {...props} /&gt;;    // return &lt;div&gt;퀴즈 끝!&lt;/div&gt;;  }  return (    &lt;QuizContainer&gt;      &lt;p&gt;        &lt;span&gt;{num + 1}번 문제&lt;/span&gt;      &lt;/p&gt;      {quiz.map((l, idx) =&gt; {        if (num === idx) {          return &lt;Question key={idx}&gt;{l.question}&lt;/Question&gt;;        }      })}      &lt;AnswerZone&gt;        &lt;Answer&gt;O&lt;/Answer&gt;        &lt;Answer&gt;X&lt;/Answer&gt;      &lt;/AnswerZone&gt;      {quiz.map((l, idx) =&gt; {        if (idx === num) {          return (            &lt;DragItem key={idx}&gt;              &lt;TinderCard                onSwipe={onSwipe}                onCardLeftScreen={onSwipe}                onCardRightScreen={onSwipe}                preventSwipe={&quot;up&quot;, &quot;down&quot;}              &gt;                &lt;img src={img} /&gt;              &lt;/TinderCard&gt;            &lt;/DragItem&gt;          );          //   &lt;SwipeItem key={idx} onSwipe={onSwipe} /&gt;;        }      })}    &lt;/QuizContainer&gt;  );};const QuizContainer = styled.div`  text-align: center;  margin-top: 130px;  &amp; &gt; p &gt; span {    padding: 8px 16px;    background-color: #ffe08c;    border-radius: 30px;    font-weight: bold;  }`;const Question = styled.h1`  font-size: 1.5em;`;const AnswerZone = styled.div`  width: 100vw;  height: 100vh;  display: flex;  position: absolute;  top: 0;  left: 0;  z-index: 1;`;const Answer = styled.div`  width: 50%;  display: flex;  justify-content: center;  align-items: center;  font-size: 100px;  font-weight: 600;  color: #dadafc77;`;const DragItem = styled.div`  display: flex;  align-items: center;  justify-content: center;  position: fixed;  top: 0;  left: 0;  width: 100vw;  height: 100vh;  z-index: 10;  &amp; img {    max-width: 130px;  }`;const Finish = styled.p`  text-align: center;  margin-top: 300px;  font-weight: 600;  font-size: 30px;`;export default Quiz;결과 화면버킷리스트 아이템 추가 후, 상세 페이지상세 페이지에서 삭제하기 누르면 뒤로가기와 동시에 리스트에서 삭제됨.HW FriendTest ProjectApp.jsimport React from &quot;react&quot;;import &quot;./App.css&quot;;import { Route, Switch } from &quot;react-router-dom&quot;;import Start from &quot;./Start&quot;;import Quiz from &quot;./Quiz&quot;;import Score from &quot;./Score&quot;;import Message from &quot;./Message&quot;;import Ranking from &quot;./Ranking&quot;;import { withRouter } from &quot;react-router&quot;;import { connect } from &quot;react-redux&quot;;const mapStateToProps = (state) =&gt; ({  ...state,});const mapDispatchToProps = (dispatch) =&gt; ({  load: () =&gt; {},});class App extends React.Component {  constructor(props) {    super(props);this.state = {};  }  render() {    return (                                                                                  );  }}export default connect(mapStateToProps, mapDispatchToProps)(withRouter(App));- Start.js```javascriptimport React from &quot;react&quot;;import img from &quot;./ponyo.jpg&quot;;import { useDispatch, useSelector } from &quot;react-redux&quot;;import { addUserName } from &quot;./redux/modules/rank&quot;;const Start = (props) =&gt; {  const dispatch = useDispatch();  const name = useSelector((state) =&gt; state.quiz.name);  const input_text = React.useRef(null);  return (    &lt;div className=&quot;container&quot;&gt;      &lt;div className=&quot;outter&quot;&gt;        &lt;img className=&quot;scc-img&quot; src={img} /&gt;        &lt;h1&gt;          나는 &lt;span&gt;{name}&lt;/span&gt;에 대해 얼마나 알고 있을까?        &lt;/h1&gt;        &lt;input          ref={input_text}          className=&quot;text-box&quot;          type=&quot;text&quot;          placeholder=&quot;내 이름&quot;        /&gt;        &lt;button          className=&quot;button&quot;          onClick={() =&gt; {            dispatch(addUserName(input_text.current.value));            props.history.push(&quot;/quiz&quot;);          }}        &gt;          시작하기        &lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  );};export default Start;Score.jsimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import { useSelector, useDispatch } from &quot;react-redux&quot;;import { addRank } from &quot;./redux/modules/rank&quot;;const Score = (props) =&gt; {  const name = useSelector((state) =&gt; state.quiz.name);  const score_texts = useSelector((state) =&gt; state.quiz.score_texts);  const answers = useSelector((state) =&gt; state.quiz.answers);  let correct = answers.filter((answer) =&gt; {    return answer;  });  let score = (correct.length / answers.length) * 100;  let score_text = &quot;&quot;;  Object.keys(score_texts).map((s, idx) =&gt; {    if (idx === 0) {      score_text = score_textss;    }    score_text = parseInt(s) &lt;= score ? score_textss : score_text;  });  return (                  {name}        퀴즈에         대한 내 점수는?                    {score}점{score_text}            &lt;Button        onClick={() =&gt; {          props.history.push(&quot;/message&quot;);        }}        outlined      &gt;        {name}에게 한마디            );};const ScoreContainer = styled.divdisplay: flex;  width: 100vw;  height: 100vh;  overflow: hidden;  padding: 20px;  box-sizing: border-box;  flex-direction: column; //세로로 객체 배열  justify-content: center;  align-items: center;;const Text = styled.h1font-size: 1.5em;  margin: 0px;  line-height: 1.7;  text-align: center;  &amp; span {    background-color: #ffe08c;    padding: 5px 10px;    border-radius: 30px;  };const MyScore = styled.div`  &amp; span {    border-radius: 25px;    padding: 5px 10px;    background-color: #ffe08c;  }  font-weight: 600;  font-size: 2em;  margin: 25px;  text-align: center;  &amp; &gt; p {    margin: 20px 0px;    font-size: 18px;    font-weight: 550;  };const Button = styled.button  color: white;  padding: 10px 20px;  background-color: #6799ff;  border-radius: 30px;  margin: 10px;  border: 1px solid #b2ccff;  width: 70vw;`;export default Score;- Ranking.js```javascriptimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import { useSelector, useDispatch } from &quot;react-redux&quot;;import { resetAnswer } from &quot;./redux/modules/quiz&quot;;const Ranking = (props) =&gt; {  const dispatch = useDispatch();  const _ranking = useSelector((state) =&gt; state.rank.ranking);  const ranking = _ranking.sort((a, b) =&gt; {    return b.score - a.score;  });  return (    &lt;RankContainer&gt;      &lt;Topbar&gt;        &lt;p&gt;          &lt;span&gt;{ranking.length}명&lt;/span&gt;의 사람들 중 당신은?        &lt;/p&gt;      &lt;/Topbar&gt;      &lt;RankWrap&gt;        {ranking.map((r, idx) =&gt; {          return (            &lt;RankItem key={idx} highlight={r.current ? true : false}&gt;              &lt;RankNum&gt;{idx + 1}등&lt;/RankNum&gt;              &lt;RankUser&gt;                &lt;p&gt;                  &lt;b&gt;{r.name}&lt;/b&gt;                &lt;/p&gt;                &lt;p&gt;{r.message}&lt;/p&gt;              &lt;/RankUser&gt;            &lt;/RankItem&gt;          );        })}      &lt;/RankWrap&gt;      &lt;Button        onClick={() =&gt; {          dispatch(resetAnswer());          window.location.href = &quot;/&quot;;        }}      &gt;        다시 하기      &lt;/Button&gt;    &lt;/RankContainer&gt;  );};const RankContainer = styled.div`  width: 100%;  padding-bottom: 100px;`;const Topbar = styled.div`  position: fixed;  top: 0;  left: 0;  width: 100vw;  min-height: 50px;  border-bottom: 1px solid #ddd;  background-color: #fff;  &amp; &gt; p {    text-align: center;  }  &amp; &gt; p &gt; span {    border-radius: 30px;    background-color: #fef5d4;    font-weight: 600;    padding: 4px 8px;  }`;const RankWrap = styled.div`  display: flex;  flex-direction: column;  width: 100%;  margin-top: 58px;`;const RankItem = styled.div`  width: 80vw;  margin: 8px auto;  display: flex;  border-radius: 5px;  border: 1px solid #ddd;  padding: 8px 16px;  align-items: center;  background-color: ${(props) =&gt; (props.highlight ? &quot;#ffd6aa&quot; : &quot;#ffffff&quot;)};`;const RankNum = styled.div`  text-align: center;  font-size: 2em;  font-weight: 600;  padding: 0px 16px 0px 0px;  border-right: 1px solid #ddd;`;const RankUser = styled.div`  padding: 8px 16px;  text-align: left;  &amp; &gt; p {    &amp;:first-child &gt; b {      border-bottom: 2px solid #212121;    }    margin: 0px 0px 8px 0px;  }`;const Button = styled.button`  position: fixed;  bottom: 5vh;  left: 0;  padding: 8px 24px;  background-color: ${(props) =&gt; (props.outlined ? &quot;#ffffff&quot; : &quot;#dadafc&quot;)};  border-radius: 30px;  margin: 0px 10vw;  border: 1px solid #dadafc;  width: 80vw;`;export default Ranking;Message.jsimport React from &quot;react&quot;;import img from &quot;./ponyo.jpg&quot;;import { useDispatch, useSelector } from &quot;react-redux&quot;;import { addRank } from &quot;./redux/modules/rank&quot;;const Message = (props) =&gt; {  const dispatch = useDispatch();  const name = useSelector((state) =&gt; state.quiz.name);  const answers = useSelector((state) =&gt; state.quiz.answers);  const user_name = useSelector((state) =&gt; state.rank.user_name);  const input_text = React.useRef(null);  let correct = answers.filter((answer) =&gt; {    return answer;  });  let score = (correct.length / answers.length) * 100;  return (    &lt;div      style={{        display: &quot;flex&quot;,        height: &quot;100vh&quot;,        width: &quot;100vw&quot;,        overflow: &quot;hidden&quot;,        padding: &quot;16px&quot;,        boxSizing: &quot;border-box&quot;,      }}    &gt;      &lt;div        className=&quot;outter&quot;        style={{          display: &quot;flex&quot;,          alignItems: &quot;center&quot;,          justifyContent: &quot;center&quot;,          flexDirection: &quot;column&quot;,          height: &quot;100vh&quot;,          width: &quot;100vw&quot;,          overflow: &quot;hidden&quot;,          padding: &quot;0px 10vw&quot;,          boxSizing: &quot;border-box&quot;,          maxWidth: &quot;400px&quot;,          margin: &quot;0px auto&quot;,        }}      &gt;        &lt;img          src={img}          style={{ width: &quot;80%&quot;, margin: &quot;-70px 16px 48px 16px&quot; }}        /&gt;        &lt;h1 style={{ fontSize: &quot;1.5em&quot;, margin: &quot;0px&quot;, lineHeight: &quot;1.4&quot; }}&gt;          &lt;span            style={{              backgroundColor: &quot;#fef5d4&quot;,              padding: &quot;5px 10px&quot;,              borderRadius: &quot;30px&quot;,            }}          &gt;            {name}                    에게 한마디                &lt;input          ref={input_text}          type=&quot;text&quot;          style={{            padding: &quot;10px&quot;,            margin: &quot;24px 0px&quot;,            border: &quot;1px solid #dadafc&quot;,            borderRadius: &quot;30px&quot;,            width: &quot;100%&quot;,          }}          placeholder=&quot;한 마디 적기&quot;        /&gt;        &lt;button          onClick={() =&gt; {            let rank_info = {              score: parseInt(score),              name: user_name,              message: input_text.current.value,              current: true,            };            dispatch(addRank(rank_info));            props.history.push(&quot;/ranking&quot;);          }}          style={{            padding: &quot;8px 24px&quot;,            backgroundColor: &quot;#dadafc&quot;,            borderRadius: &quot;30px&quot;,            border: &quot;#dadafc&quot;,          }}        &gt;          한마디하고 랭킹 보러 가기                    );};export default Message;- ./redux/modules/quiz.js```javascript//Actionsconst GET_QUIZ = &quot;quiz/GET_QUIZ&quot;;const ADD_ANSWER = &quot;quiz/ADD_ANSWER&quot;;const RESET_ANSWER = &quot;quiz/RESET_ANSWER&quot;;const initialState = {  name: &quot;포뇨&quot;,  score_texts: {    60: &quot;우린 친구! 앞으로도 더 친하게 지내요!&quot;,    80: &quot;우와! 우리는 엄청 가까운 사이!&quot;,    100: &quot;우린 둘도 없는 단짝! :)&quot;,  },  answers: ,  quiz:     { question: &quot;포뇨는 5살이다.&quot;, answer: &quot;O&quot; },    { question: &quot;포뇨는 주황색 머리다.&quot;, answer: &quot;O&quot; },    { question: &quot;포뇨는 물을 좋아한다.&quot;, answer: &quot;O&quot; },    { question: &quot;포뇨는 라면을 좋아한다.&quot;, answer: &quot;O&quot; },  ,};export const getQuiz = (quiz_list) =&gt; {  return { type: GET_QUIZ, quiz_list };};export const addAnswer = (answer) =&gt; {  return { type: ADD_ANSWER, answer };};export const resetAnswer = () =&gt; {  return { type: RESET_ANSWER };};//Reducerexport default function reducer(state = initialState, action = {}) {  switch (action.type) {    case &quot;quiz/GET_QUIZ&quot;: {      return { ...state, quiz: action.quiz_list };    }    case &quot;quiz/ADD_ANSWER&quot;: {      return { ...state, answers: ...state.answers, action.answer };    }    case &quot;quiz/RESET_ANSWER&quot;: {      return { ...state, answers:  };    }    default:      return state;  }}./redux/modules/rank.js// Actionsconst ADD_USER_NAME = &quot;rank/ADD_USER_NAME&quot;;const ADD_USER_MESSAGE = &quot;rank/ADD_USER_MESSAGE&quot;;const ADD_RANK = &quot;rank/ADD_RANK&quot;;const GET_RANK = &quot;rank/GET_RANK&quot;;const initialState = {  user_name: &quot;&quot;,  user_message: &quot;&quot;,  user_score: &quot;&quot;,  score_text: {    60: &quot;우린 친구! 앞으로도 더 친하게 지내요!&quot;,    80: &quot;우와! 우리는 엄청 가까운 사이!&quot;,    100: &quot;우린 둘도 없는 단짝! :)&quot;,  },  ranking: { score: 40, name: &quot;최수빈&quot;, message: &quot;안녕 포뇨!&quot; },};export const addUserName = (user_name) =&gt; {  return { type: ADD_USER_NAME, user_name };};export const addRank = (rank_info) =&gt; {  return { type: ADD_RANK, rank_info };};export const addUserMessage = (user_message) =&gt; {  return { type: ADD_USER_MESSAGE, user_message };};export const getRank = (rank_list) =&gt; {  return { type: GET_RANK, rank_list };};//Reducerexport default function reducer(state = initialState, action = {}) {  switch (action.type) {    case &quot;rank/ADD_USER_NAME&quot;: {      return { ...state, user_name: action.user_name };    }case &quot;rank/ADD_USER_MESSAGE&quot;: {  return { ...state, user_message: action.user_message };}case &quot;rank/ADD_RANK&quot;: {  return { ...state, ranking: ...state.ranking, action.rank_info };}case &quot;rank/GET_RANK&quot;: {  return { ...state, ranking: action.rank_list };}default:  return state;  }}```결과 화면❗ 아직 세부 스타일이 깔끔하게 적용되지 않음. 좀 더 스타일 신경써서 완성시켜야 함.❗ Quiz 화면에서 스와이프를 한번 할 때 화면이 두번 넘어가는 에러 수정해야 함."
199,"스파르팅코딩클럽 '프론트엔드의 꽃, 리액트' 2주차 강의를 듣고 작성한 글입니다.SCSS: CSS를 편하게 쓰도록 도와주는 style.필요한 모듈 설치 :yarn add node-sass@4.14.1 open-color sass-loader classnames문자열 치환 가능, &quot;&amp;&quot;으로 상위 요소에 이어 쓰기 가능$defaultSize: 20px;$className: blue;p{    font-size: #{$defaultSize};    &amp;.#{$className} {color: #{$className}}}div {  background-color: green  &amp;:hover { background-color: blue }}### styled-components: 컴포넌트 스타일링 기법. (class 이름 고민할 필요 X)- 패키지 설치 : yarn add styled-components```javascriptconst MyStyled = styled.div`  width: 50vw;  min-height: 150px;  padding: 10px;  border-radius: 15px;  color: #fff;  &amp;:hover{    background-color: #ddd;  }  background-color: ${(props) =&gt; (props.bgColor를 ? &quot;red&quot; : &quot;purple&quot;)};`;export default App;라이프 사이클: 컴포넌트가 렌더링을 준비하는 순간 ~ 페이지에서 사라질 때까지컴포넌트: 생성 → 수정(업데이트) → 사라짐(제거)라이프 사이클 함수는 클래스형 컴포넌트에서만 사용 가능.constructor() : 생성자 함수. 컴포넌트 생성시 가장 처음으로 호출.render() : 컴포넌트 모양 정의componentDidMount() : 컴포넌트가 화면에 나타나도록 함.componentDidUpdate(prevProps, prevState, snapshot) : 리렌더링을 완료한 후 실행되는 함수componentWillUnmount() : 컴포넌트가 DOM에서 제거 될 때 실행하는 함수Ref리액트에서 돔요소를 가져오려면 React.createRef() 사용.State 관리setState() : 클래스형 컴포넌트의 state를 업데이트할 때 사용하는 함수.Event Listener: componentDidMount()에 넣어주면 됨.Toy Project Nemo ProjectApp.jsimport React from &quot;react&quot;;import Nemo from &quot;./Nemo&quot;;class App extends React.Component {  constructor(props) {    super(props);this.state = {};this.div = React.createRef();  }  hoverEvent = (e) =&gt; {    console.log(e);    console.log(e.target);e.target.style.background = &quot;#eee&quot;;  };  componentDidMount() {    this.div.current.addEventListener(&quot;mouseover&quot;, this.hoverEvent);  }  componentWillUnmount() {    this.div.current.removeEvenListener(&quot;mouseover&quot;, this.hoverEvent);  }  render() {    return (                        );  }}export default App;* Nemo.js```javascriptimport React from &quot;react&quot;;const Nemo = (props) =&gt; {  const count, setCount = React.useState(3);  console.log(count);  const addNemo = () =&gt; {    setCount(count + 1);  };  const removeNemo = () =&gt; {    setCount(count &gt; 0 ? count - 1 : 0);  };  const nemo_count = Array.from({ length: count }, (v, i) =&gt; i);  return (    &lt;div className=&quot;App&quot;&gt;      {nemo_count.map((num, idx) =&gt; {        return (          &lt;div            key={idx}            style={{              width: &quot;150px&quot;,              height: &quot;150px&quot;,              backgroundColor: &quot;#ddd&quot;,              margin: &quot;10px&quot;,            }}          &gt;            nemo          &lt;/div&gt;        );      })}      &lt;div&gt;        &lt;button onClick={addNemo}&gt;하나 추가&lt;/button&gt;        &lt;button onClick={removeNemo}&gt;하나 빼기&lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  );};export default Nemo;결과 화면Toy Project BucketList에 아이템 추가App.jsimport React from &quot;react&quot;;import BucketList from &quot;./BucketList&quot;;import styled from &quot;styled-components&quot;;class App extends React.Component {  constructor(props) {    super(props);    this.state = {      list: &quot;영화관 가기&quot;, &quot;매일 책읽기&quot;, &quot;수영 배우기&quot;,    };this.text = React.createRef();  }  addBucketList = () =&gt; {    let list = this.state.list;    const new_item = this.text.current.value;this.setState({ list: ...list, new_item });  };  componentDidMount() {    console.log(this.text);    console.log(this.text.current);  }  render() {    return (                        내 버킷리스트                                                        추가하기                  );  }}const Input = styled.divmax-width: 350px;  min-height: 10vh;  background-color: #fff;  padding: 16px;  margin: 20px auto;  border-radius: 5px;  border: 1px solid #ddd;;const Container = styled.divmax-width: 350px;  min-height: 80vh;  background-color: #fff;  padding: 16px;  margin: 20px auto;  border-radius: 5px;  border: 1px solid #ddd;;const Title = styled.h1color: slateblue;  text-align: center;;const Line = styled.hrmargin: 16px 0px;  border: 1px dotted #ddd;;export default App;- BucketList.js```javascriptimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;const BucketList = (props) =&gt; {  const my_lists = props.list;  return (    &lt;ListStyle&gt;      {my_lists.map((list, index) =&gt; {        return &lt;ItemStyle key={index}&gt;{list}&lt;/ItemStyle&gt;;      })}    &lt;/ListStyle&gt;  );};const ListStyle = styled.div`  display: flex;  flex-direction: column;  height: 100%;  overflow-x: hidden;  overflow-y: auto;`;const ItemStyle = styled.div`  padding: 16px;  margin: 8px;  background-color: aliceblue;`;export default BucketList;결과 화면HW FriendTest ProjectApp.jsimport React from &quot;react&quot;;import &quot;./App.css&quot;;import Start from &quot;./Start&quot;;import Quiz from &quot;./Quiz&quot;;import Score from &quot;./Score&quot;;class App extends React.Component {  constructor(props) {    super(props);this.state = {  name: &quot;포뇨&quot;,  page: &quot;quiz&quot;,  scoreMsg: &quot;아주 친한 친구 사이:)&quot;,  list:     { question: &quot;포뇨는 5살이다.&quot;, answer: &quot;O&quot; },    { question: &quot;포뇨는 검정색 머리다.&quot;, answer: &quot;X&quot; },    { question: &quot;포뇨는 물을 좋아한다.&quot;, answer: &quot;O&quot; },    { question: &quot;포뇨는 라면을 싫어한다.&quot;, answer: &quot;&quot; },  ,  ranking:     { rank: 1, name: &quot;최수빈&quot;, message: &quot;안녕, 포뇨야!&quot; },    { rank: 2, name: &quot;배인혁&quot;, message: &quot;포뇨 HI~&quot; },    { rank: 3, name: &quot;김원필&quot;, message: &quot;안녕, 포뇨!&quot; },    { rank: 4, name: &quot;송건희&quot;, message: &quot;포뇨포뇨&quot; },  ,};  }  render() {    return (              {this.state.page === &quot;quiz&quot; &amp;&amp; }        {this.state.page === &quot;start&quot; &amp;&amp; }        {this.state.page === &quot;score&quot; &amp;&amp; (                  )}          );  }}export default App;- Score.js```javascriptimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;const Score = (props) =&gt; {  return (    &lt;ScoreContainer&gt;      &lt;Text&gt;        &lt;span&gt;{props.name}&lt;/span&gt; 퀴즈에        &lt;br /&gt;        대한 내 점수는?      &lt;/Text&gt;      &lt;MyScore&gt;        &lt;span&gt;100&lt;/span&gt;점&lt;p&gt;{props.scoreMsg}&lt;/p&gt;      &lt;/MyScore&gt;      &lt;Button&gt;랭킹보기&lt;/Button&gt;    &lt;/ScoreContainer&gt;  );};const ScoreContainer = styled.div`  display: flex;  width: 100vw;  height: 100vh;  overflow: hidden;  padding: 20px;  box-sizing: border-box;  flex-direction: column; //세로로 객체 배열  justify-content: center;  align-items: center;`;const Text = styled.h1`  font-size: 1.5em;  margin: 0px;  line-height: 1.7;  text-align: center;  &amp; span {    background-color: #ffe08c;    padding: 5px 10px;    border-radius: 30px;  }`;const MyScore = styled.div`  &amp; span {    border-radius: 25px;    padding: 5px 10px;    background-color: #ffe08c;  }  font-weight: 600;  font-size: 2em;  margin: 25px;  text-align: center;  &amp; &gt; p {    margin: 20px 0px;    font-size: 18px;    font-weight: 550;  }`;const Button = styled.button`  color: white;  padding: 10px 20px;  background-color: #6799ff;  border-radius: 30px;  margin: 10px;  border: 1px solid #b2ccff;  width: 70vw;`;export default Score;Quiz.jsimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import img from &quot;./ponyo.jpg&quot;;import TinderCard from &quot;react-tinder-card&quot;;// import SwipeItem from &quot;./SwiptItem&quot;;const Quiz = (props) =&gt; {  const num, setNum = React.useState(0);  const onSwipe = (direction) =&gt; {    console.log(&quot;You swiped: &quot; + direction);    setNum(num + 1);  };  if (num &gt; 3) {    return 퀴즈 끝!;  }  return (                  {num + 1}번 문제            {props.list.map((l, idx) =&gt; {        if (num === idx) {          return {l.question};        }      })}  &lt;AnswerZone&gt;    &lt;Answer&gt;O&lt;/Answer&gt;    &lt;Answer&gt;X&lt;/Answer&gt;  &lt;/AnswerZone&gt;  {props.list.map((l, idx) =&gt; {    if (idx === num) {      return (        &lt;DragItem key={idx}&gt;          &lt;TinderCard            onSwipe={onSwipe}            onCardLeftScreen={onSwipe}            onCardRightScreen={onSwipe}            preventSwipe={&quot;up&quot;, &quot;down&quot;}          &gt;            &lt;img src={img} /&gt;          &lt;/TinderCard&gt;        &lt;/DragItem&gt;        //   &lt;SwipeItem key={idx} onSwipe={onSwipe} /&gt;;      );    }  })}&lt;/QuizContainer&gt;  );};const QuizContainer = styled.divtext-align: center;  margin-top: 130px;  &amp; &gt; p &gt; span {    padding: 8px 16px;    background-color: #ffe08c;    border-radius: 30px;    font-weight: bold;  };const Question = styled.h1font-size: 1.5em;;const AnswerZone = styled.divwidth: 100vw;  height: 100vh;  display: flex;  position: absolute;  top: 0;  left: 0;  z-index: 1;;const Answer = styled.divwidth: 50%;  display: flex;  justify-content: center;  align-items: center;  font-size: 100px;  font-weight: 600;  color: #dadafc77;;const DragItem = styled.div`  display: flex;  align-items: center;  justify-content: center;  position: fixed;  top: 0;  left: 0;  width: 100vw;  height: 100vh;  z-index: 10;  &amp; img {    max-width: 130px;  }`;const Finish = styled.ptext-align: center;  margin-top: 300px;  font-weight: 600;  font-size: 30px;;export default Quiz;- SwipeItem.js```javascriptimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import img from &quot;./ponyo.jpg&quot;;const SwipeItem = React.memo(({ onSwipe }) =&gt; {  const swipe_div = React.useRef(null);  let swipe_status = &quot;ready&quot;;  let target_classname = &quot;&quot;;  let coordinate = {    start_x: 0,    start_y: 0,    end_x: 0,    end_y: 0,  };  React.useEffect(() =&gt; {    const reset = () =&gt; {      console.log(&quot;in reset&quot;);      swipe_status = &quot;ready&quot;;      coordinate = {        start_x: 0,        start_y: 0,        end_x: 0,        end_y: 0,      };      swipe_div.current.className = target_classname;      swipe_div.current.style.left = 0 + &quot;px&quot;;      swipe_div.current.style.top = 0 + &quot;px&quot;;    };    const touchStart = (e) =&gt; {      swipe_status = &quot;touchstart&quot;;      target_classname = swipe_div.current.className;      coordinate = {        ...coordinate,        start_x: e.touches0.clientX,        start_y: e.touches0.clientY,      };    };    const touchEnd = (e) =&gt; {      swipe_status = &quot;touchend&quot;;      coordinate = {        ...coordinate,        end_x: e.changedTouches0.clientX,        end_y: e.changedTouches0.clientY,      };      let diff_x = coordinate.end_x - coordinate.start_x;      let direct = &quot;left&quot;;      if (Math.abs(diff_x) &gt; 50) {        swipe_div.current.className = target_classname + &quot; swipe&quot;;      }      if (diff_x &gt; 0) {        direct = &quot;right&quot;;        swipe_div.current.style.left = diff_x + 150 + &quot;px&quot;;        swipe_div.current.style.opacity = 0;      } else {        direct = &quot;left&quot;;        swipe_div.current.style.left = diff_x - 150 + &quot;px&quot;;        swipe_div.current.style.opacity = 0;      }      window.setTimeout(() =&gt; {        reset();        onSwipe(direct);      }, 300);      return;    };    const touchMove = (e) =&gt; {      swipe_status = &quot;toucmove&quot;;      e.preventDefault();      let current_coordinate = {        x: e.touches0.clientX,        y: e.touches0.clientY,      };      swipe_div.current.style.left =        current_coordinate.x - coordinate.start_x + &quot;px&quot;;      swipe_div.current.style.top =        current_coordinate.y - coordinate.start_y + &quot;px&quot;;    };    const touchCancel = (e) =&gt; {      swipe_status = &quot;touchcancel&quot;;      reset();    };    swipe_div.current.addEventListener(&quot;touchstart&quot;, touchStart);    swipe_div.current.addEventListener(&quot;touchend&quot;, touchEnd);    swipe_div.current.addEventListener(&quot;touchmove&quot;, touchMove);    swipe_div.current.addEventListener(&quot;touchcancel&quot;, touchCancel);    return () =&gt; {      if (!swipe_div.current) {        return;      }      swipe_div.current.removeEventListener(&quot;touchstart&quot;, touchStart);      swipe_div.current.removeEventListener(&quot;touchend&quot;, touchEnd);      swipe_div.current.removeEventListener(&quot;touchmove&quot;, touchMove);      swipe_div.current.removeEventListener(&quot;touchcancel&quot;, touchCancel);    };  }, );  return (    &lt;DragItem ref={swipe_div}&gt;      &lt;img src={img} /&gt;    &lt;/DragItem&gt;  );});const DragItem = styled.div`  display: flex;  align-items: center;  justify-content: center;  position: fixed;  top: 0;  left: 0;  width: 100vw;  height: 100vh;  &amp;.swipe {    transition: 300ms;  }  &amp; &gt; div {    border-radius: 500px;    background-color: #ffd6aa;  }  &amp; img {    max-width: 130px;  }`;SwipeItem.defaultProps = {  onSwipe: () =&gt; {},};export default SwipeItem;❓ Quiz.js에 SwiptItem.js를 import해서 실행했을 경우 포뇨 이미지는 잘 뜨는데 swipe 기능이 아예 먹히질 않는다,,,❓ 무엇이 문제인지 해결하지 못해서 SwipeItem.js import 하지 않고 Quiz.js 내에서 TinderCard를 사용하여 Swipe 기능을 그냥 구현하였다.결과 화면포뇨 이미지를 좌우로 스와이프 할 때마다 문제가 바뀌며, 모든 문제가 끝났을 때 '퀴즈 끝!' 문구가 나오게 됨."
200,"스파르팅코딩클럽 '프론트엔드의 꽃, 리액트' 1주차 강의를 듣고 작성한 글입니다.Javascript 기본 개념클래스 : 상태 + 함수 로 구성class Cat {    // 생성자 함수    constructor(name) {        this.name = name;     }    // 함수    showName(){        return this.name;    }}extends로 클래스 상속super로 부모의 constructor 호출하면서 인수 전달 (this 쓸 수 있음)var, let : 변경 가능const: 변경 불가능map: 배열에 속한 항목 변환시 많이 사용. 즉, 새로운 배열 생성fiilter: 조건을 만족하는 항목들만 골라서 새로운 배열 생성concat: 배열 합치기 + ...new Set() 으로 중복 항목 제거React 프로젝트 시작전에 React 프로젝트를 시작할 때는 'nvm'를 따로 설치하지 않았는데 이번에는 설치해주었다.NVM(Node Version Manager) 란? Node.js의 버전 관리자.NPM(Node Package Manager): 수많은 third-party 패키지를 활용할 수 있게 해줌. 즉, Frontend 의존성을 관리하기 위한 패키지 매니저 →패키지를 가져다 쓰기 편하게 도와줌. ( = yarn)npm으로 yarn 설치 : npm install -g yarnyarn 버전 확인 : yarn -vyarn add global create-react-appreact 프로젝트 생성 : yarn create react-app project name컴포넌트(Component)State : 컴포넌트가 가지고 있는 데이터Props : 컴포넌트가 부모 컴포넌트로 부터 받아온 데이터 (수정 불가능)1. 함수형 컴포넌트1) 첫번째 방법function App(props){    return(        &lt;div&gt;Hi&lt;/div&gt;    );}export default App;2) 두번째 방법const App = (props) =&gt; {    return (        &lt;div&gt;Hi&lt;/div&gt;    );}export default App;2. 클래스형 컴포넌트//App.jsclass App extends React.Component {    constructor(props){        super(props);        this.state = {            list: 'A', 'B', 'C'        };    }    render() {        return (        &lt;div className=&quot;App&quot;&gt;            &lt;BucketList list={this.state.list}/&gt;        &lt;/div&gt;        );    }}export default App;CSS fileimport './style.css'; 로 선언.App{    width: 100vw;    height: 100vh;    display: flex;    flex-direction: column // 세로로 배열}ToyProject BucketListApp.jsimport React from &quot;react&quot;;import BucketList from &quot;./BucketList&quot;;import &quot;./style.css&quot;;class App extends React.Component {  constructor(props) {    super(props);    this.state = {      list: &quot;여행 가기&quot;, &quot;매일 책읽기&quot;, &quot;기타 배우기&quot;, &quot;드라마 정주행하기&quot;,    };  }  render() {return (  &lt;div className=&quot;App&quot;&gt;    &lt;div className=&quot;container&quot;&gt;      &lt;h1 className=&quot;title&quot;&gt;내 버킷리스트&lt;/h1&gt;      &lt;hr className=&quot;line&quot; /&gt;      &lt;BucketList list={this.state.list} /&gt;    &lt;/div&gt;  &lt;/div&gt;);  }}export default App;- BucketList.js```javasciptimport React from &quot;react&quot;;const BucketList = (props) =&gt; {  const my_lists = props.list;  return (    &lt;div className=&quot;lists&quot;&gt;      {        my_lists.map((list, index) =&gt; {          return (            &lt;div className=&quot;list-item&quot; key={index}&gt;              {list}            &lt;/div&gt;          );        })      }    &lt;/div&gt;  );};export default BucketList;style.css.App {width: 100vw;min-height: 100vh;background-color: #eee;padding: 32px;box-sizing: border-box;}.container {  max-width: 350px;  min-height: 80vh;  background-color: #fff;  padding: 16px;  margin: 20px auto;  border-radius: 5px;  border: 1px solid #ddd;}.title {  color: slateblue;  text-align: center;}.line {  margin: 16px 0px;  border: 1px dotted #ddd;}.lists {  display: flex;  flex-direction: column;  height: 100%;  overflow-x: hidden;  overflow-y: auto;}.list-item {  padding: 16px;  margin: 8px;  background-color: aliceblue;}* 결과 화면&lt;img src=&quot;https://images.velog.io/images/tnqls1211v/post/bc20b2ae-703a-4e1b-8a13-250d220e69a3/bucket.jpg&quot; width=&quot;30%&quot;&gt;&lt;br/&gt;### HW FriendTest- App.js```javascriptimport React from &quot;react&quot;;import &quot;./App.css&quot;;import Start from &quot;./Start&quot;;class App extends React.Component {  constructor(props) {    super(props);    this.state = {      name: &quot;포뇨&quot;,    };  }  render() {    return (      &lt;div className=&quot;App&quot;&gt;        &lt;Start name={this.state.name} /&gt;      &lt;/div&gt;    );  }}export default App;Start.jsimport React from &quot;react&quot;;const Start = (props) =&gt; {  return (                            나는 {props.name} 에 대해서                    얼마나 알고 있을까?                        시작하기            );};export default Start;- App.css```css.container {  display: flex;  height: 100vh;  width: 100vw;  overflow: hidden;  padding: 20px;  box-sizing: border-box;}.outter {  display: flex;  align-items: center;  justify-content: center;  flex-direction: column;  height: 100vh;  width: 100vw;  max-width: 400px;  border: 1px solid #eee;  padding: 0vh 30px;  box-sizing: border-box;  margin: 0px auto;}.outter h1 {  text-align: center;  font-size: 1.5em;  margin: 0;  line-height: 1.8;}.outter h1 span {  background-color: #ffe08c;  padding: 5px 10px;  border-radius: 30px;}.text-box {  padding: 10px;  margin: 25px 0px;  border: 1px solid #eaeaea;  border-radius: 30px;  width: 70%;  background-color: #eaeaea;}.button {  padding: 10px 30px;  background-color: #4374d9;  border-radius: 30px;  border: #4374d9;  color: white;}결과 화면"
201,KEEP (유지할 것)어려움에 부딪혀도 새로운 도전을 멈추지 않는것내가 만족할 때까지 끝을 보는 것지난 주에 새로 시도해보기로 했던 목업작업마감시간 잘 지키기Problem (문제점)컨디션 관리 (자꾸 밤을 새게 됨)게임개발할 때는 거짓말 좀 보태서 1초도 안쉬고 했다.프로젝트 하나당 꼭 한 번은 밤을 새게 되는데 비효율적 작업 때문이라고 생각한다.til작성을 자꾸 뒤로 미룸작업을 순서에 맞게 하기 보다는 되는 대로 한다.발표할 때 하고싶은 얘기를 정확하게 전달하지 못한다.Try (시도할 것)새롭게 배운 깃헙으로 내 작업추적을 해서 효율적인 작업관리를 하고 싶다.목업을 충분히 구체화했지만 작업의 순서까지 정할 수 있으면 좋겠다.Feeling사실 모든 problem들이 평소 나의 문제점과 맞닿아 있어서 내 문제점과 계속 씨름을 해야했던 개인적으로는 꽤나 괴로웠던 한 주였다. 그만큼 기존에 개발하던 화살쏘는 게임에서 화살촉 트래킹을 성공했을 때나 프로젝트를 완성하고 발표했을 때에는 끝내주게 기분이 좋기도 했다. 사람의 뇌는 자기가 하기 싫은 것을 할 때 성장한다는데 기존에 하던 방식보다는 치밀하게 계획한(평소에 내가 너무 힘들어하는) 코딩으로 내 성장을 꾀해봐야겠다.
202,"gitcommitgit은 commit 메시지를 통해서 버전관리를 한다. commit에는 누가 언제 commit을 했는지 정보와 프로젝트 변경에 대한 내용이 나와있다. commit을 작성할 때는 명확하게 적을 필요가 있다.add, staging변경된 파일을 기능별로 묶어서 commit을 할 수 있다. 변경된 기능별로 잘 묶여서 commit이 돼 있다면 오류수정이나 팀 단위 작업에서 용이함.원격 repo로컬repo에서 push를 통해서 원격repo로 변경된 파일과 commit을 보낼 수가 있다.pull을 통해서 원격repo의 변경사항을 가져 올 수 있다.내 컴퓨터에 로컬repo가 없다면 원격repo에 있는 정보를 clone을 통해 전부 가져올 수 있다.branch와 merge깃에서 팀작업을 가능하게 하는 기능은 branch라는 기능이다. 나뭇가지처럼 갈라져 나와서 작업을 하고 완성하고 나서 다시 메인 branch로 merge하는 식으로 관리한다.branch— 개인적으로도 브랜치를 활용하면 기능별로 정리가 될 것 같아서 너무 좋을 것 같다.— 작업을 개별적으로 나누어서 한다는게 평소에 정리를 힘들어하는 나에게 좋은 영향을 끼칠거라고 생각한다.오류를 두려워하지 마라요즘 제일 많이 듣는 말이지만 들을 때마다 절로 고개가 끄덕여진다. merge conflict 상황에서도 당황하지말고 깃이 알려주는대로 conflict를 자연스럽게 처리하면 된다. 순서에 맞게ex) 이슈 -&gt; 코드작성 -&gt; 커밋 -&gt; 푸시개발에 관련된 모든 스택들은 순서가 중요하다고 생각한다.  순서에 맞게 작업을 하고 정돈된 작업 라인을 만드는 것을 마음에 새기자."
203,"사과처럼 작은 오브젝트는 rect값이 너무 커서 아무리 작은 포인트를 찾아서 충돌함수를 이용해도 오브젝트 rect간의 겹침현상을 막을 수가 없다. 그래서 원안에 포함되어 있는지 확인하는 함수를 찾아서 코드에 대입했다. 잘 구동이 되었고 원과 다른 오브젝트가 잘 겹치지 않도록 잘 처리가 되었다.# 특정포인트 값이 원 내부에 있는지 검사하는 함수# 사과 주변의 정확한 원을 그리기 위해서 # 사과의 중앙을 구함center_x = self.x_pos + (self.width /2)center_y = self.y_pos + (self.height/2)collide = (math.pow(10,2) &gt;= (math.pow(center_x - point0, 2) + math.pow(center_y - point1,2)))또한 기존의 코드 중에서 화살의 포인트 추적을 pygame의 x포지션 y포지션으로 추적하다보니 화살촉에 딱 맞아들어가지 않아서 각도 변화에 따라서 밑변과 높이 값을 구해서 포인트에다 더하고 빼는 함수를 추가했더니 딱 맞게 떨어지지는 않지만 비슷하게 맞아 들어가는 것을 확인했다. # 화살의 4각형의 rect값은 다음과 같다 # x, y, width, height # 기존의 x, y 에서 오른쪽 위로 이동하기 위해서는 # 각각 width와 height값을 더해야하고 # 거기다 더해 각도에 따라 변화하는 특정 포인트를 찾기 위해서 # 피타고라스 정의를 활용하여 각도마다 변하는 정확한 값을 추가함precise_point = arrow.x_pos + 40 + (ux * tm), arrow.y_pos +24 +((uy * tm) + (g * tm ** 2) / 2)pre_cos_val = (12 * math.cos(math.radians(90) - radian_now))pre_sin_val = (12 * math.sin(math.radians(90) - radian_now))# 0도 일때는 arrow의 height/2 값을 더해준다.if arrow_degree == 0:precise_point1 += 12# 각도가 높아질 때 안 쪽 삼각형의 밑변과 높이를# 구해야하기 때문에 구한 value값을 빼준다.if arrow_degree &gt; 0:    precise_point0 -= pre_cos_val    precise_point1 -= pre_sin_valif arrow_degree &lt; 0:    precise_point0 += pre_cos_val    precise_point1 += pre_sin_val이번에 게임을 개발하면서 개발이 내 생각보다 더 재밌다는 것을 깨달았다. 너무 어렵고 정복하지 못할거라고 생각했던 문제를 하나씩 찾아가면서 해결하고 새로운 인사이트를 얻고 내가 발전하는 것을 느끼는 게 너무 즐겁다."
204,"if enemy.rect.collidepoint(arrow.x_pos + ux, arrow.y_pos + uy):            off_space = False            arrow.x_pos = 2000            arrow.y_pos = 2000            pygame.time.delay(1500)            self.state = 'clear'            stage += 1        # 화면에 그리기        # 화살과 다른 쿼카가 부딪혔을 때 게임오버 페이지로 이동한다.        quokka.rect.left = quokka.x_pos        quokka.rect.top = quokka.y_pos        if quokka.rect.collidepoint(arrow.x_pos + ux, arrow.y_pos + uy):            off_space = False            stage = 0            on_game = False            self.state = 'gameover'colliderect 함수로 충돌검사를 하니 화살의 정확도도 떨어지고 충돌을 겹쳐서 인식하거나 제대로 인식하지 못하는 상태가 되었다. 그래서 collidepoint함수로 대체 하였고 start_ticks = pygame.time.get_ticks()elapsed_time = (pygame.time.get_ticks() - start_ticks) / 1000timer = game_font.render(""Time : {}"".format(int(total_timestage - elapsed_time)), True, (255,0,0))screen.blit(timer, (screen_width -400 , 100))시간을 표시해주는 타이머까지 설정하였다. 이제 화살 갯수를 표시하는 것까지 만들면 오늘 할 일은 마칠 것 같다. 좀만 더 힘내자!!"
205,"import pygamemouse_pos = pygame.mouse.get_pos()radian = math.atan2((-mouse_pos1 + arrow_y_pos ), (mouse_pos0 - arrow_x_pos))arrow_degree = int(radian * 180 / math.pi)rotated_arrow = pygame.transform.rotate(arrow, arrow_degree)new_arrow_pos = rotated_arrow.get_rect()new_arrow_pos.center = (arrow_x_pos, arrow_y_pos)마우스 포인터를 따라서 각도를 계산하고 화살이 그에 따라 옴직이는 게임화면을 만들었다. 어려울 줄은 알았지만 마우스 포인터와 캐릭터간의 역탄젠트 값을 구할 때 나의 인지와는 다르게 pygame에서의 y값은 아래로 갈수록 커지기 때문에 -를 붙여 로직을 완성할 수 있었다.tm = 0.3g = 9.8arrow_pos0 += (ux*tm)arrow_pos1 += ((uy*tm) + (g*tm**2)/2)radian_now = math.atan2((- arrow_pos1 + before_y)  , arrow_pos0 - before_x)degree_now = int(radian_now * 180 / math.pi)rotated_arrow = pygame.transform.rotate(arrow,degree_now)화살의 움직임을 계산한 로직이다. 중력가속도를 더해 포물선 운동을 만들었다. 또한, 다음 x,y 값과 지금 x,y값의 각도를 구해 화살촉의 방향을 운동방향으로 바꾸었다."
206,"https://yjyoon-dev.github.io/project/2020/11/19/jsgame-tetris/yjyoon님의 코드를 참고하여 js로 테트리스를 만들어 보았다. 코드 자체는 따라 친 코드지만 데이터가 어떻게 흐르는지 주석을 일일이 달아가며 공부해보았다. &lt;script&gt;let shapeRotateMap =     1, 0,    3, 2,    4,    6, 7, 8, 5,    10, 9,    12, 13, 14, 11,    16, 17, 18, 15;// rotate가 가능한지 4개지 로테이트 상황을 다 비교해 false가 한 번이라도 나오면// false를 반환하고 함수를 끝낸다. function canRotate() {    var tempShape = shapeArrayshapeRotateMapcurrentShape;    for (var i = 0; i &lt; 4; i++) {        var ty = shapePoint0 + tempShapei0;        var tx = shapePoint1 + tempShapei1;        if (!isValidPoint(ty, tx)) return false;    }    return true;}// 로테이션 맵을 통해서 지금 값을 회전시킨다.// 현재 shapepoint 값과 변화시킨 로테이트 값을 업데이트 시키고// showshape함수를 통해서 화면에 변화된 값을 그린다.function rotateShape() {    if (!canRotate()) return;    removeShape();    shapeCell =     currentShape = shapeRotateMapcurrentShape;    let rotateShape = shapeArraycurrentShape;    for (let i = 0; i &lt; 4; i++) {        let sy = shapePoint0 + rotateShapei0;        let sx = shapePoint1 + rotateShapei1;        shapeCell.push(sy, sx);    }    showShape();}&lt;/script&gt;rotatemap으로 회전할 함수들을 구분해놓는 아이디어가 너무 좋아서 마음에 드는 코드를 가져와 봤다. 또, 이 코드에서 오류가 발생해서 애먹었는데 알고보니 내가 조건절 안에 함수를 넣는 것이 어색해서 무의식중에 ()를 생략해서 오류가 난 거였다. 이렇게 여러 시도를 해보면서 코드 리뷰도 하고 따라서 해보는 시도가 중요한 것 같다.&lt;script&gt;// 속도를 변화시켜 더 빠르게 움직이게 한다.function moveFast() {    if (fastMode) return;    clearTimeout(movingThread);    movingSpeed = fastSpeed;    movingThread = setTimeout(""moveDown()"", movingThread);    fastMode = true;}&lt;/script&gt;개인적으로 내가 하던 테트리스는 fastmode 보다는 특정 키를 눌렀을 때 블럭이 위치할 수 있는 제일 아래에 순식간에 이동하는 게임이라는 인식이 있는데, 이 기능은 스스로 만들어봐야겠다.전체 코드는 github에 올려 놓았다.https://github.com/about-joo91/about-joo91.github.io"
207,"&lt;script&gt;function typing_hwang() {    const content = ""필요텍스트""    const text = document.querySelector("".text2"")    let index = 0;    function sleep(delay) {        const start = new Date().getTime();        while (new Date().getTime() &lt; start + delay) ;    }    function typing() {        text.textContent += contentindex++;        if (index &gt; content.length) {            text.textContent = """"            index = 0;            sleep(1000);        }    }    setInterval(typing, 200)}&lt;/script&gt;기존에 팀에서 사용하던 타이핑 애니매이션을 포함한 코드다. 이 코드를 $('documet').ready()에 넣고 사용했는데 비동기적 호출이 200ms 마다 호출되면서 다른 함수들이 우선순위가 밀려 리로딩이 계속 일어났다.(여러 페이지를 둔 것도 아니고 프레임워크를 활용한 spa도 아니고 그냥 원페이지 사이트다보니 더 그런 것 같기도 하다.) 어떻게든 함수를 살려서 사용하기 위해서 노력해봤지만 기존의 목적에 부합하지 않아서 폐기할 수밖에 없었다.버튼을 누르는 등 상호작용 없이 이 코드가 반복적으로 돌아갔으면 좋겠다.4명의 사람에 대한 소개이다 보니 각각 제어해야하는 class가 다르고 나와야하는 텍스트도 다르다이 조건에 맞게 코드를 고치다가 문득 자바스크립트로 이 클래스를 꼭 제어할 필요가 있나 하는 생각이 들었다. 결국 css로 타이핑 애니매이션 코드를 만들었다.&lt;style&gt;.text1, .text2, .text3, .text {    animation: typing 3s steps(15) infinite, blink .5s step-end infinite alternate;    white-space: nowrap;    overflow: hidden;    border-right: 3px solid;    font-size: 38px;}&lt;/style&gt;코딩을 하다보면 내가 기존에 맞다고 생각했던 것들 때문에 시야가 가려지곤 하는데 그때마다 거기서 벗어나서 새로운 시야로 상황을 봐야겠구나라고 생각을 했다. 오늘 하루도 즐겁게 코딩했다."
208,"4개의 묶음데이터를 각각의 모달 페이지에 보내야하는 코드를 짜다보니 html 코드가 너무 길어지고 쓸데 없이 많은 코드가 사용된다는 생각이 들었다. (모달의 특성상 새로고침을 할 수도 없다) 방법을 고민하던 중 javascript 객체에 innerHTML 코드를 사용하면 바로 텍스트 값을 변경할 수 있다는 것을 알아냈다.&lt;script&gt;// 모달로직을 수행하기 위한 javascript object들    const body = document.querySelector('body');    const modal = document.querySelector('.modal');    let btns = document.querySelectorAll("".open-modal"");// 데이터 변경을 위한 각각의 javascript object값을 각 변수에 저장    const status_name = document.getElementById('status-name');    const status_nickname = document.getElementById('status-nickname');    const status_mbti = document.getElementById('status-mbti');    const strong_point = document.getElementById('strong-point')    const teaming_method = document.getElementById('teaming-method');    const tmi_to_line = document.getElementById('tmi-to-line');    const status_img_url = document.getElementById('status-image'); &lt;/script&gt;그래서 다음과 같은 코드로 각 데이터가 필요한 HTML 코드에 아이디 값을 주고 각 객체들을 const로 저장해 두고 &lt;script&gt;.forEach.call(btns, function (col) {    col.addEventListener('click', (e) =&gt; {        open_modal(e)    })});function open_modal(e) {    // 이벤트를 가져와 num 변수에 저장해 어떤 버튼이 눌러졌는지 확인한다.    // e.target.classList는 내가 지정한 class값인 {openmodal},{num} {블라블라} 가 나옴     let num = e.target.classList1    // 각 javascript object를 제어해서 값을 변경한다.    status_name.innerHTML = team_summarynum.name    status_nickname.innerHTML = team_summarynum.nick_name    status_mbti.innerHTML = team_summarynum.mbti    strong_point.innerHTML = team_summarynum.strong_point    teaming_method.innerHTML = team_summarynum.teaming_method    tmi_to_line.innerHTML = team_summarynum.tmi_to_line    status_img_url.src = team_summarynum.img_url    // 모달을 화면을 보여준다.    modal.style.top = ((window.innerHeight - modal.scrollHeight) / 2 + window.scrollY) + ""px""    modal.style.left = ((window.innerHeight - modal.scrollWidth) / 2 + window.scrollX) + ""px""    modal.classList.toggle('show');    if (modal.classList.contains('show')) {        body.style.overflow = 'hidden';    }}&lt;/script&gt;다음과 같이 이벤트를 받아 e.target.classList를 호출하면 내가 지정한 class값인 {openmodal}, {num}, {블라블라} 가 나오는데 그 중에 내가 필요한 값인 num을 사용해 딕셔너리로 구성된 리스트를 조회해 지정한 아이디로 데이터를 보내준다.이렇게 각 클래스에 내가 지정한 번호로 재사용이 가능한 모달페이지를 만들 수 있었다."
209,이러한 모양의 올드게임 status풍의 페이지를 만들다 보니 재밌는 사이트를 찾았다.https://border-image.com/이따금씩 미니 프로젝트 때 필요하면 들어가서 만들어봐야겠다.
210,"&lt;script&gt;        const body = document.querySelector('body');        const modal = document.querySelector('.modal');        const open_btn = document.querySelector('.open-btn');        open_btn.addEventListener('click', () =&gt; {            modal.classList.toggle('show');            if (modal.classList.contains('show')) {                body.style.overflow = 'hidden';            }        });        modal.addEventListener('click', (event) =&gt; {            if (event.target === modal) {                modal.classList.toggle('show');                if (!modal.classList.contains('show')) {                    body.style.overflow = 'auto';                }            }        });    &lt;/script&gt;출처: https://7942yongdae.tistory.com/104 프로그래머 YD모달 페이지 구현을 위해 구글링을 하던 중 발견한 코드 클래스 이름 정도만 변경한 이 코드를 jquery 구문으로 그대로 옮겼더니 작동하지 않았다.    &lt;script&gt;        const body = $('.body')        const modal = $('.modal')        const open_btn = $('.open-btn')        open_btn.addEventListener('click', () =&gt; {            modal.classList.toggle('show');            if (modal.classList.contains('show')) {                body.style.overflow = 'hidden';            }        })        modal.addEventListener('click', (event) =&gt; {            if (event.target == modal) {                modal.classList.toggle('show');                if (!modal.classList.contains('show')) {                    body.style.overflow = 'auto';                }            }        })    &lt;/script&gt;궁금해서 다시 구글링을 해 보았더니 jquery가 반환하는 객체는 jquery객체고 queryselector가 반환하는 객체는 nodelist 즉 native javascript 객체임을 알 수 있었다. 위 코드처럼 jquery를 변수에 담고 사용할 수는 없음순수 javascript 객체를 조율하고 싶다면 queryselector 나 getElementByID(Or Class)등을 이용하는 것이 좋아보임내부적 처리면에서도 더 유리하다고 함"
211,"웹 프로그래밍 A-Z 기초4주차수강기록 4주차 숙제제출5주차수강기록 5-1 5주차 오늘 배울 것 &amp; 설치 5-2 버킷리스트 - 프로젝트 세팅 5-3 버킷리스트 - 뼈대 준비하기 5-4 버킷리스트 - POST연습(기록하기) 5-5 버킷리스트 - GET연습(보여주기) 5-6 버킷리스트 - POST연습(완료하기) 5-7 내 프로젝트를 서버에 올리기 5-8 AWS 서버 구매하기 5-9 서버 세팅하기 5-10 Flask 서버를 실행해보기 5-11 nohup 설정하기 5-12 도메인 연결하기 5-13 og 태그 5-14 5주차 끝 &amp; 숙제 설명 5주차 숙제제출개발일지알고 있던 것페이지 뼈대 만들기GET, POST 보내고 받기GET으로 받아온 데이터 화면으로 띄우기새롭게 알게된 것aws ec2 인스턴스인스턴스 설정법보안그룹 변경콘솔에서 보안그룹 ipv4 anywhere 설정특정 ip만 접근하게 할 수도 있는 것 같다.(회사서버, 제한 서버 등등)컴퓨터를 꺼도 동작할 수 있다.nohup python app.py &amp;돌아가고 있는 서버를 종료하려면 ps -ef | grep 'python app.py' | awk '{print $2}' | xargs kill 명령어를 통해 종료  1-1 필수 프로그램 설치  1-2 파이썬 기초 문법 뽀개기  1-3 파이썬 시작하기  1-4 변수 선언과 자료형  1-5 문자열 다루기  1-6 리스트와 딕셔너리  1-7 조건문  1-8 반복문  1-9 반복문 - 연습문제  1-10 함수  1-11 파이썬 심화 문법 뽀개기  1-12 튜플, 집합  1-13 f-string  1-14 예외처리  1-15 파일 불러오기  1-16 한줄의 마법  1-17 map, filter, lambda식  1-18 함수 심화  1-19 클래스개발일지알고 있던 것파이썬의 기본문법새롭게 알게된 것클래스의 개념과 활용class에서는 각 객체에 필요한 함수와 속성만 가지고 있다object가 각자 데이터를 따로 가짐필요에 따라 class에 저장된 함수들을 불러 object를 제어함"
212,"웹 프로그래밍 A-Z 기초1주차수강기록 1주차 1강 - 오늘 배울 것 1주차 2강 - 필수 프로그램 설치 1주차 3강 - HTML, CSS 기본 내용 1주차 4강 - Quiz_간단한 로그인 페이지 만들어보기 1주차 5강 - CSS 기초 1주차 6강 - 자주 쓰이는 CSS 연습하기 1주차 7강 - 폰트, 주석, 파일분리 1주차 8강 - 부트스트랩, 예쁜 CSS 모음집 1주차 9강 - CSS 꿀팁 한번 더 배우기 1주차 10강 - 본격 부트스트랩 써보기 1주차 11강 - Quiz_포스팅박스를 완성하기 1주차 12강 - Javascript 맛보기 1주차 13강 - Javascript 기초 문법 배우기(1)  1주차 14강 - Javascript 기초 문법 배우기(2) 1주차 15강 - Javascript 연습하기 1주차 16강 - 1주차 끝 &amp; 숙제 설명 1주차 숙제제출개발일지알고 있던 것html, css, javascript 간의 구동방식이나 사용하는 법프론트 단에 페이지를 만드는 법새롭게 알게된 것프로그래밍 언어를 다 이해하기 보다는 그때 그때 필요한 부분을 구글에서 찾거나 이전에 사용했던 코드들을 재활용한다.그동안 이해가 안 되는 부분들을 하나하나 짚고 넘어가려고 하다보니 지치고서비스 개발이 멀게만 느껴졌는데이렇게 하나씩 해나가다보면 멀지 않게 느껴질 것 같다.2주차수강기록 2주차 1강 - 오늘 배울 것 2주차 2강 - JQuery 시작하기 2주차 3강 - JQuery 다뤄보기 2주차 4강 - JQuery 적용하기(포스팅 박스) 2주차 5강 - Quiz_JQuery 연습하기 2주차 6강 - 서버-클라이언트 통신 이해하기 2주차 7강 - Ajax 시작하기 2주차 8강 - Ajax 함께 연습하기 2주차 9강 - Quiz_Ajax 연습하기(1) 2주차 10강 - Quiz_Ajax 연습하기(2) 2주차 11강 - 2주차 끝 &amp; 숙제 설명 2주차 숙제제출개발일지알고 있던 것jquery, ajax 다루는 법서버 클라이언트 통신새롭게 알게된 것$('#아이디이름') 으로 아이디를 불러와 html에 append가 가능attr 로 img 태그 안에 속성값 변경 가능 3-1 3주차 설치 3-2 연습 겸 복습 - 스파르타피디아에 OpenAPI 붙여보기 3-3 파이썬 시작하기 3-4 파이썬 기초공부 3-5 파이썬 패키지 설치하기 3-6 패키지 사용해보기 3-7 웹스크래핑(크롤링) 기초 3-8 Quiz_웹스크래핑(크롤링) 연습 3-9 DB개괄 3-10 mongoDB 시작하기 3-11 mongoDB 연결하기 3-12 pymongo로 DB조작하기 3-13 웹스크래핑 결과 저장하기 3-14 Quiz_웹스크래핑 결과 이용하기 3-15 3주차 끝 &amp; 숙제 설명 숙제 제출개발일지알고 있던 것크롤링 방법몽고db 사용법새롭게 알게된 것local호스트에 저장하던 방식이 아니라 몽고db 클러스터에 직접 저장하는 방법1.몽고db 페이지에 들어가 링크를 복사한다.2.몽고 클라이언트 입력란에 링크를 넣고 비밀번호를 수정한다.og태그 이용하기내가 가져가고 싶은 중요한 정보 (제목이나, 이미지 등)은 og태그에 저장 돼 있는 경우가 많다.og태그를 참고 해볼 것!  4-1 4주차 오늘 배울 것  4-2 Flask 시작하기 - 서버만들기  4-3 Flask 시작하기 - HTML파일 주기  4-4 Flask 시작하기 - 본격 API 만들기  4-5 화성땅 공동구매 - 프로젝트 세팅  4-6 화성땅 공동구매 - 뼈대 준비하기  4-7 화성땅 공동구매 - POST 연습(주문 저장)  4-8 화성땅 공동구매 - GET 연습(주문 보여주기)  4-9 스파르타피디아 - 프로젝트 세팅  4-10 스파르타피디아 - 조각 기능 구현해보기  4-11 스파르타피디아 - 뼈대 준비하기  4-12 스파르타피디아 - POST 연습(포스팅하기)  4-13 스파르타피디아 - GET 연습(보여주기)개발일지알고 있던 것서버 만들기GET, POST를 통한 페이지 구현새롭게 알게된 것화면이 새로고침 될 때 마다 함수를 불러올 수 있는 코드$(document).ready()post 한 후 reloadwindow.location.reload()"
213,"https://www.acmicpc.net/problem/2210난이도 🥇🥈🥉알고리즘 분류: dfs, 브루트포스🧐 문제접근그냥 평범하게 dfs로 완전탐색하면 됩니다오랜만에 다시 문제풀이 시작해서.. 익숙치 않네요 ㅎㅎ전체코드//2210번: 숫자판 점프var arr = Int()for _ in 0..&lt;5 {    let t = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}    arr.append(t)}let dx = 1,-1,0,0let dy = 0,0,1,-1var answer = Set&lt;Int&gt;()func dfs(_ i: Int, _ j: Int, _ depth: Int, _ number: Int) {    if depth == 5 {        answer.insert(number)        return    }    for index in 0..&lt;4 {        let nx = i + dxindex        let ny = j + dyindex        if (0..&lt;5).contains(nx) &amp;&amp; (0..&lt;5).contains(ny) {            dfs(nx, ny, depth+1, number * 10 + arrnxny)        }    }}for i in 0..&lt;5 {    for j in 0..&lt;5 {        dfs(i,j,0,arrij)    }}print(answer.count)한줄평가: 매우쉬움"
214,"https://www.acmicpc.net/problem/1613난이도 - 골드3🥇알고리즘 분류: 그래프, 플로이드와샬🧐 문제접근n = 400 이므로, 플로이드 와샬로 한방에 풀 수 있다대체 왜 골드3인지..?전체코드//1613번func floyidWarshall() {    for k in 1...n {        for i in 1...n {            for j in 1...n where !arrij {                if arrik, arrkj {                    arrij = true                }            }        }    }}let nk = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}let n = nk0, k = nk1var arr = Array(repeating: Array(repeating: false, count: n+1), count: n+1)for _ in 0..&lt;k {    let ab = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}    let a = ab0, b = ab1    arrab = true}floyidWarshall()let s = Int(readLine()!)!for _ in 0..&lt;s {    let ab = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}    let a = ab0, b = ab1    if arrab {        print(-1)    } else if arrba {        print(1)    } else {        print(0)    }}"
215,"https://www.acmicpc.net/problem/1309난이도 - 실버1🥈알고리즘 분류: dp🧐 문제접근평범한 dp문제입니다사자가 왼쪽이면 0, 오른쪽이면 1, 아무도없으면 2 index로 넣어서 dp를 수행하면 됩니다!전체코드//1309번 동물원let n = Int(readLine()!)!let mod = 9901var dp = Array(repeating: 0,0,0, count: n)//0: 왼쪽, 1: 오른쪽, 2: 둘다 비었을때dp0 = 1,1,1for i in 1..&lt;n {    dpi0 = dpi-11 + dpi-12    dpi1 = dpi-10 + dpi-12    dpi2 = dpi-10 + dpi-11 + dpi-12    dpi0 %= mod    dpi1 %= mod    dpi2 %= mod}print(dpn-1.reduce(0,+) % mod)한줄평가: 평범한 dp문제이다"
216,"https://www.acmicpc.net/problem/11265난이도 🥇🥈🥉알고리즘 분류: 플로이드와샬, 그래프탐색🧐 문제접근n이 최대 500이므로, n^3의 플로이드 와샬 알고리즘을 통해 쉽게 풀수 있습니다전체코드//11265번 끝나지 않는 파티func floydWarshall() {    for k in 0..&lt;n {        for i in 0..&lt;n {            for j in 0..&lt;n {                graphij = min(graphij, graphik + graphkj)            }        }    }}let nm = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}let n = nm0, m = nm1var graph = Int()for _ in 0..&lt;n {    let line = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}    graph.append(line)}floydWarshall()for _ in 0..&lt;m {    let abc = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}    let (a,b,c) = (abc0-1, abc1-1, abc2)    if graphab &lt;= c {        print(&quot;Enjoy other party&quot;)    } else {        print(&quot;Stay here&quot;)    }}한줄평가: 플로이드 와샬의 정석"
217,"https://www.acmicpc.net/problem/1766난이도 - 골드2 🥇알고리즘 분류: 위상정렬, 우선순위큐🧐 문제접근일반적인 위상정렬문제인데, 다만 문제풀이에 쓰이는 큐를 우선순위큐로 해줘야 하는 문제입니다골드2 치고는 너무쉬웠습니다전체코드//1766번 문제집final class Heap&lt;T: Equatable&gt; {    private var nodes: T =     private let sort: (T,T) -&gt; Bool    init(sort: @escaping ((T,T) -&gt; Bool)) {        self.sort = sort    }    var isEmpty: Bool {        nodes.isEmpty    }    func insert(_ data: T) {        var index = nodes.count        nodes.append(data)        while index &gt;= 0, sort(nodesindex, nodes(index-1)/2) {            nodes.swapAt(index, (index - 1) / 2)            index = (index - 1) / 2        }    }    func delete() -&gt; T {        if nodes.count == 1 {            return nodes.removeFirst()        }        let data = nodes.first!        nodes.swapAt(0, nodes.count - 1)        _ = nodes.popLast()        let limit = nodes.count        var index = 0        while index &lt; limit {            let leftChild = index * 2 + 1            let rightChild = leftChild + 1            let children = leftChild, rightChild                .filter{ $0 &lt; limit &amp;&amp; sort(nodes$0, nodesindex)}                .sorted{ sort(nodes$0, nodes$1)}            if children.isEmpty { break }            nodes.swapAt(index, children.first!)            index = children.first!        }        return data    }}let nm = readLine()!.split(separator: &quot; &quot;).map{Int($0)!}let n = nm0, m = nm1var indegree = Array(repeating: 0, count: n+1)var earlyProblem = Array(repeating: Int(), count: n+1)for _ in 0..&lt;m {    let ab = readLine()!.split(separator: &quot; &quot;).map{Int($0)!}    let a = ab0, b = ab1    indegreeb += 1    earlyProblema.append(b)}//topologySortfunc topologySort() -&gt; String {    var visitedNode = Int()    //초기데이터 셋업    let queue = Heap&lt;Int&gt;(sort: &lt;)    for i in 1...n where indegreei == 0 {        queue.insert(i)    }    while !queue.isEmpty {        let cur = queue.delete()        visitedNode.append(cur)        for next in earlyProblemcur {            indegreenext -= 1            if indegreenext == 0 {                queue.insert(next)            }        }    }    return visitedNode.map{String($0)}.joined(separator: &quot; &quot;)}print(topologySort())한줄평가: 쉽다"
218,"https://www.acmicpc.net/problem/2096난이도 - 골드4 🥇알고리즘 분류: dp🧐 문제접근swift는 슬라이딩 윈도우 테크닉을 안써도 풀린다..(??)그래서 그냥 평범한 dp문제가 되서 쉬웠습니다전체코드//2096번 내려가기let n = Int(readLine()!)!var arr = Int()var dp = Array(repeating: Array(repeating: 0, count: 3), count: n)for _ in 0..&lt;n {    let t = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}    arr.append(t)}dp0 = arr0for i in 1..&lt;n {    dpi0 = max(dpi-10, dpi-11) + arri0    dpi1 = max(dpi-10, dpi-11, dpi-12) + arri1    dpi2 = max(dpi-11, dpi-12) + arri2}let maxValue = dpn-1.max()!dp = Array(repeating: Array(repeating: 0, count: 3), count: n)dp0 = arr0for i in 1..&lt;n {    dpi0 = min(dpi-10, dpi-11) + arri0    dpi1 = min(dpi-10, dpi-11, dpi-12) + arri1    dpi2 = min(dpi-11, dpi-12) + arri2}let minValue = dpn-1.min()!print(maxValue, minValue)한줄평가: 골드보다 훨씬 쉬운 dp문제이다"
219,"https://www.acmicpc.net/problem/2531난이도 - 실버1 🥈알고리즘 분류: 투포인터🧐 문제접근윈도우 사이즈가 k로 정해져있어서, 윈도우를 먼저 만든다음, 한칸씩 이동하면서 최대값을 갱신하면됩니다전체코드//2531번 회전초밥let t = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}let (n,d,k,c) = (t0, t1, t2, t3)var arr = Int()for _ in 0..&lt;n {    arr.append(Int(readLine()!)!)}arr.append(contentsOf: arr)var start = 0, end = 0, result = 0var eatDict = c:1while end &lt; k {    if eatDictarrend == nil { eatDictarrend = 0 }    eatDictarrend! += 1    end += 1}while end &lt; arr.count {    result = max(result, eatDict.count)    eatDictarrstart! -= 1    if eatDictarrstart == 0 {        eatDictarrstart = nil    }    if eatDictarrend == nil {        eatDictarrend = 0    }    eatDictarrend! += 1    start += 1    end += 1}print(result)한줄평가: 무난무난"
220,"https://www.acmicpc.net/problem/1965난이도 - 실버2 🥈알고리즘 분류: dp🧐 문제접근가장 긴 증가하는 부분수열 구하는 문제전체코드//1965번 상자넣기let n = Int(readLine()!)!let boxes = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}//가장 긴 증가하는 부분수열 구하는 문제var dp = Array(repeating: 1, count: n+1)for i in 1..&lt;n {    for j in 0..&lt;i {        if dpi &lt; dpj + 1 &amp;&amp; boxesi &gt; boxesj {            dpi = dpj + 1        }    }}print(dp.max()!)한줄평가: 대표유형이다"
221,"https://www.acmicpc.net/problem/1149난이도 - 실버1🥈알고리즘 분류: dp🧐 문제접근평범한 dp문제전체코드let n = Int(readLine()!)!var rgbCost: (r: Int, g: Int, b: Int) = var dp = Array(repeating: 0,0,0, count: n)for _ in 0..&lt;n {    let t = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}    rgbCost.append((t0, t1, t2))}dp00 = rgbCost0.rdp01 = rgbCost0.gdp02 = rgbCost0.bfor i in 1..&lt;n {    dpi0 = min(dpi-11, dpi-12) + rgbCosti.r    dpi1 = min(dpi-10, dpi-12) + rgbCosti.g    dpi2 = min(dpi-10, dpi-11) + rgbCosti.b}print(dpn-1.min()!)한줄평가: 그냥 dp의 정석"
222,"RxSwift 스터디 GitHub (https://github.com/fimuxd/RxSwift) 를 보고 하나씩 따라하는 곳입니다Ch2 ObservableObservable이란?비동기적으로 관찰가능한 이벤트를 방출하는 객체를 말한다Observable 만들기just, of, fromlet ob1 = Observable.just(1)let ob2 = Observable.of(1,2,3)let ob3 = Observable.from(1,2,3)Observable 구독위의 옵져버블을 선언하는걸로는 아무일도 일어나지 않습니다.무조건 구독을 해줘야, 방출하는 값을 받을 수 있음!subscribe()let ob1 = Observable.just(1)ob1.subscribe({ event in    if let element = event.element {        print(element)    }})//1subscribe(onNext: )let ob2 = Observable.of(1,2,3)ob2.subscribe(onNext: { (element) in    print(element)})/*123*/.empty()completed 이벤트를 전달하고 바로 종료let ob = Observable&lt;Void&gt;.empty()ob.subscribe(onNext: { (element) in    print(element)}, onCompleted: {    print(&quot;Completed&quot;)})//Completed.never()아무런 이벤트를 전달하지 않음let ob = Observable&lt;Void&gt;.never()ob.subscribe(onNext: { (element) in    print(element)}, onCompleted: {    print(&quot;Completed&quot;)}).range()let ob = Observable&lt;Int&gt;.range(start: 1, count: 10)ob.subscribe(onNext: { (element) in    print(element)})/*12345678910*/Disposing과 종료각각의 구독을 관리를 해줘야 하는데, dispose()를 명시적으로 호출하는 방법이 있지만 권장되지 않는다(비효율, 휴먼 에러)let bag = DisposeBag() 이라는 변수를 하나 선언해서, 모든 구독의 끝에 .disposed(by: disposeBag) 을 호출하면, 모두 bag에 담아놓았다가, 해당 bag이 선언된 부분이 해제될때 한꺼번에 해제시켜준다.Create직접 Observable을 customgkrp Create해줄수도 있습니다let disposeBag = DisposeBag()let ob = Observable&lt;String&gt;.create { (observer) -&gt; Disposable in    observer.onNext(&quot;1&quot;)    observer.onNext(&quot;4&quot;)    observer.onNext(&quot;9&quot;)    observer.onCompleted()    return Disposables.create()}ob.subscribe(onNext: {print($0)},             onError: {print($0)},             onCompleted: {print(&quot;Complted&quot;)},             onDisposed: {print(&quot;Disposed&quot;)}).disposed(by: disposeBag)Observable factory 만들기deferred를 이용해서 외부 조건에 영향을 받게 만들 수도 있습니다 :)import RxSwiftlet disposeBag = DisposeBag()var flip = falselet ob = Observable&lt;Int&gt;.deferred {    flip.toggle()    if flip {        return Observable.of(1,2,3)    } else {        return Observable.of(4,5,6)    }}for _ in 0...3 {    ob.subscribe(onNext: {        print($0, terminator: &quot; &quot;)    })    .disposed(by: disposeBag)    print()}/*1 2 3 4 5 6 1 2 3 4 5 6 */Traits 사용보다 좁은 범위의 Observable로써 특정 용도에 적절하다Singlesuccess(data) or error 만 방출success(data) (는 next + completed를 의미한다)아래 예제를 보겠습니다let bag = DisposeBag()enum NetworkError: Error {    case failToConnect}func getRequest(url: String?) -&gt; Single&lt;Bool&gt; {    return Single&lt;Bool&gt;.create { single in        guard let url = url else {            single(.failure(NetworkError.failToConnect))            return Disposables.create()        }        if url == &quot;https://www.apple.com&quot; {            single(.success(true))        } else {            single(.success(false))        }        return Disposables.create()    }}getRequest(url: &quot;https://www.apple.com&quot;)    .subscribe(onSuccess: { success in        print(success)    },    onFailure: {error in        print(error.localizedDescription)    },    onDisposed: {        print(&quot;disposed&quot;)    })    .disposed(by: bag)약간 Result Type 느낌?Completablecompleted or error 만 방출enum LoadingError: Error {    case failToLoad}let bag = DisposeBag()func loading(complete: Bool) -&gt; Completable {    return Completable.create { completable in        guard complete else {            completable(.error(LoadingError.failToLoad))            return Disposables.create()        }        completable(.completed)        return Disposables.create()    }}loading(complete: true)    .subscribe {        print(&quot;completed&quot;)    } onError: { error in        print(error.localizedDescription)    }    .disposed(by: bag)완료했는지 에러가 났는지 여부만 방출합니다. 값은 xMaybesuccess(data), completed, error를 모두 방출enum LoadingError: Error {    case failToLoad}let bag = DisposeBag()func study() -&gt; Maybe&lt;String&gt; {    return Maybe&lt;String&gt;.create { maybe in        maybe(.success(&quot;RxSwift&quot;))        maybe(.completed)        maybe(.error(LoadingError.failToLoad))        return Disposables.create()    }}study()    .subscribe { result in        switch result {        case .success(let language):            print(&quot;Study &quot; + language)        case .completed:            print(&quot;Completed&quot;)        case .error(let error):            print(error.localizedDescription)        }    }    .disposed(by: bag)이런느낌?Challengesdo연산자특정 이벤트가 발생했을때, 실행되는 콜백함수를 등록하고 싶을때 사용.발생되는 요소를 수정하지 않고 구독자로 그대로 전달합니다let bag = DisposeBag()Observable.of(1,2,3,4,5)    .do {        $0 * 10    }    .subscribe(onNext: {        print(&quot;sub: &quot;, $0)    })    .disposed(by: bag)debug연산자let bag = DisposeBag()let ob = Observable&lt;Any&gt;.never()    .debug(&quot;동작확인&quot;)    .subscribe()    .disposed(by: bag)// 2022-03-25 18:23:34.315: 동작확인 -&gt; subscribed"
223,"RxSwift 스터디 GitHub (https://github.com/fimuxd/RxSwift) 를 보고 하나씩 따라하는 곳입니다Ch1. Hello RxSwiftRx란?Rx is a generic abstraction of computation expressed through Observable interface, which lets you broadcast and subscribe to values and other events from an Observable stream.Rx는 관찰가능한 인터페이스를 통해 표현되는 계산의 일반적인 추상화입니다. 이를 통해 관찰 가능한 스트림의 값 및 기타 이벤트를 브로드캐스트 하거나 구독할 수 있습니다.A. RxSwift란?Rx의 Swift 버전, Swfit로 작성한 코드가, 새로운 데이터에 반응하고, 순차적으로 분리된 방식으로 처리할 수 있게 하므로써, 비동기 프로그래밍을 쉽게 구현할 수 있게 해주는 프레임워크B. Cocoa and UIKit Asynchronous APIs그러면 UIKit에서는 비동기 프로그래밍을 못할까요? (x)아래의 방법들이 있습니다Notificaiton Centerdelegate patternGCDcompletion closure하지만, 내가 어떤 앱 코드를 작성했을때, 각 클래스가 어떤식으로 동작하는지 추적을 하는것은 불가능한 문제가 있습니다!C. 비동기 프로그래밍 용어들1. StateState는 상태를 의미합니다.그리고 State에 따라서 같은 함수인데도 동작이 달라질 수도 있습니다2. 명령형 프로그래밍프로그램밍의 상태와 상태를 변경시키는 구문의 관점에서 프로그래밍하는것!복잡한 비동기 앱을 만들기 위해 명령형 프로그래밍은 너무 힘들다.. ㅠㅠfunc doSomething() {    cleanRoom()      eatLunch()      goRunning()      playGame()} 각각의 매서드가 순서대로 동작하는데, 각 매서드가 앱의 상태를 바꿔버릴 수가 있죠?그러면 추적하기도 힘들고, 이 함수가 앱의 state를 변경할지 안할지도 알수가 없어요 ㅠ3. 부수작용현재 scope외의 상태에서 일어나는 모든 변화를 뜻합니다위에서 cleanRoom ~ playGame이라는 함수를 실행 시켰는데, 이 함수들이 app의 state를 변경할 수도 있죠? 그거 자체는 문제가 안되는데, 컨트롤이 되냐 안되냐가 바로 문제입니다 ㅠ4. 선언형 코드명령형 프로그래밍, 객체지향 프로그래밍에서는 상태 변화는 자유자재로 가능합니다함수형 프로그래밍에서는 부작용을 허용하지 않습니다RxSwift는 명령형과 함수형을 결합하여 동작합니다자유로운 상태변화와 + 추적/예측가능한 결과값을 모두 얻을수 있게 됩니다D. RxSwift 기초1. Observables- Rx코드의 기반이고, 전달가능한 이벤트를 비동기적으로 생성합니다- Observable은 이벤트를 방출하고, observer는 해당 이벤트를 구독합니다      - next: 다음 데이터를 전달하는 이벤트      - completed: 이벤트를 정상적으로 종료시킴      - error: 에러를 발생시키고, 이벤트를 종료시킴2. Operators- 비동기 작업을 추상화하기위한 여러 매서드를 연산자라고 부릅니다- 한두개가 아님.... map, filter, flatMap, skip 등등E. App ArchitectureRxSwift는 기존의 앱 아키텍쳐와 상관이 없으나, MVVM과 함께 사용하면 매우 멋지게 동작합니다 :)View Model에서 Observable로 값을 방출하고, View에서는 그 값을 받기만 해서 사용하는거죠!F. RxCocoaRxSwift는 UIKit과 Cocoa 프레임워크에 포함된 클래스에 대한 아무 정보가 없습니다. 그래서 RxCocoa라는 라이브러리를 같이 사용해야, UI와 연동하여 제대로 사용할 수 있게됩니다"
224,"https://www.acmicpc.net/problem/16987난이도 - 실버1 🥈알고리즘 분류: 백트래킹, dfs🧐 문제접근전형적인 dfs문제다. 예외만 잘 처리한다면 쉽게 풀 수 있다전체코드let n = Int(readLine()!)!var durability = Int()var weight = Int()for _ in 0..&lt;n {    let sw = readLine()!.split(separator: &quot; &quot;).map{Int($0)!}    durability.append(sw0)    weight.append(sw1)}var ans = 0dfs(0)print(ans)func dfs(_ idx: Int) {    if idx &gt;= n {        ans = max(ans, durability.filter{$0 &lt;= 0}.count)        return    }    if durabilityidx &lt;= 0 {        dfs(idx+1)        return    }    var eggExist = false    for i in 0..&lt;n where i != idx &amp;&amp; durabilityi &gt; 0 {        durabilityi -= weightidx        durabilityidx -= weighti        eggExist = true        dfs(idx+1)        durabilityi += weightidx        durabilityidx += weighti    }    if !eggExist { dfs(n) }}한줄평가: 실버 dfs중에는 젤 어려운 문제아니었나?"
225,"https://www.acmicpc.net/problem/3980난이도 - 골드4🥇알고리즘 분류: 백트래킹, dfs, 완전탐색🧐 문제접근그냥 백트래킹과 dfs를 이용해서 풀었다더 설명할만한 요소는 없는것 같습니다 :)전체코드//3980번 선발명단var ans = 0var arr: Int = var visit: Bool = for _ in 0..&lt;Int(readLine()!)! {    visit = Array(repeating: false, count: 12)    arr = Array(repeating: Int(), count: 12)    ans = 0    (1...11).forEach {        arr$0 = 1 + readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}    }    dfs(player: 1, sum: 0)    print(ans)}func dfs(player: Int, sum: Int) {    if player &gt;= 12 {        ans = max(ans, sum)        return    }    for position in 1...11 where !visitposition {        if arrplayerposition != 0 {            visitposition = true            dfs(player: player+1, sum: sum+arrplayerposition)            visitposition = false        }    }}한줄평가: 쉬웠다"
226,"https://www.acmicpc.net/problem/4358난이도 - 실버1🥈알고리즘 분류: 해시🧐 문제접근Dictionary를 이용하면 바로 풀 수 있습니다주의할점은 무조건 소숫점 넷째자리까지 출력해 줘야한다50 (x)50.0000 (o)전체코드/* 4358번 생태학 */import Foundationfunc getPercentage(value: Double, total: Double) -&gt; String {    let percent = value/total * 100    let roundPercent = round(percent * 10000) / 10000    return String(format: &quot;%.4f&quot;, roundPercent)}var dict: String:Double = :while true {    if let tree = readLine() {        let value = dicttree ?? 0        dicttree = value + 1    } else {        break    }}let total = Double(dict.values.reduce(0, +))for (tree, value) in dict.sorted(by: {$0.key &lt; $1.key}) {    print(tree + &quot; &quot; + getPercentage(value: value, total: total))}한줄평가: 너무쉬움"
227,"https://www.acmicpc.net/problem/15724난이도 - 실버1🥈알고리즘 분류: 누적합🧐 문제접근그냥 2차원 누적합 문제이다전체 행렬에 대한 누적합을 구한뒤,x1,y1,x2,y2가 주어졌을때는빨간색부분을 구하려면, arrSumx2y2에서 파란 부분 두개를 빼준후, 중복연산이 된 주황부분 하나를 더해주면 됩니다 :)전체코드/* 15724번 누가봐도 2차원 누적합문제 *///2차원 누적합 구하기func getSum() -&gt; Int {    var arrSum = arr    for i in 0..&lt;n {        for j in 1..&lt;m {            arrSumij += arrSumij-1        }    }    for j in 0..&lt;m {        for i in 1..&lt;n {            arrSumij += arrSumi-1j        }    }    return arrSum}func getAreaSum(x1: Int, y1: Int, x2: Int, y2: Int) -&gt; Int {    var ansArea = arrSumx2y2    //가로영역구하기    let rx = x1-1    let ry = y2    if rx &gt;= 0 {        ansArea -= arrSumrxry    }    //세로영역구하기    let cx = x2    let cy = y1-1    if cy &gt;= 0 {        ansArea -= arrSumcxcy    }    //겹치는 부분 빼주기    if rx &gt;= 0, cy &gt;= 0 {        ansArea += arrSumrxcy    }    return ansArea}let nm = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}let (n,m) = (nm0, nm1)var arr = Int()for _ in 0..&lt;n {    let t = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}    arr.append(t)}let arrSum = getSum()let k = Int(readLine()!)!for _ in 0..&lt;k {    let r = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!-1}    let (x1,y1,x2,y2) = (r0,r1,r2,r3)    print(getAreaSum(x1: x1, y1: y1, x2: x2, y2: y2))}한줄평가: 대표유형인것같다"
228,"https://www.acmicpc.net/problem/1669난이도 - 실버1🥈알고리즘 분류: 수학🧐 문제접근처음에는 bfs로 하다가 바로 메모리 초과 당해버렸다..(문제 특성상 방문처리를 확실히 할 수 없어서 그런듯?)생각을 좀더 해보면1 = 1일1 2 1 = 3일1 2 3 2 1 = 5일1 2 3 4 3 2 1 = 7일1 2 3 4 5 4 3 2 1 = 9일원숭이와 멍멍이의 키차이를 diff라고 할때,diff는 위의 구간중 하나에 속할 수 밖에 없다ex) diff = 5라면, 3일 ~ 5일 구간에 속한다그래서 어느 구간에 속하는지 구한후, 4일인지, 5일인지 구해주면된다3일과 5일중 3일쪽에 가까우면 4일이고, 5일쪽에 가까우면 5일이다전체코드/* 1669번 멍멍이 쓰다듬기 1차시도: bfs 메모리초과 실패 */let xy = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}let (x,y) = (xy0, xy1)let diff = y-x//현재키var tall = 1//키의 증가분var dx = 3//현재 날짜var day = 1while true {    //키가 목표치를 넘어버렸다면?    if tall &gt;= diff {        //이전 키를 구한다        let prevTall = tall - (dx-2)        //중간값을 구한다: (3일과 5일의 사이라면, 답이 4일인지, 5일인지 판별하기 위해)        let mid = (tall+prevTall)/2        if diff &lt;= mid {            print(day-1)        } else {            print(day)        }        break    }    //아직 키가 부족하면 더 늘리기    day += 2    tall += dx    dx += 2}한줄평가: 수학은 실버문제도 어려운것 같다.."
229,"11일 Delegate와 Weak (순환참조가 무조건 일어나나요?)delegate 공부를 하다보니 이상한 점을 발견했습니다다음 예를 한번 보겠습니다예제import UIKitclass FirstViewController: UIViewController {    override func viewDidLoad() {        super.viewDidLoad()        view.backgroundColor = .systemYellow    }    override func viewDidAppear(_ animated: Bool) {        super.viewDidAppear(animated)        present(SecondViewControler(), animated: true)    }}protocol NothingDelegate: AnyObject {}class SecondViewControler: UIViewController, NothingDelegate {    override func viewDidLoad() {        super.viewDidLoad()        view.backgroundColor = .systemBlue    }    override func viewDidAppear(_ animated: Bool) {        super.viewDidAppear(animated)        let thirdVC = ThirdViewController()        thirdVC.delegate = self        present(thirdVC, animated: true)    }    deinit {        print(&quot;2 Deinit&quot;)    }}class ThirdViewController: UIViewController {    var delegate: NothingDelegate?    override func viewDidLoad() {        super.viewDidLoad()        view.backgroundColor = .systemRed    }    deinit {        print(&quot;3 Deinit&quot;)    }}FirstVC -&gt; SecondVC -&gt; ThirdVC를 순서로 띄웁니다ThirdVC의 delegate를 SecondVC로 설정합니다뭐가문제인데?이상황에 대부분은 delegate를 무조건 weak으로 써야한다고 배웠을 겁니다. 구글도 그렇게 말하고요.저도 당연히 무지성으로 썼었고, 이번에 직접 확인해 보고 싶어서 위와 같은 코드를 작성했습니다. 그리고 당연히 될줄 알았어요!근데.. delegate를 붙이나 안붙이나 ThirdVC, SecondVC의 deinit이 아주 잘 해제 됩니다..!같이 공부하는 친구들과도 얘기해 봤는데, 도저히 결론이 안나오더라구요.. 결국 리뷰어인 올라프⛄️에게 도움을 요청했습니다순환참조에 대해 완전히 잘못 알고 있다는것을 깨달음..SecondVC에서 ThirdVC 만들고 present하니까 이거 SecondVC -&gt; ThirdVC 참조하고 있는거 아니야? (아니였음)strong delegate최초에 모든 VC가 다 떠있는 상태thirdVC.delegate = self 이니깐, ThirdVC의 delegate에서 SecondVC를 참조하고 있는 상황ThirdVC가 dismiss된 상태thirdVC가 dismiss될때 RC = 0 이 되고, SecondVC를 가리키고 있던 참조도 끊어지게 됩니다. 그래서 SecondVC의 RC = 1이됩니다 ThirdVC의 deinit 호출SecondVC가 dismiss된 상태SecondVC의 deinit 호출weak delegatestrong일때도 잘됬는데 weak일때 안될이유 1도 없죠?설명은 생략하겠습니다순환참조를 발생시킨다면 어떨까?코드를 다음과 같이 바꿔보겠습니다class SecondViewControler: UIViewController, NothingDelegate {    var subVC: UIViewController?    override func viewDidLoad() {        super.viewDidLoad()        view.backgroundColor = .systemBlue    }    override func viewDidAppear(_ animated: Bool) {        super.viewDidAppear(animated)        let thirdVC = ThirdViewController()        self.subVC = thirdVC        thirdVC.delegate = self        present(thirdVC, animated: true)    }    deinit {        print(&quot;2 Deinit&quot;)    }}이제는 self.subVC = thirdVC라는 코드 때문에, SecondVC가 ThirdVC를 참조하고 있습니다strong delegate최초에 모든 VC가 다 떠있는 상태SecondVC의 subVC가 ThirdVC를 참조ThirdVC의 delegate가 SecondVC를 참조이게 순환참조가 되있는 상태죠? 앞으로 어떻게 될까요?ThirdVC가 dismiss된 상태ThirdVC가 dismiss되니깐 RC -= 1하지만 subVC에서 참조하고 있기때문에, dismiss는 되지 않습니다그래서 delegate도 여전히 그대로 SecondVC를 참조하고 있네요SecondVC가 dismiss된 상태마찬가지로 SecondVC가 dismiss되니깐 RC -= 1하지만 delegate에서 여전히 참조하고 있기 때문에, dismiss는 되지 않습니다그래서 subVC도 여전히 ThirdVC를 참조하고 있네요이제 이 친구들은 영원히 해제되지 못하겠군요 ㅠㅠ이게 바로 문제의 상황이고, 이 상황을 해결하기 위한 방법이 weak을 사용하는것weak delegate최초에 모든 VC가 다 떠있는 상태subVC가 ThirdVC를 참조하므로 ThirdVC의 RC = 2근데 delegate는 weak으로 선언되어 있으므로 SecondVC의 RC = 1ThirdVC가 dismiss된 상태ThirdVC가 dismiss되므로 RC -= 1, 그러나 아직은 메모리에 남아있다SecondVC가 dismiss된 상태SecondVC가 dismiss될때, RC = 0 이되어 메모리에서 사라집니다그때, subVC가 참조하고 있던 연결도 끊겨서 ThirdVC의 RC = 0이 됩니다그래서 이 시점에 ThirdVC, SecondVC가 동시에 deinit 됩니다추가적인 궁금증Q. 그러면 이번프로젝트에서 weak 안써도 되나요?A. 구현만 보면 맞지만, 추후 어떻게 될지 모르므로 굳이 안쓸이유는 없다  Q. 마찬가지로 클로져에서 self를 쓰는경우, 순환참조가 없다면 weak을 붙이지 않아도 되나요?A. 어떻게 확신하죠? 무지성 weak 붙여도 크게 문제되지 않는다고 생각한다  도움: 리뷰어 올라프⛄️명쾌한 예제와 내 수준에 맞춰준 눈높이 설명 💯같이 고민해준 캠퍼들도 감사합니다 :)마이노, 티아나, 사파리, 레드"
230,"https://www.acmicpc.net/problem/1790난이도: 실버1🥈알고리즘 분류: 수학🧐 문제접근당연하지만, 모든 수를 다 쓴후, k번째 수를 구하면 시간초과가 난다각 자리수에 속하는 수의 개수를 구해보면 다음과 같다숫자개수1~99개10-9990개100-999900개1000-99999000개10000-9999990000개먼가 규칙이 딱 보이는거 같다n자리수는 9 * 10^(n-1)개..!1-9 구간에는 9개의 숫자가 있고, 순서로 따지면 9번째까지 커버10-99 구간에는 90개의 숫자가 있고, 순서로 따지면 90 * 2 = 180 번째까지 커버...이런식이므로, k가 커버할 수 있는 구간을 모두 빼준다.그러면 마지막으로 끝난 수 ans, 남은 k번째수, 그때의 자릿수(digit)이 나오고, 그걸로 답을 구할 수 있다.ex) n = 20, k = 23일때..k 는 첫번째 구간의 9자리 커버 가능, 두번째 구간의 180자리는 커버 불가능그래서 k = 14 (23-9)그때의 자리수 digit = 2그때의 마지막수 ans = 9그러면 처음 시작하는 수는 ans + 1 = 10이고해당 수부터 카운트 해야 하므로 k - 1 = 13digit = 2 이므로, k = 13 는 수의 개수로 따지면 k / dight = 13 / 2 = 6,그래서 ans + 6 ans = 16이 된다.이중 k가 1을 가르키는지 6을 가르키는지 k % digit = 13 % 2 으로 알 수 있고, 1이므로 index 1인 6을 가르킨다.따라서 답은 6전체코드//1790번 수 이어 쓰기2let nk = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}let n = nk0var k = nk1var ans = 0var digit = 1var count = 9//1의 자리 9개, 2의 자리 90개 .. 가능할때까지 계속뺀다while k &gt; digit * count {    k -= digit * count    ans += count    digit += 1    count *= 10}ans = ans + 1 + (k-1)/digitif ans &gt; n {    print(-1)} else {    let idx = (k-1)%digit    let str = String(ans)    print(strstr.index(str.startIndex, offsetBy: idx))}한줄평가: 너무 어렵다.. ㅠㅠㅠㅠㅠ :("
231,"https://www.acmicpc.net/problem/2146난이도: 골드3🥇알고리즘 분류: bfs, 구현🧐 문제접근골드 3이지만, 간단하게 풀 수 있는 문제였다.예제입력101 1 1 0 0 0 0 1 1 11 1 1 1 0 0 0 0 1 11 0 1 1 0 0 0 0 1 10 0 1 1 1 0 0 0 0 10 0 0 1 0 0 0 0 0 10 0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 00 0 0 0 1 1 0 0 0 00 0 0 0 1 1 1 0 0 00 0 0 0 0 0 0 0 0 0numberingContinent(), bfs(): 전체 그래프를 bfs탐색하며, 모든 대륙에 넘버링을 해준다결과2, 2, 2, 0, 0, 0, 0, 3, 3, 32, 2, 2, 2, 0, 0, 0, 0, 3, 32, 0, 2, 2, 0, 0, 0, 0, 3, 30, 0, 2, 2, 2, 0, 0, 0, 0, 30, 0, 0, 2, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0, 00, 0, 0, 0, 4, 4, 0, 0, 0, 00, 0, 0, 0, 4, 4, 4, 0, 0, 00, 0, 0, 0, 0, 0, 0, 0, 0, 0bfs2(): 한 대륙에 대해서 bfs로 영역을 늘려나가면서, 가장 가까운 대륙까지의 거리를 구한다각 대륙에 속하는 index를 빠르게 구하기 위해 넘버링 과정에서 Int: (Int,Int) 딕셔너리에 index들을 저장을 해줬다.해당방식으로 했을때 시간초과를 걱정했는데, 그냥 구현문제였나보다. 시간초과 나지 않았음!전체코드//2146번 다리 만들기import Foundationvar graph = Int()let dx = 1,-1,0,0let dy = 0,0,1,-1let n = Int(readLine()!)!for _ in 0..&lt;n {    let line = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}    graph.append(line)}var dict: Int: (Int,Int) = :func numberingContinent() -&gt; Int{    var number = 2    for i in 0..&lt;n {        for j in 0..&lt;n {            if graphij == 1 {                bfs(i, j, number: number)                number += 1            }        }    }    return number}func bfs(_ sx: Int, _ sy: Int, number: Int) {    graphsxsy = number    dictnumber = (sx,sy)    var queue = (sx,sy)    var idx = 0    while queue.count &gt; idx {        let (cx,cy) = queueidx        idx += 1        for i in 0..&lt;4 {            let (nx,ny) = (cx+dxi, cy+dyi)            if (0..&lt;n) ~= nx &amp;&amp; (0..&lt;n) ~= ny &amp;&amp; graphnxny == 1 {                graphnxny = number                queue.append((nx,ny))                dictnumber!.append((nx,ny))            }        }    }}let cnt = numberingContinent()func bfs2(number: Int) -&gt; Int {    var queue = dictnumber!    var idx = 0    let INF = Int.max    var dist = Array(repeating: Array(repeating: INF, count: n), count: n)    queue.forEach {dist$0$1 = 0}    while queue.count &gt; idx {        let (cx,cy) = queueidx        idx += 1        //다른 대륙에 도착했다면 리턴        if graphcxcy != 0 &amp;&amp; graphcxcy != number {            return distcxcy        }        for i in 0..&lt;4 {            let (nx,ny) = (cx+dxi, cy+dyi)            if (0..&lt;n) ~= nx &amp;&amp; (0..&lt;n) ~= ny &amp;&amp; distnxny &gt; distcxcy + 1 {                distnxny = distcxcy + 1                queue.append((nx,ny))            }        }    }    return Int.max}var minDist = Int.maxfor k in 2..&lt;cnt {    let dist = bfs2(number: k)    minDist = min(minDist, dist)}print(minDist-1)한줄평가: 일반적인 bfs 유형이었다"
232,"https://www.acmicpc.net/problem/1926난이도: 실버1🥈알고리즘 분류: bfs, 그래프탐색🧐 문제접근너무나도 쉬운 bfs 기본문제..visit배열을 따로 둘 필요조차 없다전체코드//1926번 그림let nm = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}let n = nm0let m = nm1var arr = Int()for _ in 0..&lt;n {    arr.append(readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!})}var maxWidth = 0var pictureCount = 0for i in 0..&lt;n {    for j in 0..&lt;m {        if arrij == 1 {            let width = bfs(i,j)            pictureCount += 1            maxWidth = max(maxWidth, width)        }    }}private func bfs(_ sx: Int, _ sy: Int) -&gt; Int {    var width = 1    arrsxsy = 0    let dx = 1,-1,0,0    let dy = 0,0,1,-1    var idx = 0    var queue = (sx,sy)    while queue.count &gt; idx {        let (cx,cy) = queueidx        idx += 1        for i in 0..&lt;4 {            let nx = cx + dxi            let ny = cy + dyi            if (0..&lt;n) ~= nx &amp;&amp; (0..&lt;m) ~= ny &amp;&amp; arrnxny == 1{                arrnxny = 0                queue.append((nx,ny))                width += 1            }        }    }    return width}print(pictureCount)print(maxWidth)한줄평가: 너무 전형적인 유형이라 실버1보다 더 쉬워야 한다"
233,"입양을 간 기록은 있는데, 보호소에 들어온 기록이 없는 동물의 ID와 이름을 ID 순으로 조회하는 SQL문SELECT O.ANIMAL_ID, O.NAMEFROM ANIMAL_OUTS O LEFT OUTER JOIN ANIMAL_INS ION O.ANIMAL_ID = I.ANIMAL_IDWHERE I.ANIMAL_ID IS NULL;OUTER JOIN: JOIN 조건에서 동일한 값이 없는 행도 반환할 때 사용-&gt; USING(두 테이블 간 필드 이름이 동일) 또는 ON(두 테이블 간 필드 이름이 다름) 조건절 필수LEFT (OUTER) JOIN-left table에만 있는 행은 right table의 컬럼에 NULL 값을 채움RIGHT (OUTER) JOIN-right table에만 있는 행은 left table의 컬럼에 NULL 값을 채움FULL (OUTER) JOIN-UNION과 비슷중복되는 데이터 삭제보호 시작일보다 입양일이 더 빠른 동물의 아이디와 이름을 조회하는 SQL문 (결과는 보호 시작일이 빠른 순으로 조회)SELECT I.ANIMAL_ID, I.NAMEFROM ANIMAL_INS I JOIN ANIMAL_OUTS OON I.ANIMAL_ID = O.ANIMAL_IDWHERE I.DATETIME &gt; O.DATETIMEORDER BY I.DATETIME;(INNER) JOIN: 양쪽 테이블이 모두 가지고 있는 데이터만을 검색할 때 사용 (≒ 교집합)아직 입양을 못 간 동물 중, 가장 오래 보호소에 있었던 동물 3마리의 이름과 보호 시작일을 조회하는 SQL문 (결과는 보호 시작일 순으로 조회)SELECT I.NAME, I.DATETIMEFROM ANIMAL_INS I LEFT OUTER JOIN ANIMAL_OUTS OON I.ANIMAL_ID = O.ANIMAL_IDWHERE O.ANIMAL_ID IS NULLORDER BY I.DATETIMELIMIT 3;보호소에서 중성화 수술을 거친 동물 정보를 알아보려 합니다. 보호소에 들어올 당시에는 중성화1되지 않았지만, 보호소를 나갈 당시에는 중성화된 동물의 아이디와 생물 종, 이름을 조회하는 아이디 순으로 조회하는 SQL문SELECT I.ANIMAL_ID, I.ANIMAL_TYPE, I.NAMEFROM ANIMAL_INS I JOIN ANIMAL_OUTS OON I.ANIMAL_ID = O.ANIMAL_IDWHERE I.SEX_UPON_INTAKE LIKE 'Intact%' AND O.SEX_UPON_OUTCOME NOT LIKE 'Intact%'ORDER BY I.ANIMAL_ID;"
234,"💻 C++ 기반마법사 상어와 복제https://www.acmicpc.net/problem/23290#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#define MAX 11using namespace std;struct SHARK_MOVE{    vector&lt;int&gt; directions;    int cntOfFish;};int M, S;int board_smell55; // 0: 없음vector&lt;pair&lt;int, int&gt; &gt; board_fish55;vector&lt;pair&lt;int, int&gt; &gt; board_fish_copy55;int sharkY, sharkX;int dy9 = {0, 0, -1, -1, -1, 0, 1, 1, 1};int dx9 = {0, -1, -1, 0, 1, 1, 1, 0, -1};int dirToNum4 = {1, 2, 3, 4}; // 상, 좌, 하, 우int dirY4 = {-1, 0, 1, 0};int dirX4 = {0, -1, 0, 1};void duplicateStart(){    for (int i = 1; i &lt;= 4; i++)    {        for (int j = 1; j &lt;= 4; j++)        {            board_fish_copyij = board_fishij;        }    }}void moveFish(){    vector&lt;pair&lt;int, int&gt; &gt; temp55;    for (int i = 1; i &lt;= 4; i++)    {        for (int j = 1; j &lt;= 4; j++)        {            if (!board_fishij.empty())            {                for (int k = 0; k &lt; board_fishij.size(); k++)                {                    int curY = i;                    int curX = j;                    int curFish = board_fishijk.first;                    int curDir = board_fishijk.second;                    bool isMoved = false;                    for (int l = 0; l &lt; 8; l++)                    {                        int nextY = curY + dycurDir;                        int nextX = curX + dxcurDir;                        if (nextY == sharkY &amp;&amp; nextX == sharkX || board_smellnextYnextX &gt; 0 || nextY &lt; 1 || nextY &gt; 4 || nextX &lt; 1 || nextX &gt; 4)                        {                            curDir = (curDir + 7) % 8;                            if (curDir == 0)                            {                                curDir = 8;                            }                            continue;                        }                        else                        {                            isMoved = true;                            tempnextYnextX.push_back(make_pair(curFish, curDir));                            break;                        }                    }                    if (!isMoved)                    {                        tempcurYcurX.push_back(make_pair(curFish, curDir));                    }                }            }        }    }    for (int i = 1; i &lt;= 4; i++)    {        for (int j = 1; j &lt;= 4; j++)        {            board_fishij = tempij;        }    }}bool compare(SHARK_MOVE input1, SHARK_MOVE input2){    if (input1.cntOfFish &gt; input2.cntOfFish)    {        return true;    }    else if (input1.cntOfFish == input2.cntOfFish)    {        for (int i = 0; i &lt; 3; i++)        {            if (dirToNuminput1.directionsi &lt; dirToNuminput2.directionsi)            {                return true;            }            else if (dirToNuminput1.directionsi == dirToNuminput2.directionsi)            {                continue;            }            else            {                return false;            }        }        return false;    }    else    {        return false;    }}void moveShark(int step){    vector&lt;SHARK_MOVE&gt; v_shark_move;    SHARK_MOVE shark_move;    for (int temp = 0; temp &lt; (1&lt;&lt;(2*3)); temp++)    {        int brute = temp;        int cntOfFish = 0;        vector&lt;int&gt; directions;        int curY = sharkY;        int curX = sharkX;        bool eaten55 = {false,};        bool isAble = true;        for (int i = 0; i &lt; 3; i++)        {            int dir = brute % 4;            brute /= 4;            int nextY = curY + dirYdir;            int nextX = curX + dirXdir;            if (nextY &lt; 1 || nextY &gt; 4 || nextX &lt; 1 || nextX &gt; 4)            {                isAble = false;                break;            }            directions.push_back(dir);            if (!board_fishnextYnextX.empty() &amp;&amp; !eatennextYnextX)            {                cntOfFish += board_fishnextYnextX.size();                eatennextYnextX = true;            }            curY = nextY;            curX = nextX;        }        if (isAble)        {            shark_move.cntOfFish = cntOfFish;            shark_move.directions = directions;            v_shark_move.push_back(shark_move);        }    }    sort(v_shark_move.begin(), v_shark_move.end(), compare);    int curY = sharkY;    int curX = sharkX;    for (int i = 0; i &lt; 3; i++)    {        int dir = v_shark_move0.directionsi;        curY += dirYdir;        curX += dirXdir;        if (!board_fishcurYcurX.empty())        {            vector&lt;pair&lt;int, int&gt; &gt; empty;            board_fishcurYcurX = empty;            board_smellcurYcurX = step;        }    }    sharkY = curY;    sharkX = curX;}void removeSmell(int step){    if (step &lt;= 2)    {        return;    }    for (int i = 1; i &lt;= 4; i++)    {        for (int j = 1; j &lt;= 4; j++)        {            if (board_smellij == step - 2)            {                board_smellij = 0;            }        }    }}void duplicateFinish(){    for (int i = 1; i &lt;= 4; i++)    {        for (int j = 1; j &lt;= 4; j++)        {            if (!board_fish_copyij.empty())            {                for (int k = 0; k &lt; board_fish_copyij.size(); k++)                {                    int curFish = board_fish_copyijk.first;                    int curDir = board_fish_copyijk.second;                    board_fishij.push_back(make_pair(curFish, curDir));                }            }        }    }}int main(){    scanf(&quot;%d %d&quot;, &amp;M, &amp;S);    for (int i = 1; i &lt;= M; i++)    {        int fishY, fishX, d;        scanf(&quot;%d %d %d&quot;, &amp;fishY, &amp;fishX, &amp;d);        board_fishfishYfishX.push_back(make_pair(i, d));    }    scanf(&quot;%d %d&quot;, &amp;sharkY, &amp;sharkX);    for (int i = 1; i &lt;= S; i++)    {        duplicateStart();        moveFish();        moveShark(i);        removeSmell(i);        duplicateFinish();    }    int ans = 0;    for (int i = 1; i &lt;= 4; i++)    {        for (int j = 1; j &lt;= 4; j++)        {            if (!board_fishij.empty())            {                ans += board_fishij.size();            }        }    }    printf(&quot;%d&quot;, ans);    return 0;}"
235,"💻 C++ 기반주사위 굴리기 2https://www.acmicpc.net/problem/23288#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;utility&gt;#define MAX 21using namespace std;int N, M, K;int boardMAXMAX;int dice6 = {1, 3, 6, 4, 2, 5}; // 주사위 아랫면: 6(인덱스 2)int dy4 = {-1, 0, 1, 0}; // 북동남서int dx4 = {0, 1, 0, -1};int getOppositeDir(int dir){    if (dir == 0)    {        return 2;    }    else if (dir == 1)    {        return 3;    }    else if (dir == 2)    {        return 0;    }    else    {        return 1;    }}void rollDice(int dir){    int dice_copy6 = {0,};    if (dir == 0)    {        dice_copy0 = dice5;        dice_copy1 = dice1;        dice_copy2 = dice4;        dice_copy3 = dice3;        dice_copy4 = dice0;        dice_copy5 = dice2;    }    else if (dir == 1)    {        dice_copy0 = dice3;        dice_copy1 = dice0;        dice_copy2 = dice1;        dice_copy3 = dice2;        dice_copy4 = dice4;        dice_copy5 = dice5;    }    else if (dir == 2)    {        dice_copy0 = dice4;        dice_copy1 = dice1;        dice_copy2 = dice5;        dice_copy3 = dice3;        dice_copy4 = dice2;        dice_copy5 = dice0;    }    else if (dir == 3)    {        dice_copy0 = dice1;        dice_copy1 = dice2;        dice_copy2 = dice3;        dice_copy3 = dice0;        dice_copy4 = dice4;        dice_copy5 = dice5;    }    for (int i = 0; i &lt; 6; i++)    {        dicei = dice_copyi;    }}int getScore(int y, int x){    int num = boardyx;    queue&lt;pair&lt;int, int&gt; &gt; q;    q.push(make_pair(y, x));    bool visitedMAXMAX = {false,};    visitedyx = true;    while (!q.empty())    {        int curY = q.front().first;        int curX = q.front().second;        q.pop();        for (int i = 0; i &lt; 4; i++)        {            int nextY = curY + dyi;            int nextX = curX + dxi;            if (nextY &lt; 1 || nextY &gt; N || nextX &lt; 1 || nextX &gt; M)            {                continue;            }            if (!visitednextYnextX &amp;&amp; boardnextYnextX == num)            {                q.push(make_pair(nextY, nextX));                visitednextYnextX = true;            }        }    }    int cnt = 0;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= M; j++)        {            if (visitedij)            {                cnt++;            }        }    }    return num * cnt;}int decideNexDir(int y, int x, int dir){    int A = dice2;    int B = boardyx;    if (A &gt; B)    {        return (dir + 1) % 4;    }    else if (A &lt; B)    {        return (dir + 3) % 4;    }    else    {        return dir;    }}int main(){    scanf(&quot;%d %d %d&quot;, &amp;N, &amp;M, &amp;K);    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= M; j++)        {            scanf(&quot;%d&quot;, &amp;boardij);        }    }    int total = 0;    int dir = 1;    int curY = 1, curX = 1;    while (K--)    {        int nextY = curY + dydir;        int nextX = curX + dxdir;        if (nextY &lt; 1 || nextY &gt; N || nextX &lt; 1 || nextX &gt; M)        {            dir = getOppositeDir(dir);            nextY = curY + dydir;            nextX = curX + dxdir;        }        curY = nextY;        curX = nextX;        rollDice(dir);        total += getScore(curY, curX);        dir = decideNexDir(curY, curX, dir);    }    printf(&quot;%d&quot;, total);    return 0;}"
236,"💻 C++ 기반마법사 상어와 블리자드https://www.acmicpc.net/problem/21611✔️ 2차원 배열을 1차원 배열로 바꿔서 동작 -&gt; 다시 2차원 배열로 복귀✔️ 1차원 배열에서 처리할 때는 투포인터 사용#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 50using namespace std;int N, M;int boardMAX_NMAX_N;int tempMAX_N * MAX_N = {0,};int sharkY, sharkX;int dy5 = {0, -1, 1, 0, 0}; // X, 북, 남, 서, 동int dx5 = {0, 0, 0, -1, 1};int dirY4 = {0, 1, 0, -1}; // 서, 남, 동, 북int dirX4 = {-1, 0, 1, 0};int beads4;void removeBeads(int d, int s){    int curY = sharkY;    int curX = sharkX;    while (s--)    {        int nextY = curY + dyd;        int nextX = curX + dxd;        boardnextYnextX = 0;        curY = nextY;        curX = nextX;    }}void flatten(){    int limit1 = N * 2 - 1;    int dir = 0;    int curY = sharkY;    int curX = sharkX;    int idx = 1;    for (int i = 0; i &lt; limit1; i++)    {        int limit2 = i == limit1 - 1 ? i / 2 : i / 2 + 1;        for (int j = 0; j &lt; limit2; j++)        {            int nextY = curY + dirYdir;            int nextX = curX + dirXdir;            tempidx = boardnextYnextX;            curY = nextY;            curX = nextX;            idx++;        }        dir = (dir + 1) % 4;    }}void moveBeads(){    int left = 1;    int right = 1;    while (left &lt; N * N)    {        if (templeft == 0)        {            right = left + 1;            while (right &lt; N * N)            {                if (tempright != 0)                {                    swap(templeft, tempright);                    break;                }                right++;            }        }        left++;    }}bool explodeBeads(){    bool isThereExplosion = false;    int left = 1;    int right = 2;    while (right &lt; N * N)    {        if (templeft == tempright)        {            right++;        }        else        {            if (right - left &gt;= 4)            {                isThereExplosion = true;                beadstempleft += (right - left);                for (int i = left; i &lt; right; i++)                {                    tempi = 0;                }            }            left = right;            right = left + 1;        }    }    return isThereExplosion;}void changeBeads(){    int temp_copyMAX_N * MAX_N = {0,};    int idx = 1;    int left = 1;    int right = 2;    while (right &lt; N * N)    {        if (templeft == tempright)        {            right++;        }        else        {            temp_copyidx = right - left;            idx++;            if (idx &gt;= N * N)            {                break;            }            temp_copyidx = templeft;            idx++;            if (idx &gt;= N * N)            {                break;            }            left = right;            right = left + 1;        }    }    for (int i = 0; i &lt; N * N; i++)    {        tempi = temp_copyi;    }}void backToBoard(){    int limit1 = N * 2 - 1;    int dir = 0;    int curY = sharkY;    int curX = sharkX;    int idx = 1;    for (int i = 0; i &lt; limit1; i++)    {        int limit2 = i == limit1 - 1 ? i / 2 : i / 2 + 1;        for (int j = 0; j &lt; limit2; j++)        {            int nextY = curY + dirYdir;            int nextX = curX + dirXdir;            boardnextYnextX = tempidx;            curY = nextY;            curX = nextX;            idx++;        }        dir = (dir + 1) % 4;    }}int main(){    scanf(&quot;%d %d&quot;, &amp;N, &amp;M);    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            scanf(&quot;%d&quot;, &amp;boardij);        }    }    sharkY = (N+1)/2;    sharkX = (N+1)/2;    while (M--)    {        int d, s;        scanf(&quot;%d %d&quot;, &amp;d, &amp;s);        removeBeads(d, s);        flatten();        moveBeads();        while (1)        {            bool isThereExplosion = explodeBeads();            if (!isThereExplosion)            {                break;            }            moveBeads();        }        changeBeads();        backToBoard();    }    printf(&quot;%d&quot;, beads1 + 2 * beads2 + 3 * beads3);    return 0;}"
237,"💻 C++ 기반스타트 택시https://www.acmicpc.net/problem/19238#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define MAX_N 21#define MAX_M 401using namespace std;int N, M, gas;int boardMAX_NMAX_N;int taxiY, taxiX;pair&lt;int, int&gt; customers_departMAX_M;pair&lt;int, int&gt; customers_arriveMAX_M;int dy4 = {-1, 0, 1, 0}; // 북동남서int dx4 = {0, 1, 0, -1};int cntOfCustomers;int gasToCharge = 0;bool compare(pair&lt;int, int&gt; cust1, pair&lt;int, int&gt; cust2){    if (cust1.first &lt; cust2.first)    {        return true;    }    else if (cust1.first == cust2.first)    {        if (customers_departcust1.second.first &lt; customers_departcust2.second.first)        {            return true;        }        else if (customers_departcust1.second.first == customers_departcust2.second.first)        {            return customers_departcust1.second.second &lt; customers_departcust2.second.second;        }        else        {            return false;        }    }    else    {        return false;    }}int findCustomer(){    queue&lt;pair&lt;int, int&gt; &gt; q;    q.push(make_pair(taxiY, taxiX));    int distMAX_NMAX_N;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            distij = -1;        }    }    disttaxiYtaxiX = 0;    /* 택시와 승객이 같은 위치에 서 있는 경우 */    if (boardtaxiYtaxiX &gt;= 1)    {        return boardtaxiYtaxiX;    }    vector&lt;pair&lt;int, int&gt; &gt; candidates;    while (!q.empty())    {        int curY = q.front().first;        int curX = q.front().second;        q.pop();        for (int i = 0; i &lt; 4; i++)        {            int nextY = curY + dyi;            int nextX = curX + dxi;            if (nextY &lt; 1 || nextY &gt; N || nextX &lt; 1 || nextX &gt; N)            {                continue;            }            if (distnextYnextX &lt; 0 &amp;&amp; boardnextYnextX != -1)            {                if (boardnextYnextX &gt;= 1)                {                    candidates.push_back(make_pair(distcurYcurX + 1, boardnextYnextX));                }                q.push(make_pair(nextY, nextX));                distnextYnextX = distcurYcurX + 1;            }        }    }    if (candidates.empty())    {        return 0;    }    else    {        sort(candidates.begin(), candidates.end(), compare);        gas -= candidates0.first;        if (gas &lt;= 0)        {            return 0;        }        return candidates0.second;    }}bool moveCustomer(int idxOfCustomer){    queue&lt;pair&lt;int, int&gt; &gt; q;    q.push(make_pair(taxiY, taxiX));    int distMAX_NMAX_N;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            distij = -1;        }    }    disttaxiYtaxiX = 0;    while (!q.empty())    {        int curY = q.front().first;        int curX = q.front().second;        q.pop();        if (curY == customers_arriveidxOfCustomer.first &amp;&amp; curX == customers_arriveidxOfCustomer.second)        {            gas -= distcurYcurX;            if (gas &lt; 0)            {                return false;            }            gasToCharge = distcurYcurX * 2;            return true;        }        for (int i = 0; i &lt; 4; i++)        {            int nextY = curY + dyi;            int nextX = curX + dxi;            if (nextY &lt; 1 || nextY &gt; N || nextX &lt; 1 || nextX &gt; N)            {                continue;            }            if (distnextYnextX &lt; 0 &amp;&amp; boardnextYnextX != -1)            {                q.push(make_pair(nextY, nextX));                distnextYnextX = distcurYcurX + 1;            }        }    }    return false;}int main(){    scanf(&quot;%d %d %d&quot;, &amp;N, &amp;M, &amp;gas);    cntOfCustomers = M;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            scanf(&quot;%d&quot;, &amp;boardij);            if (boardij == 1)            {                // 벽을 -1로 대체                boardij = -1;            }        }    }    scanf(&quot;%d %d&quot;, &amp;taxiY, &amp;taxiX);    for (int i = 1; i &lt;= M; i++)    {        int departY, departX, arriveY, arriveX;        scanf(&quot;%d %d %d %d&quot;, &amp;departY, &amp;departX, &amp;arriveY, &amp;arriveX);        boarddepartYdepartX = i;        customers_departi = make_pair(departY, departX);        customers_arrivei = make_pair(arriveY, arriveX);    }    while (cntOfCustomers &gt; 0)    {        int idxOfCustomer = findCustomer();        if (idxOfCustomer == 0)        {            printf(&quot;-1&quot;);            return 0;        }        else        {            taxiY = customers_departidxOfCustomer.first;            taxiX = customers_departidxOfCustomer.second;            bool arrived = moveCustomer(idxOfCustomer);            if (!arrived)            {                printf(&quot;-1&quot;);                return 0;            }            boardtaxiYtaxiX = 0;            cntOfCustomers--;            gas += gasToCharge;            taxiY = customers_arriveidxOfCustomer.first;            taxiX = customers_arriveidxOfCustomer.second;        }    }    printf(&quot;%d&quot;, gas);    return 0;}"
238,"💻 C++ 기반컨베이어 벨트 위의 로봇https://www.acmicpc.net/problem/20055✔️ 벨트를 움직일 때 내구도 배열도 같이 움직여야 됨#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#define MAX_N 101#define MAX_K 201using namespace std;int N, K;int AMAX_N * 2;int beltMAX_N * 2;void moveBelt(){    int belt_copyMAX_N * 2 = {0, };    fill(belt_copy, belt_copy + N * 2 + 1, 0);    int A_copyMAX_N * 2;    for (int i = 1; i &lt;= N * 2; i++)    {        A_copyi = Ai;    }    for (int i = 1; i &lt;= N * 2; i++)    {        if (i == N * 2)        {            belt_copy1 = belti;            A_copy1 = Ai;        }        else        {            belt_copyi + 1 = belti;            A_copyi + 1 = Ai;        }    }    for (int i = 1; i &lt;= N * 2; i++)    {        belti = belt_copyi;        Ai = A_copyi;    }}void takeOutRobot(){    if (beltN &gt; 0)    {        beltN = 0;    }}void moveRobots(){    vector&lt;pair&lt;int, int&gt; &gt; v;    for (int i = 1; i &lt;= N * 2; i++)    {        if (belti &gt; 0)        {            v.push_back(make_pair(belti, i));        }    }    sort(v.begin(), v.end());    for (int i = 0; i &lt; v.size(); i++)    {        int cur_loc = vi.second;        int next_loc = cur_loc == N * 2 ? 1 : cur_loc + 1;        if (beltnext_loc == 0 &amp;&amp; Anext_loc &gt;= 1)        {            beltnext_loc = beltcur_loc;            Anext_loc--;            beltcur_loc = 0;        }    }}void putRobot(int step){    if (belt1 == 0 &amp;&amp; A1 &gt;= 1)    {        belt1 = step;        A1--;    }}bool checkEscape(){    int cnt = 0;    for (int i = 1; i &lt;= N * 2; i++)    {        if (Ai == 0)        {            cnt++;        }    }    if (cnt &gt;= K)    {        return true;    }    else    {        return false;    }}int main(){    scanf(&quot;%d %d&quot;, &amp;N, &amp;K);    for (int i = 1; i &lt;= N * 2; i++)    {        scanf(&quot;%d&quot;, &amp;Ai);    }    int step = 1;    while (1)    {        moveBelt();        takeOutRobot();        moveRobots();        takeOutRobot();        putRobot(step);        bool stop = checkEscape();        if (stop)        {            break;        }        step++;    }    printf(&quot;%d&quot;, step);    return 0;}"
239,"💻 C++ 기반주사위 윷놀이https://www.acmicpc.net/problem/17825✔️ 움직일 말의 조합 구하는 것은 '진법' 사용 -&gt; 감시 문제와 유사 참고✔️ 파란색 동그라미 10, 20, 30에서 경로 갈라짐✔️ 검은색 큰 동그라미 25부터 30, 35, 40에서 경로가 합쳐짐✔️ 반례 참고✔️ 틀리는 이유 참고#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dice10;int red22 = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 0}; // 도착 칸 인덱스: 21int blue19 = {10, 13, 16, 19, 25, 30, 35, 40, 0}; // 도착 칸 인덱스: 8int blue28 = {20, 22, 24, 25, 30, 35, 40, 0}; // 도착 칸 인덱스: 7int blue39 = {30, 28, 27, 26, 25, 30, 35, 40, 0}; // 도착 칸 인덱스: 8bool checkArrival(int loc4, int check4, int piece){    if (checkpiece == 0)    {        if (locpiece &gt;= 21)        {            return true;        }    }    else if (checkpiece == 1)    {        if (locpiece - 5 &gt;= 8)        {            return true;        }    }    else if (checkpiece == 2)    {        if (locpiece - 10 &gt;= 7)        {            return true;        }    }    else if (checkpiece == 3)    {        if (locpiece - 15 &gt;= 8)        {            return true;        }    }    return false;}int main(){    for (int i = 0; i &lt; 10; i++)    {        scanf(&quot;%d&quot;, &amp;dicei);    }    int ans = 0;    for (int temp = 0; temp &lt; (1&lt;&lt;(2*10)); temp++)    {        int loc4;        fill(loc, loc + 4, 0);        int check4; // 0: red 경로, 1: blue1 경로, 2: blue2 경로, 3: blue3 경로        fill(check, check + 4, 0);        int scores4;        fill(scores, scores + 4, 0);        int brute = temp;        int score = 0;        bool stop = false;        for (int i = 0; i &lt; 10; i++)        {            int piece = brute % 4; // 0번 말부터 3번 말까지            brute /= 4;            /* 도착 칸에 있는 말이면 break &amp; stop을 true로 */            bool isArrived = checkArrival(loc, check, piece);            if (isArrived)            {                stop = true;                break;            }            /* 이동 */            locpiece += dicei;            if (checkpiece == 0)            {                if (locpiece == 5)                {                    checkpiece = 1;                }                else if (locpiece == 10)                {                    checkpiece = 2;                }                else if (locpiece == 15)                {                    checkpiece = 3;                }            }            /* 이동한 칸의 점수 저장 */            if (checkArrival(loc, check, piece))            {                // 한번에 도착해버렸으면 점수 저장할 필요 없이 다음 말 이동                scorespiece = 0;                continue;            }            else            {                if (checkpiece == 0)                {                    scorespiece = redlocpiece;                }                else if (checkpiece == 1)                {                    scorespiece = blue1locpiece - 5;                }                else if (checkpiece == 2)                {                    scorespiece = blue2locpiece - 10;                }                else if (checkpiece == 3)                {                    scorespiece = blue3locpiece - 15;                }            }            /* 25에 왔을 때 다 만나므로 별도 처리 */            if (checkpiece == 1 &amp;&amp; locpiece &gt;= 9)            {                // blue1을 blue2 경로로 통일                checkpiece = 2;                locpiece = locpiece - 9 + 13;            }            else if (checkpiece == 3 &amp;&amp; locpiece &gt;= 19)            {                // blue3을 blue2 경로로 통일                checkpiece = 2;                locpiece = locpiece - 19 + 13;            }            /* 40에 왔을 때 다 만나므로 별도 처리 */            if (scorespiece == 40)            {                // blue를 red 경로로 통일                checkpiece = 0;                locpiece = 20;            }            /* 다른 말이 이미 있으면 break &amp; stop을 true로 */            for (int j = 0; j &lt; 4; j++)            {                if (j != piece)                {                    if (scoresj == scorespiece &amp;&amp; checkj == checkpiece)                    {                        stop = true;                        break;                    }                }            }            if (stop)            {                break;            }            /* 점수 추가 */            score += scorespiece;        }        if (!stop)        {            ans = max(ans, score);        }    }    printf(&quot;%d&quot;, ans);    return 0;}// 22, 24, 26, 28, 30 주의!"
240,https://kbstar.incruit.com/hire/viewhire.asp?projectid=118지원 기간: 2022.03.31(목) ~ 2022.04.12(화) 18:00AI역량검사: 2022.04.13(수) 09:00 ~ 2022.04.18(월) 18:00잡다 역검과 동일서류 전형 결과 발표: 2022.04.27(수) 17:01문자 온 시간 기준약 2주 소요코딩테스트 응시안내: 2022.04.27(수)문자 온 시간: 18:30메일 온 시간: 19:18
241,"동물 보호소에 들어온 동물 중 이름이 Lucy, Ella, Pickle, Rogan, Sabrina, Mitty인 동물의 아이디와 이름, 성별 및 중성화 여부를 조회하는 SQL문SELECT ANIMAL_ID, NAME, SEX_UPON_INTAKEFROM ANIMAL_INS IWHERE I.NAME IN ('Lucy', 'Ella', 'Pickle', 'Sabrina', 'Mitty')ORDER BY I.ANIMAL_ID;📍 AS 대신, _띄어쓰기_만으로도 별칭을 지정 가능IN 연산자: WHERE 절에서 특정값 여러개를 선택하는 SQL 연산자-&gt; 괄호 내의 값 중 일치하는 것이 있으면 TRUE 반환동물 보호소에 들어온 동물 이름 중, 이름에 &quot;EL&quot;이 들어가는 개의 아이디와 이름을 조회하는 SQL문 (결과는 이름 순으로 조회해주세요. 단, 이름의 대소문자는 구분하지 않습니다.)SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSWHERE ANIMAL_TYPE = 'Dog' and NAME LIKE '%el%'order by name;LIKE 절: 어떤 조건을 만족시키는 컬럼을 찾을 때 사용-&gt; &#37;와 &#95; 같은 기호 연산자(wild card)와 함께 사용-&gt; &#37;는 ‘모든 문자’라는 의미고, &#95; 는 ‘한 글자’라는 의미-&gt; 조건에는 문자나 숫자를 포함 가능중성화된 동물은 SEX_UPON_INTAKE 컬럼에 'Neutered' 또는 'Spayed'라는 단어가 들어있습니다. 동물의 아이디와 이름, 중성화 여부를 아이디 순으로 조회하는 SQL문을 작성해주세요. 이때 중성화가 되어있다면 'O', 아니라면 'X'라고 표시해주세요.1) 첫 번째 방법SELECT ANIMAL_ID, NAME, IF(SEX_UPON_INTAKE LIKE &quot;Intact%&quot;, 'X', 'O') AS '중성화'FROM ANIMAL_INSORDER BY ANIMAL_ID;2) 두 번째 방법SELECT ANIMAL_ID, NAME,     CASE    WHEN SEX_UPON_INTAKE LIKE 'Intact%' THEN 'X'    ELSE 'O'    END AS '중성화'FROM ANIMAL_INSORDER BY ANIMAL_ID;CASE 문: 데이터를 범주화 하거나 읽기 쉬운 값으로 바꿔줄 때 사용CASE 컬럼  WHEN 조건1 THEN 값1 WHEN 조건2 THEN 값2 ELSE 값3 END 입양을 간 동물 중, 보호 기간이 가장 길었던 동물 두 마리의 아이디와 이름을 조회하는 SQL문SELECT O.ANIMAL_ID, O.NAME, O.DATETIME - I.DATETIMEFROM ANIMAL_INS I JOIN ANIMAL_OUTS OON I.ANIMAL_ID = O.ANIMAL_IDORDER BY O.DATETIME - I.DATETIME DESCLIMIT 2;📍 JOIN은 다른 포스팅에서 정리각 동물의 아이디와 이름, 들어온 날짜를 조회하는 SQL문을 작성 (결과는 아이디 순)들어온 날짜: 시각(시-분-초)을 제외한 날짜(년-월-일)만SELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, '%Y-%m-%d') AS '날짜'FROM ANIMAL_INSORDER BY ANIMAL_ID;DATE_FORMAT(날짜, 형식): 날짜를 지정한 형식으로 출력참고: https://www.w3schools.com/sql/func_mysql_date_format.asp"
242,"동물 보호소에 들어온 동물 중, 이름이 없는 채로 들어온 동물의 ID를 조회하는 SQL문SELECT ANIMAL_IDFROM ANIMAL_INSWHERE NAME IS NULL;SQL에서 컬럼 값이 NULL인지 확인하려면 IS NULL 또는 IS NOT NULL을 사용동물 보호소에 들어온 동물 중, 이름이 있는 동물의 ID를 조회하는 SQL 문 (ID는 오름차순 정렬)SELECT ANIMAL_IDFROM ANIMAL_INSWHERE NAME IS NOT NULLORDER BY ANIMAL_ID;동물의 생물 종, 이름, 성별 및 중성화 여부를 아이디 순으로 조회하는 SQL문 (이름이 없는 동물의 이름은 &quot;No name&quot;으로 표시)SELECT ANIMAL_TYPE, IFNULL(NAME, &quot;No name&quot;), SEX_UPON_INTAKEFROM ANIMAL_INSORDER BY ANIMAL_ID;IFNULL(컬럼명, &quot;대체 값&quot;): 해당 컬럼이 NULL 값일 때 대체 값을 출력하는 함수📍 또는 아래와 같이 대체 가능SELECT ANIMAL_TYPE, IF(IS NULL(NAME), &quot;No name&quot;, NAME) as NAME, SEX_UPON_INTAKENAME 값이 NULL이라면(True) &quot;No name&quot; 반환, 아니라면(False) NAME 값 그대로 반환"
243,지원 기간: 2022.03.11(금) ~ 2022.03.21(월) 17:00서류 전형 결과 발표: 2022.04.19(화) 17:31메일 온 시간 기준약 4주 소요SW역량테스트 응시안내 메일: 2022.04.26(화) 18:34메일 온 시간 기준서류 전형 발표로부터 약 1주 후
244,"동물 보호소에 들어온 동물 중 고양이와 개가 각각 몇 마리인지 조회하는 SQL문 (고양이를 개보다 먼저 조회)SELECT ANIMAL_TYPE, COUNT(ANIMAL_ID)FROM ANIMAL_INSGROUP BY ANIMAL_TYPE--WHERE 절로 대체 가능HAVING ANIMAL_TYPE = &quot;Cat&quot; OR ANIMAL_TYPE = &quot;Dog&quot;ORDER BY ANIMAL_TYPE;HAVING 절: 집계함수를 가지고 조건 비교를 할 때 사용 (cf. WHERE 절에서는 집계함수 사용 불가)보통 GROUP BY절과 함께 사용동물 보호소에 들어온 동물 이름 중 두 번 이상 쓰인 이름과 해당 이름이 쓰인 횟수를 조회하는 SQL문 (이름이 없는 동물은 집계에서 제외, 결과는 이름 순)SELECT NAME, COUNT(NAME) AS cntFROM ANIMAL_INSGROUP BY NAMEHAVING cnt &gt;= 2ORDER BY NAME;AS 절: 필드 명이나 테이블의 이름을 다시 지을 때 사용09:00부터 19:59까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문 (결과는 시간대 순)SELECT HOUR(DATETIME), COUNT(ANIMAL_ID)FROM ANIMAL_OUTSWHERE 9 &lt;= HOUR(DATETIME) AND HOUR(DATETIME) &lt;= 19GROUP BY HOUR(DATETIME)ORDER BY HOUR(DATETIME);날짜 데이터에서 일부만 추출하기YEAR: 연도 추출MONTH: 월 추출DAY: 일 추출 (또는 DAYOFMONTH)HOUR: 시 추출MINUTE: 분 추출SECOND: 초 추출0시부터 23시까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문 (결과는 시간대 순)WITH RECURSIVE TEMP AS (    SELECT 0 AS HOUR    UNION ALL    SELECT HOUR + 1 FROM TEMP WHERE HOUR &lt; 23)SELECT TEMP.HOUR, COUNT(HOUR(ANIMAL_OUTS.DATETIME)) AS COUNTFROM TEMP LEFT JOIN ANIMAL_OUTSON TEMP.HOUR = HOUR(ANIMAL_OUTS.DATETIME)GROUP BY TEMP.HOURORDER BY TEMP.HOUR;WITH RECURSIVE 문: 메모리 상에 가상의 테이블 저장WITH RECURSIVE 테이블명 AS(    SELECT 초기값 AS 컬럼 별칭    UNION ALL    SELECT 컬럼 별칭 계산식 FROM 테이블명 WHERE 제어문)UNION ALL: 중복제거 안하는 합집합UNION: 중복제거를 하는 합집합📍 JOIN은 다른 포스팅에서 정리"
245,https://recruit.kt.com/apply/notifyView?seq=93012지원 기간: 2022.03.29(화) 10:00 ~ 2022.04.11(월) 16:00서류 전형 결과 발표: 2022.04.26(수) 14:04문자 온 시간 기준약 2주 소요
246,지원 기간: 2022.03.28 ~ 2022.04.11 23:59서류전형 결과발표: 2022.04.26(화) 16:21약 2주 소요
247,"1. 최댓값 구하기동물 보호소에 가장 최근에 들어온 동물은 언제 들어왔는지 조회하는 SQL문SELECT MAX(DATETIME)FROM ANIMAL_INS;2. 최솟값 구하기동물 보호소에 가장 먼저 들어온 동물은 언제 들어왔는지 조회하는 SQL문SELECT MIN(DATETIME)FROM ANIMAL_INS;3. 동물 수 구하기동물 보호소에 동물이 몇 마리 들어왔는지 SQL문SELECT COUNT(ANIMAL_ID)FROM ANIMAL_INS;테이블 전체의 행 숫자를 알고 싶다면?COUNT(*)특정 컬럼의 숫자를 알고 싶다면?COUNT(컬럼명)📍 COUNT 집계함수는 NULL 값 제외, 중복값 포함해서 집계한다.4. 중복 제거하기동물 보호소에 들어온 동물의 이름은 몇 개인지 조회하는 SQL문을 작성 (이때 이름이 NULL인 경우는 집계하지 않으며 중복되는 이름은 하나로 침)SELECT COUNT(DISTINCT NAME)FROM ANIMAL_INS;📍 중복값을 제외하고 집계하기 위해서는 DISTINCT 키워드 사용"
248,"1. 모든 레코드 조회하기동물 보호소에 들어온 모든 동물의 정보를 ANIMAL_ID순으로 조회하는 SQL문SELECT * from ANIMAL_INSORDER BY ANIMAL_INS.ANIMAL_ID;2. 역순 정렬하기동물 보호소에 들어온 모든 모든 동물의 이름과 보호 시작일을 ANIMAL_ID 역순으로 조회하는 SQL문SELECT NAME, DATETIME FROM ANIMAL_INSORDER BY ANIMAL_INS.ANIMAL_ID DESC;📍 ASC는 오름차순을 의미하며, default 값이라 굳이 쓰지 않아도 된다.3. 조건 추가하기동물 보호소에 들어온 동물 중 아픈 동물의 아이디와 이름을 조회하는 SQL문 (결과는 아이디 순)SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSWHERE INTAKE_CONDITION = &quot;Sick&quot;ORDER BY ANIMAL_ID;동물 보호소에 들어온 동물 중 젊은 동물의 아이디와 이름을 조회하는 SQL문 (결과는 아이디 순)SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSWHERE INTAKE_CONDITION != &quot;Aged&quot;ORDER BY ANIMAL_ID;4. 여러 기준으로 정렬하기동물 보호소에 들어온 모든 동물의 아이디와 이름, 보호 시작일을 이름 순으로 조회하는 SQL문 (이름이 같은 동물 중에서는 보호를 나중에 시작한 동물을 먼저 보여줘야 함)SELECT ANIMAL_ID, NAME, DATETIMEFROM ANIMAL_INSORDER BY NAME, DATETIME DESC;📍 다중정렬을 할 때, 왼쪽부터 순차적으로 정렬되므로 우선순위가 높은 순서대로 나열 필요5. 상위 n개 레코드동물 보호소에 가장 먼저 들어온 동물의 이름을 조회하는 SQL문SELECT NAMEFROM ANIMAL_INSORDER BY DATETIMELIMIT 1;LIMIT (시작위치), 반환할 결과의 개수📍 시작위치는 인덱스가 0부터 시작"
249,"💻 C++ 기반원판 돌리기https://www.acmicpc.net/problem/17822✔️ 평균 구할 때 double로 캐스팅✔️ 평균 구할 때 숫자의 개수 음수되는지 확인 참고#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;utility&gt;#define MAX 51using namespace std;int N, M;deque&lt;int&gt; boardMAX;void rotateBoard(int idx, int d, int k){    while (k--)    {        if (d == 0)        {            boardidx.push_front(boardidx.back());            boardidx.pop_back();        }        else if (d == 1)        {            boardidx.push_back(boardidx.front());            boardidx.pop_front();        }    }}bool removeSameNumbers(int M){    int dy4 = {-1, 0, 1, 0}; // 북동남서    int dx4 = {0, 1, 0, M - 1};    deque&lt;int&gt; board_copyMAX;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 0; j &lt; M; j++)        {            board_copyi.push_back(boardij);        }    }    bool isThereSameNum = false;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 0; j &lt; M; j++)        {            if (boardij == 0)            {                continue;            }            for (int k = 0; k &lt; 4; k++)            {                int nextBoardIdx = i + dyk;                if (nextBoardIdx &lt; 1 || nextBoardIdx &gt; N)                {                    continue;                }                int nextNum = ((j + dxk) % M);                if (boardnextBoardIdxnextNum == boardij)                {                    isThereSameNum = true;                    board_copyij = 0;                    board_copynextBoardIdxnextNum = 0;                }            }        }    }    for (int i = 1; i &lt;= N; i++)    {        for (int j = 0; j &lt; M; j++)        {            boardij = board_copyij;        }    }    return isThereSameNum;}int getTotal(){    int total = 0;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 0; j &lt; M; j++)        {            total += boardij;        }    }    return total;}int getCnt(){    int cnt = 0;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 0; j &lt; M; j++)        {            if (boardij != 0)            {                cnt++;            }        }    }    return cnt;}int main(){    int T;    scanf(&quot;%d %d %d&quot;, &amp;N, &amp;M, &amp;T);    for (int i = 1; i &lt;= N; i++)    {        for (int j = 0; j &lt; M; j++)        {            int num;            scanf(&quot;%d&quot;, &amp;num);            boardi.push_back(num);        }    }    while (T--)    {        int x, d, k;        scanf(&quot;%d %d %d&quot;, &amp;x, &amp;d, &amp;k);        for (int i = 1; i &lt;= N; i++)        {            if (i % x == 0)            {                rotateBoard(i, d, k);            }        }        bool isThereSameNum = removeSameNumbers(M);        if (!isThereSameNum)        {            double avg = double(getTotal()) / double(getCnt());            for (int i = 1; i &lt;= N; i++)            {                for (int j = 0; j &lt; M; j++)                {                    if (boardij == 0)                    {                        continue;                    }                    if (boardij &gt; avg)                    {                        boardij--;                    }                    else if (boardij &lt; avg)                    {                        boardij++;                    }                }            }        }    }    printf(&quot;%d&quot;, getTotal());    return 0;}"
250,"💻 C++ 기반상어 중학교https://www.acmicpc.net/problem/21609✔️ 무지개 블록은 다른 블록 그룹을 찾을 때에도 중복으로 사용될 수 있음 -&gt; 한 번 그룹을 찾았으면 무지개 블록만 visited를 false로 바꿔야 함 참고📍 이렇듯 BFS를 사용해서 그룹을 찾을 때, 그룹끼리 겹쳐도 되는지 확인하자#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define MAX_N 21using namespace std;struct BLOCK_GROUP{    int sz;    int rainbow;    int standardY;    int standardX;    vector&lt;pair&lt;int, int&gt; &gt; visitedBlocks;};int N, M;int boardMAX_NMAX_N; // -2: 빈칸, -1: 검은색, 0: 무지개int dy4 = {-1, 0, 1, 0}; // 북동남서int dx4 = {0, 1, 0, -1};int score = 0;bool compare1(pair&lt;int, int&gt; block1, pair&lt;int, int&gt; block2){    if (block1.first &lt; block2.first)    {        return true;    }    else if (block1.first == block2.first)    {        return block1.second &lt; block2.second;    }    else    {        return false;    }}bool compare2(BLOCK_GROUP block1, BLOCK_GROUP block2){    if (block1.sz &gt; block2.sz)    {        return true;    }    else if (block1.sz == block2.sz)    {        if (block1.rainbow &gt; block2.rainbow)        {            return true;        }        else if (block1.rainbow == block2.rainbow)        {            if (block1.standardY &gt; block2.standardY)            {                return true;            }            else if (block1.standardY == block2.standardY)            {                return block1.standardX &gt; block2.standardX;            }            else            {                return false;            }        }        else        {            return false;        }    }    else    {        return false;    }}BLOCK_GROUP findBiggestGroup(){    vector&lt;BLOCK_GROUP&gt; v;    bool visitedMAX_NMAX_N = {false, };    vector&lt;pair&lt;int, int&gt; &gt; rainbows;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            if (boardij == 0)            {                rainbows.push_back(make_pair(i, j));            }        }    }    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            if (!visitedij &amp;&amp; boardij &gt; 0)            {                BLOCK_GROUP block_group;                queue&lt;pair&lt;int, int&gt; &gt; q;                q.push(make_pair(i, j));                visitedij = true;                int sz = 0;                int rainbow = 0;                bool isThereNormalBlock = boardij &gt; 0 ? true : false;                int normal = boardij;                vector&lt;pair&lt;int, int&gt; &gt; visitedBlocks;                vector&lt;pair&lt;int, int&gt; &gt; normalBlocks;                while (!q.empty())                {                    int curY = q.front().first;                    int curX = q.front().second;                    q.pop();                    sz++;                    visitedBlocks.push_back(make_pair(curY, curX));                    if (boardcurYcurX &gt; 0)                    {                        normalBlocks.push_back(make_pair(curY, curX));                    }                    for (int k = 0; k &lt; 4; k++)                    {                        int nextY = curY + dyk;                        int nextX = curX + dxk;                        if (nextY &lt; 1 || nextY &gt; N || nextX &lt; 1 || nextX &gt; N)                        {                            continue;                        }                        if (!visitednextYnextX &amp;&amp; boardnextYnextX &gt;= 0)                        {                            if (boardnextYnextX == 0)                            {                                rainbow++;                                q.push(make_pair(nextY, nextX));                                visitednextYnextX = true;                            }                            else if (boardnextYnextX &gt; 0)                            {                                if (isThereNormalBlock)                                {                                    if (boardnextYnextX != normal)                                    {                                        continue;                                    }                                    else                                    {                                        q.push(make_pair(nextY, nextX));                                        visitednextYnextX = true;                                    }                                }                                else                                {                                    isThereNormalBlock = true;                                    normal = boardnextYnextX;                                    q.push(make_pair(nextY, nextX));                                    visitednextYnextX = true;                                }                            }                        }                    }                }                if (!isThereNormalBlock)                {                    continue;                }                if (sz &lt; 2)                {                    continue;                }                sort(normalBlocks.begin(), normalBlocks.end(), compare1);                block_group.sz = sz;                block_group.rainbow = rainbow;                block_group.standardY = normalBlocks0.first;                block_group.standardX = normalBlocks0.second;                block_group.visitedBlocks = visitedBlocks;                v.push_back(block_group);                for (int k = 0; k &lt; rainbows.size(); k++)                {                    // 그 다음 블록 그룹을 찾을 때 무지개 블록은 또 사용될 수 있음                    visitedrainbowsk.firstrainbowsk.second = false;                }            }        }    }    sort(v.begin(), v.end(), compare2);    if (v.empty())    {        BLOCK_GROUP block_group;        block_group.sz = 0;        return block_group;    }    return v0;}void removeBlocks(BLOCK_GROUP biggest){    for (int i = 0; i &lt; biggest.sz; i++)    {        boardbiggest.visitedBlocksi.firstbiggest.visitedBlocksi.second = -2;    }    score += (biggest.sz * biggest.sz);}void gravity(){    int tempN + 1;    for (int j = 1; j &lt;= N; j++)    {        int empty = N;        for (int i = N; i &gt; 0; i--)        {            tempi = boardij;            if (boardij == -1)            {                if (i == 1)                {                    break;                }                else                {                    empty = i - 1;                }            }            else if (boardij &gt;= 0)            {                tempempty = boardij;                if (empty != i)                {                    tempi = -2;                }                empty--;            }        }        for (int i = N; i &gt; 0; i--)        {            boardij = tempi;        }    }}void rotateBoard(){    int board_copyMAX_NMAX_N;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            board_copyN - j + 1i = boardij;        }    }    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            boardij = board_copyij;        }    }}int main(){    scanf(&quot;%d %d&quot;, &amp;N, &amp;M);    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            scanf(&quot;%d&quot;, &amp;boardij);        }    }    while (1)     {        BLOCK_GROUP biggest = findBiggestGroup();        if (biggest.sz == 0)        {            break;        }        removeBlocks(biggest);        gravity();        rotateBoard();        gravity();    }    printf(&quot;%d&quot;, score);    return 0;}"
251,"💻 C++ 기반상어 초등학교https://www.acmicpc.net/problem/21608✔️ 1번 과정에서 좋아하는 학생이 인접한 칸에 아무도 없을 때, check 배열 전체가 1이 될 수 있으므로 temp 배열 초기화를 -1로 할 것✔️ 2번 과정에서 비어있는 칸이 아예 없을 때, check 배열 전체가 2이 될 수 있으므로 temp 배열 초기화를 -1로 할 것#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 21#define MAX_STUDENT 401using namespace std;int N;int classroomMAX_NMAX_N;int studentsMAX_STUDENT4;int dy4 = {0, -1, 0, 1}; //동북서남int dx4 = {1, 0, -1, 0};int checkMAX_NMAX_N;int scores5 = {0, 1, 10, 100, 1000};bool first(int student_idx){    int tempMAX_NMAX_N;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            tempij = -1;        }    }    int maximum = 0;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            if (classroomij == 0)            {                int cnt = 0;                for (int k = 0; k &lt; 4; k++)                {                    int nextY = i + dyk;                    int nextX = j + dxk;                    if (nextY &lt; 1 || nextY &gt; N || nextX &lt; 1 || nextX &gt; N)                    {                        continue;                    }                    for (int l = 0; l &lt; 4; l++)                    {                        if (classroomnextYnextX == studentsstudent_idxl)                        {                            cnt++;                            break;                        }                    }                }                tempij = cnt;                maximum = max(maximum, cnt);            }        }    }    int cnt = 0;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            if (tempij == maximum)            {                checkij = 1;                cnt++;            }        }    }    if (cnt &gt; 1)    {        return true;    }    else    {        for (int i = 1; i &lt;= N; i++)        {            for (int j = 1; j &lt;= N; j++)            {                if (checkij == 1)                {                    classroomij = student_idx;                }            }        }        return false;    }}bool second(int student_idx){    int tempMAX_NMAX_N;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            tempij = -1;        }    }    int maximum = 0;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            if (checkij == 1)            {                int cnt = 0;                for (int k = 0; k &lt; 4; k++)                {                    int nextY = i + dyk;                    int nextX = j + dxk;                    if (nextY &lt; 1 || nextY &gt; N || nextX &lt; 1 || nextX &gt; N)                    {                        continue;                    }                    if (classroomnextYnextX == 0)                    {                        cnt++;                    }                }                tempij = cnt;                maximum = max(maximum, cnt);            }        }    }    int cnt = 0;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            if (tempij == maximum)            {                checkij = 2;                cnt++;            }        }    }    if (cnt &gt; 1)    {        return true;    }    else    {        for (int i = 1; i &lt;= N; i++)        {            for (int j = 1; j &lt;= N; j++)            {                if (checkij == 2)                {                    classroomij = student_idx;                }            }        }        return false;    }}void third(int student_idx){    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            if (checkij == 2)            {                classroomij = student_idx;                return;            }        }    }}int getScore(){    int total = 0;    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= N; j++)        {            int student_idx = classroomij;            int cnt = 0;            for (int k = 0; k &lt; 4; k++)            {                int nextY = i + dyk;                int nextX = j + dxk;                if (nextY &lt; 1 || nextY &gt; N || nextX &lt; 1 || nextX &gt; N)                {                    continue;                }                for (int l = 0; l &lt; 4; l++)                {                    if (classroomnextYnextX == studentsstudent_idxl)                    {                        cnt++;                        break;                    }                }            }            total += scorescnt;        }    }    return total;}int main(){    scanf(&quot;%d&quot;, &amp;N);    int cntOfStudent = N * N;    for (int i = 1; i &lt;= cntOfStudent; i++)    {        int idx;        scanf(&quot;%d&quot;, &amp;idx);        for (int j = 0; j &lt; 4; j++)        {            scanf(&quot;%d&quot;, &amp;studentsidxj);        }        for (int i = 1; i &lt;= N; i++)        {            for (int j = 1; j&lt;= N; j++)            {                checkij = 0;            }        }        bool goToSecond = first(idx);        if (goToSecond)        {            bool goToThird = second(idx);            if (goToThird)            {                third(idx);            }        }    }    int ans = getScore();    printf(&quot;%d&quot;, ans);    return 0;}"
252,"💻 C++ 기반마법사 상어와 파이어스톰https://www.acmicpc.net/problem/20058✔️ BFS 돌릴 때 시작점의 얼음 양이 0인 경우에는 BFS 돌리면 안됨✔️ 얼음 양을 줄일 때 음수가 되지 않도록 주의#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#define MAX 65using namespace std;int N, Q;int AMAXMAX;int A_copyMAXMAX;int length;int dy4 = {0, -1, 0, 1}; //동북서남int dx4 = {1, 0, -1, 0};bool visitedMAXMAX;void rotateBoard(int startY, int startX, int small_length){    int tempsmall_lengthsmall_length;    for (int i = 0; i &lt; small_length; i++)    {        for (int j = 0; j &lt; small_length; j++)        {            tempij = AstartY + small_length - 1 - jstartX + i;        }    }    for (int i = 0; i &lt; small_length; i++)    {        for (int j = 0; j &lt; small_length; j++)        {            AstartY + istartX + j = tempij;        }    }}void firestorm(int level){    int small_length = 1&lt;&lt;level;    for (int i = 1; i &lt;= length; i += small_length)    {        for (int j = 1; j &lt;= length; j += small_length)        {            rotateBoard(i, j, small_length);        }    }    for (int i = 1; i &lt;= length; i++)    {        for (int j = 1; j &lt;= length; j++)        {            A_copyij = Aij;            int cnt = 0;            for (int k = 0; k &lt; 4; k++)            {                int nextY = i + dyk;                int nextX = j + dxk;                if (nextY &lt; 1 || nextY &gt; length || nextX &lt; 1 || nextX &gt; length)                {                    continue;                }                if (AnextYnextX != 0)                {                    cnt++;                }            }            if (cnt &lt; 3)            {                if (Aij - 1 &gt;= 0)                {                    A_copyij = Aij - 1;                }                else                {                    A_copyij = 0;                }            }        }    }    for (int i = 1; i &lt;= length; i++)    {        for (int j = 1; j &lt;= length; j++)        {            Aij = A_copyij;        }    }}int bfs(int startY, int startX){    queue&lt;pair&lt;int, int&gt; &gt; q;    q.push(make_pair(startY, startX));    visitedstartYstartX = true;    int cnt = 0;    while (!q.empty())    {        int curY = q.front().first;        int curX = q.front().second;        q.pop();        cnt++;        for (int i = 0; i &lt; 4; i++)        {            int nextY = curY + dyi;            int nextX = curX + dxi;            if (nextY &lt; 1 || nextY &gt; length || nextX &lt; 1 || nextX &gt; length)            {                continue;            }            if (!visitednextYnextX &amp;&amp; AnextYnextX != 0)            {                q.push(make_pair(nextY, nextX));                visitednextYnextX = true;            }        }    }    return cnt;}int main(){    scanf(&quot;%d %d&quot;, &amp;N, &amp;Q);    length = 1&lt;&lt;N;    for (int i = 1; i &lt;= length; i++)    {        for (int j = 1; j &lt;= length; j++)        {            scanf(&quot;%d&quot;, &amp;Aij);        }    }    for (int i = 0; i &lt; Q; i++)    {        int level;        scanf(&quot;%d&quot;, &amp;level);        firestorm(level);    }    int total = 0;    for (int i = 1; i &lt;= length; i++)    {        for (int j = 1; j &lt;= length; j++)        {            total += Aij;        }    }    for (int i = 1; i &lt;= length; i++)    {        for (int j = 1; j &lt;= length; j++)        {            visitedij = false;        }    }    int maximum = 0;    for (int i = 1; i &lt;= length; i++)    {        for (int j = 1; j &lt;= length; j++)        {            if (!visitedij &amp;&amp; Aij != 0)            {                int result = bfs(i, j);                if (result != 1)                {                    maximum = max(maximum, result);                }            }        }    }    printf(&quot;%d\n&quot;, total);    printf(&quot;%d\n&quot;, maximum);    return 0;}"
253,"7.1 앙상블 학습목표 : 여러 분류기를 하나의 메타 분류기로 연결 -&gt; 개별 분류기보다 더 좋은 일반화 성능을 달성하는 것☑️방법☑️1) 과반수 투표 : 분류기의 과반수가 예측한 클래스 레이블을 선택하는 단순한 방법2) 다수결 투표 : 가장 많은 투표(최빈값)를 받은 클래스 레이블을 선택3) 랜덤 포레스트 : 서로 다른 결정 트리를 연결📍과반수 투표📍1) 훈련 데이터셋을 사용하여 m개의 다른 분류기(예 : 결정 트리, 서포트 벡터 머신, 로지스틱 회귀 분류기)를 훈련시킴 또는, 같은 분류 알고리즘을 사용하고 훈련 데이터셋의 부분 집합을 달리하여 학습2) 개별 분류기의 예측 레이블을 모두 모아 가장 맣은 표를 받은 레이블 y를 선택📍앙상블 방법이 개별 분류기보다 성능이 뛰어난 이유📍ex) 에러율이 0.25인 분류기 11개로 구성된 앙상블의 에러율은 0.034로 훨씬 낮게 됨이상적인 앙상블 분류기와 다양한 범위의 분류기를 가진 경우 비교☑️파이썬으로 확률 질량 함수 구현☑️from scipy.special import combimport mathdef ensemble_error(n_classifier, error):    k_start = int(math.ceil(n_classifier / 2.))    probs = comb(n_classifier, k) * error**k * (1-error)**(n_classifier - k)             for k in range(k_start, n_classifier + 1)    return sum(probs)print(ensemble_error(n_classifier=11, error=0.25))☑️분류기 에러가 0.0에서 1.0까지 걸쳐 있을 때 앙상블의 에러율을 계산, 앙상블과 개별 분류기 에러 사이의 관계를 선 그래프로 시각화☑️import numpy as nperror_range = np.arange(0.0, 1.01, 0.01)ens_errors = ensemble_error(n_classifier=11, error=error)              for error in error_rangeimport matplotlib.pyplot as pltplt.plot(error_range,          ens_errors,          label='Ensemble error',          linewidth=2)plt.plot(error_range,          error_range,          linestyle='--',         label='Base error',         linewidth=2)plt.xlabel('Base error')plt.ylabel('Base/Ensemble error')plt.legend(loc='upper left')plt.grid(alpha=0.5)plt.show()➡️ 앙상블의 에러 확률은 개별 분류기보다 항상 좋음7.2 다수결 투표를 사용한 분류 앙상블7.2.1 간단한 다수결 투표 분류기 구현📍목표📍-&gt; 특정 데이터셋에서 개별 분류기의 약점을 보완하는 강력한 메타 분류기를 구축☑️가중치가 적용된 다수결 투표를 파이썬 코드로 구현☑️argmax &amp; bicount 함수 : 가중치가 적용된 다수결 투표 구현 가능하게import numpy as npnp.argmax(np.bincount(0, 0, 1,                       weights=0.2, 0.2, 0.6))&lt;br&gt;☑️클래스 확률 기반으로 가중치가 적용된 다수결 투표 구현☑️- average 함수 : weights 매개변수가 주어지면 weights 배열의 비율을 더할 원소에 곱해 가중 평균을 구함``` pythonex = np.array(0.9, 0.1,               0.8, 0.2,               0.4, 0.6)p = np.average(ex,               axis=0,               weights=0.2, 0.2, 0.6)np.argmax(p) # 0☑️MajorityVoteClassifer 파이썬 클래스 구현☑️get_params 메서드 : 분류기의 매개변수를 반환set_params 메서드 : 분류기의 매개변수를 설정score 메서드 : 예측 정확도를 계산from sklearn.base import BaseEstimatorfrom sklearn.base import ClassifierMixinfrom sklearn.preprocessing import LabelEncoderfrom sklearn.base import clonefrom sklearn.pipeline import _name_estimatorsimport numpy as npimport operatorclass MajorityVoteClassifier(BaseEstimator,                              ClassifierMixin):    &quot;&quot;&quot;다수결 투표 앙상블 분류기    매개변수    ----------    classifiers : 배열 타입, 크기 = n_classifiers        앙상블에 사용할 분류기    vote : str, {'classlabel', 'probability'}        기본값: 'classlabel'        'classlabel'이면 예측은 다수인 클래스 레이블의 인덱스가 됩니다        'probability'면 확률 합이 가장 큰 인덱스로        클래스 레이블을 예측합니다(보정된 분류기에 추천합니다)    weights : 배열 타입, 크기 = n_classifiers        선택 사항, 기본값: None        'int' 또는 'float' 값의 리스트가 주어지면 분류기가 이 중요도로 가중치됩니다        'weights=None'이면 동일하게 취급합니다    &quot;&quot;&quot;    def __init__(self, classifiers, vote='classlabel', weights=None):        self.classifiers = classifiers        self.named_classifiers = {key: value for key, value                                  in _name_estimators(classifiers)}        self.vote = vote        self.weights = weights    def fit(self, X, y):        &quot;&quot;&quot;분류기를 학습합니다        매개변수        ----------        X : {배열 타입, 희소 행렬},            크기 = n_samples, n_features            훈련 샘플 행렬        y : 배열 타입, 크기 = n_samples            타깃 클래스 레이블 벡터        반환값        -------        self : 객체        &quot;&quot;&quot;        if self.vote not in ('probability', 'classlabel'):            raise ValueError(&quot;vote는 'probability' 또는 'classlabel'이어야 합니다&quot;                             &quot;; (vote=%r)이 입력되었습니다.&quot;                             % self.vote)        if self.weights and len(self.weights) != len(self.classifiers):            raise ValueError('분류기와 가중치 개수는 같아야 합니다'                             '; 가중치 %d 개, 분류기 %d 개'                             % (len(self.weights), len(self.classifiers)))        # self.predict 메서드에서 np.argmax를 호출할 때        # 클래스 레이블이 0부터 시작되어야 하므로 LabelEncoder를 사용합니다        self.lablenc_ = LabelEncoder()        self.lablenc_.fit(y)        self.classes_ = self.lablenc_.classes_        self.classifiers_ =         for clf in self.classifiers:            fitted_clf = clone(clf).fit(X, self.lablenc_.transform(y))            self.classifiers_.append(fitted_clf)        return self☑️predict 메서드 만들기☑️predict_proba 메서드 : 평균 확률을 반환_name_estimators 함수 : 앙상블에 있는 각 분류기의 매개변수에 접근하기 위함def predict(self, X):      &quot;&quot;&quot;X에 대한 클래스 레이블을 예측합니다      매개변수      ----------      X : {배열 타입, 희소 행렬},          크기 = n_samples, n_features          샘플 데이터 행렬      반환값      ----------      maj_vote : 배열 타입, 크기 = n_samples          예측된 클래스 레이블      &quot;&quot;&quot;      if self.vote == 'probability':          maj_vote = np.argmax(self.predict_proba(X), axis=1)      else:  # 'classlabel' 투표          # clf.predict 메서드를 사용하여 결과를 모읍니다          predictions = np.asarray(clf.predict(X)                                    for clf in self.classifiers_).T          maj_vote = np.apply_along_axis(                                    lambda x:                                    np.argmax(np.bincount(x,                                              weights=self.weights)),                                    axis=1,                                    arr=predictions)      maj_vote = self.lablenc_.inverse_transform(maj_vote)      return maj_vote  def predict_proba(self, X):      &quot;&quot;&quot;X에 대한 클래스 확률을 예측합니다      매개변수      ----------      X : {배열 타입, 희소 행렬},          크기 = n_samples, n_features          n_samples는 샘플의 개수고 n_features는 특성의 개수인          샘플 데이터 행렬      반환값      ----------      avg_proba : 배열 타입,          크기 = n_samples, n_classes          샘플마다 가중치가 적용된 클래스의 평균 확률      &quot;&quot;&quot;      probas = np.asarray(clf.predict_proba(X)                           for clf in self.classifiers_)      avg_proba = np.average(probas, axis=0, weights=self.weights)      return avg_proba  def get_params(self, deep=True):      &quot;&quot;&quot;GridSearch를 위해 분류기의 매개변수 이름을 반환합니다&quot;&quot;&quot;      if not deep:          return super(MajorityVoteClassifier, self).get_params(deep=False)      else:          out = self.named_classifiers.copy()          for name, step in self.named_classifiers.items():              for key, value in step.get_params(deep=True).items():                  out'%s__%s' % (name, key) = value          return out7.2.2 다수결 투표 방식을 사용하여 예측 만들기☑️테스트를 위한 데이터셋 준비☑️from sklearn import datasetsfrom sklearn.preprocessing import StandardScalerfrom sklearn.preprocessing import LabelEncoderfrom sklearn.model_selection import train_test_splitiris = datasets.load_iris()X, y = iris.data50:, 1, 2, iris.target50:le = LabelEncoder()y = le.fit_transform(y)☑️붓꽃 데이터 샘플을 50:50으로 훈련 데이터와 테스트 데이터로 나누기☑️X_train, X_test, y_train, y_test =\       train_test_split(X, y,                         test_size=0.5,                         random_state=1,                        stratify=y)☑️10-겹 교차 검증으로 성능 평가 후, 서로 다른 세 개의 분류기를 훈련☑️로지스틱 회귀 분류기결정 트리 분류기k-최근접 이웃 분류기import numpy as npfrom sklearn.linear_model import LogisticRegressionfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.neighbors import KNeighborsClassifier from sklearn.pipeline import Pipelinefrom sklearn.model_selection import cross_val_scoreclf1 = LogisticRegression(penalty='l2',                           C=0.001,                          random_state=1)clf2 = DecisionTreeClassifier(max_depth=1,                              criterion='entropy',                              random_state=0)clf3 = KNeighborsClassifier(n_neighbors=1,                            p=2,                            metric='minkowski')pipe1 = Pipeline('sc', StandardScaler(),                  'clf', clf1)pipe3 = Pipeline('sc', StandardScaler(),                  'clf', clf3)clf_labels = 'Logistic regression', 'Decision tree', 'KNN'print('10-겹 교차 검증:\n')for clf, label in zip(pipe1, clf2, pipe3, clf_labels):    scores = cross_val_score(estimator=clf,                             X=X_train,                             y=y_train,                             cv=10,                             scoring='roc_auc')    print(&quot;ROC AUC: %0.2f (+/- %0.2f) %s&quot;          % (scores.mean(), scores.std(), label))!(https://velog.velcdn.com/images/rosesua318/post/f186b836-3c03-423d-99f5-6d9f61df2097/image.png)&lt;br&gt;☑️다수결 투표 앙상블을 위해 MajorityVoteClassifier 클래스로 각 분류기를 하나로 연결☑️``` pythonmv_clf = MajorityVoteClassifier(classifiers=pipe1, clf2, pipe3)clf_labels += 'Majority voting'all_clf = pipe1, clf2, pipe3, mv_clffor clf, label in zip(all_clf, clf_labels):    scores = cross_val_score(estimator=clf,                             X=X_train,                             y=y_train,                             cv=10,                             scoring='roc_auc')    print(&quot;ROC AUC: %0.2f (+/- %0.2f) %s&quot;          % (scores.mean(), scores.std(), label))➡️ MajorityVoteClassifier의 성능이 개별 분류기보다 뛰어남7.2.3 앙상블 분류기의 평가와 튜닝테스트 데이터셋의 목적 : 편향되지 않은 분류기의 일반화 성능을 추정하기 위함(테스트 데이터셋은 모델 선택에 사용하지 않음)☑️테스트 데이터셋에 대한 RCO 곡선 그리기☑️from sklearn.metrics import roc_curvefrom sklearn.metrics import auccolors = 'black', 'orange', 'blue', 'green'linestyles = ':', '--', '-.', '-'for clf, label, clr, ls \        in zip(all_clf,               clf_labels, colors, linestyles):    # 양성 클래스의 레이블이 1이라고 가정합니다    y_pred = clf.fit(X_train,                     y_train).predict_proba(X_test):, 1    fpr, tpr, thresholds = roc_curve(y_true=y_test,                                     y_score=y_pred)    roc_auc = auc(x=fpr, y=tpr)    plt.plot(fpr, tpr,             color=clr,             linestyle=ls,             label='%s (auc = %0.2f)' % (label, roc_auc))plt.legend(loc='lower right')plt.plot(0, 1, 0, 1,         linestyle='--',         color='gray',         linewidth=2)plt.xlim(-0.1, 1.1)plt.ylim(-0.1, 1.1)plt.grid(alpha=0.5)plt.xlabel('False positive rate (FPR)')plt.ylabel('True positive rate (TPR)')plt.show()➡️ 앙상블 분류기는 테스트 데이터셋에서도 좋은 성능을 냄(ROC AUC=0.95)☑️앙상블의 결정 경계 확인☑️sc = StandardScaler()X_train_std = sc.fit_transform(X_train)from itertools import productall_clf = pipe1, clf2, pipe3, mv_clfx_min = X_train_std:, 0.min() - 1x_max = X_train_std:, 0.max() + 1y_min = X_train_std:, 1.min() - 1y_max = X_train_std:, 1.max() + 1xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),                     np.arange(y_min, y_max, 0.1))f, axarr = plt.subplots(nrows=2, ncols=2,                        sharex='col',                        sharey='row',                        figsize=(7, 5))for idx, clf, tt in zip(product(0, 1, 0, 1),                        all_clf, clf_labels):    clf.fit(X_train_std, y_train)    Z = clf.predict(np.c_xx.ravel(), yy.ravel())    Z = Z.reshape(xx.shape)    axarridx0, idx1.contourf(xx, yy, Z, alpha=0.3)    axarridx0, idx1.scatter(X_train_stdy_train == 0, 0,                                  X_train_stdy_train == 0, 1,                                  c='blue',                                  marker='^',                                  s=50)    axarridx0, idx1.scatter(X_train_stdy_train == 1, 0,                                  X_train_stdy_train == 1, 1,                                  c='green',                                  marker='o',                                  s=50)    axarridx0, idx1.set_title(tt)plt.text(-3.5, -5.,         s='Sepal width standardized',         ha='center', va='center', fontsize=12)plt.text(-12.5, 4.5,         s='Petal length standardized',         ha='center', va='center',         fontsize=12, rotation=90)plt.show()➡️앙상블 분류기의 결정 경계는 개별 분류기의 결정 경계를 혼합한 것처럼 보임☑️GridSearchCV 객체 안에 있는 매개변수 접근☑️mv_clf.get_params()☑️그리드 서치로 로지스틱 회귀 분류기의 규제 매개변수 C와 결정 트리의 깊이를 튜닝☑️from sklearn.model_selection import GridSearchCVparams = {'decisiontreeclassifier__max_depth': 1, 2,          'pipeline-1__clf__C': 0.001, 0.1, 100.0}grid = GridSearchCV(estimator=mv_clf,                    param_grid=params,                    cv=10,                    scoring='roc_auc')grid.fit(X_train, y_train)☑️그리드 서치 실행이 완료되면 평균 ROC AUC 점수 출력☑️for r, _ in enumerate(grid.cv_results_'mean_test_score'):    print(&quot;%0.3f +/- %0.2f %r&quot;          % (grid.cv_results_'mean_test_score'r,              grid.cv_results_'std_test_score'r / 2.0,              grid.cv_results_'params'r))print('최적의 매개변수: %s' % grid.best_params_)print('정확도: %.2f' % grid.best_score_)➡️규제 매개변수가 가장 낮을 때(C=0.001) 최상의 교차 검증 결과를 얻음➡️트리 깊이는 성능에 영향을 주지 않음7.3 배깅: 부트스트랩 샘플링을 통한 분류 앙상블배깅 : 앙상블에 있는 개별 분류기를 동일한 훈련 데이터셋으로 학습하는 것이 아니라, 원본 훈련 데이터셋에서 부트스트랩 샘플(중복을 허용한 랜덤 샘플)을 뽑아서 사용7.3.1 배깅 알고리즘의 작동 방식1) 1에서 7까지 인덱스가 부여된 일곱 개의 훈련 샘플이 있음2) 배깅 단계 마다 중복을 허용하여 랜덤하게 샘플링됨3) 각각의 부트스트랩 샘플을 사용하여 분류기를 학습함 (분류기는 일반적으로 가지치기하지 않는 결정트리를 사용)4) 개별 분류기가 부트스트랩 샘플에 학습되고 나면 다수결 투표를 사용하여 예측을 모음7.3.2 배깅으로 Wine 데이터셋의 샘플 분류☑️Wine 데이터셋 가져오기☑️import pandas as pddf_wine = pd.read_csv('https://archive.ics.uci.edu/ml/'                      'machine-learning-databases/wine/wine.data',                      header=None)df_wine.columns = 'Class label', 'Alcohol', 'Malic acid', 'Ash',                   'Alcalinity of ash', 'Magnesium', 'Total phenols',                   'Flavanoids', 'Nonflavanoid phenols', 'Proanthocyanins',                   'Color intensity', 'Hue', 'OD280/OD315 of diluted wines',                   'Proline'# 클래스 1 제외df_wine = df_winedf_wine'Class label' != 1y = df_wine'Class label'.valuesX = df_wine'Alcohol', 'OD280/OD315 of diluted wines'.values☑️클래스 레이블을 이진 형태로 인코딩하고 80%는 훈련 데이터셋으로, 20%는 테스트 데이터셋으로 분리☑️from sklearn.preprocessing import LabelEncoderfrom sklearn.model_selection import train_test_splitle = LabelEncoder()y = le.fit_transform(y)X_train, X_test, y_train, y_test =\            train_test_split(X, y,                              test_size=0.2,                              random_state=1,                             stratify=y)☑️500개의 결정 트리로 구성된 BagginClassifier 앙상블 만들기☑️from sklearn.ensemble import BaggingClassifierfrom sklearn.tree import DecisionTreeClassifiertree = DecisionTreeClassifier(criterion='entropy',                               max_depth=None,                              random_state=1)bag = BaggingClassifier(base_estimator=tree,                        n_estimators=500,                         max_samples=1.0,                         max_features=1.0,                         bootstrap=True,                         bootstrap_features=False,                         n_jobs=1,                         random_state=1)☑️배깅 분류기와 가지치기가 없는 단일 결정 트리에서 훈련 데이터셋과 테스트 데이터셋의 예측 정확도를 계산하여 성능 비교☑️from sklearn.metrics import accuracy_scoretree = tree.fit(X_train, y_train)y_train_pred = tree.predict(X_train)y_test_pred = tree.predict(X_test)tree_train = accuracy_score(y_train, y_train_pred)tree_test = accuracy_score(y_test, y_test_pred)print('결정 트리의 훈련 정확도/테스트 정확도 %.3f/%.3f'      % (tree_train, tree_test))bag = bag.fit(X_train, y_train)y_train_pred = bag.predict(X_train)y_test_pred = bag.predict(X_test)bag_train = accuracy_score(y_train, y_train_pred) bag_test = accuracy_score(y_test, y_test_pred) print('배깅의 훈련 정확도/테스트 정확도 %.3f/%.3f'      % (bag_train, bag_test))➡️ 훈련 정확도가 훈련 데이터셋에서 비슷하지만 테스트 데이터셋의 정확도로 미루어 보아 배깅 분류기가 일반화 성능이 더 나음➡️ 결정 트리 테스트 정확도는 모델의 분산이 높은 과대적합을 나타냄☑️결정 트리와 배깅 분류기의 결정 경계 비교☑️import numpy as npimport matplotlib.pyplot as pltx_min = X_train:, 0.min() - 1x_max = X_train:, 0.max() + 1y_min = X_train:, 1.min() - 1y_max = X_train:, 1.max() + 1xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),                     np.arange(y_min, y_max, 0.1))f, axarr = plt.subplots(nrows=1, ncols=2,                         sharex='col',                         sharey='row',                         figsize=(8, 3))for idx, clf, tt in zip(0, 1,                        tree, bag,                        'Decision tree', 'Bagging'):    clf.fit(X_train, y_train)    Z = clf.predict(np.c_xx.ravel(), yy.ravel())    Z = Z.reshape(xx.shape)    axarridx.contourf(xx, yy, Z, alpha=0.3)    axarridx.scatter(X_trainy_train == 0, 0,                       X_trainy_train == 0, 1,                       c='blue', marker='^')    axarridx.scatter(X_trainy_train == 1, 0,                       X_trainy_train == 1, 1,                       c='green', marker='o')    axarridx.set_title(tt)axarr0.set_ylabel('Alcohol', fontsize=12)plt.tight_layout()plt.text(0, -0.2,         s='OD280/OD315 of diluted wines',         ha='center',         va='center',         fontsize=12,         transform=axarr1.transAxes)plt.show()➡️ 결정 트리의 선형 결정 경계가 배깅 앙상블에서 더 부드러워짐📍배깅 장점📍실전에서 고차원 데이터셋을 사용하는 복잡한 분류 문제에서 단일 결정 트리가 쉽게 과대적합되는 문제 해결📍배깅 단점📍모델이 너무 단순해서 모델의 편향을 낮추고 데이터의 경향을 잘 잡아내지는 못함7.4 약한 학습기를 이용한 에이다부스트부스팅의 핵심 아이디어 : 잘못 분류된 훈련 샘플을 그다음 약한 학습기가 학습하여 앙상블 성능을 향상시킴7.4.1 부스팅 작동 원리📍원본 부스팅 과정📍1) 훈련 데이터셋 D에서 중복을 허용하지 않고 랜덤한 부분 집합 d1을 뽑아 약한 학습기 C1을 훈련2) 훈련 데이터셋에서 중복을 허용하지 않고 랜덤한 훈련 부분 집합 d2를 뽑고 이전에 잘못 분류된 샘플의 50%를 더해서 약한 학습기 C2를 훈련3) 훈련 데이터셋 D에서 C1과 C2에서 잘못 분류한 훈련 샘플 d3을 찾아 세 번째 약한 학습기인 C3을 훈련4) 약한 학습기 C1, C2, C3를 다수결 투표로 연결📍장점📍-&gt; 배깅 모델에 비해 분산은 물론 편향도 감소시킬 수 있음-&gt; but, 실제로는 훈련 데이터에 과대적합되는 경향 있음(분산이 높음)📍에이다 부스트 과정📍1) 가중치 벡터 w를 동일한 가중치로 설정2) m번 부스팅 반복의 j번째에서 다음을 수행가중치가 부여된 약한 학습기를 훈련함클래스 레이블을 예측함가중치가 적용된 에러율 을 계산학습기 가중치를 계산가중치를 업데이트함합이 1이 되도록 가주치를 정규화함3) 최종 예측을 계산7.4.2 사이킷런에서 에이다부스트 사용☑️깊이가 1인 결정 트리 500개로 구성된 AdaBoostClassifier를 훈련시키기☑️from sklearn.ensemble import AdaBoostClassifiertree = DecisionTreeClassifier(criterion='entropy',                               max_depth=1,                              random_state=1)ada = AdaBoostClassifier(base_estimator=tree,                         n_estimators=500,                          learning_rate=0.1,                         random_state=1)                         tree = tree.fit(X_train, y_train)y_train_pred = tree.predict(X_train)y_test_pred = tree.predict(X_test)tree_train = accuracy_score(y_train, y_train_pred)tree_test = accuracy_score(y_test, y_test_pred)print('결정 트리의 훈련 정확도/테스트 정확도 %.3f/%.3f'      % (tree_train, tree_test))ada = ada.fit(X_train, y_train)y_train_pred = ada.predict(X_train)y_test_pred = ada.predict(X_test)ada_train = accuracy_score(y_train, y_train_pred) ada_test = accuracy_score(y_test, y_test_pred) print('에이다부스트의 훈련 정확도/테스트 정확도 %.3f/%.3f'      % (ada_train, ada_test))➡️깊이가 1인 결정 트리는 훈련 데이터에 과소적합됨➡️에이다부스트 모델은 훈련 데이터셋의 모든 클래스 레이블을 정확하게 예측하고 결정트리에 비해 테스트 데이터셋 성능도 좀 더 높음☑️결정 영역 확인☑️x_min, x_max = X_train:, 0.min() - 1, X_train:, 0.max() + 1y_min, y_max = X_train:, 1.min() - 1, X_train:, 1.max() + 1xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),                     np.arange(y_min, y_max, 0.1))f, axarr = plt.subplots(1, 2, sharex='col', sharey='row', figsize=(8, 3))for idx, clf, tt in zip(0, 1,                        tree, ada,                        'Decision tree', 'AdaBoost'):    clf.fit(X_train, y_train)    Z = clf.predict(np.c_xx.ravel(), yy.ravel())    Z = Z.reshape(xx.shape)    axarridx.contourf(xx, yy, Z, alpha=0.3)    axarridx.scatter(X_trainy_train == 0, 0,                       X_trainy_train == 0, 1,                       c='blue', marker='^')    axarridx.scatter(X_trainy_train == 1, 0,                       X_trainy_train == 1, 1,                       c='green', marker='o')    axarridx.set_title(tt)axarr0.set_ylabel('Alcohol', fontsize=12)plt.tight_layout()plt.text(0, -0.2,         s='OD280/OD315 of diluted wines',         ha='center',         va='center',         fontsize=12,         transform=axarr1.transAxes)plt.show()➡️에이다부스트 모델이 결정 트리의 결정 경계보다 더 복잡함➡️에이다부스트 모델이 배깅 분류기와 매우 비슷하게 특성 공간을 분할"
254,"문제풀이print(int(input(), 16))"
255,"문제풀이a = list(map(int, input().split()))c = list(map(int, input().split()))print(c0 - a2, c1 // a1, c2 - a0)"
256,문제풀이import mathn = float(input())print(int(math.ceil(n / 5)))
257,"문제풀이a, b, c = map(int, input().split())print(a + b + c)"
258,"문제풀이a, b = map(int, input().split())print((a + b) * (a - b))"
259,"문제풀이n = int(input())print(int(n * 0.78), int(n * 0.8 + (n * 0.2 * 0.78)))"
260,"6.1 파이프라인을 사용한 효율적인 워크플로6.1.1 위스콘신 유방암 데이터셋위스콘신 유방암 데이터셋 - 악성과 양성인 종양 세포 샘플 569개첫 2열 : 샘플의 고유 ID 번호와 진단 결과(M=악성,B=양성)3~32번째 열 : 세포 핵의 디지털 이미지에서 계산된 30개의 실수 값 특성 =&gt; 종양이 악성인지 양성인지 예측하는 모델 만들기☑️pandas를 사용하여 UCI 서버에서 직접 데이터셋을 읽어들임☑️import pandas as pddf = pd.read_csv('https://archive.ics.uci.edu/ml/'                 'machine-learning-databases'                 '/breast-cancer-wisconsin/wdbc.data', header=None)☑️30개의 특성을 넘파이 배열 X에 할당☑️LabelEncoder 객체 : 클래스 레이블을 원본 문자열 표현에서 정수로 변환from sklearn.preprocessing import LabelEncoderX = df.loc:, 2:.valuesy = df.loc:, 1.valuesle = LabelEncoder()y = le.fit_transform(y)➡️ 클래스 레이블(진단 결과)을 배열 y에 인코딩하면 악성 종양은 클래스 1로 표현, 양성 종양은 클래스 0으로 표현☑️데이터셋을 훈련 데이터셋과 별도의 테스트 데이터셋으로 나눔☑️from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = \    train_test_split(X, y,                      test_size=0.20,                     stratify=y,                     random_state=1)6.1.2 파이프라인으로 변환기와 추정기 연결주성분 분석을 통해 초기 30차원에서 좀 더 낮은 2차원 부분 공간으로 데이터를 압축☑️StandardScaler, PCA, LogisticRegression 객체를 하나의 파이프라인으로 연결☑️make_pipeline 함수 : 여러 개의 사이킷런 변환기와 그 뒤에 fit 메서드와 predict 메서드를 구현한 사이킷런 추정기를 연결 가능 -&gt; 입력으로 받은 객체들을 사용하여 사이킷런의 Pipeline 클래스 객체를 생성하여 반환from sklearn.preprocessing import StandardScalerfrom sklearn.decomposition import PCAfrom sklearn.linear_model import LogisticRegressionfrom sklearn.pipeline import make_pipelinepipe_lr = make_pipeline(StandardScaler(),                        PCA(n_components=2),                        LogisticRegression(random_state=1))pipe_lr.fit(X_train, y_train)y_pred = pipe_lr.predict(X_test)print('테스트 정확도: %.3f' % pipe_lr.score(X_test, y_test))📍사이킷런의 파이프라인 작동 방식📍6.2 k-겹 교차 검증을 사용한 모델 성능 평가6.2.1 홀드아웃 방법모델 선택 : 주어진 분류 문제에서 튜닝할 파라미터(하이퍼파라미터)의 최적 값을 선택해야 하는 것📍홀드아웃 교차 검증📍📍단점📍검증 데이터셋의 성능 추정이 어떤 샘플을 사용하느냐에 따라 민감하게 달라짐6.2.2 k-겹 교차 검증k-겹 교차 검증 : 훈련 데이터를 k개의 부분으로 나누어 k번 홀드아웃 방법을 반복 / 훈련 데이터셋을 k개의 폴드로 랜덤하게 나눔 -&gt; k-1개의 폴드로 모델을 훈련하고 나머지 하나의 폴드로 성능을 평가 -&gt; 이 과정을 k번 반복하여 k개의 모델과 성능 추정을 얻음 -&gt; 서로 다른 독립적인 폴드에서 얻은 성능 추정을 기반으로 모델의 평균 성능을 계산☑️사이킷런의 StratifiedKFold 반복자를 사용☑️import numpy as npfrom sklearn.model_selection import StratifiedKFoldkfold = StratifiedKFold(n_splits=10).split(X_train, y_train)scores = for k, (train, test) in enumerate(kfold):    pipe_lr.fit(X_traintrain, y_traintrain)    score = pipe_lr.score(X_traintest, y_traintest)    scores.append(score)    print('폴드: %2d, 클래스 분포: %s, 정확도: %.3f' % (k+1,          np.bincount(y_traintrain), score))print('\nCV 정확도: %.3f +/- %.3f' % (np.mean(scores), np.std(scores)))☑️사이킷런의 k-겹 교차 검증 함수 사용☑️from sklearn.model_selection import cross_val_scorescores = cross_val_score(estimator=pipe_lr,                         X=X_train,                         y=y_train,                         cv=10,                         n_jobs=1)print('CV 정확도 점수: %s' % scores)print('CV 정확도: %.3f +/- %.3f' % (np.mean(scores), np.std(scores)))6.3 학습 곡선과 검증 곡선을 사용한 알고리즘 디버깅6.3.1 학습 곡선으로 편향과 분산 문제 분석☑️사이킷런의 학습 곡선 함수를 사용하여 모델 평가☑️learning_curve 함수의 train_sizes 매개변수 : 학습 곡선을 생성하는 데 사용할 훈련 샘플의 개수나 비율을 지정learning_curve 함수 : 계층별 k-겹 교차 검증을 사용하여 분류기의 교차 검증 정확도를 계산fill_between 함수 : 그래프에 평균 정확도의 표준 편차를 그려서 추정 분산을 나타냄import matplotlib.pyplot as pltfrom sklearn.model_selection import learning_curvepipe_lr = make_pipeline(StandardScaler(),                        LogisticRegression(penalty='l2', random_state=1,                                           max_iter=10000))train_sizes, train_scores, test_scores =                learning_curve(estimator=pipe_lr,                               X=X_train,                               y=y_train,                               train_sizes=np.linspace(0.1, 1.0, 10),                               cv=10,                               n_jobs=1)train_mean = np.mean(train_scores, axis=1)train_std = np.std(train_scores, axis=1)test_mean = np.mean(test_scores, axis=1)test_std = np.std(test_scores, axis=1)plt.plot(train_sizes, train_mean,         color='blue', marker='o',         markersize=5, label='Training accuracy')plt.fill_between(train_sizes,                 train_mean + train_std,                 train_mean - train_std,                 alpha=0.15, color='blue')plt.plot(train_sizes, test_mean,         color='green', linestyle='--',         marker='s', markersize=5,         label='Validation accuracy')plt.fill_between(train_sizes,                 test_mean + test_std,                 test_mean - test_std,                 alpha=0.15, color='green')plt.grid()plt.xlabel('Number of training examples')plt.ylabel('Accuracy')plt.legend(loc='lower right')plt.ylim(0.8, 1.03)plt.tight_layout()plt.show()!(https://velog.velcdn.com/images/rosesua318/post/a0e3c8e7-74e9-482f-a4d9-1660ff4409f8/image.png)&lt;br&gt;#### 6.3.2 검증 곡선으로 과대적합과 과소적합 조사☑️사이킷런으로 검증 곡선 만들기☑️- validation_curv 함수 : 계층별 k-겹 교차 검증을 사용하여 모델의 성능을 추정``` pythonfrom sklearn.model_selection import validation_curveparam_range = 0.001, 0.01, 0.1, 1.0, 10.0, 100.0train_scores, test_scores = validation_curve(                estimator=pipe_lr,                 X=X_train,                 y=y_train,                 param_name='logisticregression__C',                 param_range=param_range,                cv=10)train_mean = np.mean(train_scores, axis=1)train_std = np.std(train_scores, axis=1)test_mean = np.mean(test_scores, axis=1)test_std = np.std(test_scores, axis=1)plt.plot(param_range, train_mean,          color='blue', marker='o',          markersize=5, label='Training accuracy')plt.fill_between(param_range, train_mean + train_std,                 train_mean - train_std, alpha=0.15,                 color='blue')plt.plot(param_range, test_mean,          color='green', linestyle='--',          marker='s', markersize=5,          label='Validation accuracy')plt.fill_between(param_range,                  test_mean + test_std,                 test_mean - test_std,                  alpha=0.15, color='green')plt.grid()plt.xscale('log')plt.legend(loc='lower right')plt.xlabel('Parameter C')plt.ylabel('Accuracy')plt.ylim(0.8, 1.0)plt.tight_layout()plt.show()➡️매개변수 C에 대한 검증 곡선 그래프를 얻게 됨6.4 그리드 서치를 사용한 머신 러닝 모델 세부 튜닝튜닝 파라미터(하이퍼파라미터) : 별도로 최적화되는 학습 알고리즘의 파라미터 로지스틱 회귀의 규제 매개변수, 결정 트리의 깊이 매개변수6.4.1 그리드 서치를 사용한 하이퍼파라미터 튜닝그리드 서치 : 리스트로 지정된 여러 가지 하이퍼파라미터 값 전체를 모두 조사 -&gt; 이 리스트에 있는 값의 모든 조합에 대해 모델 성능을 평가하여 최적의 조합을 찾음☑️사이킷런 그리드 서치☑️from sklearn.model_selection import GridSearchCVfrom sklearn.svm import SVCpipe_svc = make_pipeline(StandardScaler(),                         SVC(random_state=1))param_range = 0.0001, 0.001, 0.01, 0.1, 1.0, 10.0, 100.0, 1000.0param_grid = {'svc__C': param_range,                'svc__kernel': 'linear'},              {'svc__C': param_range,                'svc__gamma': param_range,                'svc__kernel': 'rbf'}gs = GridSearchCV(estimator=pipe_svc,                   param_grid=param_grid,                   scoring='accuracy',                   refit=True,                  cv=10,                  n_jobs=-1)gs = gs.fit(X_train, y_train)print(gs.best_score_)print(gs.best_params_)☑️독립적인 테스트 데이터셋을 사용하여 최고 모델의 성능을 추정☑️clf = gs.best_estimator_# refit=True로 지정했기 때문에 다시 fit() 메서드를 호출할 필요가 없습니다.# clf.fit(X_train, y_train)print('테스트 정확도: %.3f' % clf.score(X_test, y_test))6.4.2 중첩 교차 검증을 사용한 알고리즘 선택중첩 교차 검증 방법 - 여러 종류의 머신 러닝 알고리즘 비교할 때 권장☑️사이킷런으로 중첩 교차 검증 수행☑️gs = GridSearchCV(estimator=pipe_svc,                  param_grid=param_grid,                  scoring='accuracy',                  cv=2)scores = cross_val_score(gs, X_train, y_train,                          scoring='accuracy', cv=5)print('CV 정확도: %.3f +/- %.3f' % (np.mean(scores),                                      np.std(scores)))☑️max_depth 매개변수 튜닝☑️from sklearn.tree import DecisionTreeClassifiergs = GridSearchCV(estimator=DecisionTreeClassifier(random_state=0),                  param_grid={'max_depth': 1, 2, 3, 4, 5, 6, 7, None},                  scoring='accuracy',                  cv=2)scores = cross_val_score(gs, X_train, y_train,                          scoring='accuracy', cv=5)print('CV 정확도: %.3f +/- %.3f' % (np.mean(scores),                                       np.std(scores)))➡️ SVM 모델의 중첩 교차 검증 성능(97.4%)이 결정 트리의 성능(93.4%) 보다 훨씬 뛰어남6.5 여러 가지 성능 평가 지표6.5.1 오차 행렬☑️사이킷런 confusion_matrix 함수 사용☑️from sklearn.metrics import confusion_matrixpipe_svc.fit(X_train, y_train)y_pred = pipe_svc.predict(X_test)confmat = confusion_matrix(y_true=y_test, y_pred=y_pred)print(confmat)☑️오차 행렬 그리기☑️matshow 함수 : 오차 행렬 그려줌fig, ax = plt.subplots(figsize=(2.5, 2.5))ax.matshow(confmat, cmap=plt.cm.Blues, alpha=0.3)for i in range(confmat.shape0):    for j in range(confmat.shape1):        ax.text(x=j, y=i, s=confmati, j, va='center', ha='center')plt.xlabel('Predicted label')plt.ylabel('True label')plt.tight_layout()plt.show()6.5.2 분류 모델의 정밀도와 재현율 최적화오차 : 잘못된 예측의 합을 전체 예측 샘플 개수로 나눈 것정확도 : 옳은 예측의 합을 전체 예측 샘플 개수로 나누어 계산☑️사이킷런에서 성능 지표☑️from sklearn.metrics import precision_score, recall_score, f1_scoreprint('정밀도: %.3f' % precision_score(y_true=y_test, y_pred=y_pred))print('재현율: %.3f' % recall_score(y_true=y_test, y_pred=y_pred))print('F1: %.3f' % f1_score(y_true=y_test, y_pred=y_pred))from sklearn.metrics import make_scorerscorer = make_scorer(f1_score, pos_label=0)c_gamma_range = 0.01, 0.1, 1.0, 10.0param_grid = {'svc__C': c_gamma_range,               'svc__kernel': 'linear'},              {'svc__C': c_gamma_range,               'svc__gamma': c_gamma_range,               'svc__kernel': 'rbf'}gs = GridSearchCV(estimator=pipe_svc,                  param_grid=param_grid,                  scoring=scorer,                  cv=10,                  n_jobs=-1)gs = gs.fit(X_train, y_train)print(gs.best_score_)print(gs.best_params_)6.5.3 ROC 곡선 그리기ROC 그래프 - 분류기의 임계 값을 바꾸어 가며 계산된 FPR과 TPR 점수를 기반으로 분류 모델을 선택하는 유용한 도구☑️종양의 악성 여부를 예측하는 분류 모델의 ROC 곡선 그리기☑️from sklearn.metrics import roc_curve, aucfrom distutils.version import LooseVersion as Versionfrom scipy import __version__ as scipy_versionif scipy_version &gt;= Version('1.4.1'):    from numpy import interpelse:    from scipy import interppipe_lr = make_pipeline(StandardScaler(),                        PCA(n_components=2),                        LogisticRegression(penalty='l2',                                            random_state=1,                                           C=100.0))X_train2 = X_train:, 4, 14cv = list(StratifiedKFold(n_splits=3).split(X_train, y_train))fig = plt.figure(figsize=(7, 5))mean_tpr = 0.0mean_fpr = np.linspace(0, 1, 100)for i, (train, test) in enumerate(cv):    probas = pipe_lr.fit(X_train2train,                         y_traintrain).predict_proba(X_train2test)    fpr, tpr, thresholds = roc_curve(y_traintest,                                     probas:, 1,                                     pos_label=1)    mean_tpr += interp(mean_fpr, fpr, tpr)    mean_tpr0 = 0.0    roc_auc = auc(fpr, tpr)    plt.plot(fpr,             tpr,             label='ROC fold %d (area = %0.2f)'                   % (i+1, roc_auc))plt.plot(0, 1,         0, 1,         linestyle='--',         color=(0.6, 0.6, 0.6),         label='Random guessing')mean_tpr /= len(cv)mean_tpr-1 = 1.0mean_auc = auc(mean_fpr, mean_tpr)plt.plot(mean_fpr, mean_tpr, 'k--',         label='Mean ROC (area = %0.2f)' % mean_auc, lw=2)plt.plot(0, 0, 1,         0, 1, 1,         linestyle=':',         color='black',         label='Perfect performance')plt.xlim(-0.05, 1.05)plt.ylim(-0.05, 1.05)plt.xlabel('False positive rate')plt.ylabel('True positive rate')plt.legend(loc=&quot;lower right&quot;)plt.tight_layout()plt.show()6.5.4 다중 분류의 성능 지표pre_scorer = make_scorer(score_func=precision_score,                          pos_label=1,                          greater_is_better=True,                          average='micro')6.6 불균형한 클래스 다루기☑️불균형한 유방암 데이터셋 만들기☑️212개의 악성 종양(클래스 1)357개의 양성 종양(클래스 0)X_imb = np.vstack((Xy == 0, Xy == 1:40))y_imb = np.hstack((yy == 0, yy == 1:40))y_pred = np.zeros(y_imb.shape0)np.mean(y_pred == y_imb) * 100☑️사이킷런 소수 클래스의 샘플을 늘리기☑️from sklearn.utils import resampleprint('샘플링하기 전 클래스 1의 샘플 개수:', X_imby_imb == 1.shape0)X_upsampled, y_upsampled = resample(X_imby_imb == 1,                                    y_imby_imb == 1,                                    replace=True,                                    n_samples=X_imby_imb == 0.shape0,                                    random_state=123)print('샘플링하기 후 클래스 1의 샘플 개수:', X_upsampled.shape0)➡️데이터셋에서 다수 클래스의 훈련 샘플을 삭제하여 다운샘플링도 가능(클래스 레이블 1과 0을 서로 바꾸면 됨)"
261,"5.1 주성분 분석을 통한 비지도 차원 축소특성 추출 : 데이터셋의 특성 개수를 줄이는 방법으로, 새로운 특성 곤간으로 데이터를 변환하거나 투영하여 원본 특성이 유지되지 않음📍장점📍1) 저장 공간 절약2) 학습 알고리즘의 계산 효율성 향상3)** 차원의 저주** 문제 감소 -&gt; 예측 성능 향상5.1.1 주성분 분석의 주요 단계PCA : 비지도 선형 변환 기법, 고차원 데이터에서 분산이 가장 큰 방향을 찾고 좀 더 작거나 같은 수의 차원을 갖는 새로운 부분 공간으로 이를 투영-&gt; 사용 분야 : 탐색적 데이터 분석과 주식 거래 시장의 잡음 제거, 생물정보학 분야에서 게놈 데이터나 유전자 발현 분석📍PCA 단계📍1) d 차원 데이터셋을 표준화 전처리2) 공분산 행렬을 만듦3) 공분산 행렬을 고유 베거와 고유값으로 분해4) 고윳값을 내림차순으로 정렬하고 그에 해당하는 고유 벡터의 순위를 매김5) 고윳값이 가장 큰 k개의 고유 벡터를 선택. 여기서 k는 새로운 특성 부분 공간의 차원(k &lt;= d)6) 최상위 k개의 고유 벡터로 투영 행렬 w를 만듦7) 투영 행렬 w를 사용해서 d 차원 입력 데이터셋 X를 새로운 k 차원의 특성 부분 공간으로 변환5.1.2 주성분 추출 단계📍네 단계 구성📍1) 데이터를 표준화 전처리2) 공분산 행렬을 구성3) 공분산 행렬의 고윳값과 고유 벡터를 구함4) 고윳값을 내림차순으로 정렬하여 고유 벡터의 순위를 매김☑️Wine 데이터셋 로드☑️import pandas as pddf_wine = pd.read_csv('https://archive.ics.uci.edu/ml/'                      'machine-learning-databases/wine/wine.data',                      header=None)☑️Wine 데이터셋 훈련 데이터셋과 테스트 데이터셋으로 나누기☑️from sklearn.model_selection import train_test_splitX, y = df_wine.iloc:, 1:.values, df_wine.iloc:, 0.valuesX_train, X_test, y_train, y_test = \    train_test_split(X, y, test_size=0.3,                      stratify=y,                     random_state=0)☑️데이터 표준화 적용하여 단위 분산 갖게 하기☑️from sklearn.preprocessing import StandardScalersc = StandardScaler()X_train_std = sc.fit_transform(X_train)X_test_std = sc.transform(X_test)☑️공분산 행렬의 고윳값 분해☑️numpy.cov 함수 : 표준화 전처리된 훈련 데이터셋의 공분산 행렬을 계산linalg.eig 함수 : 공분산 행렬에 대한 고윳값 분해를 수행import numpy as npcov_mat = np.cov(X_train_std.T)eigen_vals, eigen_vecs = np.linalg.eig(cov_mat)print('\n고윳값 \n%s' % eigen_vals)➡️ 13개의 고윳값이 들어있는 벡터(eigen_vals)와 각 고윳값에 대응하는 고유 벡터가 열에 저장된 13x13차원의 행렬(eigen_vals)을 얻음5.1.3 총 분산과 설명된 분산☑️설명된 분산 비율 그래프로 그려보기☑️cumsum 함수 : 설명된 분산의 누적 합을 계산step 함수 : 그래프로 그리기tot = sum(eigen_vals)var_exp = (i / tot) for i in sorted(eigen_vals, reverse=True)cum_var_exp = np.cumsum(var_exp)import matplotlib.pyplot as pltplt.bar(range(1, 14), var_exp, alpha=0.5, align='center',        label='Individual explained variance')plt.step(range(1, 14), cum_var_exp, where='mid',         label='Cumulative explained variance')plt.ylabel('Explained variance ratio')plt.xlabel('Principal component index')plt.legend(loc='best')plt.tight_layout()plt.show()➡️첫 번째 주성분이 거의 분산의 40%를 커버하고 있음을 보여줌➡️처음 두 개의 주성분이 데이터셋에 있는 분산의 대략 60%를 설명함5.1.4 특성 변환📍남은 단계📍1) 고윳값이 가장 큰 k개의 고유 벡터를 선택. 여기서 k는 새로운 특성 부분 공간의 차원(k &lt;= d)2) 최상위 k개의 고유 벡터로 투영 행렬 w를 만듦3) 투영 행렬 w를 사용해서 d 차원 입력 데이터셋 X를 새로운 k 차원의 특성 부분 공간으로 변환☑️고윳값의 내림차순으로 고유 벡터와 고윳값의 쌍을 정렬☑️# (고윳값, 고유벡터) 튜플의 리스트를 만듭니다eigen_pairs = (np.abs(eigen_valsi), eigen_vecs:, i)               for i in range(len(eigen_vals))# 높은 값에서 낮은 값으로 (고윳값, 고유벡터) 튜플을 정렬합니다eigen_pairs.sort(key=lambda k: k0, reverse=True)☑️최상위 두 개의 고유 벡터로부터 13 x 2 차원의 투영 행렬 W를 만듦☑️w = np.hstack((eigen_pairs01:, np.newaxis,               eigen_pairs11:, np.newaxis))print('투영 행렬 W:\n', w)☑️샘플 x(13차원의 행 벡터)를 PCA 부분 공간(두 개의 주성분)을 투영하여 x' 얻기☑️X_train_std0.dot(w)☑️훈련 데이터셋을 행렬 점곱으로 두 개의 주성분에 투영☑️X_train_pca = X_train_std.dot(w)☑️변환된 Wine 훈련 데이터셋을 2차원 산점도로 시각화☑️colors = 'r', 'b', 'g'markers = 's', 'x', 'o'for l, c, m in zip(np.unique(y_train), colors, markers):    plt.scatter(X_train_pcay_train == l, 0,                 X_train_pcay_train == l, 1,                 c=c, label=l, marker=m)plt.xlabel('PC 1')plt.ylabel('PC 2')plt.legend(loc='lower left')plt.tight_layout()plt.show()➡️데이터가 y축(두 번째 주성분)보다 x축(첫 번째 주성분)을 따라 더 넓게 퍼져 있음➡️선형 분류기가 클래스들을 잘 분리할 수 있음을 직관적으로 알 수 있음5.1.5 사이킷런의 주성분 분석☑️결정 경계 만드는 함수 생성하여 파일로 저장☑️import numpy as npfrom matplotlib import pyplot as pltfrom matplotlib.colors import ListedColormapdef plot_decision_regions(X, y, classifier, resolution=0.02):    # 마커와 컬러맵을 설정합니다    markers = ('s', 'x', 'o', '^', 'v')    colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan')    cmap = ListedColormap(colors:len(np.unique(y)))    # 결정 경계를 그립니다    x1_min, x1_max = X:, 0.min() - 1, X:, 0.max() + 1    x2_min, x2_max = X:, 1.min() - 1, X:, 1.max() + 1    xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution),                           np.arange(x2_min, x2_max, resolution))    Z = classifier.predict(np.array(xx1.ravel(), xx2.ravel()).T)    Z = Z.reshape(xx1.shape)    plt.contourf(xx1, xx2, Z, alpha=0.3, cmap=cmap)    plt.xlim(xx1.min(), xx1.max())    plt.ylim(xx2.min(), xx2.max())    # 샘플의 산점도를 그립니다    for idx, cl in enumerate(np.unique(y)):        plt.scatter(x=Xy == cl, 0,                    y=Xy == cl, 1,                    alpha=0.8,                    c=colorsidx,                    marker=markersidx,                    label=cl,                    edgecolor='black')☑️함수 이용하여 결정 경계 생성☑️from sklearn.linear_model import LogisticRegressionpca = PCA(n_components=2)X_train_pca = pca.fit_transform(X_train_std)X_test_pca = pca.transform(X_test_std)lr = LogisticRegression(random_state=1)lr = lr.fit(X_train_pca, y_train)plot_decision_regions(X_train_pca, y_train, classifier=lr)plt.xlabel('PC 1')plt.ylabel('PC 2')plt.legend(loc='lower left')plt.tight_layout()plt.show()☑️테스트 데이터셋을 변환하고 로지스틱 회귀가 클래스를 잘 구분하는지 결정 경계 그리기☑️plot_decision_regions(X_test_pca, y_test, classifier=lr)plt.xlabel('PC 1')plt.ylabel('PC 2')plt.legend(loc='lower left')plt.tight_layout()plt.show()➡️로지스틱 회귀가 2차원 특성 부분 공간에서 매우 잘 작동함5.2 선형 판별 분석을 통한 지도 방식의 데이터 압축선형 판별 분석(LDA) : 규제가 없는 모델에서 차원의 저주로 인한 과대 적합 정도를 줄이고 계산 효율성을 높이기 위한 특성 추출의 기법으로 사용📍LDA 목표📍-&gt; 클래스를 최적으로 구분할 수 있는 특성 부분 공간 찾는 것5.2.1 주성분 분석 vs 선형 판별 분석5.2.2 선형 판별 분석의 내부 동작 방식📍LDA 수행에 필요한 주요 단계📍1) d 차원의 데이터셋을 표준화 전처리(d는 특성 개수)2) 각 클래스에 대해 d 차원의 평균 벡터를 계산3) 클래스 간의 산포 행렬 SB와 클래스 내 산포 행렬 SW를 구성4) SW-1SB행렬의 고유 벡터와 고윳값을 계산5) 고윳값을 내림차순으로 정렬하여 고유 벡터의 순서를 매김6) 고윳값이 가장 큰 k개의 고유 벡터를 선택하여 d x k 차원의 변환 행렬 W를 구성. 이 행렬의 열이 고유 벡터이다.7) 변환 행렬 W를 사용하여 샘플을 새로운 특성 부분 공간으로 투영5.2.3 산포 행렬 계산☑️각 클래스에 대한 평균 벡터를 계산☑️np.set_printoptions(precision=4)mean_vecs = for label in range(1, 4):    mean_vecs.append(np.mean(X_train_stdy_train == label, axis=0))    print('MV %s: %s\n' % (label, mean_vecslabel - 1))☑️클래스 내 산포 행렬 계산☑️d = 13 # 특성의 수S_W = np.zeros((d, d))for label, mv in zip(range(1, 4), mean_vecs):    class_scatter = np.zeros((d, d))  # 각 클래스에 대한 산포 행렬    for row in X_train_stdy_train == label:        row, mv = row.reshape(d, 1), mv.reshape(d, 1)  # 열 벡터를 만듭니다        class_scatter += (row - mv).dot((row - mv).T)    S_W += class_scatter                          # 클래스 산포 행렬을 더합니다print('클래스 내의 산포 행렬: %sx%s' % (S_W.shape0, S_W.shape1))☑️클래스 내 산포 행렬 스케일 조정☑️d = 13  # 특성의 수S_W = np.zeros((d, d))for label, mv in zip(range(1, 4), mean_vecs):    class_scatter = np.cov(X_train_stdy_train == label.T)    S_W += class_scatterprint('스케일 조정된 클래스 내의 산포 행렬: %sx%s' %       (S_W.shape0, S_W.shape1))☑️클래스 간의 산포 행렬 계산☑️mean_overall = np.mean(X_train_std, axis=0)mean_overall = mean_overall.reshape(d, 1)  # 열 벡터로 만들기d = 13  # 특성 개수S_B = np.zeros((d, d))for i, mean_vec in enumerate(mean_vecs):    n = X_train_stdy_train == i + 1, :.shape0    mean_vec = mean_vec.reshape(d, 1)  # 열 벡터로 만들기    S_B += n * (mean_vec - mean_overall).dot((mean_vec - mean_overall).T)print('클래스 간의 산포 행렬: %sx%s' % (S_B.shape0, S_B.shape1))5.2.4 새로운 특성 부분 공간을 위해 선형 판별 벡터 선택☑️행렬 SW-1SB의 고윳값 계산☑️eigen_vals, eigen_vecs = np.linalg.eig(np.linalg.inv(S_W).dot(S_B))☑️고윳값의 역순으로 고유 벡터를 정렬☑️# (고윳값, 고유벡터) 튜플의 리스트를 만듭니다.eigen_pairs = (np.abs(eigen_valsi), eigen_vecs:, i)               for i in range(len(eigen_vals))# (고윳값, 고유벡터) 튜플을 큰 값에서 작은 값 순서대로 정렬합니다.eigen_pairs = sorted(eigen_pairs, key=lambda k: k0, reverse=True)# 고윳값의 역순으로 올바르게 정렬되었는지 확인합니다.print('내림차순의 고윳값:\n')for eigen_val in eigen_pairs:    print(eigen_val0)☑️고윳값의 내림차순으로 선형 판별 벡터 그리기☑️tot = sum(eigen_vals.real)discr = (i / tot) for i in sorted(eigen_vals.real, reverse=True)cum_discr = np.cumsum(discr)plt.bar(range(1, 14), discr, alpha=0.5, align='center',        label='Individual &quot;discriminability&quot;')plt.step(range(1, 14), cum_discr, where='mid',         label='Cumulative &quot;discriminability&quot;')plt.ylabel('&quot;Discriminability&quot; ratio')plt.xlabel('Linear discriminants')plt.ylim(-0.1, 1.1)plt.legend(loc='best')plt.tight_layout()plt.show()➡️처음 두 개의 선형 판별 벡터가 Wine 데이터셋에 있는 정보 중 거의 100%를 잡아냄☑️두 개의 판별 고유 벡터를 열로 쌓아서 변환 행렬 W 만들기☑️w = np.hstack((eigen_pairs01:, np.newaxis.real,              eigen_pairs11:, np.newaxis.real))print('행렬 W:\n', w)5.2.5 새로운 특성 공간으로 샘플 투영☑️변환 행렬 W를 훈련 데이터셋에 곱해서 데이터 변환☑️X_train_lda = X_train_std.dot(w)colors = 'r', 'b', 'g'markers = 's', 'x', 'o'for l, c, m in zip(np.unique(y_train), colors, markers):    plt.scatter(X_train_lday_train == l, 0,                X_train_lday_train == l, 1 * (-1),                c=c, label=l, marker=m)plt.xlabel('LD 1')plt.ylabel('LD 2')plt.legend(loc='lower right')plt.tight_layout()plt.show()➡️세 개의 와인 클래스를 새로운 특성 부분 공간에서 선형적으로 완벽하게 구분5.2.6 사이킷런의 LDA☑️사이킷런에 구현된 LDA 클래스 불러오기☑️from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDAlda = LDA(n_components=2)X_train_lda = lda.fit_transform(X_train_std, y_train)☑️LDA로 변환한 저차원 훈련 데이터셋에 로지스틱 회귀 분류기가 잘 동작하는지 확인☑️from sklearn.linear_model import LogisticRegressionlr = LogisticRegression(random_state=1)lr = lr.fit(X_train_lda, y_train)plot_decision_regions(X_train_lda, y_train, classifier=lr)plt.xlabel('LD 1')plt.ylabel('LD 2')plt.legend(loc='lower left')plt.tight_layout()plt.show()➡️클래스 2의 샘플 하나가 로지스틱 회귀 모델의 결정 경계에 가까이 놓여 있음X_test_lda = lda.transform(X_test_std)plot_decision_regions(X_test_lda, y_test, classifier=lr)plt.xlabel('LD 1')plt.ylabel('LD 2')plt.legend(loc='lower left')plt.tight_layout()plt.show()➡️모든 샘플을 완벽하게 분류5.3 커널 PCA를 사용하여 비선형 매핑커널 PCA -&gt; 선형적으로 구분되지 않는 데이터를 선형 분류기에 적합한 새로운 저차원 부분 공간으로 변환5.3.1 커널 함수와 커널 트릭📍단계📍1) 커널 PCA를 통한 비선형 매핑을 수행하여 데이터를 고차원 공간으로 변환2) 고차원 공간에 표준 PCA를 사용하여 샘플이 선형 분류기로 구분될 수 있는 저차원 공간으로 데이터를 투영커널 트릭 : 원본 특성 공간에서 두 고차원 특성 벡터의 유사도를 계산 가능 (계산 비용이 비싼 문제를 해결)5.3.2 파이썬으로 커널 PCA 구현from scipy.spatial.distance import pdist, squareformfrom scipy.linalg import eighimport numpy as npfrom distutils.version import LooseVersion as Versionfrom scipy import __version__ as scipy_version# scipy 2.0.0에서 삭제될 예정이므로 대신 numpy.exp를 사용합니다.if scipy_version &gt;= Version('1.4.1'):    from numpy import expelse:    from scipy import expdef rbf_kernel_pca(X, gamma, n_components):    &quot;&quot;&quot;    RBF 커널 PCA 구현    매개변수    ------------    X: {넘파이 ndarray}, shape = n_samples, n_features    gamma: float      RBF 커널 튜닝 매개변수    n_components: int      반환할 주성분 개수    반환값    ------------     X_pc: {넘파이 ndarray}, shape = n_samples, k_features       투영된 데이터셋    &quot;&quot;&quot;    # MxN 차원의 데이터셋에서 샘플 간의 유클리디안 거리의 제곱을 계산합니다.    sq_dists = pdist(X, 'sqeuclidean')    # 샘플 간의 거리를 정방 대칭 행렬로 변환합니다.    mat_sq_dists = squareform(sq_dists)    # 커널 행렬을 계산합니다.    K = exp(-gamma * mat_sq_dists)    # 커널 행렬을 중앙에 맞춥니다.    N = K.shape0    one_n = np.ones((N, N)) / N    K = K - one_n.dot(K) - K.dot(one_n) + one_n.dot(K).dot(one_n)    # 중앙에 맞춰진 커널 행렬의 고윳값과 고유벡터를 구합니다.    # scipy.linalg.eigh 함수는 오름차순으로 반환합니다.    eigvals, eigvecs = eigh(K)    eigvals, eigvecs = eigvals::-1, eigvecs:, ::-1    # 최상위 k 개의 고유벡터를 선택합니다(결과값은 투영된 샘플입니다).    X_pc = np.column_stack(eigvecs:, i                            for i in range(n_components))    return X_pc예제 1 : 반달 모양 구분하기☑️rbf_kernel_pca 함수를 비선형 데이터셋에 적용☑️import matplotlib.pyplot as pltfrom sklearn.datasets import make_moonsX, y = make_moons(n_samples=100, random_state=123)plt.scatter(Xy == 0, 0, Xy == 0, 1, color='red', marker='^', alpha=0.5)plt.scatter(Xy == 1, 0, Xy == 1, 1, color='blue', marker='o', alpha=0.5)plt.tight_layout()plt.show()☑️기본 PCA의 주성분에 데이터셋을 투영하여 확인☑️from sklearn.decomposition import PCAscikit_pca = PCA(n_components=2)X_spca = scikit_pca.fit_transform(X)fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(7, 3))ax0.scatter(X_spcay == 0, 0, X_spcay == 0, 1,              color='red', marker='^', alpha=0.5)ax0.scatter(X_spcay == 1, 0, X_spcay == 1, 1,              color='blue', marker='o', alpha=0.5)ax1.scatter(X_spcay == 0, 0, np.zeros((50, 1)) + 0.02,              color='red', marker='^', alpha=0.5)ax1.scatter(X_spcay == 1, 0, np.zeros((50, 1)) - 0.02,              color='blue', marker='o', alpha=0.5)ax0.set_xlabel('PC1')ax0.set_ylabel('PC2')ax1.set_ylim(-1, 1)ax1.set_yticks()ax1.set_xlabel('PC1')plt.tight_layout()plt.show()☑️커널 PCA 함수 rbf_kernel_pca를 적용☑️X_kpca = rbf_kernel_pca(X, gamma=15, n_components=2)fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(7, 3))ax0.scatter(X_kpcay==0, 0, X_kpcay==0, 1,             color='red', marker='^', alpha=0.5)ax0.scatter(X_kpcay==1, 0, X_kpcay==1, 1,            color='blue', marker='o', alpha=0.5)ax1.scatter(X_kpcay==0, 0, np.zeros((50, 1))+0.02,             color='red', marker='^', alpha=0.5)ax1.scatter(X_kpcay==1, 0, np.zeros((50, 1))-0.02,            color='blue', marker='o', alpha=0.5)ax0.set_xlabel('PC1')ax0.set_ylabel('PC2')ax1.set_ylim(-1, 1)ax1.set_yticks()ax1.set_xlabel('PC1')plt.tight_layout()plt.show()예제 2: 동심원 분리하기☑️동심원 모양의 데이터셋☑️from sklearn.datasets import make_circlesX, y = make_circles(n_samples=1000, random_state=123, noise=0.1, factor=0.2)plt.scatter(Xy == 0, 0, Xy == 0, 1, color='red', marker='^', alpha=0.5)plt.scatter(Xy == 1, 0, Xy == 1, 1, color='blue', marker='o', alpha=0.5)plt.tight_layout()plt.show()☑️기본 PCA를 적용☑️scikit_pca = PCA(n_components=2)X_spca = scikit_pca.fit_transform(X)fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(7, 3))ax0.scatter(X_spcay == 0, 0, X_spcay == 0, 1,              color='red', marker='^', alpha=0.5)ax0.scatter(X_spcay == 1, 0, X_spcay == 1, 1,              color='blue', marker='o', alpha=0.5)ax1.scatter(X_spcay == 0, 0, np.zeros((500, 1)) + 0.02,              color='red', marker='^', alpha=0.5)ax1.scatter(X_spcay == 1, 0, np.zeros((500, 1)) - 0.02,              color='blue', marker='o', alpha=0.5)ax0.set_xlabel('PC1')ax0.set_ylabel('PC2')ax1.set_ylim(-1, 1)ax1.set_yticks()ax1.set_xlabel('PC1')plt.tight_layout()plt.show()➡️선형 분류기에 적합한 결과 만들 수 ❌☑️RBF 커널 PCA 구현 사용☑️X_kpca = rbf_kernel_pca(X, gamma=15, n_components=2)fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(7, 3))ax0.scatter(X_kpcay == 0, 0, X_kpcay == 0, 1,              color='red', marker='^', alpha=0.5)ax0.scatter(X_kpcay == 1, 0, X_kpcay == 1, 1,              color='blue', marker='o', alpha=0.5)ax1.scatter(X_kpcay == 0, 0, np.zeros((500, 1)) + 0.02,              color='red', marker='^', alpha=0.5)ax1.scatter(X_kpcay == 1, 0, np.zeros((500, 1)) - 0.02,              color='blue', marker='o', alpha=0.5)ax0.set_xlabel('PC1')ax0.set_ylabel('PC2')ax1.set_ylim(-1, 1)ax1.set_yticks()ax1.set_xlabel('PC1')plt.tight_layout()plt.show()➡️RBF 커널 PCA가 두 클래스를 선형적으로 구분할 수 있는 새로운 부분 공간으로 데이터를 투영5.3.3 새로운 데이터 포인트 투영☑️rbf_kernel_pca 함수를 커널 행렬의 고윳값도 반환하도록 수정☑️from scipy.spatial.distance import pdist, squareformfrom numpy import expfrom scipy.linalg import eighimport numpy as npdef rbf_kernel_pca(X, gamma, n_components):    &quot;&quot;&quot;    RBF 커널 PCA 구현    매개변수    ------------    X: {넘파이 ndarray}, shape = n_samples, n_features    gamma: float      RBF 커널 튜닝 매개변수    n_components: int      반환할 주성분 개수    Returns    ------------     alphas: {넘파이 ndarray}, shape = n_samples, k_features       투영된 데이터셋     lambdas: list       고윳값    &quot;&quot;&quot;    # MxN 차원의 데이터셋에서 샘플 간의 유클리디안 거리의 제곱을 계산합니다.    sq_dists = pdist(X, 'sqeuclidean')    # 샘플 간의 거리를 정방 대칭 행렬로 변환합니다.    mat_sq_dists = squareform(sq_dists)    # 커널 행렬을 계산합니다.    K = exp(-gamma * mat_sq_dists)    # 커널 행렬을 중앙에 맞춥니다.    N = K.shape0    one_n = np.ones((N, N)) / N    K = K - one_n.dot(K) - K.dot(one_n) + one_n.dot(K).dot(one_n)    # 중앙에 맞춰진 커널 행렬의 고윳값과 고유 벡터를 구합니다.    # scipy.linalg.eigh 함수는 오름차순으로 반환합니다.    eigvals, eigvecs = eigh(K)    eigvals, eigvecs = eigvals::-1, eigvecs:, ::-1    # 최상위 k 개의 고유 벡터를 선택합니다(투영 결과).    alphas = np.column_stack(eigvecs:, i                              for i in range(n_components))    # 고유 벡터에 상응하는 고윳값을 선택합니다.    lambdas = eigvalsi for i in range(n_components)    return alphas, lambdas☑️새로운 반달 데이터셋을 만들고 수정된 커널 PCA 구현을 사용하여 1차원 부분 공간에 투영☑️X, y = make_moons(n_samples=100, random_state=123)alphas, lambdas = rbf_kernel_pca(X, gamma=15, n_components=1)☑️원본 투영을 재현☑️x_new = X25x_proj = alphas25 # 원본 투영def project_x(x_new, X, gamma, alphas, lambdas):    pair_dist = np.array(np.sum((x_new - row)**2) for row in X)    k = np.exp(-gamma * pair_dist)    return k.dot(alphas / lambdas)# 새로운 데이터포인트를 투영합니다.x_reproj = project_x(x_new, X, gamma=15, alphas=alphas, lambdas=lambdas)☑️첫 번째 주성분에 투영한 것을 그래프로 그리기☑️plt.scatter(alphasy == 0, 0, np.zeros((50)),            color='red', marker='^', alpha=0.5)plt.scatter(alphasy == 1, 0, np.zeros((50)),            color='blue', marker='o', alpha=0.5)plt.scatter(x_proj, 0, color='black',            label='Original projection of point X25', marker='^', s=100)plt.scatter(x_reproj, 0, color='green',            label='Remapped point X25', marker='x', s=500)plt.yticks(, )plt.legend(scatterpoints=1)plt.tight_layout()plt.show()5.3.4 사이킷런의 커널 PCA☑️사이킷런의 커널 PCA 사용하여 그려보기☑️from sklearn.decomposition import KernelPCAX, y = make_moons(n_samples=100, random_state=123)scikit_kpca = KernelPCA(n_components=2, kernel='rbf', gamma=15)X_skernpca = scikit_kpca.fit_transform(X)plt.scatter(X_skernpcay == 0, 0, X_skernpcay == 0, 1,            color='red', marker='^', alpha=0.5)plt.scatter(X_skernpcay == 1, 0, X_skernpcay == 1, 1,            color='blue', marker='o', alpha=0.5)plt.xlabel('PC1')plt.ylabel('PC2')plt.tight_layout()plt.show()"
262,"문제풀이a, b = map(int, input().split())print(a + b)"
263,문제풀이n = ord(input())print(n - 44031)
264,Could not acquire management access for administrationRumtimeError: Unable to execute command chcp. Please make sure that C:\Windows\System32 directory is in your PATH environment variable.해결법 :(1) window키 +  R(2) services.msc 입력하고 엔터(3) MYSQL56 찾아서 서비스 시작 누르고 확인
265,"1. 메뉴를 만드는 데 사용되는 클래스가 아닌 것은?1) JMenu   2) JMenuItem   3) JMenuBar   4) Separator답 : 4번2. 다음 프로그램의 빈칸을 채워라.JMenuItem item1 = new JMenuItem(&quot;Open&quot;);JMenuItem item2 = new JMenuItem(&quot;Save&quot;);item1.addActionListener(new MyAction());item2.addActionListener(new MyAction());class MyAction implements _____ {    public void actionPerformed(ActionEvent e) {        String s = e.____();        if(s.equals(&quot;Open&quot;)) ....; // 열기 작업을 수행한다.        else ....; // 닫기 작업을 수행한다.    }}답 :JMenuItem item1 = new JMenuItem(&quot;Open&quot;);JMenuItem item2 = new JMenuItem(&quot;Save&quot;);item1.addActionListener(new MyAction());item2.addActionListener(new MyAction());class MyAction implements ActionListener {    public void actionPerformed(ActionEvent e) {        String s = e.getActionCommand();        if(s.equals(&quot;Open&quot;)) ....; // 열기 작업을 수행한다.        else ....; // 닫기 작업을 수행한다.    }}3. 툴바에 대해 잘못 설명한 것은?1) 툴바는 컨테이너이다.2) JToolBar를 이용하여 툴바를 만든다.3) 툴바는 반드시 BorderLayout 배치관리자를 가진 컨테이너만 붙는다.4) 툴바의 핸들을 마우스로 드래깅할 수 없게 만드는 메소드는 JToolBar의 setEnabled(false)이다.답 : 4번풀이 : setFloatable(false) 이다.4. 툴팁에 대해 잘못 설명한 것은?1) 툴팁은 JComponent를 상속받은 모든 스윙 컴포넌트에 달 수 있다.2) 툴팁은 반드시 문자열만 사용된다.3) 툴팁이 나타나지 않도록 설정하기 위해서는 JToolTip의 setEnabled(false) 메소드를 사용한다.4) 툴팁의 지속 시간을 제어할 수 있으며 설정된 시간은 모든 툴팁에 일괄적으로 적용된다.답 : 1번풀이 : 모든 스윙 컴포넌트들이 툴팁을 가질 수 있다.5. 다음 버튼에 &quot;안녕하세요&quot;라는 툴팁을 만드는 코드를 작성하라.JButton b = new JButton(&quot;Hello&quot;);_______________;답 :JButton b = new JButton(&quot;Hello&quot;);b.setToolTipText(&quot;안녕하세요&quot;);6. 다음 JLabel 컴포넌트에 마우스를 올리면 1초 후에 &quot;자바&quot;라는 툴팁이 나타나서 10초 동안 지속되도록 아래의 빈 줄에 코드를 삽입하라.JLabel la = new JLabel(&quot;Java&quot;);____________________________________________________답 :JLabel la = new JLabel(&quot;Java&quot;);la.setToolTipText(&quot;자바&quot;);ToolTipManager m = ToolTipManager.sharedInstance();m.setInitialDelay(1);m.setDissmissDelay(10);8. 다이얼로그와 관련이 제일 먼 것은 무엇인가?1) JDialog2) JOptionPane3) JFileChooser4) FileNameExtensionFilter5) JTabbedPane6) JColorChooser답 : 5번10. 다음 설명 중 틀린 것은 무엇인가?1) 컬러 다이얼로그는 모달 타입이다.2) 사용자가 파일 열기 다이얼로그 창을 닫으면 다이얼로그가 화면에서 사라지지만 다이얼로그 객체는 사라지지 않기 때문에 재사용이 가능하다.3) 파일 저장 다이얼로그에서 파일 이름을 선택한 후 &quot;닫기&quot; 버튼을 선택하여 정상적으로 닫기가 이루어진 경우, JFileChooser.saveFileDialog() 메소드는 JFileChooser.APPROVE_OPTION을 리턴한다.4) 탭팬에서 탭의 위치는 디폴트 값이 왼쪽, 즉 JTabbedPane.LEFT이다.답 : 3번풀이 : 파일 &quot;저장&quot; 버튼을 선택하였을 때 JFileChooser.APPROVE_OPTION을 리턴한다."
266,"1. C++ 표준 입출력 스트림의 특징이 아닌 것은?1) C++ 입력 스트림은 입력 장치에 연결하여 입력된 값을 프로그램에 전달하는 객체이다.2) C++ 출력 스트림은 출력 장치와 프로그램을 연결한다.3) C++ 표준 입출력 스트림은 GUI를 지원한다.4) C++ 표준에서 입출력 스트림은 제네릭 클래스로 작성되어 있다.답 : 3번2. C++ 표준 입출력 스트림은 버퍼를 가지고 있다. 버퍼에 대한 설명 중에서 틀린 것은?1) 키 입력 스트림 버퍼는 사용자가 입력 도중 입력된 키를 수정할 수 있게 한다.2) 출력 스트림 버퍼는 장치 접근 횟수를 줄여 장치에 대한 접근이 효율적이다.3) 입력된 키들은 키 입력 스트림 버퍼에 일단 저장되고, &lt;.Enter&gt; 키를 입력할 때 비로소 C++ 프로그램이 읽어 갈 수 있다.4) cout.plush()는 cout 버퍼를 모두 화면에 출력하게 한다.답 : 4번풀이 : cout.flush()이다.3. cin은 어떤 장치와 연결된 스트림 객체인가?답 : 키보드4. cout은 어떤 장치와 연결된 스트림 객체인가?답 : 모니터5. C++로 작성된 프로그램이 실행을 시작하면 자동으로 생성되는 C++ 표준 스트림 객체들에는 어떤 것들이 있는가?답 : cin, cout, cerr, clog6. 다음에서 템플릿으로 선언된 클래스가 아닌 것은?1) basic_ios2) istream3) vector4) list답 : 2번7. 현재 C++ 표준 입출력 라이브러리가 모두 재네릭 클래스로 작성된 가장 주된 이유는 무엇인가?1) 다국어 문자의 입출력을 지원하기 위해2) 템플릿으로 작성하여 코드의 중복을 줄이려고3) 제네릭 프로그래밍이 추세이므로4) 입출력 속도 향상을 위해답 : 1번8. 빈칸에 적절한 말을 채워라ios, istream, ostream 클래스는 basic_ios, basic_istream, basic_ostream 템플릿의 제네릭 타입을 ___ 타입으로 구체화시킨 클래스이다.답 : char10. 다음에서 get()과 getline()의 가장 큰 차이점은 무엇인가?char address100;cin.get(address, 100);cin.getline(address, 100);답 : 버퍼에 '\n'의 남아있는 지에 대한 여부11. &quot;Happy Birthday&quot; 문자열을 입력받는 코드로 잘못된 것은?char tmp100;1) cin &gt;&gt; tmp;2) cin.get(tmp, 100);3) cin.get(tmp, 100, '\n');4) cin.getline(tmp, 100);답 : 1번풀이 : cin &gt;&gt; tmp는 공백을 입력하는 순간 공백 전까지만 입력받기 때문이다. Happy 까지만 입력 받을 수 있다.12. 다음 프로그램을 실행하고 키보드로 Happy Birthday&lt;/Enter/&gt; 키를 입력하였다. 실행 결과는 무엇인가?char line80;cin.getline(line, 80);cout &lt;&lt; cin.gCount();답 : 15풀이 : getline은 엔터키까지 개수에 포함하기 때문에 다 더하면 15개이다.13. 다음 중 사용자가 입력하는 &lt;.Enter&gt; 키, 즉 '\n' 문자를 변수 ch나 buf 배열에 읽어들일 수 있는 것은? 복수 개로 답하라.1) char ch; cin &gt;&gt; ch;2) int ch; ch = cin.get();3) char ch; cin.get(ch);4) char buf10; cin.get(buf, 10);답 : 2, 3번풀이 : 4번이 안되는 이유는 엔터키를 입력하면 입력이 종료됨과 동시에 '\n'은 버퍼에 남아있기 때문이다.14. C++에서 포맷 입출력 방법이 아닌것은?1) 포맷 플래그를 설정하는 setf() 함수 이용2) 출력 포맷을 지정하는 width() 함수 이용3) endl 등과 같은 조작자 이용4) flush() 함수 이용답 : 4번15. 다음 중에서 조작자가 아닌 것은?1) hex2) left3) endl4) put답 : 4번16. 다음 프로그램의 실행 결과는 무엇인가?cout.width(12);cout.fill('%');cout &lt;&lt; &quot;C++&quot;;답 : %%%%%%%%%C++17. 다음 프로그램의 실행 결과는 무엇인가?cout.width(10);cout.percision(4);cout &lt;&lt; setfill('~') &lt;&lt; left &lt;&lt; 2./3.;답 : 0.6667~18. 다음 문장을 사용하고자 할 때 필요한 헤더 파일은 무엇인가?cout &lt;&lt; setw(10) &lt;&lt; &quot;hello&quot;;답 : &lt;,iomanip&gt; 헤더파일20. 조작자에 대해 잘못 말한 것은?1) 조작자는 함수이다.2) 조작자는 반드시 &lt;&lt; 나 &gt;&gt; 와 함께 사용된다.3) 사용자는 자신만의 조직자를 만들 수 있다.4) 조작자는 ostream이나 istream의 멤버 함수이다.답 : 4번"
267,"1. 예제 프로그램 - 간단한 그림 그리기 프로그램&lt;Command.java&gt;package ch22.Sample.command;// ‘명령’을 표현하기 위한 인터페이스public interface Command {    // 무언가를 실행하는 메소드    // 구체적으로 무슨 일을 하는지는     // Command 인터페이스를 구현한 클래스가 결정한다.    public abstract void execute();}&lt;DrawCommand.java&gt;package ch22.Sample.drawer;import ch22.Sample.command.Command;import java.awt.Point;// ‘그림 그리기 명령’을 표현함public class DrawCommand implements Command {    // 그림 그리기를 실행할 대상(객체)를 저장함    protected Drawable drawable;    // 그림 그리는 위치    private Point position;    // java.awt.Point 클래스: X좌표와 Y좌표를 갖는 클래스    // 2차원 평면 상의 위치를 나타냄    // 속성으로 x, y를 가진다.    // 생성자    public DrawCommand(Drawable drawable, Point position) {        this.drawable = drawable;        this.position = position;    }    // 실제 그리기를 실행하는 메소드    // drawable 필드의 draw 메소드를 호출함    public void execute() {        drawable.draw(position.x, position.y);    }}&lt;MacroCommand.java&gt;package ch22.Sample.command;import java.util.Stack;import java.util.Iterator;// ‘여러 개의 명령을 한데 모은 명령’을 나타냄// Composite 패턴이 사용됨// =&gt; 여러 개의 명령을 모은 것(container)이면서, // 그 자체가 하나의 명령(content)가 된다.public class MacroCommand implements Command {    // 다수의 Command를 모아둠    // Stack: 나중에 들어간 원소가 먼저 나오는 자료구조체    private Stack commands = new Stack();    // 실행    public void execute() {        // 자신이 가지고 있는 모든 명령의 execute( )을 호출한다(실행한다)        Iterator it = commands.iterator();        while (it.hasNext()) {            ((Command) it.next()).execute();        }        // 자신이 가지고 있는 명령이 MacroCommand이면,         // 그 MacroCommand가 가지고 있는 명령들의 execute( )이 차례대로 실행된다.        // (recursive call)    }    // MacroCommand 클래스에     // 새로운 Command(Command 인터페이스를 구현한 클래스의 인스턴스)를     // 추가하는 메소드    public void append(Command cmd) {        // 실수로 자기 자신을 추가하지 않도록 체크함        // 자기 자신이 추가되면, execute( ) 실행 시 무한 루프가 돌게 된다.        if (cmd != this) {            commands.push(cmd); // Stack 클래스의 push( )를 이용함        }    }    // commands의 마지막 명령을 삭제하는 메소드    public void undo() {        if (!commands.empty()) {            commands.pop();        }    }    // commands 의 모든 명령을 삭제하는 메소드    public void clear() {        commands.clear();    }}&lt;Drawable.java&gt;package ch22.Sample.drawer;// ‘그림 그리기 대상’을 표현함public interface Drawable {    public abstract void draw(int x, int y);}&lt;DrawCanvas.java&gt;package ch22.Sample.drawer;import ch22.Sample.command.*;import java.util.*;import java.awt.*;import java.awt.event.*;import javax.swing.*;// Drawable 인터페이스를 구현하고, java.awt.Canvas 를 상속함public class DrawCanvas extends Canvas implements Drawable {    // 그림 그리는 색    private Color color = Color.red;    // 그림 그리기를 할 점의 변경    private int radius = 6;    // 지금까지 실행한 그림 그리기 명령어들의 집합을 가지고 있음    private MacroCommand history;    // 폭, 높이, 그림 그리기 이력(history)를 받아서,    // DrawCanvas 인스턴스를 초기화한다.    public DrawCanvas(int width, int height, MacroCommand history) {        setSize(width, height);        setBackground(Color.white);        this.history = history;    }    // DrawCanvas를 다시 그릴 필요가 생겼을 때    // java.awt 프레임워크로부터 자동으로 호출되는 메소드    // repaint( ) 메소드가 호출되면, 화면이 지워진 후 자동으로 paint( ) 메소드가 실행된다.    public void paint(Graphics g) {        // history가 보관하고 있는 모든 그리기 명령들을 실행한다.        history.execute();    }    // 그리기    public void draw(int x, int y) {        // Graphics 객체를 얻어서,        Graphics g = getGraphics();        // 색깔을 빨간색으로 지정하고        g.setColor(color);        // Graphics 객체의 filloval(x, y, 사각형 가로, 사각형 세로)을         // 이용하여 원을 그린다.        g.fillOval(x - radius, y - radius, radius * 2, radius * 2);    }}&lt;Main.java&gt;package ch22.Sample;import ch22.Sample.command.*;import ch22.Sample.drawer.*;import java.awt.*;import java.awt.event.*;import javax.swing.*;// 예제 프로그램을 작동시키는 클래스public class Main extends JFrame implements ActionListener,        MouseMotionListener, WindowListener {    // DrawCanvas 생성 시에 인자로 넘겨줌    // Main 인스턴스와 DrawCanvas 인스턴스가 history를 공유한다.    private MacroCommand history = new MacroCommand();    // 그림 그리는 영역을 나타냄    private DrawCanvas canvas = new DrawCanvas(400, 400, history);    // javax.swing.JButton 클래스    // 그린 점들을 모두 지우는 버튼    private JButton clearButton = new JButton(&quot;clear&quot;);    public Main(String title) {        super(title);        // 리스너 등록하기        this.addWindowListener(this);        canvas.addMouseMotionListener(this);        clearButton.addActionListener(this);        // 여러 가지 GUI 부품을 배치함        // Box 객체를 이용함        // Box: BoxLayout 객체를 레이아웃매니저로 사용하는 가벼운 컨테이너        Box buttonBox = new Box(BoxLayout.X_AXIS);        buttonBox.add(clearButton);        Box mainBox = new Box(BoxLayout.Y_AXIS);        mainBox.add(buttonBox);        mainBox.add(canvas);        getContentPane().add(mainBox);        // 프레임을 화면에 보여준다.        pack();        setVisible(true);    }    // clearButton이 눌러졌을 때 호출되는 메소드    public void actionPerformed(ActionEvent e) {        if (e.getSource() == clearButton) {            history.clear(); // history에 보관되어 있던 모든 명령을 지우고            canvas.repaint(); // 캔버스의 repaint( )가 호출된다.        }    }    // MouseMotionListener    public void mouseMoved(MouseEvent e) {    }    // 사용자가 마우스를 drag 하면 이 메소드가 호출된다.    public void mouseDragged(MouseEvent e) {        // 그리기 명령을 나타내는 DrawCommand 객체를 생성한 후,        Command cmd = new DrawCommand(canvas, e.getPoint());  // e.getPoint( ) : 마우스 이벤트가 발생한 위치를 얻음        history.append(cmd); // 이를 history에 추가하고,        cmd.execute(); // 지정 위치에 빨간 점을 그린다.    }    // WindowListener    // 창의 오른 쪽 위 아이콘 중에  X 사각형을 눌렀을 때 호출되는 메소드    public void windowClosing(WindowEvent e) {        System.exit(0);    }    // WindowListener 인터페이스에 선언되어 있는 나머지 메소드들    // 구현할 필요가 없으므로, 빈 문장의 메소드로 구현되어 있다.    public void windowActivated(WindowEvent e) {    }    public void windowClosed(WindowEvent e) {    }    public void windowDeactivated(WindowEvent e) {    }    public void windowDeiconified(WindowEvent e) {    }    public void windowIconified(WindowEvent e) {    }    public void windowOpened(WindowEvent e) {    }    public static void main(String args) {        new Main(&quot;Command Pattern Sample&quot;);    }}2. 연습문제 3번 - 어댑터 사용&lt;Command.java&gt;package ch22.Sample.command;// ‘명령’을 표현하기 위한 인터페이스public interface Command {    // 무언가를 실행하는 메소드    // 구체적으로 무슨 일을 하는지는     // Command 인터페이스를 구현한 클래스가 결정한다.    public abstract void execute();}&lt;DrawCommand.java&gt;package ch22.A3.drawer;import ch22.A3.command.Command;import java.awt.Point;public class DrawCommand implements Command {    // 그림 그리는 대상    protected Drawable drawable;    // 그림 그리는 위치    private Point position;    // 생성자    public DrawCommand(Drawable drawable, Point position) {        this.drawable = drawable;        this.position = position;    }    // 실행    public void execute() {        drawable.draw(position.x, position.y);    }}&lt;MacroCommand.java&gt;package ch22.A3.command;import java.util.Stack;import java.util.Iterator;public class MacroCommand implements Command {    // 명열의 집합    private Stack commands = new Stack();    // 실행    public void execute() {        Iterator it = commands.iterator();        while (it.hasNext()) {            ((Command)it.next()).execute();        }    }    // 추가    public void append(Command cmd) {        if (cmd != this) {            commands.push(cmd);        }    }    // 최후의 명령을 삭제    public void undo() {        if (!commands.empty()) {            commands.pop();        }    }    // 전부 삭제    public void clear() {        commands.clear();    }}&lt;Drawable.java&gt;package ch22.A3.drawer;public interface Drawable {    public abstract void draw(int x, int y);}&lt;DrawCanvas.java&gt;package ch22.A3.drawer;import ch22.A3.command.*;import java.util.*;import java.awt.*;import java.awt.event.*;import javax.swing.*;public class DrawCanvas extends Canvas implements Drawable {    // 그림 그리는 색    private Color color = Color.red;    // 그림 그리기를 할 점의 반경    private int radius = 6;    // 이력    private MacroCommand history;    // 생성자    public DrawCanvas(int width, int height, MacroCommand history) {        setSize(width, height);        setBackground(Color.white);        this.history = history;    }    // 이력 전체를 다시 그리기    public void paint(Graphics g) {        history.execute();    }    // 그리기     public void draw(int x, int y) {        Graphics g = getGraphics();        g.setColor(color);        g.fillOval(x - radius, y - radius, radius * 2, radius * 2);    }}&lt;Main.java&gt;package ch22.A3;import ch22.A3.command.*;import ch22.A3.drawer.*;import java.awt.*;import java.awt.event.*;import javax.swing.*;public class Main extends JFrame implements ActionListener {            // 그리기 이력    private MacroCommand history = new MacroCommand();    // 그리기 영역    private DrawCanvas canvas = new DrawCanvas(400, 400, history);    // 제거 버튼    private JButton clearButton  = new JButton(&quot;clear&quot;);    // 생성자    public Main(String title) {        super(title);        this.addWindowListener(new WindowAdapter() {                    public void windowClosing(WindowEvent e) {                      System.exit(0);                                         }                                                       });                                                         canvas.addMouseMotionListener(new MouseMotionAdapter() {                public void mouseDragged(MouseEvent e) {                                Command cmd = new DrawCommand(canvas, e.getPoint());                    history.append(cmd);                                                    cmd.execute();                                                      }                                                                   });                                                                     clearButton.addActionListener(this);        Box buttonBox = new Box(BoxLayout.X_AXIS);        buttonBox.add(clearButton);        Box mainBox = new Box(BoxLayout.Y_AXIS);        mainBox.add(buttonBox);        mainBox.add(canvas);        getContentPane().add(mainBox);        pack();        setVisible(true);    }    // ActionListener용    public void actionPerformed(ActionEvent e) {        if (e.getSource() == clearButton) {            history.clear();            canvas.repaint();        }    }    public static void main(String args) {        new Main(&quot;Command Pattern Sample&quot;);    }}"
268,"1. 입출력 스트림에 내장된 버퍼에 관한 설명 중 틀린 것은?1) 표준 입출력 스트림은 내부 버퍼를 가지고 있다.2) flush 명령이 출력 스트림에 존재하는 이유는 버퍼 때문이다.3) C++ 표준 입력 스트림은 키 입력 즉시 응용프로그램에게 전달된다.4) C++ 표준에서는 스트림 입출력 되에 다른 입출력 방식은 정의하지 않는다.답 : 3번2. C++의 표준 입출력 라이브러리에 대한 설명 중 틀린 것은?1) 2003년 이전까지 C++ 입출력 라이브러리는 한 문자를 한 바이트로만 처리한다.2) 최신 표준의 C++ 입출력 라이브러리는 템플릿으로 작성되어 있다.3) ios, istream, ostream, iostream 등은 과거 C++ 입출력 스트림 클래스 이름으로서, 현재 응용 프로그램에서 사용할 수 없다.4) 현재 C++ 입출력 라이브러리로 문자 한 개가 2바이트 이상으로 표현되는 다국어를 입출력할 수 있다.답 : 3번풀이 : 사용할 수 있다.3. 다음은 키보드로부터 EOF(ctrl-z 키 입력, ^z)를 만날 때까지 문자를 읽고 화면에 출력하는 코드를 작성하고자 한다. 빈칸에 적절한 코드를 삽입하라.int ch;while(____) {    cout.put(ch);}답 :int ch;while((ch = cin.get()) != EOF) {    cout.put(ch);}4. 다음 코드로 한글 문자를 읽을 수 있는가? 그 이유를 말하여라.char ch;cin &gt;&gt; ch;답 : 읽을 수 없다. cin은 basic_istream 템플릿으로부터 char 타입으로 구체화하여 생성된 객체이므로 char 타입의 문자만 다루는데, 2바이트인 한글은 다룰 수 없다.5. 아래 코드에 대해 설명한 다음 글의 빈칸을 채워라.char buf80;cin.getline(buf, 80, '\n');이 코드는 _키가 입력될 때까지 문자열을 읽는다. 읽어들일 수 있는 총 문자의 개수는 _개 이며, 문자열을 읽은 후 cin의 버퍼에서 _문자를 제거한다. 이 코드로 한글을 읽을 수 _다.답 : &lt;.Enter&gt; , 79 , '\n' , 있6. 다음과 같이 키보드에서 읽어 Circle 객체를 완성하고 다시 화면에 출력하고자 한다.Circle donut;cin &gt;&gt; donut; // 키보드로부터 값을 읽어 donut 완성cout &lt;&lt; donut; // donut 객체 출력(1) &lt;&lt;와 &gt;&gt; 연산자 함수의 원형은 각각 무엇인가?답 : ostream&amp; operator &lt;&lt; (ostream&amp;, Circle); istream&amp; operator &gt;&gt; (istream&amp;, Circle&amp;);"
269,"1. 예제 11-1 : ostream 멤버 함수를 이용한 문자 출력#include &lt;iostream&gt;using namespace std;int main() {    // &quot;Hi!&quot;를 출력하고 다음 줄로 넘어간다.    cout.put('H');    cout.put('i');    cout.put(33); // ASCII 코드 33은 '!' 문자임    cout.put('\n');    // &quot;C++&quot;을 출력한다.    cout.put('C').put('+').put('+').put(' ');    char str = &quot;I love programming&quot;;    cout.write(str, 6); // str 배열의 6개의 문자 &quot;I love&quot;를 스트림에 출력}2. 예제 11-2 : get()과 get(char&amp;)을 이용한 한 줄의 문자 읽기#include &lt;iostream&gt;using namespace std;void get1() {    cout &lt;&lt; &quot;cin.get()로 &lt;Enter&gt; 키까지 입력 받고 출력합니다&gt;&gt;&quot;;    int ch; // EOF와의 비교를 위해 int 타입으로 선언    while ((ch = cin.get()) != EOF) { // 문자 읽기. EOF는 -1        cout.put(ch); // 읽은 문자 출력        if (ch == '\n') break; // &lt;Enter&gt; 키가 입력되면 읽기 중단    }}void get2() {    cout &lt;&lt; &quot;cin.get(char&amp;)로 &lt;Enter&gt;키까지 입력 받고 출력합니다&gt;&gt;&quot;;    char ch;    while (true) {        cin.get(ch); // 문자 읽기        if (cin.eof()) break; // EOF를 만나면 읽기 종료        cout.put(ch); // ch의 문자 출력        if (ch == '\n') break; // &lt;Enter&gt; 키가 입력되면 읽기 중단    }}int main() {    get1(); // cin.get()을 이용하는 사례    get2(); // cin.get(char&amp;)을 이용하는 사례}3. 예제 11-3 : get(char*, int)을 이용한 문자열 입력#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    char cmd80;    cout &lt;&lt; &quot;cin.get(char*, int)로 문자열을 읽습니다.&quot; &lt;&lt; endl;    while (true) {        cout &lt;&lt; &quot;종료하려면 exit을 입력하세요 &gt;&gt; &quot;;        cin.get(cmd, 80); // 79개까지의 영어 문자 읽음.        if (strcmp(cmd, &quot;exit&quot;) == 0) {            cout &lt;&lt; &quot;프로그램을 종료합니다....&quot;;            return 0;        }        else            cin.ignore(1); // 버퍼에 남아있는 &lt;Enter&gt; 키 ('\n') 제거    }}4. 예제 11-4 : getline()으로 한 줄 단위로 문장 읽기#include &lt;iostream&gt;using namespace std;int main() {    char line80;    cout &lt;&lt; &quot;cin.getline() 함수로 라인을 읽습니다.&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;exit를 입력하면 루프가 끝납니다.&quot; &lt;&lt; endl;    int no = 1; // 라인 번호    while (true) {        cout &lt;&lt; &quot;라인 &quot; &lt;&lt; no &lt;&lt; &quot;&gt;&gt; &quot;;        cin.getline(line, 80); // 79개까지의 문자 읽음        if (strcmp(line, &quot;exit&quot;) == 0)            break;        cout &lt;&lt; &quot;echo --&gt; &quot;;        cout &lt;&lt; line &lt;&lt; endl; // 읽은 라인을 화면에 출력        no++; // 라인 번호 증가    }}5. 예제 11-5 : setf(), unsetf()를 사용한 포맷 출력#include &lt;iostream&gt;using namespace std;int main() {    cout &lt;&lt; 30 &lt;&lt; endl; // 10진수로 출력    cout.unsetf(ios::dec);  // 10진수 해제    cout.setf(ios::hex); // 16진수로 설정    cout &lt;&lt; 30 &lt;&lt; endl;    cout.setf(ios::showbase); // 16진수로 설정    cout &lt;&lt; 30 &lt;&lt; endl;    cout.setf(ios::uppercase); // 16진수의 A~F는 대문자로 출력    cout &lt;&lt; 30 &lt;&lt; endl;    cout.setf(ios::dec | ios::showpoint); // 10진수 표현과 동시에 소숫점 이하 나머지는 0으로 출력    cout &lt;&lt; 23.5 &lt;&lt; endl;    cout.setf(ios::scientific); // 실수를 과학산술용 표현으로 출력    cout &lt;&lt; 23.5 &lt;&lt; endl;    cout.setf(ios::showpos); // 양수인 경우 + 부호도 함께 출력    cout &lt;&lt; 23.5;}6. 예제 11-6 : width(), fill(), precision()을 사용한 포맷 출력#include &lt;iostream&gt;using namespace std;void showWidth() {    cout.width(10); // 다음에 출력되는 &quot;hello&quot;를 10 칸으로 지정    cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl;    cout.width(5); // 다음에 출력되는 정수 12를 5 칸으로 지정    cout &lt;&lt; 12 &lt;&lt; endl;    cout &lt;&lt; '%';    cout.width(10); // 다음에 출력되는 &quot;Korea/&quot;만 10 칸으로 지정    cout &lt;&lt; &quot;Korea/&quot; &lt;&lt; &quot;Seoul/&quot; &lt;&lt; &quot;City&quot; &lt;&lt; endl;}int main() {    showWidth();    cout &lt;&lt; endl;    cout.fill('^');    showWidth();    cout &lt;&lt; endl;    cout.precision(5);    cout &lt;&lt; 11. / 3. &lt;&lt; endl;}7. 예제 11-7 : 매개 변수 없는 조작자 사용#include &lt;iostream&gt;using namespace std;int main() {    cout &lt;&lt; hex &lt;&lt; showbase &lt;&lt; 30 &lt;&lt; endl;    cout &lt;&lt; dec &lt;&lt; showpos &lt;&lt; 100 &lt;&lt; endl;    cout &lt;&lt; true &lt;&lt; ' ' &lt;&lt; false &lt;&lt; endl;    cout &lt;&lt; boolalpha &lt;&lt; true &lt;&lt; ' ' &lt;&lt; false &lt;&lt; endl;}8. 예제 11-8 : 매개 변수를 가진 조작자 사용 예#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main() {    cout &lt;&lt; showbase;    // 타이틀을 출력한다.    cout &lt;&lt; setw(8) &lt;&lt; &quot;Number&quot;;    cout &lt;&lt; setw(10) &lt;&lt; &quot;Octal&quot;;    cout &lt;&lt; setw(10) &lt;&lt; &quot;Hexa&quot; &lt;&lt; endl;    // 하나의 수를 십진수, 8진수 16진수 형태로 한 줄에 출력한다.    for (int i = 0; i &lt; 50; i += 5) {        cout &lt;&lt; setw(8) &lt;&lt; setfill('.') &lt;&lt; dec &lt;&lt; i; // 10진수        cout &lt;&lt; setw(10) &lt;&lt; setfill(' ') &lt;&lt; oct &lt;&lt; i; // 8진수        cout &lt;&lt; setw(10) &lt;&lt; setfill(' ') &lt;&lt; hex &lt;&lt; i &lt;&lt; endl; // 16진수    }}9. 예제 11-9 : Point 객체를 스트림에 출력하는 &lt;&lt; 연산자 작성#include &lt;iostream&gt;using namespace std;class Point { // 한 점을 표현하는 클래스    int x, y; // private 멤버public:    Point(int x = 0, int y = 0) {        this-&gt;x = x;        this-&gt;y = y;    }    friend ostream&amp; operator &lt;&lt; (ostream&amp; stream, Point a);};// &lt;&lt; 연산자 함수ostream&amp; operator &lt;&lt; (ostream&amp; stream, Point a) {    stream &lt;&lt; &quot;(&quot; &lt;&lt; a.x &lt;&lt; &quot;,&quot; &lt;&lt; a.y &lt;&lt; &quot;)&quot;;    return stream;}int main() {    Point p(3, 4); // Point 객체 생성    cout &lt;&lt; p &lt;&lt; endl; // Point 객체 화면 출력    Point q(1, 100), r(2, 200); // Point 객체 생성    cout &lt;&lt; q &lt;&lt; r &lt;&lt; endl; // Point 객체들 연속하여 화면 출력}10. 예제 11-10 : Book 클래스를 만들고 Book 객체를 스트림에 출력하는 &lt;&lt; 연산자 작성#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Book { // 책을 표현하는 클래스    string title;    string press;    string author;public:    Book(string title = &quot;&quot;, string press = &quot;&quot;, string author = &quot;&quot;) {        this-&gt;title = title;        this-&gt;press = press;        this-&gt;author = author;    }    friend ostream&amp; operator &lt;&lt; (ostream&amp; stream, Book b); // friend 선언};// &lt;&lt; 연산자 함수ostream&amp; operator &lt;&lt; (ostream&amp; stream, Book b) {    stream &lt;&lt; b.title &lt;&lt; &quot;,&quot; &lt;&lt; b.press &lt;&lt; &quot;,&quot; &lt;&lt; b.author;    return stream;}int main() {    Book book(&quot;소유냐 존재냐&quot;, &quot;한국출판사&quot;, &quot;예리히프롬&quot;); // Book 객체 생성    cout &lt;&lt; book; // Book 객체 book 화면 출력}11. 예제 11-11 : Point 객체를 입력 받는 &gt;&gt; 연산자 작성#include &lt;iostream&gt;using namespace std;class Point { // 한 점을 표현하는 클래스    int x, y; // private 멤버public:    Point(int x = 0, int y = 0) {        this-&gt;x = x;        this-&gt;y = y;    }    friend istream&amp; operator &gt;&gt; (istream&amp; ins, Point&amp; a); // friend 선언    friend ostream&amp; operator &lt;&lt; (ostream&amp; stream, Point a); // friend 선언};istream&amp; operator &gt;&gt; (istream&amp; ins, Point&amp; a) { // &gt;&gt; 연산자 함수    cout &lt;&lt; &quot;x 좌표&gt;&gt;&quot;;    ins &gt;&gt; a.x;    cout &lt;&lt; &quot;y 좌표&gt;&gt;&quot;;    ins &gt;&gt; a.y;    return ins;}ostream&amp; operator &lt;&lt; (ostream&amp; stream, Point a) { // &lt;&lt; 연산자 함수    stream &lt;&lt; &quot;(&quot; &lt;&lt; a.x &lt;&lt; &quot;,&quot; &lt;&lt; a.y &lt;&lt; &quot;)&quot;;    return stream;}int main() {    Point p; // Point 객체 생성    cin &gt;&gt; p; // &gt;&gt; 연산자 호출하여 x 좌표와 y 좌표를 키보드로 읽어 객체 p 완성    cout &lt;&lt; p; // &lt;&lt; 연산자 호출하여 객체 p 출력}"
270,"1. 스트림 : 데이터의 흐름, 혹은 데이터를 전송하는 소프트웨어 모듈스트림의 양 끝에는 프로그램과 장치 연결, 보낸 순서대로 데이터 전달입출력 기본 단위 : 바이트종류입력 스트림 : 입력 장치, 네트워크, 파일로부터 데이터를 프로그램으로 전달하는 스트림출력 스트림 : 프로그램에서 출력되는 데이터를 출력 장치, 네트워크, 파일로 전달하는 스트림2. C++ 입출력 스트림 버퍼1) 키 입력 스트림의 버퍼 - 입력 장치로부터 입력된 데이터를 프로그램으로 전달하기 전에 일시 저장키 입력 도중 수정 가능 : 백스페이스 키가 입력되면 이전에 입력된 키를 버퍼에서 지움프로그램은 사용자의 키 입력이 끝난 시점에서 읽음 엔터키 : 키 입력의 끝을 의미엔터키가 입력된 시점부터 키 입력 버퍼에서 프로그램이 읽기 시작2) 스크린 출력 스트림 버퍼 - 프로그램에서 출력된 데이터를 출력 장치로 보내기 전에 일시 저장버퍼가 꽉 차거나 강제 출력 명령 시에 출력 장치에 출력3. C++ 표준은 스트림 입출력만 지원스트림 입출력 방식(stream I/O) : 스트림 버퍼를 이용한 입출력 방식입력된 키는 버퍼에 저장 - 엔터 키가 입력되면 프로그램이 버퍼에서 읽어가는 방식출력되는 데이터는 일차적으로 스트림 버퍼에 저장  -&gt; 버퍼가 꽉 차거나, '\n'을 만나거나, 강제 출력 명령의 경우에만 버퍼가 출력 장치에 출력4. 표준 입출력 스트림 객체C++ 프로그램이 실행될 때 자동으로 생겨나는 스트림cin : istream 타입의 스트림 객체로서 키보드 장치와 연결cout : ostream 타입의 스트림 객체로서 스크린 장치와 연결cerr : ostream 타입의 스트림 객체로서 스크린 장치와 연결오류 메시지를 출력할 목적, 스트림 내부 버퍼 거치지 않고 출력clog : ostream 타입의 스트림 객체로서 스크린 장치와 연결오류 메시지를 출력할 목적, 스트림 내부에 버퍼 거쳐 출력5. ostream 멤버 함수ostream&amp; put(char ch) : ch의 문자를 스트림에 출력ostream&amp; write(char* str, int n) : str 배열에 있는 n 개의 문자를 스트림에 출력ostream&amp; flush() : 현재 스트림 버퍼에 있는 내용 강제 출력6. istream 멤버 함수 - 문자 입력, get() 함수int get() : 입력 스트림에서 문자를 읽어 리턴. 오류나 EOF를 만나면 -1(EOF) 리턴istream&amp; get(char&amp; ch) : 입력 스트림에서 문자를 읽어 ch에 저장. 현재 입력 스트림 객체(*this)의 참조 리턴. 오류나 EOF를 만나면, 스트림 내부의 오류 플래그(failbit) 세팅int ch;while((ch = cin.get()) != EOF) { // EOF는 -1  cout.put(ch); // 읽은 문자 출력  if(ch == '\n')      break; // &lt;Enter&gt; 키가 입력되면 읽기 중단}char ch;while(true) {  cin.get(ch); // 입력된 키를 ch에 저장하여 리턴  if(cin.eof()) break; // EOF를 만나면 읽기 종료  cout.put(ch); // ch의 문자 출력  if(ch == '\n')      break; // &lt;Enter&gt; 키가 입력되면 읽기 중단}7. 문자열 입력istream&amp; get(char* s, int n) : 입력 스트림으로부터 n-1 개의 문자를 읽어 배열 s에 저장하고 마지막에 '\0' 문자 삽입. 입력 도중 '\n'을 만나면 '\0'을 삽입하고 리턴=&gt; 입력 도중 키('\n')을 만날 때 - 읽기를 중단하고 리턴, 다시 get()으로 문자열 읽기를 시도하면 입력 스트림에 남은 '\n' 키를 읽게 되어 무한 루프에 빠짐  =&gt; cin.get()이나 cin.ignore(1);를 통해 문자 1개('\n')을 스트림에서 읽어 버려야 함8. 한 줄 읽기istream&amp; get(char* s, int n, char delim='\n') - '\n' 문자 버퍼에 남겨둠istream&amp; getline(char* s, int n, char delim='\n') - get()과 동일, 하지만 delim에 지정된 구분 문자를 스트림에서 제거** 9. 입력 문자 건너 띄기와 문자 개수 알아내기**istream&amp; ignore(int n=1, int delim=EOF) - 입력스트림에서 n개 문자 제거. 도중에 delim 문자를 만나면 delim문자를 제거하고 리턴int gcount() - 최근에 입력 스트림에서 읽은 바이트 수(문자의 개수) 리턴.  키도 개수에 포함cin.ignore(10); // 입력 스트림에 입력된 문자 중 10개 제거cin.ignore(10, ';'); // 입력 스트림에서 10개의 문자 제거. 제거 도중 ';'를 만나면 종료10. 포맷 입출력 - 포맷 플래그, 포맷 함수, 조작자포맷 플래그 : 입출력 스트림에서 입출력 형식을 지정하기 위한 플래그플래그값의미ios::skipwq0x001입력시 공백 문자(스페이스, 탭, 개행문자)를 무시ios::unitbuf0x002출력 스트림에 들어오는 데이터를 버퍼링하지 않고 바로 출력ios::uppercase0x000416진수의 A~F. 지수 표현의 E를 대문자로 표현ios::showbase0x000816진수이면 0x를, 8진수이면 0을 숫자 앞에 붙여 출력ios::showpoint0x0010실수 값에 대해, 정수 부분과 더불어 소수점 이하의 끝자리들을 0으로 출력ios::showpos0x0020양수에 대해 + 기호 출력ios::left0x0040필드를 왼쪽 맞춤(left-aling)형식으로 출력ios::right0x0080필드를 오른쪽 맞춤(right-aling)형식으로 출력ios::internal0x0100부호는 왼쪽 맞춤으로 숫자는 오른쪽 맞춤으로 출력ios::dec0x020010진수로 출력. 디폴트 설정ios::oct0x04008진수로 출력ios::hex0x080016진수로 출력ios::scientific0x1000실수에 대해 과학 산술용 규칙에 따라 출력ios::fixed0x2000실수에 대해 소수점 형태로 출력ios::boolalpha0x4000설정되면, 논리값 true를 &quot;true&quot;로, false를 &quot;false&quot;로 출력하고, 설정되지 않으면, 정수 1과 0으로 출력☑️포맷 플래그를 세팅하는 멤버 함수☑️(1) long setf(long flags) : flags를 스트림의 포맷 플래그로 설정하고 이전 플래그를 리턴한다.(2) long unsetf(long flags) : floags에 설정된 비트 값에 따라 스트림의 포맷 플래그를 해제하고 이전 플래그를 리턴=&gt; 포맷 플래그는 한 번 설정하면 해제할 때까지 유지포맷 함수 활용(1) int width(int minwidth) : 출력되는 필드의 최소 너비를 minwidth로 설정하고 이전에 설정된 너비값 리턴(2) char fill(char cfill) : 필드의 빈칸을 cfill문자로 채우도록 지정하고 이전 문자 값 리턴(3) int precision(int np) : 출력되는 수의 유효숫자 자리수를 np개로 설정. 정수 부분과 소수점 이하의 수의 자리를 모두 포함하고 소수점(.)은 제외조작자 - 조작자는 함수, 항상 &lt;&lt; 나 &gt;&gt; 연산자와 함께 사용됨(1) 매개 변수 없는 조작자조작자I/O용도endlO스트림 버퍼를 모두 출력하고 다음 줄로 넘어감octO정수 필드를 8진수 기반으로 출력decO정수 필드를 10진수 기반으로 출력hexO정수 필드를 16진수 기반으로 출력leftO왼쪽 맞춤으로 출력rightO오른쪽 맞춤으로 출력fixedO실수 필드를 고정 소수점 방식으로 출력scientificO실수 필드를 과학 산술용 방식으로 출력flushO스트림 버퍼 강제 출력showbaseO16진수의 경우 0x로, 8진수의 경우 0을 앞에 붙여서 출력noshowbaseOshowbase지정 취소showpointO실수 값에 대해, 정수 부분과 소수점 이하의 끝자리 이후 남은 공간을 0으로 출력noshowpointOshowpoint 지정 취소showposO양수인 경우 + 부호를 붙여 출력skipwsI입력 스트림에서 공백 문자를 읽지않고 건너뜀noskipwsIskipws지정취소boolalphaO불린 값이 출력될 때, &quot;true&quot;혹은 &quot;false&quot;문자열로 출력  (2) 매개 변수를 가진 조작자조작자I/O용도resetioflags(long flags)IOflags에 지정된 플래그들 해제setbase(int base)Obase를 출력할 수의 진수로 지정setfill(char cFill)I필드를 출력하고 남은 공간에 cFIll문자로 채움setioflags(long flags)IOflags를 스트림 입출력 플래그로 설정setprecision(int np)O출력되는 수의 유효숫자 자리수를 np개로 설정. 소수점(.)은 별도의 카운트setw(int minWidth)O필드의 최소 너비를 minWidth로 지정** 11. 삽입 연산자(&lt;&lt;) - insertion operator, 삽입자라고도 부름 / ostream 클래스에서 중복 작성되어 있음 **12. 사용자 삽입 연산자 만들기 =&gt; 클래스 private 멤버변수 사용한다면 friend 키워드 필수ostream&amp; operator &lt;&lt; (ostream&amp; stream, Point a) {    stream &lt;&lt; &quot;(&quot; &lt;&lt; a.x &lt;&lt; &quot;,&quot; &lt;&lt; a.y &lt;&lt; &quot;)&quot;;    return stream;}13.추출 연산자(&gt;&gt;) - extraction operator / istream 클래스에서 중복 작성되어 있음14. 사용자 추출 연산자 만들기 =&gt; 클래스 private 멤버 변수 사용한다면 friend 키워드 필수istream&amp; operator &gt;&gt; (istream&amp; ins, Ponit &amp;a) {    cout &lt;&lt; &quot;x 좌표&gt;&gt;&quot;;    ins &gt;&gt; a.x;    cout &lt;&lt; &quot;y 좌표&gt;&gt;&quot;;    ins &gt;&gt; a.y;    return ins;}"
271,"4.1 누락된 데이터 다루기4.1.1 테이블 형태 데이터에서 누락된 값 식별☑️CSV로부터 간단한 예제 데이터셋 만들기☑️read_csv 함수 : CSV 포맷의 데이터를 판다스 DataFrame으로 읽어들임두 개의 누락된 값은 NaN으로 바꿈StringIO 함수 : 하드 디스크에 있는 일반 CSV 파일처럼 csv_data에 저장된 문자열을 읽어들임import pandas as pdfrom io import StringIOimport syscsv_data = '''A,B,C,D1.0,2.0,3.0,4.05.0,6.0,,8.010.0,11.0,12.0,'''파이썬 2.7을 사용하는 경우다음과 같이 문자열을 유니코드로 변환해야 합니다:#if (sys.version_info &lt; (3, 0)):csv_data = unicode(csv_data)df = pd.read_csv(StringIO(csv_data))df!(https://velog.velcdn.com/images/rosesua318/post/48140e74-e5cc-4913-b576-08f7e31d40db/image.png)&lt;br&gt;#### 4.1.2 누락된 값이 있는 훈련 샘플이나 특성 제외- dropna 메서드 : 누락된 값이 있는 행을 삭제``` python# 누락된 값이 있는 행을 삭제합니다df.dropna(axis=0)axis=1 : NaN이 하나라도 있는 열을 삭제# 누락된 값이 있는 열을 삭제합니다df.dropna(axis=1)!(https://velog.velcdn.com/images/rosesua318/post/3db81e82-fdcd-448d-89a8-52e07f3dd06f/image.png)&lt;br&gt;- how='all' : 모든 열이 NaN일 때만 행을 삭제``` python# 모든 열이 NaN인 행을 삭제합니다# (여기서는 모든 값이 NaN인 행이 없기 때문에 전체 배열이 반환됨)df.dropna(how='all')  thresh=4 : NaN이 아닌 값이 네 개보다 작은 행을 삭제# NaN 값이 네 개보다 작은 행을 삭제합니다df.dropna(thresh=4)!(https://velog.velcdn.com/images/rosesua318/post/b7504a82-c311-40e8-a68d-382f9ed387e7/image.png)&lt;br&gt;- subset='C' : 특정 열에 NaN이 있는 행만 삭제(여기서는 'C'열)``` python# 특정 열에 NaN이 있는 행만 삭제합니다(여기서는 'C'열)df.dropna(subset='C')➡️ 단점 : 너무 많은 데이터를 제거하면 안정된 분석 불가능, 중요한 정보를 잃을 위험4.1.3 누락된 값 대체보간 기법 : 데이터셋에 있는 다른 훈련 샘플로부터 누락된 값을 추정📍종류📍1) 평균으로 대체 : 각 특성 열의 전체 평균으로 누락된 값을 바꿈사이킷런의 SimpleImputer 클래스 사용하면 처리 가능 strategy='median' : 데이터를 순서대로 나열했을 때 중간에 위치한 값으로 누락된 값을 대체strategy='most_frequent' : 가장 많이 나타난 값으로 누락된 값을 대체strategy='mean' : 전체 평균으로 누락된 값을 대체# 행의 평균으로 누락된 값 대체하기from sklearn.impute import SimpleImputerimport numpy as npimr = SimpleImputer(missing_values=np.nan, strategy='mean')imr = imr.fit(df.values)imputed_data = imr.transform(df.values)imputed_data!(https://velog.velcdn.com/images/rosesua318/post/887a2e15-2c1f-4982-9423-1bac2b3ecfaa/image.png)- 판다스의 fillna 메서드에 매개변수로 누락된 값을 채울 방법 전달    - df.mean() : 평균값으로 누락된 값을 대체    ``` python    df.fillna(df.mean())    ```    !(https://velog.velcdn.com/images/rosesua318/post/526e1328-93fa-422f-b208-6e5a51e5f841/image.png)    - method='bfill' : 누락된 값을 다음 행의 값으로 대체    ``` python    df.fillna(method='bfill') # method='backfill'와 같습니다    ```    !(https://velog.velcdn.com/images/rosesua318/post/ff256ec7-2a92-4e62-81de-5b5b136be1e0/image.png)    - method='ffill' : 누락된 값을 이전 행의 값으로 대체    ``` python    df.fillna(method='ffill') # method='pad'와 같습니다    ```    !(https://velog.velcdn.com/images/rosesua318/post/d59e68c0-47f7-4ec9-9083-ae73061517ad/image.png)    - axis=1 : 행이 아니라 열을 사용    ``` python    # 이전 열의 값으로 누락된 값을 대체    df.fillna(method='ffill', axis=1)    ```    !(https://velog.velcdn.com/images/rosesua318/post/f708bc89-3a3b-4899-bde7-859d9e597ca4/image.png)&lt;br&gt;#### 4.1.4 사이킷런 추정기 API 익히기☑️사이킷런 변환기의 훈련과 변환 과정☑️!(https://velog.velcdn.com/images/rosesua318/post/7a6a36bb-a114-4f83-81b0-3787d9e726da/image.png)&lt;br&gt;☑️사이킷런 추정기의 훈련과 예측 과정☑️!(https://velog.velcdn.com/images/rosesua318/post/42dd7a51-e683-46b3-8014-1ee5a2abbec7/image.png)&lt;br&gt;&lt;br&gt;### 4.2 범주형 데이터 다루기범주형 데이터 - 순서가 있는 것과 없는 것- 순서가 있는 특성 : 차례대로 놓을 수 있는 범주형 특성     - 예 : 티셔츠 사이즈 XL &gt; L &gt; M- 순서가 없는 특성 : 차례를 부여할 수 없는 범주형 특성    - 예 : 티셔츠 컬러 (순서가 ❌)&lt;br&gt;#### 4.2.1 판다스를 사용한 범주형 데이터 인코딩☑️범주형 데이터 인코딩☑️``` pythonimport pandas as pddf = pd.DataFrame('green', 'M', 10.1, 'class2',                   'red', 'L', 13.5, 'class1',                   'blue', 'XL', 15.3, 'class2')df.columns = 'color', 'size', 'price', 'classlabel'df➡️ color(순서 ❌), size(순서 ⭕), price(수치형 특성), 마지막 열은 클래스 레이블4.2.2 순서가 있는 특성 매핑☑️범주형의 문자열 값을 정수로 바꿔주는 매핑 함수 만들기☑️size_mapping = {'XL': 3,                'L': 2,                'M': 1}df'size' = df'size'.map(size_mapping)df☑️정수 값을 다시 문자열 표현으로 바꾸는 매핑 딕셔너리 정의☑️inv_size_mapping = {v: k for k, v in size_mapping.items()}df'size'.map(inv_size_mapping)4.2.3 클래스 레이블 인코딩☑️클래스 레이블을 정수로 바꾸기 위해 매핑 딕셔너리 생성☑️enumerate : 반복 가능한 객체를 입력으로 받아 인덱스와 값의 튜플을 차례대로 반환하는 파이썬 내장 함수import numpy as np클래스 레이블을 문자열에서 정수로 바꾸기 위해매핑 딕셔너리를 만듭니다class_mapping = {label: idx for idx, label in enumerate(np.unique(df'classlabel'))}class_mapping!(https://velog.velcdn.com/images/rosesua318/post/16ca06fc-736c-47a5-9d26-6f9f3bfcd62d/image.png)&lt;br&gt;☑️매핑 딕셔너리로 클래스 레이블을 정수로 변환☑️``` python# 클래스 레이블을 문자열에서 정수로 바꿉니다df'classlabel' = df'classlabel'.map(class_mapping)df☑️클래스 레이블을 원본 문자열로 매핑☑️# 클래스 레이블을 거꾸로 매핑합니다inv_class_mapping = {v: k for k, v in class_mapping.items()}df'classlabel' = df'classlabel'.map(inv_class_mapping)df☑️사이킷런 LabelEncoder 클래스로 레이블 인코딩☑️fit_transform : fit 메서드와 transform 메서드를 합쳐 놓은 단축 메서드from sklearn.preprocessing import LabelEncoder사이킷런의 LabelEncoder을 사용한 레이블 인코딩class_le = LabelEncoder()y = class_le.fit_transform(df'classlabel'.values)y!(https://velog.velcdn.com/images/rosesua318/post/b7b17f43-e2e6-4169-b451-2370bf903c44/image.png)&lt;br&gt;☑️클래스 레이블을 원본 문자열로 매핑☑️- inverse_transform : 정수 클래스 레이블을 원본 문자열 형태로 되돌림``` python# 거꾸로 매핑class_le.inverse_transform(y)4.2.4 순서가 없는 특성에 원-핫 인코딩 적용☑️순서가 없는 특성 문자열 레이블 인코딩☑️X = df'color', 'size', 'price'.valuescolor_le = LabelEncoder()X:, 0 = color_le.fit_transform(X:, 0)X원-핫 인코딩 기법 : 순서 없는 특성에 들어 있는 고유한 값마다 새로운 더미 특성을 만드는 것☑️사이킷런으로 원-핫 인코딩 수행☑️One HotEncoder : 원-핫 인코딩을 수행해줌from sklearn.preprocessing import OneHotEncoderX = df'color', 'size', 'price'.valuescolor_ohe = OneHotEncoder()color_ohe.fit_transform(X:, 0.reshape(-1, 1)).toarray()!(https://velog.velcdn.com/images/rosesua318/post/a92e782d-fa00-42dc-a699-71cc787a4558/image.png)&lt;br&gt;☑️ColumnTransformer를 사용하여 변환☑️- ColumnTransformer : 여러 개의 특성이 있는 배열에서 특정 열만 변환- passthrough : 변경하지 않는 열에 지정하면 변환하지 않음- dtype=np.int : 정수로 원-핫 인코딩``` pythonfrom sklearn.compose import ColumnTransformerX = df'color', 'size', 'price'.valuesc_transf = ColumnTransformer( ('onehot', OneHotEncoder(dtype=np.int), 0),                               ('nothing', 'passthrough', 1, 2))c_transf.fit_transform(X)☑️판다스로 원-핫 인코딩 더미 변수 만들기☑️get_dummies 메서드 : 문자열 열만 변환하고 나머지 열은 그대로 둠# 원-핫 인코딩 via 판다스pd.get_dummies(df'price', 'color', 'size')!(https://velog.velcdn.com/images/rosesua318/post/1a48b37f-9228-481b-bcb9-6018ece50916/image.png)&lt;br&gt;- drop_first=True : 첫 번째 열을 삭제``` python# get_dummies에서 다중 공선성 문제 처리pd.get_dummies(df'price', 'color', 'size', drop_first=True)drop='first' : 인코딩된 특성 중 첫 번째 열을 삭제categories='auto' : 중복된 열을 삭제# OneHotEncoder에서 다중 공선성 문제 처리 (중복된 열 삭제)color_ohe = OneHotEncoder(categories='auto', drop='first')c_transf = ColumnTransformer( ('onehot', color_ohe, 0),                               ('nothing', 'passthrough', 1, 2))c_transf.fit_transform(X)!(https://velog.velcdn.com/images/rosesua318/post/fde6e110-9dd4-4dea-9e4e-be84e8882abe/image.png)&lt;br&gt;&lt;br&gt;### 4.3 데이터셋을 훈련 데이터셋과 테스트 데이터셋으로 나누기Wine 데이터셋 - 178개의 와인 샘플과 여러 가지 화학 성분을 나타내는 13개의 특성으로 구성☑️Wine 데이터셋 읽어들이기☑️``` pythondf_wine = pd.read_csv('https://archive.ics.uci.edu/'                      'ml/machine-learning-databases/wine/wine.data',                      header=None)# UCI 머신러닝 저장소의 Wine 데이터셋에 접근되지 않을 때# 다음 코드의 주석을 제거하고 로컬 경로에서 데이터셋을 읽으세요:# df_wine = pd.read_csv('wine.data', header=None)df_wine.columns = 'Class label', 'Alcohol', 'Malic acid', 'Ash',                   'Alcalinity of ash', 'Magnesium', 'Total phenols',                   'Flavanoids', 'Nonflavanoid phenols', 'Proanthocyanins',                   'Color intensity', 'Hue', 'OD280/OD315 of diluted wines',                   'Proline'print('Class labels', np.unique(df_wine'Class label'))df_wine.head()☑️데이터셋을 훈련 데이터셋과 테스트 데이터셋으로 나누기☑️변수 X : 인덱스 1에서 인덱스 13까지 넘파이 배열로 변환해서 할당변수 y : 첫 번째 열의 클래스 레이블train_test_split 함수 : X와 y를 랜덤하게 훈련 데이터셋과 테스트 데이터셋으로 분할test_size=0.3 : 와인 샘플의 30%가 X_test와 y_test에 할당 (나머지 샘플 70%는 X_train과 y_train에 각각 할당)stratify=y : 훈련 데이터셋과 테스트 데이터셋이 있는 클래스 비율이 원본 데이터셋과 동일하게 유지됨from sklearn.model_selection import train_test_splitX, y = df_wine.iloc:, 1:.values, df_wine.iloc:, 0.valuesX_train, X_test, y_train, y_test =    train_test_split(X, y,                      test_size=0.3,                      random_state=0,                      stratify=y)&lt;br&gt;&lt;br&gt;### 4.4 특성 스케일 맞추기**정규화** : 특성의 스케일을 0, 1 범위에 맞추는 것- 최소-최대 스케일 변환 : 각 특성의 열마다 최소-최대 스케일 변환을 적용하여 새로운 값을 계산 (정해진 범위의 값이 필요할 때 유용하게 사용)    ☑️ 사이킷런으로 최소-최대 스케일 변환 수행☑️``` python    from sklearn.preprocessing import MinMaxScaler    mms = MinMaxScaler()    X_train_norm = mms.fit_transform(X_train)    X_test_norm = mms.transform(X_test)표준화 : 특성의 평균을 0에 맞추고 표준 편차를 1로 만들어 정규 분포와 같은 특징을 가지도록 만듦 -&gt; 가중치를 더 쉽게 학습할 수 있도록 만듦☑️사이킷런으로 표준화 수행☑️StandardScaler : 표준화를 위한 클래스from sklearn.preprocessing import StandardScalerstdsc = StandardScaler()X_train_std = stdsc.fit_transform(X_train)X_test_std = stdsc.transform(X_test)- RobustScaler : 특성 열마다 독립적으로 작용하며 중간 값을 뺀 다음 데이터셋의 1사분위수와 3사분위수(즉, 25백분위수와 75백분위수)를 사용해서 데이터셋의 스케일을 조정&lt;br&gt;&lt;br&gt;### 4.5 유용한 특성 선택#### 4.5.1 모델 복잡도 제한을 위한 L1 규제와 L2 규제L1 규제 : 가중치 제곱을 가중치 절댓값으로 바꾼 것 -&gt; 대부분의 특성 가중치가 0이 됨&lt;br&gt;#### 4.5.2 L2 규제의 기하학적 해석L2 규제 : 비용 함수에 페널티 항을 추가 -&gt; 가중치 값을 아주 작게 만드는 효과!(https://velog.velcdn.com/images/rosesua318/post/2db376e9-bf90-403b-9fdf-001a26bdaca3/image.png)&lt;br&gt;#### 4.5.3 L1 규제를 사용한 희소성!(https://velog.velcdn.com/images/rosesua318/post/2309d854-7978-4c38-b73e-d7f55352acee/image.png)☑️사이킷런으로 L1 규제를 지원하는 모델 만들기☑️- penalty='l1' : L1 규제를 지원하게 만듦``` pythonfrom sklearn.linear_model import LogisticRegressionLogisticRegression(penalty='l1', solver='liblinear')☑️표준화 전처리된 Wine 데이터에 L1 규제가 있는 로지스틱 회귀 적용☑️from sklearn.linear_model import LogisticRegressionlr = LogisticRegression(penalty='l1', C=1.0, solver='liblinear', random_state=1)# C=1.0이 기본입니다.# 규제 효과를 높이거나 낮추려면 C 값을 증가시키거나 감소시킵니다.lr.fit(X_train_std, y_train)print('훈련 정확도:', lr.score(X_train_std, y_train))print('테스트 정확도:', lr.score(X_test_std, y_test))➡️ 훈련과 테스트 정확도(둘 다 100%)를 보면 모델이 두 데이터셋에 완벽하게 작동함을 알 수 있음☑️규제 강도를 달리하여 특성의 가중치 변화를 그래프로 그려보기☑️import matplotlib.pyplot as pltfig = plt.figure()ax = plt.subplot(111)colors = 'blue', 'green', 'red', 'cyan',           'magenta', 'yellow', 'black',           'pink', 'lightgreen', 'lightblue',           'gray', 'indigo', 'orange'weights, params = , for c in np.arange(-4., 6.):    lr = LogisticRegression(penalty='l1', C=10.**c, solver='liblinear',                             multi_class='ovr', random_state=0)    lr.fit(X_train_std, y_train)    weights.append(lr.coef_1)    params.append(10**c)weights = np.array(weights)for column, color in zip(range(weights.shape1), colors):    plt.plot(params, weights:, column,             label=df_wine.columnscolumn + 1,             color=color)plt.axhline(0, color='black', linestyle='--', linewidth=3)plt.xlim(10**(-5), 10**5)plt.ylabel('weight coefficient')plt.xlabel('C')plt.xscale('log')plt.legend(loc='upper left')ax.legend(loc='upper center',           bbox_to_anchor=(1.38, 1.03),          ncol=1, fancybox=True)plt.show()➡️강한 규제 파라미터(C &lt; 0.1)로 모델을 제약하면 모든 가중치가 0이 됨4.5.4 순차 특성 선택 알고리즘차원 축소 - 모델 복잡도를 줄이고, 과대적합을 피함 -&gt; 규제가 없는 모델에서 특히 유용📍주요 카테고리📍1) 특성 선택 : 원본 특성에서 일부를 선택순차 특성 선택 : 탐욕적 탐색 알고리즘으로 초기 d 차원의 특성 공간을 k &lt; d인 k 차원의 특성 부분 공간으로 축소순차 후진 선택(SBS) : 계산 효율성을 향상하기 위해 모델 성능을 가능한 적게 희생하면서 초기 특성의 부분 공간으로 차원을 축소단계 알고리즘을 k=d로 초기화. d는 전체 특성 공간의 차원조건을 최대화하는 특성을 결정특성 집합에서 조건을 최대화하는 특성을 제거k가 목표하는 특성 개수가 되면 종료. 아니면 단계 2로 돌아가기SBS 파이썬으로 직접 구현from sklearn.base import clonefrom itertools import combinationsimport numpy as npfrom sklearn.metrics import accuracy_scorefrom sklearn.model_selection import train_test_splitclass SBS():    def init(self, estimator, k_features, scoring=accuracy_score,                 test_size=0.25, random_state=1):        self.scoring = scoring        self.estimator = clone(estimator)        self.k_features = k_features        self.test_size = test_size        self.random_state = random_statedef fit(self, X, y):    X_train, X_test, y_train, y_test = \        train_test_split(X, y, test_size=self.test_size,                         random_state=self.random_state)    dim = X_train.shape1    self.indices_ = tuple(range(dim))    self.subsets_ = self.indices_    score = self._calc_score(X_train, y_train,                              X_test, y_test, self.indices_)    self.scores_ = score    while dim &gt; self.k_features:        scores =         subsets =         for p in combinations(self.indices_, r=dim - 1):            score = self._calc_score(X_train, y_train,                                      X_test, y_test, p)            scores.append(score)            subsets.append(p)        best = np.argmax(scores)        self.indices_ = subsetsbest        self.subsets_.append(self.indices_)        dim -= 1        self.scores_.append(scoresbest)    self.k_score_ = self.scores_-1    return selfdef transform(self, X):    return X:, self.indices_def _calc_score(self, X_train, y_train, X_test, y_test, indices):    self.estimator.fit(X_train:, indices, y_train)    y_pred = self.estimator.predict(X_test:, indices)    score = self.scoring(y_test, y_pred)    return score&lt;br&gt;        ☑️사이킷런의 KNN 분류기를 사용하여 SBS 구현 동작 테스트☑️``` pythonimport matplotlib.pyplot as pltfrom sklearn.neighbors import KNeighborsClassifierknn = KNeighborsClassifier(n_neighbors=5)# 특성을 선택합니다sbs = SBS(knn, k_features=1)sbs.fit(X_train_std, y_train)# 선택한 특성의 성능을 출력합니다k_feat = len(k) for k in sbs.subsets_plt.plot(k_feat, sbs.scores_, marker='o')plt.ylim(0.7, 1.02)plt.ylabel('Accuracy')plt.xlabel('Number of features')plt.grid()plt.tight_layout()plt.show()    ☑️검증 데이터셋에서 계산한 KNN 분류기의 정확도 그리기☑️import matplotlib.pyplot as pltfrom sklearn.neighbors import KNeighborsClassifierknn = KNeighborsClassifier(n_neighbors=5)# 특성을 선택합니다sbs = SBS(knn, k_features=1)sbs.fit(X_train_std, y_train)# 선택한 특성의 성능을 출력합니다k_feat = len(k) for k in sbs.subsets_plt.plot(k_feat, sbs.scores_, marker='o')plt.ylim(0.7, 1.02)plt.ylabel('Accuracy')plt.xlabel('Number of features')plt.grid()plt.tight_layout()plt.show()➡️ 특성 개수를 줄여서 KNN 모델의 성능이 증가하지는 ❌ but, 데이터셋 크기를 줄였고, 더 간단한 모델을 얻었고, 해석하기도 쉬워짐2) 특성 추출 : 일련의 특성에서 얻은 정보로 새로운 특성을 만듦4.6 랜덤 포레스트의 특성 중요도 사용☑️ 랜덤 포레스트 모델의 특성 중요도 출력하기☑️from sklearn.ensemble import RandomForestClassifierfeat_labels = df_wine.columns1:forest = RandomForestClassifier(n_estimators=500,                                random_state=1)forest.fit(X_train, y_train)importances = forest.feature_importances_indices = np.argsort(importances)::-1for f in range(X_train.shape1):    print(&quot;%2d) %-*s %f&quot; % (f + 1, 30,                             feat_labelsindicesf,                             importancesindicesf))plt.title('Feature Importance')plt.bar(range(X_train.shape1),         importancesindices,        align='center')plt.xticks(range(X_train.shape1),            feat_labelsindices, rotation=90)plt.xlim(-1, X_train.shape1)plt.tight_layout()plt.show()➡️ Wine 데이터셋 특성의 상대적인 중요도에 따른 순위를 그래프로 그림➡️ 특성 중요도는 합이 1이 되도록 정규화된 값☑️사이킷런으로 특성 중요도 사용☑️SelectFromModel : 모델 훈련이 끝난 후 사용자가 지정한 임계 값을 기반으로 특성을 선택from sklearn.feature_selection import SelectFromModelsfm = SelectFromModel(forest, threshold=0.1, prefit=True)X_selected = sfm.transform(X_train)print('이 임계 조건을 만족하는 샘플의 수:',       X_selected.shape1)!(https://velog.velcdn.com/images/rosesua318/post/41b63c23-1e35-4aff-b870-dc320e44750c/image.png)``` pythonfor f in range(X_selected.shape1):    print(&quot;%2d) %-*s %f&quot; % (f + 1, 30,                             feat_labelsindicesf,                             importancesindicesf))"
272,"3.1 분류 알고리즘 선택☑️머신러닝 훈련 단계☑️1) 특성을 선택하고 훈련 샘플을 모으기2) 성능 지표를 선택3) 분류 모델과 최적화 알고리즘 선택4) 모델의 성능을 평가 (학습에 사용하는 데이터에 크게 의존)5) 알고리즘을 튜닝3.2 사이킷런 첫걸음: 퍼셉트론 훈련🟡 150개의 꽃 샘플🟡 특성 행렬 X : 꽃잎 길이, 꽃잎 너비🟡 벡터 y : 꽃 품종에 해당하는 클래스 레이블☑️사이킷런에서 붓꽃 데이터셋을 적재☑️from sklearn import datasetsimport numpy as npiris = datasets.load_iris()X = iris.data:, 2, 3y = iris.target# np.uniuqe(y) : iris.target에 저장된 세 개의 고유한 클래스 레이블 반환print('클래스 레이블:', np.unique(y))➡️ 클래스 레이블 정수로 인코딩 -&gt; 계산 성능 향상 위함☑️훈련된 모델 성능 평가 -&gt; 훈련 데이터셋과 테스트 데이터셋으로 분할☑️30% : 테스트 데이터(45개의 샘플), 70% : 훈련 데이터(105개의 샘플)train_test_split 함수 : x와 y 배열을 랜덤하게 나눔random_state 매개변수 : 데이터셋 분할 전 무작위로 섞기 위한 난수 생성기stratify=y : 계층화(훈련 데이터셋과 테스트 데이터셋의 클래스 레이블 비율을 입력 데이터셋과 동일하게 만듦)from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(    X, y, test_size=0.3, random_state=1, stratify=y)☑️계층화 잘 되었는지 확인☑️bincount 함수 : 배열에 있는 고유한 값의 등장 횟수 파악print('y의 레이블 카운트:', np.bincount(y))print('y_train의 레이블 카운트:', np.bincount(y_train))print('y_test의 레이블 카운트:', np.bincount(y_test))☑️성능을 위해 특성 스케일 조정☑️사이킷런 StandardScaler 클래스 : 특성을 표준화 해줌StandardScaler의 fit 메서드 : 훈련 데이터셋의 각 특성 차원마다 샘플 평균과 표준 편차 계산transform 메서드 : 계산된 샘플 평균과 표준 편차를 사용하여 훈련 데이터셋과 테스트 데이터셋을 표준화from sklearn.preprocessing import StandardScalersc = StandardScaler() # 클래스 로드하여 sc 변수에 할당sc.fit(X_train)X_train_std = sc.transform(X_train)X_test_std = sc.transform(X_test)&lt;br&gt;☑️퍼셉트론 모델 훈련☑️- OvR(One-versus-Rest) 방식을 사용하여 다중 분류를 지원- 3개의 붓꽃 클래스를 퍼셉트론에 한 번에 주입- eta0 : 학습률- random_state 매개변수 : 에포크마다 훈련 데이터셋을 섞은 결과가 그대로 재현될 수 있게 함``` pythonfrom sklearn.linear_model import Perceptron# Perceptron 클래스를 로드ppn = Perceptron(eta0=0.1, random_state=1)# fit 메서드로 모델 훈련ppn.fit(X_train_std, y_train)☑️모델로 예측해보기☑️y_pred = ppn.predict(X_test_std)print('잘못 분류된 샘플 개수: %d' % (y_test != y_pred).sum())➡️ 퍼셉트론 모델이 45개의 샘플에서 한 개를 잘못 분류함➡️ 테스트 데이터셋에 대한 분류 오차 : 약 0.022 또는 2.2%☑️퍼셉트론의 분류 정확도 계산☑️metrics 모듈 : 다양한 성능 지표 포함y_test : 진짜 클래스 레이블y_pred : 앞서 예측한 클래스 레이블score 메서드 : 분류기의 예측 정확도 계산(predict 메서드와 accuracy_score 메서드를 연결하여 계산)📍 정확도란? =&gt; 1 - 오차from sklearn.metrics import accuracy_scoreprint('정확도: %.3f' % accuracy_score(y_test, y_pred))print('정확도: %.3f' % ppn.score(X_test_std, y_test))!(https://velog.velcdn.com/images/rosesua318/post/298e369a-d3d5-49ae-a020-cbc7c04d8250/image.png)☑️퍼셉트론 모델의 결정 경계 그려서 시각화☑️- plot_decision_regions 함수 : 퍼셉트론 모델의 결정 경계를 그려줌``` pythonfrom matplotlib.colors import ListedColormapimport matplotlib.pyplot as pltdef plot_decision_regions(X, y, classifier, test_idx=None, resolution=0.02):    # 마커와 컬러맵을 설정합니다.    markers = ('s', 'x', 'o', '^', 'v')    colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan')    cmap = ListedColormap(colors:len(np.unique(y)))    # 결정 경계를 그립니다.    x1_min, x1_max = X:, 0.min() - 1, X:, 0.max() + 1    x2_min, x2_max = X:, 1.min() - 1, X:, 1.max() + 1    xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution),                           np.arange(x2_min, x2_max, resolution))    Z = classifier.predict(np.array(xx1.ravel(), xx2.ravel()).T)    Z = Z.reshape(xx1.shape)    plt.contourf(xx1, xx2, Z, alpha=0.3, cmap=cmap)    plt.xlim(xx1.min(), xx1.max())    plt.ylim(xx2.min(), xx2.max())    for idx, cl in enumerate(np.unique(y)):        plt.scatter(x=Xy == cl, 0,                    y=Xy == cl, 1,                    alpha=0.8,                    c=colorsidx,                    marker=markersidx,                    label=cl,                    edgecolor='black')    # 테스트 샘플을 부각하여 그립니다.    if test_idx:        # 모든 샘플을 그립니다.        X_test, y_test = Xtest_idx, :, ytest_idx        plt.scatter(X_test:, 0,                    X_test:, 1,                    facecolor='none',                    edgecolor='black',                    alpha=1.0,                    linewidth=1,                    marker='o',                    s=100,                    label='test set')X_combined_std = np.vstack((X_train_std, X_test_std))y_combined = np.hstack((y_train, y_test))plot_decision_regions(X=X_combined_std, y=y_combined,                      classifier=ppn, test_idx=range(105, 150))plt.xlabel('petal length standardized')plt.ylabel('petal width standardized')plt.legend(loc='upper left')plt.tight_layout()# plt.savefig('images/03_01.png', dpi=300)plt.show()➡️ 3개의 붓꽃 클래스는 선형 결정 경계로 완벽하게 분류되지 ❌➡️ 퍼셉트론 알고리즘은 선형적으로 구분되지 않는 데이터셋에는 수렴하지 ❌3.3 로지스틱 회귀를 사용한 클래스 확률 모델링3.3.1 로지스틱 회귀의 이해와 조건부 확률로지스틱 회귀 : 구현이 쉽고 선형적으로 구분되는 클래스에 뛰어난 성능을 내는 분류 모델, 이진 분류를 위한 선형 모델☑️시그모이드 함수 그려보기☑️import matplotlib.pyplot as pltimport numpy as npdef sigmoid(z):    return 1.0 / (1.0 + np.exp(-z))z = np.arange(-7, 7, 0.1)phi_z = sigmoid(z)plt.plot(z, phi_z)plt.axvline(0.0, color='k')plt.ylim(-0.1, 1.1)plt.xlabel('z')plt.ylabel('$\phi (z)$')# y 축의 눈금과 격자선plt.yticks(0.0, 0.5, 1.0)ax = plt.gca()ax.yaxis.grid(True)plt.tight_layout()# plt.savefig('images/03_02.png', dpi=300)plt.show()➡️ S자 형태의 (시그모이드) 곡선이 그려짐☑️이용 분야☑️클래스에 소속될 확률을 추정하는 것이 유용한 서비스ex) 비 올 확률을 예측해야 하는 날씨 예보, 환자가 특정 질병을 가질 확률 예측3.3.2 로지스틱 비용 함수의 가중치 학습☑️로지스틱 분류 비용 그려보기☑️def cost_1(z):    return - np.log(sigmoid(z))def cost_0(z):    return - np.log(1 - sigmoid(z))z = np.arange(-10, 10, 0.1)phi_z = sigmoid(z)c1 = cost_1(x) for x in zplt.plot(phi_z, c1, label='J(w) if y=1')c0 = cost_0(x) for x in zplt.plot(phi_z, c0, linestyle='--', label='J(w) if y=0')plt.ylim(0.0, 5.1)plt.xlim(0, 1)plt.xlabel('$\phi$(z)')plt.ylabel('J(w)')plt.legend(loc='best')plt.tight_layout()plt.show()➡️ x축 : 0에서 1까지 범위의 시그모이드 활성화 값➡️ y축 : 해당하는 로지스틱 비용➡️ 예측이 잘못되면 비용이 무한대가 됨, 잘못된 예측에 점점 더 큰 비용을 부여3.3.3 아달린 구현을 로지스틱 회귀 알고리즘으로 변경선형 활성화 함수를 시그모이드 활성화로 바꾸기임계 함수가 클래스 레이블 -1 과 1이 아닌 0과 1을 반환하도록 변경☑️아달린 코드에 변경 사항을 반영하여 로지스틱 회귀 모델 만들기☑️class LogisticRegressionGD(object):    &quot;&quot;&quot;경사 하강법을 사용한 로지스틱 회귀 분류기    매개변수    ------------    eta : float      학습률 (0.0과 1.0 사이)    n_iter : int      훈련 데이터셋 반복 횟수    random_state : int      가중치 무작위 초기화를 위한 난수 생성기 시드    속성    -----------    w_ : 1d-array      학습된 가중치    cost_ : list      에포크마다 누적된 로지스틱 비용 함수 값    &quot;&quot;&quot;    def __init__(self, eta=0.05, n_iter=100, random_state=1):        self.eta = eta        self.n_iter = n_iter        self.random_state = random_state    def fit(self, X, y):        &quot;&quot;&quot;훈련 데이터 학습        매개변수        ----------        X : {array-like}, shape = n_samples, n_features          n_samples 개의 샘플과 n_features 개의 특성으로 이루어진 훈련 데이터        y : array-like, shape = n_samples          타깃값        반환값        -------        self : object        &quot;&quot;&quot;        rgen = np.random.RandomState(self.random_state)        self.w_ = rgen.normal(loc=0.0, scale=0.01, size=1 + X.shape1)        self.cost_ =         for i in range(self.n_iter):            net_input = self.net_input(X)            output = self.activation(net_input)            errors = (y - output)            self.w_1: += self.eta * X.T.dot(errors)            self.w_0 += self.eta * errors.sum()            # 오차 제곱합 대신 로지스틱 비용을 계산합니다.            cost = -y.dot(np.log(output)) - ((1 - y).dot(np.log(1 - output)))            self.cost_.append(cost)        return self    def net_input(self, X):        &quot;&quot;&quot;최종 입력 계산&quot;&quot;&quot;        return np.dot(X, self.w_1:) + self.w_0    def activation(self, z):        &quot;&quot;&quot;로지스틱 시그모이드 활성화 계산&quot;&quot;&quot;        return 1. / (1. + np.exp(-np.clip(z, -250, 250)))    def predict(self, X):        &quot;&quot;&quot;단위 계단 함수를 사용하여 클래스 레이블을 반환합니다&quot;&quot;&quot;        return np.where(self.net_input(X) &gt;= 0.0, 1, 0)        # 다음과 동일합니다.        # return np.where(self.activation(self.net_input(X)) &gt;= 0.5, 1, 0)☑️이진 분류 문제로 로지스틱 회귀 구현 작동 테스트☑️X_train_01_subset = X_train_std(y_train == 0) | (y_train == 1)y_train_01_subset = y_train(y_train == 0) | (y_train == 1)lrgd = LogisticRegressionGD(eta=0.05, n_iter=1000, random_state=1)lrgd.fit(X_train_01_subset,         y_train_01_subset)plot_decision_regions(X=X_train_01_subset,                       y=y_train_01_subset,                      classifier=lrgd)plt.xlabel('petal length standardized')plt.ylabel('petal width standardized')plt.legend(loc='upper left')plt.tight_layout()# plt.savefig('images/03_05.png', dpi=300)plt.show()3.3.4 사이킷런을 사용하여 로지스틱 회귀 모델 훈련☑️로지스틱 회귀 모델 훈련☑️표준화 처리된 붓꽃 데이터셋의 클래스 세개를 대상으로 모델 훈련from sklearn.linear_model import LogisticRegressionlr = LogisticRegression(C=100.0, random_state=1)lr.fit(X_train_std, y_train)plot_decision_regions(X_combined_std, y_combined,                      classifier=lr, test_idx=range(105, 150))plt.xlabel('petal length standardized')plt.ylabel('petal width standardized')plt.legend(loc='upper left')plt.tight_layout()plt.show()!(https://velog.velcdn.com/images/rosesua318/post/7b4f69fa-4f09-4610-be83-6e4d8e0805c2/image.png)&lt;br&gt;☑️훈련 샘플이 어떤 클래스에 속할 확률 계산☑️- predict_proba 메서드 : 훈련 샘플이 어떤 클래스에 속할 확률을 계산``` pythonlr.predict_proba(X_test_std:3, :)➡️ 첫 번째 행 : 첫 번째 붓꽃의 클래스 소속 확률, 두 번째 행도 이와 동일➡️ 열을 모두 더하면 1➡️ 첫 번째 행에서 가장 큰 값은 대략 0.999 =&gt; 첫 번째 샘플이 클래스 3에 속할 확률일 99.9%➡️ 행에서 가장 큰 값의 열이 예측 클래스 레이블이 됨 (사이킷런 사용할 때는 predict 메서드를 직접 호출하여 가능)    lr.predict(X_text_std:3, :)    lr.predict(X_test_std0, :.reshape(1, -1))3.3.5 규제를 사용하여 과대적합 피하기과대적합 : 모델이 훈련 데이터로는 잘 동작하지만 본 적 없는 데이터(테스트 데이터)로는 일반화가 잘 되지 않는 현상규제 : 공선성(특성 간의 높은 상관관계)을 다루거나 데이터에서 잡음을 제거하여 과대적합을 방지할 수 있는 방법,과도한 파라미터(가중치) 값을 제한하기 위해 추가적인 정보(편향)을 주입 -&gt; 모델 훈련 과정에서 가중치를 줄이는 역할L2 규제 -&gt; 역 규제 파라미터 C의 값을 감소시키면 규제 강도가 증가☑️가중치에 대한 L2규제 효과 보기☑️weights, params = , for c in np.arange(-5, 5):    lr = LogisticRegression(C=10.**c, random_state=1, multi_class='ovr')    lr.fit(X_train_std, y_train)    weights.append(lr.coef_1)    params.append(10.**c)weights = np.array(weights)plt.plot(params, weights:, 0,         label='petal length')plt.plot(params, weights:, 1, linestyle='--',         label='petal width')plt.ylabel('weight coefficient')plt.xlabel('C')plt.legend(loc='upper left')plt.xscale('log')plt.show()➡️ 매개변수 C가 감소하면 가중치 절댓값이 감소 -&gt; 규제 강도 증가3.4 서포트 벡터 머신을 사용한 최대 마진 분류SVM의 최적화 대상 : 마진을 최대화하는 것마진 : 클래스를 구분하는 초평면(결정 경계)과 이 초평면에 가장 가까운 훈련 샘플 사이의 거리서포트 벡터 : 초평면에 가장 가까운 훈련 샘플3.4.1 최대 마진최대 마진 : 양성 샘플 쪽의 초평면과 음성 샘플 쪽의 초평면 사이의 거리를 최대화한 것3.4.2 슬랙 변수를 사용하여 비선형 분류 문제 다루기슬랙 변수 : 선형적으로 구분되지 않는 데이터에서 선형 제약 조건을 완화시키기 위해 더해지는 양수 값소프트 마진 분류 : 슬랙 변수를 도입한 최대 마진 분류☑️꽃 분류 문제에 SVM 모델을 훈련☑️from sklearn.svm import SVCsvm = SVC(kernel='linear', C=1.0, random_state=1)svm.fit(X_train_std, y_train)plot_decision_regions(X_combined_std,                       y_combined,                      classifier=svm,                       test_idx=range(105, 150))plt.xlabel('petal length standardized')plt.ylabel('petal width standardized')plt.legend(loc='upper left')plt.tight_layout()plt.show()➡️ 결정 영역 세 개가 나타남3.4.3 사이킷런의 다른 구현데이터셋이 너무 커서 컴퓨터 메모리 용량에 맞지 않는 경우-&gt; SGDClassifier 클래스 제공 (partial_fit 메서드를 사용하여 온라인 학습 지원)from sklearn.linear_model import SGDClassifierppn = SGDClassifier(loss='perceptron')lr = SGDClassifier(loss='log')svm = SGDClassifier(loss='hinge')3.5 커널 SVM을 사용하여 비선형 문제 풀기커널 SVM : 비선형 분류 문제를 풀기 위한 모델3.5.1 선형적으로 구분되지 않는 데이터를 위한 커널 방법☑️합성 데이터셋 만들기☑️logical_xor 함수 : XOR 형태의 간단한 데이터셋 만듦샘플 100개 : 클래스 레이블 1로 할당, 나머지 샘플 100개 : 클래스 레이블 -1로 할당import matplotlib.pyplot as pltimport numpy as npnp.random.seed(1)X_xor = np.random.randn(200, 2)y_xor = np.logical_xor(X_xor:, 0 &gt; 0,                       X_xor:, 1 &gt; 0)y_xor = np.where(y_xor, 1, -1)plt.scatter(X_xory_xor == 1, 0,            X_xory_xor == 1, 1,            c='b', marker='x',            label='1')plt.scatter(X_xory_xor == -1, 0,            X_xory_xor == -1, 1,            c='r',            marker='s',            label='-1')plt.xlim(-3, 3)plt.ylim(-3, 3)plt.legend(loc='best')plt.tight_layout()plt.show()!(https://velog.velcdn.com/images/rosesua318/post/0a2c0c00-1152-48e7-8fcd-98e300331dc3/image.png)➡️ 랜덤한 잡음이 섞인 XOR 데이터셋 만들어짐&lt;br&gt;📍**커널 방법의 기본 아이디어**📍매핑 함수를 사용하여 원본 특성의 비선형 조합을 선형적으로 구분되는 고차원 공간에 투영!(https://velog.velcdn.com/images/rosesua318/post/877ec992-9bf4-406a-97a9-7aea12fdeb6a/image.png)&lt;br&gt;#### 3.5.2 커널 기법을 사용하여 고차원 공간에서 분할 초평면 찾기📍**SVM으로 비선형 문제 푸는 방법**📍1) 매핑 함수를 사용하여 훈련 데이터를 고차원 특성 공간으로 변환2) 새로운 특성 공간에서 데이터를 분류하는 선형 SVM 모델을 훈련3) 동일한 매핑 함수를 사용하여 새로운 본 적 없는 데이터를 변환4) 선형 SVM 모델을 사용하여 그 데이터를 분류➡️ 계산 비용이 매우 비쌈➡️ 커널 기법 등장&lt;br&gt;**커널** : 샘플 간의 유사도 함수 - 음수 부호가 거리 측정을 유사도 점수로 바꾸는 역할- 지수 함수로 얻게 되는 유사도 점수는 1(매우 비슷한 샘플)과 0(매우 다른 샘플)사이 범위를 가짐&lt;br&gt;☑️XOR 데이터를 구분하는 커널 SVM 훈련☑️- SVC 클래스의 매개변수 kernel='linear'를 kernel='rbf'로 바꿈- gamma : 가우시안 구의 크기를 제한하는 매개변수 -&gt; 클수록 서포트 벡터의 영향이나 범위가 줄어듦``` pythonsvm = SVC(kernel='rbf', random_state=1, gamma=0.10, C=10.0)svm.fit(X_xor, y_xor)plot_decision_regions(X_xor, y_xor,                      classifier=svm)plt.legend(loc='upper left')plt.tight_layout()plt.show()➡️ 비교적 XOR 데이터를 잘 구분함☑️붓꽃 데이터셋에서 RBF 커널SVM 적용☑️from sklearn.svm import SVCsvm = SVC(kernel='rbf', random_state=1, gamma=0.2, C=1.0)svm.fit(X_train_std, y_train)plot_decision_regions(X_combined_std, y_combined,                      classifier=svm, test_idx=range(105, 150))plt.xlabel('petal length standardized')plt.ylabel('petal width standardized')plt.legend(loc='upper left')plt.tight_layout()plt.show()➡️ gamma 값을 비교적 작게 했기 때문에 결정 경계가 부드러움☑️ gamma 값을 크게 하고 결정 경계 보기☑️svm = SVC(kernel='rbf', random_state=1, gamma=100.0, C=1.0)svm.fit(X_train_std, y_train)plot_decision_regions(X_combined_std, y_combined,                       classifier=svm, test_idx=range(105, 150))plt.xlabel('petal length standardized')plt.ylabel('petal width standardized')plt.legend(loc='upper left')plt.tight_layout()plt.show()➡️ 훈련 데이터에서는 잘 맞지만 테스트 데이터에서는 일반화 오차가 높을 것➡️ gamma 매개변수가 과대적합 또는 분산을 조절하는 중요한 역할➡️ SVM 모델에 규제를 가할 때는 gamma와 C 매개변수를 동시에 조절하는 것이 좋음3.6 결정 트리 학습결정 트리 : 훈련 데이터에 있는 특성을 기반으로 샘플의 클래스 레이블을 추정할 수 있는 일련의 질문을 학습트리의 루트에서 시작해서 정보 이득이 최대가 되는 특성으로 데이터를 나눔반복 과정을 통해 리프 노드가 순수해질 때까지 모든 자식 노드에서 이 분할 작업을 반복 -&gt; 과대적합될 가능성 -&gt; 트리의 최대 깊이를 제한하여 가지치기3.6.1 정보 이득 최대화: 자원을 최대로 활용가장 정보가 풍부한 특성으로 노드를 나누기 위해 -&gt; 트리 알고리즘으로 최적화할 목적 함수를 정의목적 함수 - 각 분할에서 정보 이득을 최대화함정보 이득 : 부모 노드의 불순도와 자식 노드의 불순도 합의 차이 (자식 노드의 불순도가 낮을 수록 정보 이득이 커짐)이진 결정 트리 사용 : 구현 간단하게 하고 탐색 공간 줄이기 위해📍이진 결정 트리에 사용되는 불순도 지표 또는 분할 조건📍1) 지니 불순도 : 클래스가 완벽하게 섞여 있을 때 최대가 됨2) 엔트로피 : 클래스 분포가 균등하면 엔트로피 최대가 됨3) 분류 오차 : 두 클래스가 같은 비율일 때 최대(0.5)가 됨☑️불순도 기준 비교 위한 클래스 1의 확률 범위 0, 1에 대한 불순도 인덱스 그려보기☑️스케일 조정된 엔트로피(엔트로피 / 2)를 추가 : 지니 불순도가 엔트로피와 분류 오차의 중간임을 관찰import matplotlib.pyplot as pltimport numpy as npdef gini(p):    return p * (1 - p) + (1 - p) * (1 - (1 - p))def entropy(p):    return - p * np.log2(p) - (1 - p) * np.log2((1 - p))def error(p):    return 1 - np.max(p, 1 - p)x = np.arange(0.0, 1.0, 0.01)ent = entropy(p) if p != 0 else None for p in xsc_ent = e * 0.5 if e else None for e in enterr = error(i) for i in xfig = plt.figure()ax = plt.subplot(111)for i, lab, ls, c, in zip(ent, sc_ent, gini(x), err,                           'Entropy', 'Entropy (scaled)',                            'Gini impurity', 'Misclassification error',                          '-', '-', '--', '-.',                          'black', 'lightgray', 'red', 'green', 'cyan'):    line = ax.plot(x, i, label=lab, linestyle=ls, lw=2, color=c)ax.legend(loc='upper center', bbox_to_anchor=(0.5, 1.15),          ncol=5, fancybox=True, shadow=False)ax.axhline(y=0.5, linewidth=1, color='k', linestyle='--')ax.axhline(y=1.0, linewidth=1, color='k', linestyle='--')plt.ylim(0, 1.1)plt.xlabel('p(i=1)')plt.ylabel('impurity index')plt.show()!(https://velog.velcdn.com/images/rosesua318/post/3ad65a89-d4e6-44b2-8f62-4931c2989e85/image.png)&lt;br&gt;#### 3.6.2 결정 트리 만들기결정 트리 - 특성 공간을 사각 격자로 나누기 때문에 복잡한 결정 경계 만들 수 ⭕☑️최대 깊이가 4인 결정 트리를 훈련☑️``` pythonfrom sklearn.tree import DecisionTreeClassifiertree_model = DecisionTreeClassifier(criterion='gini',                                     max_depth=4,                                     random_state=1)tree_model.fit(X_train, y_train)X_combined = np.vstack((X_train, X_test))y_combined = np.hstack((y_train, y_test))plot_decision_regions(X_combined, y_combined,                       classifier=tree_model,                      test_idx=range(105, 150))plt.xlabel('petal length cm')plt.ylabel('petal width cm')plt.legend(loc='upper left')plt.tight_layout()plt.show()➡️ 축에 나란히 놓인 전형적인 결정 트리의 결정 경계 얻음☑️사이킷런으로 훈련된 결정 트리 모델 시각화☑️from sklearn import treetree.plot_tree(tree_model)plt.show()☑️PyDotPlus 설치☑️pip3 install pydotplusconda install pydotplus☑️로컬 디렉터리에 PNG 포맷의 결정 트리 이미지 생성☑️out_file=None : tree.dot 중간 파일을 디스크에 만들지 않고 dot 데이터를 바로 dot_data 변수에 할당filled : 색 추가 옵션rounded : 상자 모서리의 라운드 처리 옵션class_naes : 각 노드에 다수 클래스 레이블 이름 표시 옵션feature_names : 분할 기준에 특성 이름 표시에 관한 옵션from pydotplus import graph_from_dot_datafrom sklearn.tree import export_graphvizdot_data = export_graphviz(tree_model,                           filled=True,                            rounded=True,                           class_names='Setosa',                                         'Versicolor',                                        'Virginica',                           feature_names='petal length',                                           'petal width',                           out_file=None) graph = graph_from_dot_data(dot_data) graph.write_png('tree.png') !(https://velog.velcdn.com/images/rosesua318/post/bd22edb9-3e05-4ef8-98ef-ff49e4e152a2/image.png)➡️ 루트 노드에서 105개의 샘플로 시작➡️ 꽃잎 너비 기준 0.75 센터미터 이하를 사용해서 35개와 70개의 샘플을 가진 두 개의 자식 노드로 분할➡️ 첫 번째 분할 - 왼쪽 자식 노드는 Iris-setosa 클래스의 샘플만 가진 순수 노드➡️ 오른쪽에서 분할이 더 일어나 Iris-veriscolor와 Iris-virginica 클래스의 샘플 구분&lt;br&gt;#### 3.6.3 랜덤 포레스트로 여러 개의 결정 트리 연결앙상블 - 뛰어난 분류 성능과 과대적합에 안정적 -&gt; 머신 러닝 애플리케이션에서 큰 인기를 누림랜덤 포레스트 : 결정 트리의 앙상블- 아이디어 : 여러 개의 (깊은) 결정 트리를 평균 내는 것- 단계    - n개의 랜덤한 부트스트랩 샘플을 뽑음(훈련 데이터셋에서 중복을 허용하면서 랜덤하게 n개의 샘플을 선택)    - 부트 스트램 샘플에서 결정 트리를 학습        - 중복을 허용하지 않고 랜덤하게 d개의 특성을 선택       - 정보 이득과 같은 목적 함수를 기준으로 최선의 분할을 만드는 특성을 사용해서 노드를 분할    - 단계 1~2를 k번 반복    - 각 트리의 예측을 모아 다수결 투표로 클래스 레이블을 할당- 장점 : 결정 트리만큼 해석이 쉽지는 않지만 하이퍼파라미터 튜닝에 많은 노력을 기울이지 않아도 됨, 가지치기할 필요가 ❌&lt;br&gt;☑️사이킷런을 이용하여 랜덤 포레스트 분류기 생성☑️- n_estimators=25 : 25개의 결정 트리를 사용하여 랜덤 포레스트 훈련- n_jobs=2 : 컴퓨터의 멀티 코어 2개를 사용해서 모델 훈련을 병렬화``` pythonfrom sklearn.ensemble import RandomForestClassifierforest = RandomForestClassifier(criterion='gini',                                n_estimators=25,                                 random_state=1,                                n_jobs=2)forest.fit(X_train, y_train)plot_decision_regions(X_combined, y_combined,                       classifier=forest, test_idx=range(105, 150))plt.xlabel('petal length cm')plt.ylabel('petal width cm')plt.legend(loc='upper left')plt.tight_layout()plt.show()➡️ 랜덤 포레스트의 트리 앙상블이 만든 결정 영역3.7 k-최근접 이웃: 게으른 학습 알고리즘KNN : 게으른 학습기 -&gt; 훈련 데이터에서 판별 함수를 학습하는 대신 훈련 데이터셋을 메모리에 저장단계숫자 k와 거리 측정 기준을 선택분류하려는 샘플에서 k개의 최근접 이웃을 찾음다수결 투표를 통해 클래스 레이블을 할당장점 : 새로운 훈련 데이터에 즉시 적응할 수 있는 점단점 : 계산 복잡도, 훈련 단계가 없기 때문에 훈련 샘플을 버릴 수 ❌☑️유클라디안 거리 측정 방식을 사용한 사이킷런의 KNN 모델 만들기☑️p 매개변수 : 2로 지정하면 유클리디안 거리, 1로 지정하면 맨해튼 거리from sklearn.neighbors import KNeighborsClassifierknn = KNeighborsClassifier(n_neighbors=5,                            p=2,                            metric='minkowski')knn.fit(X_train_std, y_train)plot_decision_regions(X_combined_std, y_combined,                       classifier=knn, test_idx=range(105, 150))plt.xlabel('petal length standardized')plt.ylabel('petal width standardized')plt.legend(loc='upper left')plt.tight_layout()plt.show()```➡️ 5개의 이웃을 지정 -&gt; 비교적 부드러운 결정 경계 얻음➡️ 적절한 k를 선택하는 것이 올바른 균형을 잡기 위해 중요"
273,"CASE 1이렇게 임시 객체가 생기는 순간객체에 접근해서 CRUD(조작) 한 후에 리턴만 하면 된다고 생각하기 쉬움리팩터링 1clearer리팩터링 2객체 자체 리턴하기 =&gt; CRUD 차단causing much less side effectsCASE 2특정 date obj를 받아서 월,날짜,시간을 뽑아서 CRUD하고 리턴함추가적인 spec을 넣거나 마케팅적인 요소로 날짜에 대한 요구사항이 생겼을 때?함수 추가해당 함수를 유지보수/수정 =&gt; 이 함수를 사용하는 모든 곳에서 재확인해야함So 처음부터 CRUD 없이 바로 리턴하는 형태가 좋음리팩터링 1let 을 const로 바꾸고 (수정/재할당 금지) =&gt; 바로 리턴하도록 변경추가 수정내용이 생기면 =&gt; 함수를 그대로 사용하는 additional 함수 만들기임시변수를 만들어서 지지고 볶고 하지 않고필요한 내용/추가적인 내용에 해당하는함수를 만들어서 껍데기를 씌우고 벗기고😄 하는게 바람직함 =&gt; 임시변수 줄이기!CASE 3간단하게 연산을 return하는 함수이지만 (미래에 누군가) 중간에 코드를 넣고 조작할 수 있는 가능성 있음함수를 만들 때, 함수 내부의 임시변수를 CRUD 하지 못하도록하나의 역할만 하는 함수`로 만드는 것이 중요"
274,회사에서 개츠비를 사용해서 연습해보면서tailwind css 로 스타일링 해보려고 하고 있음아래 독스에 나온 내용 + 추가적으로 세팅해서 사용 중테일윈드는 사용하면 할수록 좋아서 왜 사용자 피드백이 좋은지 이해된다더 효율적이고 깔끔하게 사용할 방법을 매번 찾아보는 중https://tailwindcss.com/docs/guides/gatsbyhttps://www.youtube.com/watch?v=ImmsEgNFxPQInstall Tailwind CSSnpm install -D tailwindcss postcss autoprefixer gatsby-plugin-postcssinit 하기 npx tailwindcss init -ppostcss.config.js 파일과 tailwind.config.js 파일이 생김독스 따라서 global css 파일 만들고gatsby-config 파일에 코드 추가 했는데 에러남 -&gt;  gatsby-config가 아니라 tailwindconfig 파일에 넣어야함!에러3.사용하기너무 간단해서 대충썼쟈나
275,"2021.Jan-Feb총평드디어 끝났다.하아.위기그룹 프로젝트 NC에서 마지막 그룹프로젝트가 정말 고비였다.5명의 경력과 배경(무려 4개국) 다른(개발자 경력 15년~6개월) 5명의 팀원들이 각기 다른 생각을 가지고 있었고 시작하고 4일 후에 프로젝트를 아예 갈아 엎고 다시 시작했다.팀으로 협업해서 나가는 것보다 개인의 성과가 더 중요하다고 생각하는 팀원,다르 팀원의 잘잘못을 자꾸 평가하는 팀원이 속한 팀에서 매일 매일 전쟁같은 3주를 보냈다.줌 미팅때마다 2-3명의 보이스가 계속 겹쳤고 중재하느라 계속 겨터바크 개장...코딩 기술보다 중재력을 집중적으로 양성했던 시기였다ㅠㅠ 늘 랜선으로 만났지만 매일 3주동안 힘듦을 함께 나눈 팀원들과 끈끈한 팀원애도 생겼다ㅠ그래서 지금이 너무 좋다. 이 모든 것이 끝났다는 점이!!많은 생각을 하게 해주는 프로젝트였고 실력보다는 경험보다 그 무엇보다도팀원들간의 협력하고자 하는 노력과 경청하는 태도가 무엇보다도 개발자에게 가장 중요하다는 사실을 깨달았다.완료고난의 NCㅠ!!지난 3달간 벨로그에 손도 못댈만큼 정신이 혼미한 상태에서하루종일 말하면서 코딩하느라고 힘들었다.사이드 프로젝트10월부터 조금씩 진행해왔던 사이드 프로젝트를 2월로 마무리했다.백엔드와의 프론트의 작업인원과 속도가 많이 달랐고, 결과적으로 아쉬움이 남는 프로젝트였지만, 과정 중에서 많이 배웠다고 생각한다..지난 2주동안 하루 취침량을 5시간까지 줄여서풀스택 프로젝트를 마무리하고 개인 포트폴리오를 완성했다. 진행-graphQL/react/node.js를 사용해서 간단한 fullstack 프로젝트를 만들기 시작-우연히 FE재남님이 새로 진행하시는 무근본 스터디를 발견해서 늦게나마 따라가고 있음 근데 계속 막히고 있음..!-👩‍💻  클린코드 자바스크립트-👩‍💻  프론트엔드 study (예정)-👩‍💻  vite 사용해보기-  도커 &amp; ci/cd 적용해보기3-4월 강의듣기-  복습 모든 개발자를 위한 HTTP 웹 기본 지식 -  1-day-1-leetcode-club 프로젝트 -👩‍💻 graphQL + React + Node.js fullstack 개인 플젝-  Ryan이랑 진행했던 blog =&gt; 갠 플젝으로 바꾸고 &amp; TS 붙이기5-6월-  영어블로그 번역 스터디-  복습강좌!모자딥 스터디다짐그룹 프로젝트 와 사이드 프로젝트를 끝으로 당분간다른 사람들과 함께 진행하는 프로젝트는 당분간 쉴거임😭😭주말에는 이제 밀린 중드 보기 + 중드 복습도 열심히 할 예정!!!!"
276,"제로초라이브 2021.12.21DON'T DO THIS 컴포넌트 바깥에서 let 쓰지 않기 예) let count = 0; 데이터는 늘 state에 담기!!  const 사용은 OK  변수를 밖에 선언해 놓고 useState 대신 사용해놓고  function 안에서 바꾸면?!  count가 공유됨변수가 바깥에 있으면 let은 한번만 써 놓고neverDoThat은 6번 부른 상황!!ReferenceWhat is useState, and why dont we use normal let?https://dev.to/theodorusclarence/react-core-concept-i-rendering-usestate-90e"
277,"https://www.youtube.com/watch?v=bjnW2NLAofI&amp;t=846sApp.tsxvariablesfunction esp, event이슈1숫자로 세팅해놔서 오류남고친 후1.Number()로 line 13 감싸줌2.함수 리턴값 없으니까 line 9 :void이슈2새로운 task를 todolist에 넣으려고 하니까 에러남원인 line 7에서 타입정의 안했음해결1.인터페이스 ts파일만들고 정의해줌 - 인터페이스 컨벤션 앞에 I붙임  2.임포트해주고 useState&lt;ITask&gt; 붙임 =&gt;  뜻은 어레이 문제되는 부분 고침 line19 =&gt; line 6,7에 각각 정의한 타입을 가져와서 newTask 만들고line20에 그걸 newTask 넣음 (타입이 정의된 task)리셋코드 넣어줌line21-22Props 넘기기TodoTask.tsx 파일 App.tsx파일에서 .map() 내용을 props로 어떻게 내리나요Todotask.tsx파일에서1.Itask 임포트2.Props 인터페이스 만들고 =&gt; 없는 경우를 대비해서 task?3.line 8에 타입지정한다 {}:Props(오브젝트로 오는 props임)TS는 아니지만 CSS 중에 place-itemplace-item 처음봐서 메모해줌Delete func만들기위치:App.tsx1.()안에 넣을 내용: 지울 task (string)2.로직: 필터로 지울 task 빼고 리턴함3. 이 함수를 TodoTask 컴포넌트 프랍스로 내려주기How=&gt;TodoTask.tsx 파일1.line6 함수 내용 추가2.line9 프랍스에 함수명 추가(destructuring)3.line18 온클릭 함수로 함수(지울 내용) 넣기"
278,2021.11월총평11월 중순부터 NC를 시작해서 본격적으로 바빴다.(영어로) 말하면서 코드를 짜는 연습에 익숙해지고 있다.요즘의 생활패턴은 정말 단순하다.아침에 일어나서 호다닥 줌미팅 참여하고 11시부터페어프로그래밍하다가 대충 점심 때우고 페어 때 부족한 내용이나그날 해치워야하는 내용 계속 검색하고 다시 페어랑 말하면서 코드 짬.6시쯤 개피곤해서 밥먹고 한숨 자고.9시쯤 일어나서 개인 공부 + 참여중인 프로젝트 &amp; 갠플젝 하면 금방 새벽 1-2시.잠자고 일어나서 다시 무한 반복중.예전에는 코딩관련 동기부여 영상이나 좋아하는 개발자분들의 영상 + 프엔드 지식확장을 위한 시간투자도 종종했는데 요즘엔 정말 하루 하루를 살아나가는 느낌이다.심지어. 11월에는 내 생활의 도피처인 중드도 못봤다.위기어찌저찌 진행해오던..쉽지 않았던 사이드 프로젝트가 마무리 없이 끝났다.5명의 인원들이 투자했던 시간만큼의 시너지와 output이 나오지 않은 이유를타산지석 삼아야겠다.연말 3주간의 holiday break를 이용해서 기존 내용을 바탕으로 개인 프로젝트로라도 마무리하면 그나마 스스로에게도 위안이 될 것 같다. 시작/완료내가 진행한 리액트 테스트 스터디 완료참여했던 알고리즘 스터디 완료-시즌2가 있을 예정이라고 하셔서 다음번에는 좀 더 활발하게 참여하고 싶다.계속 진행해오던 프로젝트 스터디에서 사이드 플젝2 시작(총 16중 중 3주진행)-좀 더 안정적인 스택 &amp; 독스 잘 남기기 &amp; 액션 플랜 잘 짜기 학습 stack-NC에서 테스팅 jest를 거의 하루 종일 하고 있음-TS basics 혼공 후에 미니 프로젝트에 적용 =&gt; 3주후에 실제 프로젝트 적용 예정-12-1월에 node.js 와 서버부분을 집중적으로 사용할 예정이라..이미 조금씩 튀어나고 있음 ㅠ 조금씩 유데미 + 노드독스 + 토이 플젝으로 해보고 있음.11월 개인 학습 완료/진행한 내용-리액트/Jest 테스트 관련 유튭강의 &amp; 독스 꾸준히 학습중-인프런 존안 리액트테스팅강의(스터디자료 100%) 완료-애플코딩 TS학습 60% (11월 WK5-12월 WK2)-인프런 풀스택 리액트 토이프로젝트 진행중(40%)(12월WK1-WK3 예정)-Kyle markdown node.js (12월 WK1-WK2 예정)-지난달까지 참여한 재남님 JS 스터디자료 주말에 1-2개 복습12월-1월 holiday break때 하려고 쟁여둔 내용-플젝1 simplified 개인프로젝트 version으로 마무리하기(로그인/회원가입 +랜딩 + detail + 좋아요 페이지까지)-포트폴리오 2/3 진행(모달 &amp; work 부분)-라이언이랑 페어 프로젝트 -알고리즘 스터디 recap`group projects'주간 멘토링을 받으며 진행했던 플젝1 완료- 12주차스터디에서 플젝2 진행중 3/16주NC에서 페어했던 라이언과 마크업앱(노션느낌) 아이디어를 building 중solo projects 11월포트폴리오 hero 페이지 완료리덕스 stack 쇼핑몰: RTK query &amp; 리덕스 toolkit 적용 (완료)로그인/회원가입 boiler plate: fire Auth &amp; 구글인증 (완료)다짐-혼자만 이해하는 게 아니라 설명도 잘 해줄 수 있는 개발자가 된다.-지금도 미친듯 시간을 쪼개서 이것 저것하느라 정신이 1도 없지만혹시라도 시간이 나면 넥스트스탭의 블랙커피 스터디에 참여하고 싶어서 알림신청 해 놓음-다음주부터 주5일 헬스 시작!!
279,"setting예1코드axios 이용해서 data 가져옴테스트 코드시도1. 비동기코드(getting promise back!)이지만 일단 일반테스트처럼 써봄!결과 fail recieved: {}간단히 고치기 =&gt; async, await 넣기mockAxioscall the codes 해줌!코드에서테스트코드에서or mockAxios 이용하기it will allow you to have an access to your mock!mockAxios.get.mockImplementation(()=&gt; Promise.resolve()); resolve 안에 쓰는 내용은 pretend value(mock data)line 4-7까지 : 실제 func 대신 mock func  data를 넣은 것임=&gt; shortened: .get.mockResolvalue()mock.fn() 같이쓰는 matchertoHaveBeenCalled()toHaveBeenCalledTimes(number)jest.clearALlMocksafterEach(jest.clearAllMocks);mock test 안전장치 =&gt; clear 해주기 otherwise, it would not work as the way I want it to workreferenceshttps://www.youtube.com/watch?v=gA-uNj2FgdM"
280,"1.사용하고 싶은 font link 넣기2-1. theme.js에 typogpraghy로 넣고 .('.') - 전체적용결과2-2 혹은 'theme.js'에서 개별 컴포넌트 (h3,h5 등)적용하기default 확인 https://mui.com/customization/default-theme/#main-content적용할 수 있는 css 범위 확인 https://mui.com/api/typography/Referenceshttps://mui.com/customization/theme-components/#global-style-overrideshttps://www.youtube.com/channel/UCCCHd7abr-a3LCZn7mvz4Xg"
281,referencesmui migration https://mui.com/guides/migration-v4/mui customizing https://www.youtube.com/watch?v=EyqpbNgrW3o00:36:00Themingtheme.js1.variable로 넣기2.App 에 넣기3.hover 진해지는 거 고치기사용한 mui 요소 =&gt;Fab 가장자리 동그란 버튼by making a better use of theming by targeting specific elements(or usage)right way to do it is..theme.js 파일안에 components:{} 만들고 커스텀할 내용 넣기 target the component =&gt; MuiFab (Fab 컴포넌트에 보면 api에 나와있음)overriding 할 rule-setting 하기 =&gt; root 레벨 설정하기 &amp; 변경 가능한 내용 확인// explain ithttps://mui.com/customization/theme-components/#global-style-overridesoutputFab 컴포넌트의1.작은 사이즈(sizeSmall)애들만 색상 바꿈!2.&amp;:hover 호버상태만 바꾸기 pinpointingend.
282,"reduxtoolkit 기본 세팅 마친 후방법1 createAsyncTunk사용하기https://redux-toolkit.js.org/api/createAsyncThunk1.slicer 만들기2.index에 넣기line 3, line 173.run 하고 redux Devtoolk 확인4.params 넣을 수 있는 값 =&gt; 에러value 넣기datathunkAPI 중에 rejectewithValue =&gt; reject 났을 때 pass 할 수 있는 error value 5.redux devtool 확인방법2 RTK Query사용하기https://redux-toolkit.js.org/tutorials/rtk-query1.import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'2.createAPI 세팅reducerPath 이름baseQeury 기본주소endpoints에 =&gt; products로 넣어주기 3.store.js에 내용 + middleware 넣기4.적용할 곳에 넣어주기"
283,"WK2 2/3context wrapper 추가로 에러 제거하기모든 테스트 케이스를 wrapper로 감싸주기옵션 가격을 위한 테스트 구현상품가격,옵션 가격을 더한 총가격 구하기2-2 내용에서 (useContext 사용해서 전역데이터 뿌려줌) 다소 복잡한 context 파일 때문에 대혼란어쨌든 오늘은 테스트 fail =&gt; pass로 바꾸기 위한 코드 짜는 내용임--에러#1실제 코드는 contextProvider 감싸주었지만calcuate.test.js테스트 코드는 감싸주지 않아서 에러남 🥦해결책 =&gt; 테스트 코드도 감싸주기🥦🥦 더 근본적인 해결책 =&gt; 모든 테스트 케이스를 wrapper로 감싸주기 useContext로 데이터를 가져온 다른 테스트들도 에러가 나니까 하나하나 다 wrapper 넣지 말고 custom render로 전체 감싸주기=&gt; 커스텀 렌더 사용하기렌더함수만 커스텀렌더를 만들어서 사용함하단에 customRender 만들어줌ui는 리액트 jsx의 ui임렌더함수 말고 다른 것들 screen들은 다시 export 하고render만 커스텀한 걸로 사용함utils-test.js파일 총 상품 가격  testing1.테스팅할 내용테스트 케이스가 비슷하면 describe()로 grouping테스트 케이스 total은 0원부터 시작함product update 될때(when a product is added(count?) total price 업데이트했느지 테스트option도 같은내용 테스트item이 removed 되었을 때도 테스트test1test2test3"
284,"WK22줄 요약-장바구니 total initial value 와 added value 테스트-전역관리로 useContext 사용1주차에는 테스팅을 짜는 강의를 처음부터 보고 따라하기 위주로 했지만, 이번주에는 설명을 듣고 내가 먼저 테스트를 짜보고비교하는 방식으로 진행함테스트라지만 너무 BE스럽게 만들어진 UI라서약간 mui + color 넣어줌..3.중요개념 useContext컴포넌트 or 페이지간 가격의 데이터들이 필요해서 data 교환/공유를 하기 위해서 useContext 사용함-리액트에서 전역 데이터 관리하는 방법1.테스트 코드 짬2.코드 에러남3.OrderContextProvider 코드작성-react 개념: useContext, useMemo-JS 개념 Map() .set()-불변성을 위해서 React는 상태update 바로 하지 않음!useEffect  상품 counts 업데이트가격 계산 함수Type.jsx 업데이트여행가격 관련 context 부분 넣기(products 컴포넌트)"
285,"https://emotion.sh/docs/introduction1.다운받기 npm i @emotion/styled @emotion/react2.스타일 파일 만들기 styles.ts3.임포트 Styled from @emotion4.필요한 내용 만들고 단위 별로 export const ~텍스트5.적용할 파일에 임포트 {가져올 애1, 2,3} 적용가능한 내용&amp;:hover {}nested selectorsglobal stylesprops object styles"
286,제로초 Sleak  강의 내용코드스플리팅당장 필요하지 않는 component 불러오지 않기나누는 기준-페이지 기준으로 나누기-SSR 필요 없는 페이지/components를 나누기1.설치 npm i @loadable/component2.임포트import lodable from '@loadable/component&quot;3.적용 import ~ 어쩌고 되어있는 부분을  const 페이지/컴포넌트명 =loadable() =&gt; import('임포트주소')
287,"학습 sources-인프런 존안님 리액트 테스팅 강의-Testing Library docs https://testing-library.com/docs/queries/bylabeltext/msw작동방식1.MSW 세팅-브라우저에 서비스 워커 등록해서 외부로 나가는 request 감지하고중간에 intercept(가로채서) MSW 클라이언트 사이드 라이브러리 보냄-등록된 핸들러에서 요청을 처리한 후 mocked 응답을 브라우저로 보냄2.노드와 통합브라우저 통합 or 노드와 통합 중 노드와 통합(jest 사용 테스트 환경) 선택3.실제 해보기폴더구조 src&gt;mocks&gt; 여기에 파일 만들기1.nsw 설치npm i msw --save2.핸들러란?노드 서버에서 작성하는 핸들러와 구조 거의 같음res: response, req: resquest, ctx:context(본문)Rest api 사용(or Graphql) =&gt; 사용 메서드 get: 이미지, data 가져옴, 엔드포인트(경로, 받아올 주소)3.필요한 handler 작성2개 작성(상품정보/옵션정부)4.서버 생성 셋업 서버 가져오고 핸들러 그 안에 넣어주기5.생성한 서버로 API 설정  위치:setupTests.js beforeAll 모든 테스트 전에 server.listen() 서버 시작하기 afterEach 하나 하나의 테스트 이후에 핸들러 리셋 afterAll 다 끝나면 server.close() 서버 닫기 업데이트 읭? 돌려보니 에러뿜"
288,"학습 sources-인프런 존안님 리액트 테스팅 강의-Testing Library docs https://testing-library.com/docs/queries/bylabeltext/실제 테스팅 Project간단한 여행App 장바구니overview프로젝트 세팅1.다운로드 dependencies2.eslint, prettier 설정3.설정 돌아가는지 test폴더구조테스트1주문확인 테스트 코드 작성 flow  테스트 내용: 주문 확인 tick 했는지 안했는지1. 테스트 코드 작성 &amp; 테스트12. 코드 작성에 넣어야 하는 내용inputtype=&quot;checkbox&quot;checked ={checked} 상태checked 상태관리 onChange((e)=&gt; setChecked(e.target.checked)}id =&gt; confirm-checkboxlabelhtmlFor =&quot;confirm-checkbox&quot; ?? //이거는 id와 맞춰주기&quot;Have you checked yoru order?&quot;button체크상태가 아니면 submit 금지type = &quot;submit&quot;disabled={!checked} 3. 테스트 코드를 보면서 코드 작성좌 컴포넌트 &amp; 우 테스트 코드 두고 작성 완료4. 테스트2=&gt; 테스트 돌려본다.FAIL!Have yo ucheked your order 뒤에 ?가 없었다..test passed!끝"
289,"라우터 업뎃된 내용을 v5-&gt;v6 리팩토링으로 개선해보기1. v5로 작성된 예math.url 등 사용useParams, useHistory 사용push,go, goBack 사용App.js1.홈: 경로 없을 때2.포스트: 아이디 url param받아서 보여줌, history 사용,goBack,go,push 사용3.유저: 서브라우팅 사용username이라는 url 파라미터 사용함,현재 경로 참고해서 math.path match.url 사용하고 있음match.url 사용 =&gt;매치객체 콘솔 찍어보면(현재 라우트설정에 매치된 값 url App 에서 준 경로 path)4.Optional withouth value받는 인자(param)이 optional인 경우5.optional with value상세 페이지 코드(넘겨도 됨)App.jsPost.jsUser.jsyarn add react-router-dom 재설치서버를 켰다 키면 v6 버전 깨져있음Switch 대신 Routes 사용함useHistory 대신 useNavigate navigate는 객체가 아니라 함수!history.push 대신 =&gt; line 10처럼 navigate()만 써주고go back =&gt; navigate(-1)숫자 써주기3.UseRouteMatch 사라지고 상대경로 씀기존 useRouteMatch 임포트와 변수 선언(line 7) 지워준다. 기존match가 더이상 필요 없으니 지워주고Link to나 Route path match.path 부분에=&gt; 상대경로나 주소  (주의!! about만 넣으면 주소이름 /about은 지금 주소 기준 뒤에 /about)4.Route에 프롭스로 children 대신에 element 사용기존 line 12 리팩토링 line12 지우고 element ={} 로 넣기하지만 계속 에러가남!Route는 Routes의 직속 자식이어야함=&gt; 모든 Route 상위에 Routes 두기6.exact component prop 사라짐!!  서브경로 필요하면 path에 와일드카드 *사용하기 App.js 기존  리팩토링line 11 exact 지워도 잘 작동함(default로 exact가지고 있음)line 13 exact 속성이 필요하지 않을 때 주소 뒤에 /* 설정해주기!Optional URL 파라미터 사라짐   필요하면 Route 2개 만들기   기존   Line 14 optional parameter로 링크 2개 만들었음         리팩토링 추가기능Outlet 서브라우트 구현하는 방법으로 추가됨 기존에는 2컴포넌트에 작성 1차 App.js  리팩토링 -&gt; 기존 user.js 안의 Route 내용을 하위에 넣어줌  2차 user.js 원하는 부분에 Outlet 컴퍼넌트를 넣는다. NavLine의 activeStyle,activeClassName 삭제 ...엄 이건 독스 참고하기^^"
290,2021.10월총평몇 가지 시험 + 개인사 + 고양이 가출 때문에 公私多忙 했지만 비교적 열심히 살았음고양이 가출로 매일 울면서 일어나서 새벽2시까지 동네 뒤집고 다니면서 전단 뿌렸는데6일째에 동네 캣맘 아주머니가 찾아주심😭😭위기프로젝트 2개 중 한 개 때문에 스트레스 받다가 안정된 것이 이번 달 중순이후의mental health에 엄청나게 긍정적인 영향을 주었음(문제의 원인이 사라짐:) 땡큐 할많하않....!완료데브옵스 코스 코테 10/5일(내년으로 일정 연기)노쓰코더스 코테 10/18일(합격)mui v.5 바뀐 내용 업뎃 패치 완료진행TS와 Next.js로 프로젝트 중에 Next 업그레이드했녜..? 터벅터벅...포트폴리오 webpage 11월 2주째까지 제출해야해서 아이디어 모으는 중(실력은 부족하면서 눈만 높아지는 중..!)리덕스 toolkit &amp; Query로 자그마한 쇼핑몰 페이지 만드는 중(개인)로그인/회원가입 boiler plate 만들고 있소(fire Auth랑 구글인증)다짐stack도 어렵고 이런저런 일이 많았던 팀프로젝트 한 개가 2-3주면 마무리 될 것 같다..역시 존버승리리액트 테스팅 스터디(3+2주) =&gt; 열심히 하쟛11월 중순부터 영어만 써야하는 NC 트레이닝 참여 예정근데..슬랙 채널에서 메시지 읽다가 현타. 2줄 질문에 50줄 답변...너무 길어서 스샷도 안됨 모든 답변에 10줄 이하로 답변다는 규칙을 정하면 좋겠다리이번 달은 공사가 다망하여중드를 많이 보지 못하였지만 넷플릭스로 한국드라마는 꽤 봤음다음 달에는 시간을 아껴서 더 열심히 살고 중드 할당량을 채워야지✨🎆
291,"♣타입스크립트 벼락치기 정리하기 한국어(updateX)https://typescript-kr.github.io/pages/basic-types.html#%ED%8A%9C%ED%94%8C-tuple영어 Docshttps://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#allow-captured-letconst-in-loops학습자료https://www.youtube.com/watch?v=LKVHFHJsiO0정리내용#1 Basic Types#2 TS function types NO BS TS#1BASICS정규식배열object또다른 방법 이렇게 하면 안되니까 =&gt; utility type Record 사용RecordFor loop 이나 forEachTS 알아서 inferring 하니까 필요 Xmap 마찬가지로 TS is smart enough to inferNO BS TS #2함수import/exportmodule.exports = 함수명;  사용하지 말고 export default 함수명;기본함수 타입예1)예2)독스에서 https://www.typescriptlang.org/docs/handbook/functions.html#functionsfunction add(x: number, y: number): number {return x + y;}let myAdd = function (x: number, y: number): number {  return x + y;};// 위 두개를 합치면...읭??let myAdd: (x: number, y: number) =&gt; number = function (  x: number,  y: number): number {  return x + y;};- #### Optional and Default Parameters`default params` =&gt; 인수 뒤에 =&quot;주고 싶은 값&quot;```jslet myAdd = function (x: number, y: number =8): number {optional =&gt;&gt; | 사용하기return 값 없을 때export const 함수명 = (params): void =&gt; {}promise 리턴 시export const 함수명 = (params): Promise&lt;string&gt; =&gt; {promise.어쩌고 }Rest Parametersfunction 함수명 = (x:number,...names:string): string =&gt; {}common mistake임포트 해온 함수에서 undefined 에러남🥓임포트 해오는 함수가 typechecking을 run 타임에 하지 않고 complie 타임에 함getName 함수 내용을 고친다아래 상태에서optional chaining해주기 so user is defined before we referece it혹은To be continued...!#3 - Typescript Functions with Functions#4 - Function Overloading in Typescript#5 - Optionals in Typescript#7 - Generics in Typescript🥠🥠#8 - Generics with keyof in Typescript#9 - Typescript Utility Types"
292,"-버튼 2개 (각 숫자를 +,- 시킴)-on/off 버튼=&gt; turn on/off, 스위치 색깔 변함counter 버튼 만들기 순서코드짜기 세부#11.테스트 코드dom에 App을 렌더해주고아이디로 엘리먼트에 접근함0부터 시작하는지 테스트test(&quot;작성하고 싶은 내용 요약&quot;,() =&gt;{// 설명 적기 코드쓰기~expect(체크할내용).toBe(원하는 값);})2.테스트(실패)npm test3.코드짜기테스트용 아이디data-testid =&quot;어쩌고&quot;4. 테스트성공...열심히 테스크 코드 짜고 돌아옴6개 성공disabled 시킬때 코드🧨1.상태 disabled 기본값 fale2.버튼에 disabled ={disabled}3.onoff버튼에 onClick이벤트  (()=&gt; setDisabled((prev)=&gt;!prev)} 중요한 점 =&gt; 어떤 matcher 쓰는 지 잘 알기"
293,"테이블을 만들고있었고 테이블 추가기능 (오름차순 내림차순 , 컬럼 필터 ... ) 을 만들고 있는도중데이터를 api 로 다시받아오는 새로고침 기능을 만들고 있었다.사실 새로고침 아이콘 버튼 클릭시 api 로 받아오는 함수를 다시 넘겨주면 간단하게해결되지만 사용자가 검색을하고나서 새로고침을 하는경우도 있기때문에 넘겨준 함수에 매개변수를 포함해서 다시넘겨주니 무한 렌더링 에러가 나왔다테이블 ui - 새로고침 버튼 &gt;테이블 컴포넌트 에서  isRefreshable 이름으로 api를 호출하는 함수를 넘겨준다&gt;"
294,개요현재 팀내에서 하고있는 프로젝트를 곧 사내에만 테스트적으로 배포한다고 했다.거기에 맞춰 사용자에게 개발오류 창을 보여줄수없어 다양한 화면단의 에러를 처리해줘야 했는데 아래와같다컴포넌트 내부로직 오류로 인한 에러 비동기 처리 에러 이벤트 핸들러에대한 에러첫번쨰 에러 처리 부터 막혔다리엑트 단에서 제공해주는 참조 componentDidCatch() : https://ko.reactjs.org/docs/react-component.html#componentdidcatchcomponentDidCatch() 란 녀석을 쓰려 했는데...해당 api 는 Class 형 컴포넌트 오류만 감지하는 특징이 있었다리엑트 단에서도 componentDidCatch()에 관한 hooks를 고려중이라 고했다..우리 컴포넌트들은 죄다 함수형으로 되있어서 (클래스형으로 바꿔야지 앵간한건..)절망 그자체 였다.함수형 컴포넌트 에러처리 하기1.첫번째 시도는 componentDidCatch() 를 포함하는 클래스를 만들어 의존성 주입을하여 오류를 감지하고 싶은 최상이 컴포넌트에 props 로 내려주는것이였다 2.두번쨰 시도는 라이브러들을 찾아봤다 역시나 componentDidCatch() hooks 로 전환하냐는 수많은 글들이 있었고 그에따라 여러 라이브러리들도있었다react-catch (https://github.com/ibrahim-13/react-catch)react-use-error-boundary (https://github.com/tatethurston/react-use-error-boundary)react-error-boundary (https://github.com/bvaughn/react-error-boundary)3번쨰 라이브러리를 이용하여 해답을 찾았고 해결방법은 아래와같다1.설치npm install --save react-error-boundary2.App.js 내부에 ErrorHandler 라는 함수를 생성한다App.jsimport {ErrorBoundary} from 'react-error-boundary'...function ErrorHandler({error}) {  return (    &lt;div role=&quot;alert&quot;&gt;      &lt;p&gt;컴포넌트 에러발생 발생된오류는 아래와 같습니다&lt;/p&gt;      &lt;p&gt;{error.message}&lt;/p&gt;    &lt;/div&gt;  )}...function App(){  return(      &lt;ErrorBoundary FallbackComponent={ErrorHandler}&gt;            &lt;하위 컴포넌트 .../&gt;      &lt;ErrorBoundary FallbackComponent={ErrorHandler}&gt;  )}배포 모드에선 오류발생시 아래와 같은 화면이된다 결과 : 라이브러리 에서 제공하는 ErrorBoundary 를 까보니 결국 내부적으로 componentDidCatch 를 사용하고 있었고 추가적으로 componentDidUpdate 라는 api를 사용하고 있었다 참조 (리엑트 공식문서 componentDidUpdate) : https://ko.reactjs.org/docs/react-component.html#componentdidupdate리엑트 생명주기를 다시 꺼내들었고 왜 그렇게 면접을 보는데 리엑트 생명주기에 대해 집요하게 여쭤보는지 내심 알게되었다 참조리엑트 공식문서 ErrorBoundary: https://ko.reactjs.org/docs/error-boundaries.html에
295,"📢 본내용은 하위링크 내용을 요약 하였습니다 : 토스ㅣSLASH 21 :   https://www.youtube.com/watch?v=edWbHp_k_9Y질문하기 버튼을 클릭하면 유저의 약관동의 여부를 검사하고 필요시 파업을 띄운다이코드에 새기능을 어떻게 추가하면 될까?아래와 같이 해보자 팝업 상태를 선언하고 연결중인 전분가가 있으면 팝업을 띄운다 타당하고 맞는 코드이지만 문제점이 매우많다 왜 ?초록색으로 강조한 코드가 모두 한가지 기능인 ‘ 연결 중인 전문가 팝업’ 관련 코드이다 이렇게 기능이 뚝뚝 떨어져있으면 기능추가시 스크롤을 위아래로 이동하며 미로 찾기를 해야한다  또 하나의 함수가 여러가지 일을 하고 있다 아래와 같이 기존의 함수가 3가지의 일을 하고 있다이렇게 세부구현을 알아야만 함수의 전체적인 쓰임을 이해할수있고 유지보수 시간도 길어진다이름 통일이 제각각이다그떄는 맞고 지금은 틀리다 ! 처음 짠 코드는 클린하지만 추가적 기능이 들어갔을땐 매우 어지러운 코드가 된다왼(처음) ⇒ 우 (기능추가후)그럼 어떻게 짜야 하는가 ? 아래 3가지 방식을 보자 함수 세부 구현 단계를 통일 한다함수 이름변경 (함수의 위계를 맞춰준다)2.하나의 목적인 코드는 뭉쳐 두기 기존에는 팝업을 여는 버튼과 파업코드가 동떨어져 있었지만 이를 모아서 PopupTriggerButton 이라는 컴포넌트를 만들어주었다 띄워줄 팝업은 props 로 내려보내 주었다 3.함수가 한 가지 일만 하도록 쪼개기 약관동의 관련 함수를 쪼개서 필요한 시점에 부르도록 바꿨다그런데 이렇게 3가지원칙에 따라 코드를 리팩토링 하니 코드가 길어졌다 ? 클린코드 맞아 ? 원하는 로직을 빠르게 찾으려면 3가지 속성이 필요하다 응집도, 단일책임, 추상화"
296,"📢 본내용은 하위링크 내용을 요약 하였습니다 : 토스ㅣSLASH 21 :   https://www.youtube.com/watch?v=edWbHp_k_9YClean Code 란 ?**‘명확한이름’  ,  ‘ 중복 줄이기 ‘ + “섬세하게 코드를 정리하는 스킬” **그럼 “섬세하게 코드를 정리하는 스킬” 엔 어떤 방법이 있을까 ?아래의 4가지를 보자!1. 실무에서 클린코드의 의미📢 “그코드는 건드리지 마세요 재가 할께요 “흔히 이런말을 하곤한다  이런코드의 특징은    1. **흐름파악이 어렵고**    2. **도메인 맥락 표현이 안됨**    3. **동료에게 물어봐야 알수 있는 코드** 문제점! 🚨  **  개발할때 병목이 되며 유지보수 시간을 길게 만든다 심하면 기능추가가 불가능 하게 한다**  이런코드는 성능도 좋지않기 떄문에 유저 입장에서 쾌적 하지 못하다**## 실무에서 클린코드의 의미  🚨  과거 동료 혹은 내가짠 코드를 빠르게 이해할 수있다면     유지보수 할때 드는 개발시간 짧아짐   ⇒ 고치는데 3일걸리는 코드와 하루 걸리는 코드가있다면 ,   전자는 개발자가 3배더 필요하다 or 3배 일하던가 ... 그럼 클린하게 짜면 되잖아 ?"
297,"현재 사내 프로젝트에 따로 에러 처리가 되있지않아. 에러를 핸들링하면서   해당 메시지를 띄워줄수있는 페이지를 만들고 있었다.  react-query 를 사용하면서 suspense를 많이 사용하는것같았지만   우린 따로 react-query를 사용하지않아, 다른 방법을 찾아봤다    componentDidCatch 라는 클래스형 컴포넌트에서 에러를 핸들링 해주는 방법이 있었는데  우린 함수형컴포넌트로 프로젝트가 구성 되있어서 다시 좌절을 맛보았다 ...  다행이 react-catcher 라는 componentDidCatch 를 함수형으로 개조해서 만든 라이브러리가 있었고 적용을 시키기위해 학습한 내용을 적어 보았다  | 🚩react-catcher : https://github.com/ibrahim-13/react-catch    참조함수형 컴포넌트 에러 잡아내기 : https://webcorgi.tistory.com/49#ReactCatcher%--%EB%-D%BC%EC%-D%B-%EB%B-%-C%EB%-F%AC%EB%A-%AC%--%ED%-C%-C%ED%--%A-%EC%B-%--%EB%B-%B-%EA%B-%B-리엑트 공식문서 Error Boundaries : https://reactjs.org/docs/error-boundaries.html"
298,"*| 타입스크립트 사내 스터디 사용을 위한 자료*하지만 이름에서 알 수 있듯 JavaScript는 독립적인 언어가 아닌 스크립트 언어이다.스크립트 언어는 특정한 프로그램 안에서 동작하는 프로그램이기 때문에 웹 브라우저 프로그램 안에서만 동작을 한다.즉, 웹 브라우저(크롬, 사파리, 익스플로러, 파이어폭스 등)가 없으면 사용할 수 없는 프로그램이다.여기서 Node.js가 나오는 이유가 된다.Node.js 는 Chrome V8 JavaScript 엔진으로 빌드 된 JavaScript 런타임입니다*런타임 : 특정 언어로 만든 프로그램을 실행할 수 있는 환경내장 HTTP 서버 라이브러리를 포함하기 떄문에  있어 웹 서버에서 아파치 등의 별도 소프트웨어 없이 동작하는 것이 가능하다이를 통한 웹 서버의 동작에 있어 더 많은 통제에서 벗어나 여러 가지 기능을 가능하게 한다.출처 : https://hanamon.kr/nodejs-%EA%B0%9C%EB%85%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/#:~:text=Node.js%EB%8A%94%20V8%EC%9D%B4%EB%9D%BC%EB%8A%94,%EC%A0%9C%EC%9E%91%ED%95%98%EA%B8%B0%20%EC%9C%84%ED%95%B4%20%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A1%8C%EB%8B%A4.2.Node js 는 서버인가 ?Node.js Chrome V8 JavaScript 엔진으로 빌드 된 JavaScript 런타임입니다런타임 : 특정 언어로 만든 프로그램을 실행할 수 있는 환경서버서버는 클라이언트에게 네트워크를 통해 정보나 서비스를 제공하는  프로그램  ⇒ Node.js 로 “서버도” 만들수있는것 Node.js 등장배경자바스크립트로 고성능에 서버를 만들고 싶어서 (99% 정답)⇒ 👨Node.js 는 자바스크립트로 (백엔드)서버를 만들기위한 런타임 환경이다자바스크립트는 싱글스레드인데 어떻게 좋은 서버를 만들수있을까 ?  Non-blocking I/O ? :"
299,"출처 : https://ko.javascript.info/modules-intro모듈 : 파일안에 코드를 모듈화해서 작성하는것        파일안에 작성되있는 코드 모듈화 해서 작성하지 않으면 모든 코드들은 글로벌하게 측정됨  브라우저 환경 -&gt; window    노드 환경  -&gt; global 모듈 이라고 하는것은 코드를 그파일 내부에서만 한정할 수 있도록 모듈화 하는것모듈화 하면 서로다른파일에서 접근 할수 없다 만약 다른 모듈을 접근하고 싶다면 &quot;import 와 export 를 사용하면된다 &quot;  default export는 모듈내에서 하나의 변수, 함수 또는 클래스만 export 할 수 있다함수 또는 클래스 여러개를 export 해야 한다면 개별적으로  export로 명시해 주셔야 한답니다"
300,ts 를 점진적으로 적용하면서 다양한 레퍼런스 들을 보고있다.   그러다 ts 쪽에선 enum 사용을 장려 하지 않는다는 말이있었고   그것의 의미에대해 학습해 보았다   enum?값들이 정해져있고 그값들의 집합이 enum 이다     어떤값이 파라미터로 들어갈까 ?   어떤값이 반환되어 서버로 전송될까 ?  enum 을 쓰면 자동완성이 편해진다 =&gt; constants 값을 설정하는방식 강의는 기존의 프로젝트에서 ts 변환 오류(타입오류)를 해결하며 진행 dom 함수 관련 타입 오류 분석 : Elemnt 타입에 왜 innerText 가 없을까 ? 돔정보에 관련된 타입체계는 아래와같이 위계를 가짐 Elemnt :  Elemnt  HTMLElemnt  HTMLParamElemnt :
301,"요즘 클린코드에 관심이 많다.  프론트 개발자로서 프론트 영역의 기술이 수명이 짧다고 느꼈다. 좋은 것을 가져다 쓰면  더좋은게 나오고 ... 더 합리적인게 나오고... 개인 생각이지만 프론트 개발자로서 지금 위치에서 할수 있는 최선은 계속 나오는 좋은 것을 쉽게 가져다 쓰기위해 코드를 유지보수 하기 쉽게 짜야 했다고 느꼈다.요즘 회사에서 사용하는 코드를 시간이되면 나름 클린(?) 하게 만들고있다 토스에서 제공하는 프론트 클린코드 영상이다 : https://www.youtube.com/watch?v=edWbHp_k_9Y&amp;t=905s  거진 5번이상은 돌려보고 문서로도 아예 만들었다 (토스에게 무한의 감사...🙇‍♂️)영상에서 말하는 클린코드 규칙중 &quot;하나의 기능이 흩뿌려진다&quot;는 말을 공감하고 그부분을 중점으로 클린하게 만들고있다출처-토스:클린코드 : https://www.youtube.com/watch?v=edWbHp_k_9Y&amp;t=905s위와같이 리엑트 코드를 보면 하나의 기능이 컨트롤단 뷰단에 흩뿌려져있는 경우가 있다 지금이야 기능이 하나있어서 나름(?) 한눈에 보이지만 대부분 한컴포넌트에 여러 기능이 있기떄문에 그런경우는 하나의 기능을 파악하기위해 스크롤을 몇번이고 올렸다 내렸다 해야한다.... 그럼 이런 기능을 어떻게 한곳으로 모을까 ???정답은 : 훅 이다 리엑트에서는 class 의 이점인 state 의 특징을 함수형에서도 사용하기위한 대체제로 훅을 사용한다. 아래 그림과같이 mounting , updating , unmounting =&gt; 리엑트 상태주기 를 함수형에서는 사용을 하지못했다 하지만 훅의 도입으로 이러한 상태를 사용할수 있게 되었다 참조 : https://www.youtube.com/watch?v=C26vJqelKlA&amp;t=65s참고토스-프론트 클린코드 :https://www.youtube.com/watch?v=edWbHp_k_9Y&amp;t=905s리엑트 훅이란 ? :https://ykss.netlify.app/react/hooks/ref 사용법 :https://merrily-code.tistory.com/121자식컴포넌트에서 부모컴포넌트 사용하기 :https://medium.com/humanscape-tech/%EB%B6%80%EB%AA%A8%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C%ED%95%98%EA%B8%B0-3911a43bc541"
302,"타입스크립트 환경설철 + js=&gt;TS 파일 변환any 타입을 먼저 선언한다이후 any 타입을 코드에 맞는 타입으로 변경한다 환경구성1.타입스크립트 라이브러리 설치 npm i typescript -D     2. 타입스크립트 설정파일 기본값 추가 tsconfig.json    3. 자바스크립트 타입스크립트 변환    4. 타입스크립트로 컴파일 tsc | tsc : 타입스크립트 컴파일 명령어 (ts =&gt; js로 변환)!(https://velog.velcdn.com/cloudflare/tkp12345/adf1c2cb-cb7a-4930-ab0d-343bcf6968e5/image.png)   tsc 에러 : cdn 으로 자바스크립트 사용시   왜?: 이미 서버에 배포된 라이브러리를 script 태그를 사용해 cdn 방식으로 당겨오면 ts 변환시 라이브러리 인식이 불가하다   &quot;기존프로젝트의 JS 파일을 모두 TS로 바꿀 필요는 없다!&quot;=&gt;선택적 점진적으로 적용 가능 =&gt; tsconfig.json : &quot;allowJS&quot; :true,any 타입을 먼저 선언 해보기1.'tsconfig.json' 파일에 'noImplicitAny' 값을 'true'로 추가"
303,"*타입스크립트 스터디 진행을위한 프로젝트 참고 자료 입니다  *nodeJS 에서 서버를 만들기 위해서는  http 모듈을 사용해야한다서버만들기 Api 디자인 하기REST API 사용하기 API : 사용자가 편하게 쓸수있도록 제공하는 기능 ( 함수 , 인터페이스 ... ) 서버측면에서 API : URLREST :(Representational State Transfer) http 메소드 4개가지고 디자인 하는것 🔺서버 소프트웨어 아키텍처 디자인할수 있는 스타일 /가이드 🔴서버에는 다양한 데이터 존재 -&gt; 이런 다양한데이터를 url 로 그룹지어 클라이언트에게 제공한다 REST 가이드 :클라이언트와 서버 구조(아키텍처)스테이트가 없는 : 하나의 요청이 다른요청과 관계없는 (HTTP 프로토콜에서 해준다)캐쉬를 할수 있도록 : headers 에 설정한다 (HTTP 프로토콜에서 해준다)서버에 개수에 상관없이 클라이언트에서 api 요청하면 하나의 api 로 응답해야한다클라이언트가 이해할수 있는 포맷으로 데이터를 보내좋야함 (html , xml, json 형태)서버로 붙어 받은 데이터를 어떻게 처리할수있는지 알아야함ex) 제이슨데이터를 서버로 붙어 받았을때 수정이나 삭제할수 있는 요청정보도 있어야함클라이언트 요청에따라 응답을 받는데이터에는 클라이언트가 어떻게 이응답을 처리할수있는지에 대한 정보가 나와있어야한다 (ex  http 헤더에 contents-type 을지정하는것)http -&gt; 서버에는 다양한 데이터 존재 -&gt; 이런 다양한데이터를 url 로 그룹지어 클라이언트에게 제공한다 api 디자인하기데이터를 가지고 무엇을할껀지는 메소드로 나타냄url 에는 무엇을할것인지"
304,"*타입스크립트 스터디 진행을위한 프로젝트 참고 자료 입니다  *파일로 작성해서 노드 실행하기 nodeJS : 컴퓨터위에서 동작하는 자바스크립트 런타임 환경프로젝트 터미널 : 👉 node 파일명this 에 관하여함수안에서 this =&gt; global 클래스 안에서 this =&gt; 그 클래스 내부 thisNodeJS  - import ,export구방식 ) es6 신방식 )"
305,왜? NodeJS를 다시 하는가  사내에서 타입스크립트 스터디를 주최해서 나름의 리딩을 하고있다. 본인도 타입스크립트가 익숙하지 않고 원래 우리팀끼리 작은 스터디를 만들어서 시작하려 했지만. 팀장님의 제안에 더불어 전사적으로 스터디 모집 공고를 작성하여  인원을 모집하여 타입스크립트 기초 개념 스터디를 시작하게되었다 스터디 모집공고   스터디 시작은 타입스크립트 교재 단권화로 시작해서 관련인터넷강의 학습 및 타입스크립트 관련 학습 발표로 진행되었다. 스터디 중반부에 돌입하게 되었고 원래 계획이였던 타입스크립트로 작은 프로젝트를 구성원과 함께 진행하려 했다. 거기에 발맞춰 프로젝트 스펙이나 구조를 리드하는 내가 짤 필요가 있었고 서버로 자바스크립트를 사용하기위해 nodeJS를 선택했다. 그런데 구성원중에 nodeJS를 경험해보신분이 전무해서 프로젝트 진행전에 간단하게 nodeJS 서버 만드는 방법과 간단한 api 만드는 방식을 알려 드려야했다.프로젝트 구성도  나는 주말간 nodejs 를 서버로한 간단한 모의프로젝트를 만들어 스터디 시간에 팀원들께 공유하며  nodeJS관련 사용법을 알려주기 위해 다시 nodeJS를 펼쳤다
306,"1.웹팩 start 웹팩은 자바스크립트 환경에서 쓰이는 모듈 번들러 입니다 우리가 웹서비스를 사용하려면 서버로 부터 네트워크 요청을 해야합니다 요즘 서비스는 고도화되고 방대해졌고 단순히 이런 서비스를 사용하기 위해  네트워크로 부터 많은파일(HTML,CSS,JS,Images...)들을 요청하게 되면 속도도 매우 느리게됩니다.이를 해결하고자 이런 많은파일들을 압축하고 모듈화 시켜 네트워크로 보내줄 녀석이 필요해 졌습니다. 이 역할 즉 , 모듈 번들링을 해주는 녀석이 바로 &quot;웹팩&quot;입니다 웹팩을 사용하기 위해서는 Node.js 와 NPM이 컴퓨터에 설치 되어 있어야한다 참고- 웹팩을 왜쓰는가? : https://developer-alle.tistory.com/297참고- 웹팩을 쓰게된 배경 :https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.htmlnpm 이란?자바스크립트 라이브러리 도구 nodeJs 를 설치하면 함께 설치된다 ide terminal 창에서npm init -&gt; 프로젝트 네임 ,,,설정 -&gt; package.json 생성 설치방식*npm install 특정라이브러리 이름 *=&gt; 해당프로젝트에 &quot;node_modules&quot; 라는 폴더생성됨 -그폴더 하위 라이브러리 파일 설치 되있음전역설치 : npm install 특정라이브러리 이름 --global전역적으로 설치됨 - 시스템레벨에서 사용 # window : AppData/Roaming/npm/node_modules# mac : /usr/local/lib/node_modules 에생성된다 2. package.json 알아보기dependencies 와 devDependencies 란dependencies(npm i 라이브러리) 코드에 직접적 영향을주는 라이브러리들 react, vue ,jquerydependencies(npm i 라이브러리 -d ) 개발을 할떄 도움을주는 보조라이브러리 =&gt; webpack , sass ,,,,dependencies 와 devDependencies 차이점👉 배포용 : dependencies =&gt; npm run build 시 배포 되지않음 👉 개발용 : devDependencies =&gt; npm run build 시 배포 되지않음 둘의 차이를 두지 않으면 배포되지 않아야할 기능들이 배포되 배포 시간을지연시킴npm 을 왜사용하는가?1 라이브러리 버전 관리를 위해특정라이브러리가 다른라이브러리 에 연관될떄=&gt; npm 을 사용하지 않으면 컴포넌트 상에서 해야함=&gt; npm 을 사용하면 생성된 package.json 안에서 라이브러리 관리2.3. 웹팩  , 웹팩 cli 이란웹팩최신 프론트엔드 프레임워크 에서 많이 사용되는 모듈 번들러애플리케이션 구성자원 (HTML,CSS,JS,Images...) 모듈화 번들링 (빌드,번들링,변환 같은의미): 위그림과 같이 몇십 몇백 개의 자원들(HTML,CSS,JS,Images...)  하나의 파일로 병합 및 앞축 해주는 동작"
307,문제상황진행되는 프로젝트에 비동기 처리 작업을 하는도중await 에서 분명히 promise 객체를 반환 할텐데 try catch 문 내부에서 api 콜 (비동기) 에러를 잡지 못하고있었다const apiCall = async ()=&gt;{    try{        await disptch (            👉 API_CALL.asyncAction.apiCall( {...}) //가공된 promise 객체 리턴        )        👉 await alert('API_CALL 성공')    }catch(err){       await alert('API_CALL 실패')        ...    }} 👉 API_CALL.asyncAction.apiCall( {...}) 에서 에러를 발생시켰는데        await alert('API_CALL 성공') 이 계속 호출되었다. **  처음엔 try catch 에서 api 요청에대한 비동기처리 에러를 감지 하지 못한다고 생각했다. **   ** 하지만 어찌됬든 promise 객체의 reject 를 반환 해서 이러한 생각은 말이 되지않았고 ****   리덕스 툴킷을 사용하고 있다는 점을 간과하였다 **       👉  *API_CALL.asyncAction.apiCall( {...})  의 리턴값은 순수한 promise 객체가 아니였고 *const apiCall = async ()=&gt;{    try{        await disptch (            👉 API_CALL.asyncAction.apiCall( {...}). unwrap() // promise 객체 리턴         )        await alert('API_CALL 성공')    }catch(err){       👉 await alert('API_CALL 실패')        ...    }}**   리덕스 툴킷  unwrap() 을 붙여주니 정상적으로 에러를 감지하게되었다 **  리덕스 툴킷unwrap() 이란? : https://velog.io/@tkp12345/Redux-toolkit-unrap-%EC%9D%B4%EB%9E%80참조에러처리중복 : https://thinkforthink.tistory.com/194async &amp; awiat :https://developer.mozilla.org/ko/docs/conflicting/Learn/JavaScript/Asynchronous/Promises에러핸들링:https://rinae.dev/posts/how-to-handle-errors-1딥다이브 : https://velog.io/@boram_in/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%94%A5%EB%8B%A4%EC%9D%B4%EB%B8%8C-46%EC%9E%A5-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EC%99%80-asyncawait제너레이터:https://ko.javascript.info/generators참조:https://ko.javascript.info/async-iterators-generators참조:https://blog.coderifleman.com/2014/11/15/javascript-and-async-error/
308,"form 에대해 공부하는도중 react 자체에서 form의 유효성 검사를 해주고 있었고그 하위특징중 dangerously set InnerHTML 이라는 특징이있었다 dangerously set InnerHTML일반적으로 코드에서 HTML을 설정하는 것은 cross-site scripting(XSS) 공격에 쉽게 노출될 수 있기 때문에 위험하다그래서 렌더링 메서드 내부에서 html 태그가 담겨있는 문자열 형태를 렌더링 하면, 태그가 먹히지 않고 문자열 그대로 렌더링되게 된다.참조react 공식문서-dom : https://reactjs.org/docs/dom-elements.html"
309,"사내 프로젝트에서 한페이지(url)에 엄청나게 많은 form 을 관리하게 되었다 단순히 form 처리만 (서버에 보내는)하는게 아니라유효성처리등등 form을 사용함으로서 추가적으로 해야하는 일이많았다.기존 프로젝트에서는 formik 이라는 라이브러리를 사용하여 상태를 관리하고있었고 한 페이지당 form이많아지자 이 formik 라이브러리에 대한 처리가너무 길어졌다 이form에대해 집고 넘어가고 싶었다.form 이란?사용자가 웹 사이트로 정보를 보낼수 있는 입력창구자바스크립트 사용자로서 form의 사용은form 태그를 사용하여 어디서부터 어디까지 form을 사용할것인지범위를 지정한다&lt;form&gt;   &lt;input.....&lt;/form&gt;form 태그form 태그 구성요소&lt;form    1.action : 서버 url (ex action=&quot;/url-323&quot;)   2.method : 요청처리방법 (ex method=&quot;get&quot;, default 로 get이간다 )   3.name   : form 식별 이름    4.novalidate : 검증수행안함 - form 전송시 입력된값 검증 수행 않음    /&gt;form 유효성 검사form 은 :사용자가 웹 사이트로 정보를 보낼수 있는 입력창구라고 했다사용자가 입력해서 오는값이 제대로된 값인지 검사를 해줘야하는데그게바로 form 유효성 검사이다 이 form 유효성검사는 클라이언트 단과서버      단에서 검사가 있는데 클라이언트에서의 검사는서버에 부하를 주지않을수 있지만 사용자에 의해 검증 결과가 쉽게 조작될 수있다는 단점이 있다 서버에서의 검사는말그대로 서버쪽에서 검사를 하는것이다 당연히 서버쪽에서 검사를하면 부하가 추가될것이고 form 라이브러리  react 단에있는 form 상태관리 라이브러리들이있다formikreact Hook Form 등등 이런라이브러리는 form 상태관리를  해준다는점에서 우리팀에서도 formik 을 사용하고 있었다 여기에 유효성 검사를 위해 yup 이라는 라이브러리를 사용하고 있었다 항상 그렇듯이 어떤 문제를위해 대체제(라이브러리)를 사용하게되면 그에따른 대체체에대한 이해도 필요하고 그에맞게 코드 길이도 길어지게 된다.일련의 예로formik은 다른팀동료가 먼저 차용해 사용하였고동료의 코드를 이해하고 다시 사용하는데 시간이걸렸고 사용함에있어 가독성이 떨어진 코드를 자연스레 쓸수 밖에없었다.참고우아한 테코톡 form :https://www.youtube.com/watch?v=Z2YJvBw3pPI&amp;list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&amp;index=15"
310,"*회사에서 프로젝트를 하다 비동기 처리 관련하여 문제에 직면했다 문제상황은 아래와같다 *문제상황몸이란 것을 만들어야하고 몸을 만들기 위해선  하위에 팔,다리 를 만들고 만든 팔다리를 연결해야한다문제해결과정 *비동기적 처리이기 떄문에 아래와 같이 함수 구조를 잡았다 **그런데 문제가 생긴다 *위와같이 코드를 작성하면***몸통생성을하고 팔을 몸에 연결한 이후에 **다리를생성 하는 작업을 처리한다**사실, 몸통이 만들어지고 나면**팔생성과 다리생성은 동시에 시작해도 상관이없다***👇 원하는 결과를 도식화 하면 아래와같다이제 저 2번에 해당하는 두녀석을 동시에 병렬로 처리해야하는데아주 알맞은 녀석이있다promise.all()순서가 무관한 비동기 처리를 병렬로 시작하고 싶을때 사용한다사용방법 promise 로 구성된 인자를 배열로 받는다 , 배열안에 있는 인자들은 병렬로 실행된다해결1.몸통생성을하고 2.생성된 몸통id를 팔생성연결 , 다리생성연결 하는 함수에 전달한다풀지못한문제배열에 있는 id 값으로 dispatch 보내는 로직을 foreach 문을 돌려서 await 하면 에러가난다하지만 foreach 문을 -&gt; for...of 문으로 바꾸면 신기하게 에러가나지않는다에러❌id배열.forEach(v=&gt;{          await dispatch(...)     }성공⭕for (const v of id배열) {          await dispatch(...)     }참조언제  promise.all() 사용해야될까?:https://code-masterjung.tistory.com/91promise.all() 이란 : https://ko.javascript.info/promise-apiasync/await로 자바스크립트에서 여러 Functions를 제대로 체이닝 해보기:https://ui.toast.com/weekly-pick/ko_20190826#asyncawait%EB%A1%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EC%97%AC%EB%9F%AC-functions%EB%A5%BC-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%B2%B4%EC%9D%B4%EB%8B%9D-%ED%95%B4%EB%B3%B4%EA%B8%B0비동기 처리방법 : https://velog.io/@findmytrueself/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC%EC%BD%9C%EB%B0%B1%ED%95%A8%EC%88%98-Promise-async-await%EC%9E%91%EC%84%B1%EC%A4%91"
311,"http 클라이언트 서버간 응답,요청   메세지 를 전달할수있다 응답 ,요청 메세지는 공통 포맷을 가지고 있고 이포맷은 http 헤더 와 http 바디로 이루어져 있다 출처 :  https://hazel-developer.tistory.com/145http 헤더 General 헤더 : 일반적 정보 - 요청응답 메시지 공통 사용    Transfer-Encoding  : http 바디  자체 압축 방식Request헤더 , Response 헤더   요청 할땐 - Request헤더  응답 할땐 - Response헤더   👉 Request헤더 :  요청 URL , 메소드 GET,POST , 브라우저 정보      👉 Response헤더: 컨텐츠 인코딩 , 서버 시스템 응답을 생성하는데                       사용되는 서버 등등 ,, Entity 헤더 : 실제 메시지 , 컨텐츠 길이 ,언어 ,인코딩 .... http 바디참조-http 구조: https://hazel-developer.tistory.com/145"
312,"객체 배열을 관리하다가 계속 재사용 하기위해 객체 배열 안의 원소를 배열로 뿌려주는 일이 생겼다     const tableColumns =                    {Header:'생성', accessor:'create'},            {Header:'삭제', accessor:'delete'},            {Header:'조회', accessor:'find'},                accessor를 따로 배열로 뽑고싶었다        👉 'create','delete','find'참조 스택오버플로우: https://stackoverflow.com/questions/34309090/convert-array-of-objects-into-array-of-properties"
313,"import cv2vid = cv2.VideoCapture(0)while True:    ret, frame = vid.read()    cv2.imshow(&quot;frame&quot;, frame)    if cv2.waitKey(1) &amp; 0xFF == ord(&quot;q&quot;):        breakvid.release()cv2.destroyAllWindows()위 코드를 실행 시켰더니 아래와 같은 에러가 출력 되었다.cv2.error: OpenCV(4.5.5) /Users/runner/work/opencv-python/opencv-python/opencv/modules/highgui/src/window.cpp:1000: error: (-215:Assertion failed) size.width&gt;0 &amp;&amp; size.height&gt;0 in function 'imshow'vid = cv2.VideoCapture(0)를 vid = cv2.VideoCapture(1)로 수정하였더니 해결. stackoverflow 첫번째 답변과는 반대지만 어쨌든 작동!"
314,"제이펍 &lt;전문서 서평단&gt; 활동을 위해서 책을 제공받아 작성된 서평입니다.이 책은 요리 레시피처럼 파이썬으로 활용할 수 있는 302가지 기술들에 대해 나열한 책이다. 따라서 표지에 쓰여있는 것처럼 실무에서 당장 구현이 필요한 부분이 있다면 목차를 보고 빠르게 찾아 사용할 수 있게끔 구성되어 있다.특히 초보자라면 내가 원하는 처리나 적합한 라이브러리를 선택하기 위한 기준이 명확하지 않을 수가 있는데, 그런 경우 좋은 참고 자료가 될 것이라고 보여진다.위 이미지는 출판사 홈페이지 미리보기 페이지에서 확인한 내용이다.이와 같은 구성이므로 깊은 내용을 이해하고 학습한다기보다는 인덱스 용도로 활용하기에 좋은 책으로 보인다. 어차피 추가적으로 필요한 지식들은 인터넷 검색을 통해서도 충분히 학습할 수 있으니 말이다. (참고문헌 페이지에도 집필시 저자가 참고한 문헌 목록도 실려 있으므로, 깊은 학습을 원한다면 참조하면 좋을 것 같다.)"
315,테스트 환경 우분투 20.04$ sudo timedatectl set-timezone Asia/Seoul$ dateTue Apr 26 15:52:05 KST 2022
316,"제이펍 &lt;전문서 서평단&gt; 활동을 위해서 책을 제공받아 작성된 서평입니다.이 책의 시작은 우리의 뇌가 세 가지 인지 과정 즉, 장기 기억 공간(long-term memory, LTM)과 단기 기억 공간(short-term memory, STM) 그리고 작업 기억 공간(working memory)을 갖고 있다는 개념에서부터 출발한다. 동시에 프로그래밍 학습이 어려운 이유와 어떻게 해야 복잡한 코드를 똑똑하게 이해할 수 있는지 또는 새로운 프로그래밍 언어를 배울 때 두뇌에서 어떤 일이 일어나는지를 과학적으로 풀어내 독자의 호기심을 자극한다.개인적으로 인상 깊었던 부분은 대부분의 사람이 프로그래밍 언어를 처음 배우면 코드를 읽는 것보다 작성하는 것에 대해 많은 관심을 두게 되는데, 놀랍게도 코드를 읽는 능력을 더 향상시켜야 관련 기술을 더 정확하고 빨리 이해할 수 있다는 내용이었다.이 외에도 좋은 코드를 작성하기 위한 명명법, 동료들과의 협업 방식, 새로운 팀원의 적응을 돕기 위한 지원 방식 등에 관한 내용도 소개하고 있다.대상 독자는 프로그래밍 스킬 뿐만 아니라 일을 잘하고 싶은 모든 개발자다. 누구나 무리 없이 읽을 수 있는 내용의 책이다. 특히 이제 막 프로그래밍을 시작한 초보자라면 좋은 습관을 들이는 데 도움을 줄 것이다."
317,"길벗출판사 &lt;17차 개발자 리뷰어&gt; 활동을 위해서 책을 제공받아 작성된 서평입니다.비교적 간단한 연습 문제들을 통해 먼저 배운 파이썬 문법을 실제로 적용해보는 연습을 할 수 있도록 유도하는 책이다. 다양한 이유로 파이썬을 첫 코딩 언어로 접하는 사람들이 많다. 하지만 기본 문법을 공부하고도 막상 어디서부터 어떻게 활용해야 할지 막막해지는 경우들이 많이 봤다. 당장 나부터도 업무에 코딩 능력이 급하게 활용되는 부분이 적어 문법 학습 단계에서만 계속해서 맴돌았던 적이 있기에 더욱 더 반가운 내용의 책이 아니었을까 싶다.이 책은 기본적인 문법에 대한 상세한 설명이 담겨있진 않지만, 문제마다 제공되는 Python Tutor 실제 예제를 통해 작성한 코드가 실제로 단계별로 어떻게 실행되는지 시각적으로 확인할 수 있어서 이해에 많은 도움이 된다. 또한 역자의 유튜브 채널에서 일부 문제에 대해 친절한 설명이 담긴 영상을 확인할 수 있으니 필요하다면 유튜브에서 역자의 이름을 검색해보길 권한다."
318,"Multus CNIMultus CNI를 사용하면 Kubernetes의 파드에 여러 네트워크 인터페이스를 연결할 수 있다.작동원리Multus CNI는 여러 네트워크 인터페이스를 파드에 연결할 수 있는 Kubernetes용 컨테이너 네트워크 인터페이스(CNI) 플러그인이다.일반적으로 Kubernetes에서 각 파드는 하나의 네트워크 인터페이스만 존재한다.(루프백 제외) Multus를 사용하면 여러 인터페이스가 있는 Multi-Homed pod를 만들 수 있다. 이것은 Multus가 여러 개의 다른 CNI 플러그인을 호출할 수 있는 CNI 플러그인인 &quot;meta-plugin&quot; 역할을 함으로써 수행된다.Multi-Homed pod다음은 Multus CNI에서 제공한 파드에 부착된 네트워크 인터페이스 예시 그림이다. eth0, net0, net1 세 가지 인터페이스를 가진 파드가 있다.eth0은 kubernetes 서버/서비스(예: kubernetes api-server, kubelet 등)에 연결하기 위해 kubernetes 클러스터 네트워크를 연결한다.net0, net1은 추가 네트워크 연결이며 다른 CNI 플러그인(예: vlan/vxlan/ptp)을 사용하여 다른 네트워크에 연결한다.AWS Multi-Heomd Pod 동작방식위 그림은 eth0, net1이라는 두 개의 네트워크 인터페이스가 있는 두 개의 파드를 보여주는 예시다.eth0의 경우, 두 인터페이스 모두 Amazon VPC CNI가 관리한다. net1은 k8s 컨트롤 플레인 트래픽과 분리된 사용자 플레인(예: 음성, 비디오) 트래픽을 처리하는 pod1 전용 ipvlan CNI 플러그인을 통해 Multus에서 관리한다.pod2 net1이 host-device CNI 플러그인을 통해 host elastic network interface에 연결되고 DPDK가 패킷 처리를 가속화할 수 있도록 한다.Multus in EKSAmazon EKS에서는 2021년 8월부터 Multus Container Networking Interface (CNI) 플러그인을 지원하여 EKS 클러스터에서 Pod를 실행함으로써 어드밴스드 네트워킹 구성을 지원하기 위해 다중 네트워크 인터페이스를 사용할 수 있게 되었다.파드에 대한 다중 네트워크 인터페이스는 다양한 사용 사례에서 유용하다.트래픽 분할: 제어/관리 분리가 필요한 Network Functions(NF)와 데이터/사용자 평면 네트워크 트래픽을 실행하여 짧은 대기 시간 QoS(Quality of Service) 요구사항을 충족할 수 있다.성능: 추가 인터페이스는 종종 SR-IOV(Single Root I/O Virtualization) 및 DPDK(Data Plane Development Kit)와 같은 전문 하드웨어 사양을 활용하며, 이를 통해 대역폭 및 네트워크 성능을 높일 수 있다.보안: 엄격한 트래픽 격리 요구 사항이 있는 멀티 테넌트 네트워크를 지원한다. 규정 준수 요구 사항을 충족하기 위해 여러 서브넷을 파드에 연결한다.현재 모든 글로벌 AWS 리전에서 사용할 수 있고 AWS Local Zones 및 AWS Outposts와 같은 엣지 로케이션에서 지원된다.고려사항Amazon EKS는 single root I/O virtualization(SR-IOV) 및 Data Plane Development Kit(DPDK) CNI 플러그인을 구축하지도 게시하지도 않는다. 그러나 Multus Managed Host-Device 및 IPvLan 플러그인을 통해 Amazon EC2 Elastic Network Adapters (ENA)에 직접 연결하여 패킷 가속을 얻을 수 있다.Amazon EKS는 추가 CNI 플러그인을 간단하게 연결할 수 있는 일반 프로세스를 제공하는 Multus를 지원한다. Multus 및 연결 프로세스가 지원되지만 AWS는 연결될 수 있는 모든 호환 가능한 CNI 플러그인 또는 연결 구성과 관련이 없는 해당 CNI 플러그인에서 발생할 수 있는 문제에 대한 지원을 제공하지 않는다.Amazon EKS는 Multus 플러그인에 대한 지원 및 수명 주기 관리를 제공하지만 추가 네트워크 인터페이스와 관련된 IP 주소 또는 추가 관리에 대해서는 책임을 지지 않는다. Amazon VPC CNI 플러그인을 사용하는 기본 네트워크 인터페이스의 IP 주소 및 관리는 변경되지 않는다.Amazon VPC CNI 플러그인만 공식적으로 기본 위임 플러그인으로 지원된다. 기본 네트워킹에 Amazon VPC CNI 플러그인을 사용하지 않기로 선택한 경우 기본 위임 플러그인을 대체 CNI로 재구성하려면 게시된 Multus 설치 매니페스트를 수정해야 한다.Multus는 Amazon VPC CNI를 기본 CNI로 사용할 때만 지원된다. 보조 또는 기타 고차 인터페이스에 사용되는 경우 Amazon VPC CNI를 지원하지 않는다.Amazon VPC CNI 플러그인이 파드에 할당된 추가 네트워크 인터페이스를 관리하지 못하도록 하려면 node.k8s.amazonaws.com/no_manage으로 네트워크 인터페이스에 태그를 지정해야 한다.Multus는 네트워크 정책과 호환되지만 파드에 연결된 추가 네트워크 인터페이스의 일부일 수 있는 포트 및 IP 주소를 포함하도록 정책을 강화해야 한다.실습 시나리오본 실습에서는 두 개의 샘플 애플리케이션에서 간단한 Ping Test를 통한 트래픽 분할 시나리오를 시연한다. Pod의 보조 인터페이스를 관리하기 위해 ipvlan CNI를 설정한다. ping 테스트는 ipvlan 플러그인에서 제공하고 Multus에서 관리하는 네트워크에 대해 수행된다.설정은 CloudFormation 템플릿을 사용하여 인프라, EKS 클러스터 및 자체 관리형 노드 그룹을 생성하게 된다.인프라 템플릿은 Amazon Virtual Private Cloud(VPC), 클러스터 및 Multus용 퍼블릭 및 프라이빗 서브넷, EKS 작업을 수행하기 위한 배스천 호스트를 프로비저닝한다.노드 템플릿은 멀티홈 파드를 실행하기 위해 추가 ENI가 연결된 작업자 노드를 생성한다.전제 조건관리자 권한이 있는 AWS 계정이 있어야 한다.EC2 키 페어를 생성해야 한다.최신 버전의 AWS CLI, aws-iam-authenticator 및 git이 설치되어 있어야 한다.Clone this repogit clone https://github.com/aws-samples/eks-install-guide-for-multusS3 버킷 생성 후, lambda_function.zip 업로드. 이 단계에서 생성된 S3 버킷 명은 'Provision Worker Node Groups' 섹션에 설명된 작업자 노드 그룹의 CloudFormation을 실행할 때 입력 매개변수 중 하나로 사용된다.실습 진행1단계: VPC 및 EKS 클러스터 생성인프라 생성을 위해 CloudFormation 실행관리자 권한으로 AWS 콘솔에 로그인하고 Cloudformation 메뉴로 이동스택 생성, 새 리소스 사용(표준) 선택템플릿 파일 업로드: eks-install-guide-for-multus/cfn/templates/infra/eks-infra.yaml스택 이름 입력: eks-multus-cluster기본 VPC CIDR(10.0.0.0/16) 블록 및 서브넷 범위 사용2개의 availability zone 선택베스천 인스턴스 유형 선택EC2 키 페어 이름 선택나머지는 기본 값으로 유지한 채 다음 클릭, 아래 부분 승인 체크 후 스택생성 CloudFormation 스택이 완료될 때까지 기다린다. (다소 시간이 소요될 수 있음)총 2개의 퍼블릭 및 프라이빗 EKS 서브넷, 4개의 Multus 서브넷(AZ당 2개), EKS 클러스터, IGW 및 NAT-GW가 있는 Amazon VPC가 생성된다. 또한 Multus 서브넷 및 컨트롤 플레인 보안 그룹에 대한 보안 그룹도 생성된다.'eks-multus-cluster'라는 스택에 대한 CloudFormation 콘솔 출력 값을 확인한다. 특히 BastionPublicIp는 다음 섹션에서 필요한 IP이므로 기록해두자.배스천 호스트 구성터미널 창에서 SSH 명령을 사용하여 Bastion Host 인스턴스에 연결한다. 직전 단계에서 기록된 퍼블릭 IP와 프라이빗 키를 이용한다.AWS CLI 구성(참고)kubectl 설치 및 구성curl -o kubectl https://amazon-eks.s3-us-west-2.amazonaws.com/1.21.2/2021-07-05/bin/linux/amd64/kubectlcurl -o kubectl.sha256 https://amazon-eks.s3.us-west-2.amazonaws.com/1.21.2/2021-07-05/bin/linux/amd64/kubectl.sha256openssl sha1 -sha256 kubectlchmod +x ./kubectlmkdir -p $HOME/bin &amp;&amp; cp ./kubectl $HOME/bin/kubectl &amp;&amp; export PATH=$PATH:$HOME/binecho 'export PATH=$PATH:$HOME/bin' &gt;&gt; ~/.bashrckubectl version —short —clientAWS CLI를 사용하여 kubeconfig 파일 생성aws eks update-kubeconfig --name eks-multus-clusterkubectl get svc2단계: 노드 그룹 프로비저닝이 단계의 일부로 자체 관리형 노드 그룹을 생성한다. 이 단계에서는 전제 조건에 따라 생성된 S3 버킷과 인프라 스택이 완료되어야 한다. 또는 새 탭에서 인프라 스택 CloudFormation 출력 콘솔을 연다.노드 그룹 생성을 위한 CloudFormation 템플릿 실행관리자 권한으로 AWS 콘솔에 로그인하고 Cloudformation 메뉴로 이동스택 생성, 새 리소스 사용(표준) 선택템플릿 파일 업로드: eks-install-guide-for-multus/cfn/templates/node-group/eks-nodegroup-multus.yaml스택 이름 지정: multus-cluster-ng011단계에서 생성했던 EKS ClusterName(eks-multus-cluster) 입력 및 ClusterControlPlaneSecurityGroup(eks-multus-cluster-EksControlSecurityGroup-xxxx 형태) 선택NodeGroupName 입력: multus-cluster-ng01노드 Autoscaling 그룹 원하는 용량, 최대 및 최소 크기에 대해 1 지정인스턴스 유형으로 c5.large를 선택하고 볼륨 크기로 20 선택1단계에서 사용한 키 페어 네임 선택VPC ID(vpc-eks-multus-cluster) 및 Subnet(privateAz1-eks-multus-cluster) 선택MultusSubnets(multus1Az1-eks-multus-cluster, multus2Az1-eks-multus-cluster) 선택MultusSecurityGroups(eks-multus-cluster-MultusSecurityGroup*) 선택LambdaS3Bucket(이전에 생성한 S3 버킷명) 및 LambdaS3Key(lambda_function.zip) 입력다음 → I Acknowledge → 스택 생성 클릭CloudFormation 스택이 완료될 때까지 기다린다.정의된 Multus 서브넷에서 ENI를 연결하기 위해 노드 그룹 스택은 AWS Lambda 함수와 Amazon CloudWatch 이벤트 규칙을 배포한다. 스택은 no_manage: true 태그와 함께 Multus 서브넷에서 연결된 ENI로 EC2 인스턴스를 시작한다.AWS VPC CNI는 ENI의 태그가 지정된 no_manage: true를 관리하지 않는다. 이것은 Multus가 파드에 대한 추가 네트워크를 관리하기 위한 필수 단계이다.스택이 완료되면 출력에서 NodeInstanceRole 값을 기록해둔다.K8s ConfigMap 업데이트 적용Bastion Host 로그인AWS authenticator configuration map 다운로드, 편집 및 적용다운로드curl -o aws-auth-cm.yaml https://s3.us-west-2.amazonaws.com/amazon-eks/cloudformation/2020-10-29/aws-auth-cm.yaml다운로드 된 yaml 파일을 열어 'rolearn'을 NodeInstanceRole(작업자 노드 그룹 CloudFormation 스택의 출력)으로 바꾸고 파일 저장구성 적용(이 명령을 완료하는 데 몇 분 정도 걸릴 수 있음)kubectl apply -f aws-auth-cm.yaml노드의 상태를 관찰하고 Ready 상태에 도달할 때까지 기다린다.kubectl get nodes --watch3단계: Multus 설치 및 구성데몬셋을 사용하여 Multus CNI 설치다음 명령을 실행하여 Multus 데몬셋 다운로드 및 설치 kubectl apply -f https://raw.githubusercontent.com/aws/amazon-vpc-cni-k8s/master/config/multus/v3.7.2-eksbuild.1/aws-k8s-multus.yaml다음 명령을 실행하여 배포된 내용 확인kubectl get pods -n kube-system각 노드에는 kube-multus-ds라는 하나의 파드가 있어야 한다.추가 인터페이스 생성다음으로 파드에 추가하는 각 추가 인터페이스에 대한 구성 생성하기. Multus는 NetworkAttachmentDefinition이라는 사용자 지정 리소스 정의(CRD)를 제공한다. 이 CRD를 사용하여 추가 인터페이스 설정을 구성한다.ipvlan-conf-1 생성ipvlan CNI를 사용하여 파드에 대한 추가 인터페이스(Multus 서브넷 10.0.4.0/24에서)구성cat &lt;&lt;EOF | kubectl apply -f -apiVersion: &quot;k8s.cni.cncf.io/v1&quot;kind: NetworkAttachmentDefinitionmetadata:name: ipvlan-conf-1spec:config: '{   &quot;cniVersion&quot;: &quot;0.3.0&quot;,   &quot;type&quot;: &quot;ipvlan&quot;,   &quot;master&quot;: &quot;eth1&quot;,   &quot;mode&quot;: &quot;l3&quot;,   &quot;ipam&quot;: {     &quot;type&quot;: &quot;host-local&quot;,     &quot;subnet&quot;: &quot;10.0.4.0/24&quot;,     &quot;rangeStart&quot;: &quot;10.0.4.70&quot;,     &quot;rangeEnd&quot;: &quot;10.0.4.80&quot;,     &quot;gateway&quot;: &quot;10.0.4.1&quot;   } }'EOFipvlan-conf-2 생성두 번째 Multus 서브넷(10.0.6.0/24)에 대해 다른 ipvlan CNI 생성cat &lt;&lt;EOF | kubectl apply -f -apiVersion: &quot;k8s.cni.cncf.io/v1&quot;kind: NetworkAttachmentDefinitionmetadata:name: ipvlan-conf-2spec:config: '{   &quot;cniVersion&quot;: &quot;0.3.0&quot;,   &quot;type&quot;: &quot;ipvlan&quot;,   &quot;master&quot;: &quot;eth2&quot;,   &quot;mode&quot;: &quot;l3&quot;,   &quot;ipam&quot;: {     &quot;type&quot;: &quot;host-local&quot;,     &quot;subnet&quot;: &quot;10.0.6.0/24&quot;,     &quot;rangeStart&quot;: &quot;10.0.6.70&quot;,     &quot;rangeEnd&quot;: &quot;10.0.6.80&quot;,     &quot;gateway&quot;: &quot;10.0.6.1&quot;   } }'EOF구성된 내용 확인: kubectl describe network-attachment-definitionsec2-user@ip-10-0-0-188 ~$ kubectl describe network-attachment-definitionsName:         ipvlan-conf-1Namespace:    defaultLabels:       &lt;none&gt;Annotations:  &lt;none&gt;API Version:  k8s.cni.cncf.io/v1Kind:         NetworkAttachmentDefinitionMetadata:Creation Timestamp:  2022-03-01T08:30:03ZGeneration:          1Managed Fields: API Version:  k8s.cni.cncf.io/v1 Fields Type:  FieldsV1 fieldsV1:   f:metadata:     f:annotations:       .:       f:kubectl.kubernetes.io/last-applied-configuration:   f:spec:     .:     f:config: Manager:         kubectl-client-side-apply Operation:       Update Time:            2022-03-01T08:30:03ZResource Version:  7916UID:               0a07351d-1e49-4e25-a70c-88f089dc5a7fSpec:Config:  { &quot;cniVersion&quot;: &quot;0.3.0&quot;, &quot;type&quot;: &quot;ipvlan&quot;, &quot;master&quot;: &quot;eth1&quot;, &quot;mode&quot;: &quot;l3&quot;, &quot;ipam&quot;: { &quot;type&quot;: &quot;host-local&quot;, &quot;subnet&quot;: &quot;10.0.4.0/24&quot;, &quot;rangeStart&quot;: &quot;10.0.4.70&quot;, &quot;rangeEnd&quot;: &quot;10.0.4.80&quot;, &quot;gateway&quot;: &quot;10.0.4.1&quot; } }Events:    &lt;none&gt;Name:         ipvlan-conf-2Namespace:    defaultLabels:       Annotations:  API Version:  k8s.cni.cncf.io/v1Kind:         NetworkAttachmentDefinitionMetadata:  Creation Timestamp:  2022-03-01T08:31:09Z  Generation:          1  Managed Fields:    API Version:  k8s.cni.cncf.io/v1    Fields Type:  FieldsV1    fieldsV1:      f:metadata:        f:annotations:          .:          f:kubectl.kubernetes.io/last-applied-configuration:      f:spec:        .:        f:config:    Manager:         kubectl-client-side-apply    Operation:       Update    Time:            2022-03-01T08:31:09Z  Resource Version:  8061  UID:               f5673daf-0c0b-4c8b-9c5c-ea923c17b896Spec:  Config:  { &quot;cniVersion&quot;: &quot;0.3.0&quot;, &quot;type&quot;: &quot;ipvlan&quot;, &quot;master&quot;: &quot;eth2&quot;, &quot;mode&quot;: &quot;l3&quot;, &quot;ipam&quot;: { &quot;type&quot;: &quot;host-local&quot;, &quot;subnet&quot;: &quot;10.0.6.0/24&quot;, &quot;rangeStart&quot;: &quot;10.0.6.70&quot;, &quot;rangeEnd&quot;: &quot;10.0.6.80&quot;, &quot;gateway&quot;: &quot;10.0.6.1&quot; } }Events:    ### 4단계: 샘플 애플리케이션 배포#### Single ipvlan attachment로 샘플 애플리케이션 배포- 이전 단계에서 생성한 network annotation으로 샘플 애플리케이션 sampleapp-1 생성cat &lt;&lt;EOF | kubectl apply -f -apiVersion: v1kind: Podmetadata:  name: sampleapp-1  annotations:      k8s.v1.cni.cncf.io/networks: ipvlan-conf-1spec:  containers:name: multitoolcommand: &quot;sh&quot;, &quot;-c&quot;, &quot;trap : TERM INT; sleep infinity &amp; wait&quot;image: praqma/network-multitoolEOF- 파드 네트워크 확인: `kubectl exec -it sampleapp-1 -- ip -d address`!(https://images.velog.io/images/200ok/post/ce978dc1-6de1-4eb3-8d22-994af9b01f2c/image.png)AWS VPC CNI는 인터페이스 eth0을 관리하는 반면 ipvlan CNI는 Multus 네트워크 연결 정의(ipvlan-conf-1)를 통해 인터페이스 net1을 관리한다.Dual ipvlan attachment로 샘플 애플리케이션 배포Dual network annotations ipvlan-conf-1과 ipvlan-conf-2를 사용하여 샘플 애플리케이션 생성cat &lt;&lt;EOF | kubectl apply -f -apiVersion: v1kind: Podmetadata:name: sampleapp-dualannotations:    k8s.v1.cni.cncf.io/networks: ipvlan-conf-1, ipvlan-conf-2spec:containers:- name: multitool  command: &quot;sh&quot;, &quot;-c&quot;, &quot;trap : TERM INT; sleep infinity &amp; wait&quot;  image: praqma/network-multitoolEOF파드 네트워크 확인: kubectl exec -it sampleapp-dual -- ip -d addressMultus 인터페이스에 대한 파드 간의 연결 테스트: kubectl exec -it sampleapp-dual -- ping -I net1 &lt;sampleapp-net1-ipaddress&gt;리소스 삭제향후 요금이 발생하지 않도록 CloudFormation 서비스를 사용하여 생성된 모든 리소스를 삭제한다. CloudFormation으로 이동하여 생성한 두 개의 스택을 하나씩 삭제한다. 추가로 앞서 생성한 S3 버킷도 함께 삭제한다.참고https://aws.amazon.com/ko/blogs/containers/amazon-eks-now-supports-multus-cni/https://github.com/k8snetworkplumbingwg/multus-cnihttps://github.com/aws-samples/eks-install-guide-for-multus/blob/main/README.mdhttps://www.notion.so/gasidaseo/K8S-Multus-CNI-83b0ec8c5aa546fcb4943cda94ba156f"
319,"한빛미디어 &lt;나는 리뷰어다&gt; 활동을 위해서 책을 제공받아 작성된 서평입니다.이 책은 구글이 수많은 서비스를 개발하고 운영하면서 터득한 보안과 신뢰성 관련 경험 및 지식을 총망라한 책이다. 보안과 신뢰성이 왜 중요한지, 보안과 신뢰성에 어떤 형태로 구멍이 생길 수 있고 또 이를 예방하려면 어떻게 해야 하는지에 대해 실용적인 조언을 제공한다. 보안과 신뢰성은 모든 정보 시스템에서 가장 중요하고 기본적인 속성이지만, 실제 사고가 발생한 이후에 고치려면 상당한 추가 비용이 든다는 공통점이 있다. 그러므로 이 책은 모든 사람이 개발을 시작하는 단계에서부터 보안과 신뢰성에 대한 부분들 고민해야 하며, 이러한 원리들을 시스템 수명 주기에 최대한 일찍 통합해야 한다고 강조한다.더불어 위와 같은 요구사항을 시스템 설계 단계에서 비용 효율적으로 구현하는 방법, 최소 권한 모델을 도입하여 알려지거나 알려지지 않은 사용자가 악의적 혹은 실수로 시스템과 데이터에 피해를 주는 상황을 보호하는 방법, 시스템 장애 발생 시 진행할 복구를 고려해 시스템을 설계하는 방법 등 시스템의 신뢰성과 보안을 향상시키는 데 도움이 되는 내용들이 상세히 담겨있다.다만 구글의 사례이므로 실제로 책을 읽는 독자들의 조직에는 적용하기 어려운 부분들이 있을 수도 있지만, 업계 최고 전문가들의 수십 년의 경험과 풍부한 지식을 한 권의 책을 통해 얻을 수 있는 기회이므로 각자의 상황에 따라 다양한 인사이트를 얻을 수 있으리라 기대한다."
320,"Kubernetes Advanced Networking Study(KANS)의 3주차 내용을 학습하며 정리한 내용입니다.Service쿠버네티스에서 Pod는 컨트롤러가 관리하므로 노드를 옮겨다니면서 실행되기도 하고 클러스터 안 Pod의 IP가 변경되기도 한다. 이렇게 동적으로 변하는 Pod에 고정적으로 접근할 때 사용하는 방법이 Service다.Service란, 쿠버네티스의 기본 오브젝트로 수신한 트래픽을 여러 파드로 로드밸런싱(부하 분산)하는 기능을 제공한다.ClusterIP: 쿠버네티스(클러스터) 내부에서만 사용 가능한 가상 IP를 가진 엔드포인트를 제공하는 로드밸런서 구성(L4)NodePort: 외부 클라이언트가 서비스를 통해서 클러스터 내부의 파드로 접속할 때 사용 가능(L7)ClusterIP동작 방식: 클라이언트(TestPod)가 'CLUSTER-IP' 접속 시 해당 노드의 iptables 룰에 의해서 DNAT(Dastination NAT:도착지 주소를 변경하는 NAT) 처리되어 목적지 Pod와 통신서비스(ClusterIP) 생성 시, apiserver → (kubelet) → kube-proxy → iptables 에 rule이 생성됨kube-proxy란, 쿠버네티스에서 Service를 만들었을 때 ClusterIP나 NodePort로 접근할 수 있게 만들어 실제 조작 하는 컴포넌트다. 쿠버네티스 클러스터의 노드마다 실행되면서 클러스터 내부 IP로 연결하려는 요청을 적절한 파드로 전달한다. 이러한 kube-proxy가 네트워크를 관리하는 방법은 userspace, iptables, IPVS 모드가 있다.이 중에서도 iptables 모드는 클라이언트에서 오는 모든 요청이 iptables를 거쳐 파드로 직접 전달된다. 그래서 파드 하나로의 연결 요청이 실패하면 재시도를 하지 않고 그냥 요청이 실패하게 된다. 따라서 컨테이너에 ReadinessProbe가 설정되어 있고, 그에 따른 헬스체크가 정상적으로 되어야 연결 요청이 이루어진다.작동 방식 확인을 위한 실습목적지 Pod 생성클라이언트(TestPod) 생성서비스(ClusterIP) 생성생성된 모든 리소스 확인클라이언트(TestPod) Shell 실행 후 Pod IP로 직접 curl 테스트서비스(ClusterIP) 부하분산 접속 확인for문을 이용하여 해당 서비스 IP:포트에 curl 명령어를 100번 반복하였을 때, 3개의 목적지(backend) 파드로 랜덤 부하 분산 접속되는 것을 확인할 수 있음sessionAffinity: ClientIP만약, ClusterIP 서비스 사용시 파드에서 ClusterIP로 보내진 트래픽은 서비스에 연결된 어느 하나의 파드에 전송된 후 다음 트래픽도 계속해서 같은 파드에 고정적으로 전달하고 싶다면 sessionAffinity를 사용할 수 있다. (NodePort나 LoadBalancer에서도 세션 어피니티 자체는 활성화 할 수 있는 경우들이 있으나 여러가지 제한되는 부분이 많아서 주로 사용하지 않는다.)NodePort동작 방식: 외부 클라이언트가 '노드IP:NodePort' 접속 시 해당 노드의 iptables 룰에 의해서 SNAT(Source NAT: 출발지 주소를 변경하는 NAT) /DNAT 되어 목적지 파드와 통신 후 리턴 트래픽은 최초 인입 노드를 경유하여 외부로 되돌아감모드 노드(마스터 포함)에 iptables rule 이 설정되므로, 모든 노드에 NodePort 로 접속 시 iptables rule 에 의해서 분산 접속작동 방식 확인을 위한 실습목적지(backend) 디플로이먼트(Pod) 파일 생성서비스(NodePort) 파일 생성생성된 리소스 확인NodePort 확인NodePort를 변수에 지정노드 포트 Listen 확인 : ss 옵션 -4(ipv4) -t(TCP) -l(Listen) -n(숫자로 출력) -p(프로세스)외부 클라이언트(k8s-pc)에서 노드의 IP와 NodePort를 변수에 지정서비스(NodePort) 부하분산 접속 확인과제 - MSA 샘플 애플리케이션(게임) 배포하기참고도서 쿠버네티스 완벽 가이드도서 IT 엔지니어를 위한 네트워크 입문"
321,"Kubernetes Advanced Networking Study(KANS)의 3주차 내용을 학습하며 정리한 내용입니다.Calico 기본 통신 이해Calico CNI 알아보기소개(링크)Calico란, 컨테이너, 가상 머신 및 기본 호스트 기반 워크로드를 위한 오픈 소스 네트워킹 및 네트워크 보안 솔루션이다.Kubernetes, OpenShift, Mirantis Kubernetes Engine(MKE), OpenStack 및 베어메탈 서비스를 포함한 광범위한 플랫폼 지원한다.Calico의 eBPF 데이터 플레인을 사용하든 Linux의 표준 네트워킹 파이프라인을 사용하든 Calico는 진정한 클라우드 네이티브 확장성과 함께 놀랍도록 빠른 성능을 제공한다.Calico는 공용 클라우드나 온프레미스, 단일 노드 또는 수천 개의 노드 클러스터에서 실행되는지 여부에 관계없이 개발자와 클러스터 운영자에게 일관된 경험과 기능 세트를 제공한다.구성 요소 아키텍처(링크)여러가지 구성 요소가 많지만, 일단 눈여겨 볼 내용은  Calico가 사용하는 Datastore1와 마스터 노드를 포함한 모든 노드들에 존재하는 Calico Pods2Felix (필릭스) : 인터페이스 관리, 라우팅 정보 관리, ACL 관리, 상태 체크BIRD (버드): BGP Peer 에 라우팅 정보 전파 및 수신, BGP RR(Route Reflector)Confd : calico global 설정과 BGP 설정 변경 시(트리거) BIRD 에 적용해줌Datastore plugin : calico 설정 정보를 저장하는 곳 - k8s API datastore(kdd) 혹은 etcd 중 선택Calico IPAM plugin : 클러스터 내에서 파드에 할당할 IP 대역calico-kube-controllers : calico 동작 관련 감시(watch)calicoctl : calico 오브젝트를 CRUD 할 수 있다, 즉 datastore 접근 가능BGP(Border Gateway Protocol): AS 사이에서 이용되는 라우팅 프로토콜. 대규모 네트워크(수천만의 경로 수)에 대응하도록 설계됐다. 그래서 BGP로 동작하는 라우터는 비교적 고가인 제품이 많다.AS(Autonomous System): 하나의 정책을 바탕으로 관리되는 네트워크(자율 시스템)를 말한다. ISP, 엔터프라이즈 기업, 공공기관 같은 조직이 이에 해당하며 인터넷은 이러한 자율 시스템의 집합체이다.!youtubef2UTifATW7s구성 요소 확인하기데몬셋으로 각 노드에 calico-node 파드가 동작하여, 해당 파드에 bird, felix, confd 등이 동작 + Calico 컨트롤러 파드는 디플로이먼트로 생성Calico의 특징은 BGP를 이용해 각 노드에 할당된 Pod 대역의 정보를 전달한다. 즉, 쿠버네티스 서버뿐만 아니라 물리적인 라우터와도 연동이 가능 하다는 뜻이다. (Flannel의 경우 해당 구성 불가)Calico Pod 안에서 Bird라고 하는 오픈소스 라우팅 데몬 프로그램이 프로세스로 동작하여 각 Node의 Pod 정보가 전파되는 것이다.이후 Felix라는 컴포넌트가 리눅스 라우터의 라우팅 테이블 및 iptables rule에 전달 받은 정보를 주입하는 형태이다.confd는 변경되는 값을 계속 반영할 수 있도록 트리거 하는 역할이다.Calico 기본 통신 과정 확인하기calicoctl 설치리소스 관리를 위해 Calico CLI를 설치 및 구성마스터 노드 확인Calico CNI 설치시, 데몬셋이므로 모든 노드에 칼리코 파드가 하나씩 존재하게 된다. (calico-node-*)칼리코 컨트롤러가 하나 존재하는 것을 확인할 수 있다.calicoctl ipm show 명령어를 통해, IAPM 정보를 확인할 수 있다. 아래 스크린샷에서는 172.16.0.0/16 대역을 해당 쿠버네티스 클러스터에서 사용할 수 있다는 내용을 알 수 있다.IPAM(IP Address Management): 풍부한 사용자 환경을 통해 IP 주소 인프라의 엔드 투 엔드 계획, 배포, 관리 및 모니터링을 지원하는 통합 도구 모음이다. IPAM은 네트워크상의 IP 주소 인프라 서버 및 DNS(도메인 이름 시스템) 서버를 자동으로 검색하여 중앙 인터페이스에서 이들 서버를 관리할 수 있다.옵션을 통해 아래와 같이 특정한 노드에 할당 가능한 대역대를 확인할 수도 있음(Block는 각 노드에 할당된 Pod CIDR 정보를 나타냄)calicoctl node 정보 확인ippool 정보 확인파드와 서비스 사용 네트워크 대역 정보 확인실습 1.동일 노드 내 파드 간 통신결론: 동일 노드 내의 파드 간 통신은 내부에서 직접 통신됨파드 생성 전 노드(k8s-w1)의 기본 상태노드(k8s-w1)에 파드 2개 생성아래 내용으로 node1-pod2.yaml 파일 작성 후 파드 생성파드 생성 전후의 변화를 관찰하기 위해 터미널 하단 추가 탭에watch calicoctl get workloadEndpoint 명령어를 사용하여 모니터링calicoctl 명령어로 endpoint 확인: veth 정보도 확인할 수 있음생성된 파드 정보 확인네트워크 인터페이스 정보 확인(k8s-w1)calice#~ 두개 추가된 것을 확인할 수 있음각각 net ns 0,1로 호스트와 구별되는 것을 확인할 수 있음네트워크 네임스페이스 확인아래 2개 PAUSE 컨테이너가 각각 파드별로 생성된 것을 확인할 수 있음바로 위 스크린샷인 link-netnsid 0, link-netnsid 1과 매칭됨라우팅 테이블 확인파드의 IP/32bit 호스트 라우팅 대역이 라우팅 테이블에 추가된 것을 확인할 수 있음파드간 통신 실행 이해(위) 마스터 노드에서 Pod1 Shell에 접근하여 Pod2로 Ping 테스트(아래) 워커 노드(k8s-w1)에서 iptables 필터 테이블에 FORWARD 리스트 중 cali-FORWARD 룰 정보를 필터링해서 watch로 확인테스트 결과 아래 이미지와 같이 Host iptables에서 FOWRARD라는 테이블의 허용 조건에 따라 정상적으로 통신이 가능한 것을 확인할 수 있다.파드에서 외부(인터넷)로의 통신결론: 파드에서 외부(인터넷) 통신 시에는 해당 노드의 네트워크 인터페이스 IP 주소로 MASQUERADE(출발지 IP가 변경) 되어서 외부에 연결됨파드 배포 전 calico 설정 정보 확인 &amp; 노드에 iptables 확인마스터 노드에서 아래 내용 확인: natOutgoing의 기본값이 true로 설정되어 있는 것을 확인 할 수 있다. 즉 이 노드에서 외부로 통신할 때 NAT의 MASQUERADE를 사용하겠다는 의미이다.NAT - MASQUERADE : 조건에 일치하는 패킷의 출발지 주소를 변환하는 것. 내부에서 전달되는 요청의 출발지 주소를 조건에 지정된 인터페이스의 IP로 변환한다.워커 노드(k8s-w1)에서도 외부로 통신시 MASQUERADE 동작 Rule이 존재하는 것을 확인할 수 있다.마스터 노드에서 워커 노드(k8s-w1)에 아래 내용의 파드 1개 생성외부 통신 가능 여부 확인통신 전, 워커 노드(k8s-w1)에 iptables NAT MASQUERADE 모니터링을 활성화 하면 외부 통신시 pkts값이 증가하는지 확인할 수 있다.(위) 마스터 노드에서 Pod1 Shell 실행 후, 8.8.8.8로의 통신 성공(아래) pkts 값이 이전 이미지와 다르게 증가한 것을 확인할 수 있다.다른 노드에서 파드 간 통신결론: 다른 노드 환경에서 파드 간 통신시에는 IPIP터널(기본값) 모드를 통해서 이루어진다.각 노드에 파드 네트워크 대역은 Bird에 의해서 BGP로 광고 전파/전달 되며, Felix에 의해서 호스트의 라우팅 테이블에 자동으로 추가/삭제 된다.다른 노드 간의 파드 통신은 tunl0 인터페이스를 통해 IP 헤더에 감싸져서 상대측 노드로 도달 후 tunl0 인터페이스에서 Outer 헤더를 제거하고 내부 파드와 통신한다.파드 배포 전, 노드에서 BGP에 의해 전달 받은 정보가 호스트 라우팅 테이블에 존재하는지 확인아래 명령어를 통해 나머지 노드들의 파드 대역을 자신의 호스트 라우팅 테이블에 가지고 있고, 해당 경로는 tunl0 인터페이스로 보내게 된다는 사실을 알 수 있다.워커 노드(k8s-w1, w2)의 tunl0 정보 확인터널 인터페이스가 IP에 할당되어 있음MTU는 1480 (칼리코 사용 시 파드의 인터페이스도 기본 MTU 1480 사용)현재 TX/RX 카운트는 0 --&gt; 잠시 후, 오버레이 통신시 카운트 값이 증가할 것마스터 노드에서 워커 노드(k8s-w1, w2) 대상으로 각각 파드 1개씩 생성calicoctl 명령어를 이용하여 생성된 파드의 엔드포인트 확인각 노드에서 파드 간 통신을 처리하는 라우팅 정보 확인k8s-w1(172.16.158.4/32) 노드에서 w2(172.16.184.0) 노드 대역에 통신하려면 192.168.10.102를 거쳐야 한다는 것을 확인할 수 있다.반대로 w2(172.16.184.1/32) 노드에서 w1(172.16.158.0) 노드 대역에 통신하려면 192.168.10.101를 거쳐야 한다.다른 노드 파드 간 통신이 어떻게 실행되는지 확인  ⇒ IPIP(상) Pod2가 속한 노드(k8s-w2)에 tunl0 인터페이스 TX/RX 패킷 카운트 모니터링 세팅(중) 마스터 노드에서 Pod1 Shell 접속 후, Pod2로 Ping 통신 테스트 준비(하) Pod1이 속한 노드(k8s-w1)에서 패킷 덤프 세팅: tunl0 - 터널 인터페이스에 파드간 IP 패킷 정보를 확인할 수 있음결과(중) Pod1 --&gt; Pod2로 정상 통신 확인(상) tunl0 인터페이스의 TX/RX 패킷 카운트가 각각 10개로 증가(하) 실제 통신을 하게 되는 파드 간 IP 패킷 정보 확인실제로 오버레이 통신을 하고 있는지 확인하기 위해 패킷덤프 명령어를 아래와 같이 수정하여 Ping 통신을 다시 하였고, 결과적으로 IP Outer(파란색 박스) 헤더 정보 안쪽에 Inner(빨간색 박스) 헤더가 1개 더 있음을 확인할 수 있다.Calico 네트워크 모드Calico Mode 요약칼리코는 다양한 네트워크 통신 방법을 제공한다.IPIP 모드파드 간 통신이 노드와 노드 구간에서는 IPIP 인캡슐레이션을 통해 이루어진다.단, Azure 네트워크에서는 IPIP 통신이 불가능하기 때문에 대신 VXLAN 모드를 사용한다고 한다.Direct 모드파드 통신 패킷이 출발지 노드의 라우팅 정보를 보고 목적지 노드로 원본 패킷 그대로 전달된다.단, 클라우드 사업자 네트워크 사용 시, NIC에 매칭되지 않는 IP 패킷은 차단되니 NIC의 Source/Destination Check 기능을 Disable해야 정상 통신 가능 (AWS 문서 링크)BGP 연동Kubernetes 클러스터 내부 네트워크와 IDC 내부망 네트워크 간 직접 라우팅도 가능VXLAN 모드파드 간 통신이 노드와 노드 구간에서는 VXLAN 인캡슐레이션을 통해서 이루어진다.다른 노드 간의 파드 통신은 vxlan 인터페이스를 통해 L2 프레임이 UDP - VXLAN에 감싸져 상대 노드로 도달 후 vxlan 인터페이스에서 Outer헤더를 제거하고 내부의 파드와 통신하게 된다.BGP 미사용, VXLAN L3 라우팅을 통해서 동작한다.UDP를 사용하므로 Azure 네트워크에서도 사용 가능하다.Pod 패킷 암호화(네트워크 레벨)Calico의 다양한 네트워크 모드 환경 위에서 WireGuard 터널을 자동 생성 및 파드 트래픽을 암호화하여 노드 간 전달한다.Yaml 파일에 간단하게 추가하는 것만으로도 네트워크 레벨의 패킷 암호화를 설정할 수 있다.WireGuard는 구닥다리 IPsec 및 OpenVPN의 대항마로 등장한 open source VPN project이며 작년, Linux 5.6 커널에 WireGuard 1.0.0 기본 패키지로 탑재되었다.정말 간결한 코드 구조와 빠른 성능 (모든 것이 kernel에서 동작하고, 주요 암호 알고리즘에 대해서 병렬처리하므로써 빠른 속도를 자랑함)실습 2. WireGuardWireGuard 설정모든 노드에 WireGuard를 설치(apt install wireguard -y)하고, Enabled 설정현재 노드에 존재하는 Wireguard 퍼블릭 키 확인wireguard.cali 인터페이스 정보 확인wg로 시작하는 명령어를 사용하여 wireguard.cali 설정 확인: 노드 별로 각각의 상대방 Peer의 IP와 퍼블릭 키를 확인할 수 있음동작 확인아래 내용으로 파드 생성(상) 파드가 생성된 노드의 eth0(enp0s8)에서 패킷 덤프 모니터링 세팅(하) 생성한 파드 Shell 접속 후 Ping 통신 준비(하) Pod2 IP 확인(중) Pod1 --&gt; Pod2 Ping 정상 통신(상) 51820 포트 패킷 덤프 내용 확인"
322,"Kubernetes Advanced Networking Study(KANS)의 2주차 내용을 학습하며 정리한 내용입니다.K8S Network 작동 방식쿠버네티스는 CNI 규격을 사용하여 네트워크와 연결한다.CNI 플러그인: 쿠버네티스는 별도 오버레이 네트워크를 구축하는 소프트웨어와 사용해야 한다. 쿠버네티스 클러스터는 여러 쿠버네티스 노드로 구성되어 있다. 여러 쿠버네티스 노드는 파드 간 통신을 확보하기 위해 클러스터 내에 분산된 파드가 서로 통신이 가능하도록 네트워크를 구성해야 한다. 이 부분을 담당하는 것이 바로 CNI(Container Network Interface) 플러그인이다. CNI의 역할은 단순히 파드 간 연결을 용이하게 만드는 것으로 이해하면 된다. 예를 들어 컨테이너 런타임(예: Docker)은 CNI 플러그인 실행 파일(예: Calico)을 호출하여 컨테이너 네트워킹 Namespace에 인터페이스를 추가하거나 제거한다. 이를 샌드박스 인터페이스라고도 한다.대표 CNI 플러그인인 플라넬은 VXLAN을 사용하여 가상 오버레이 네트워크를 구축한다. 플라넬 외에도 쿠버네티스가 표준으로 지원하는 CNI 플러그인은 Open vSwitch, Calico, Cillium, Weave Net 등이 있다.오버레이 네트워크(Overlay Network): 실제 물리 Network 위에서 가상 Network를 구축하는 기법을 의미한다. 각 가상 Network는 서로 완전히 격리되어 관리 된다.VXLAN (Virtual Extensible LAN): Overlay Network 구축을 위한 Network Protocol 중 하나다. 가상 Network안에서 발생한 Packet은 Encapsulation되어 물리 Network를 통과하고 다시 Decapsulation되어 가상 Network로 전달된다.!(https://images.velog.io/images/200ok/post/a9279345-ea12-4929-a63c-9060d38dfef4/image.png &quot;VXLAN Overview&quot;)Flannel코어 OS 주도의 프로젝트이며 쿠버네티스용으로 설계된 3계층 오버레이 네트워크를 구성하기 쉬운 방법이다. 패킷은 VXLAN 및 다양한 메커니즘을 사용하여 전달된다.Flannel의 필요성Kubernetes Default Network 구조 사용시, 아래 그림과 같이 Worker Node가 2개 생생되면 Pod에 부여되는 IP가 동일하여 Worker Node 1의 Pod에서 Work Node 2 Pod로의 통신이 불가하다.Flannel 사용시, 아래 그림과 같이 다른 Worker Node간 Pod IP가 동일하지 않으므로 라우터를 거쳐 Pod간 통신이 가능해진다.노드마다 VXLAN VTEP 역할을 하는 flannel.1과 bridge 역할을 하는 cni0이 생성된다.실제 실습 환경 구성시, 기본 네트워크 정보를 확인하면 아래 스크린샷과 같이 flannel.1과 cni0을 확인할 수 있었다.flannel.1의 자세한 정보를 확인하면 아래와 같이 vxlan을 사용한다는 것 또한 확인할 수 있었다.전체 노드 정보 중 flannel 관련 정보 확인하면 아래 스크린샷과 같이 각 노드의 Backend-type이 vxlan 사용되는 것을 확인할 수 있었다.실습 환경 구성아래 이미지 출처: 스터디 멤버 라임님이 제출하신 구성도 실습 환경 구동되는 Host(PC)포함한 실습 랩 환경워커 노드마다 할당된 dedicated subnet (pod CIDR) 확인실습 1. 플라넬 CNI는 Pod 생성을 통해 'cni0'이라고 하는 브릿지에 파드에 연결된 veth 페어 인터페이스가 실제로 추가되는지 확인하기현재 cni0가 존재하지 않는 w-1, w-2번 워커 노드에 모니터링 명령어를 걸어두었다.마스터 노드에서 파드 2개를 생성 해보았다.파드가 생성됨과 동시에 cni0에 연결된 veth인터페이스가 각 노드마다 생성되는 것을 확인할 수 있다.PAUSE파드 네트워킹 이해하기하나의 파드에 속한 컨테이너들은 아래 그림과 같이 veth0 하나를 공유한다. 그래서 같은 파드에 속한 컨테이너들은 모두 같은 IP를 갖게 되며, 각 컨테이너마다 서로 다른 포트를 사용해야 통신이 가능하다. 그렇다면 쿠버네티스는 어떻게 가상 네트워크 인터페이스를 공유할까? 정답은 pause 컨테이너의 존재 때문이다. 파드의 veth0은 pause컨테이너 네트워크 네임스페이스에 속한 장치로써, 같은 파드 안 다른 컨테이너들은 해당 pause 컨테이너 네트워크 네임스페이스를 공유해 사용한다.즉 파드가 실행될 때 pause라는 이름의 컨테이너가 자동으로 먼저 실행되고, 이 pause 컨테이너의 리눅스 네임스페이스를 파드 내부의 모든 컨테이너들이 공유해서 사용한다. 이 컨테이너는 단순히 네임스페이스를 공유하기 위한 컨테이너이며, SIGINT나 SIGTERM 시그널을 받기 전까지 아무 동작도 하지 않고 Sleep 상태로 대기한다.실습 환경 구성마스터 노드에서 아래 스크린샷과 같이 nginx와 netshoot 컨테이너 2개가 포함된 파드 생성생성된 파드 확인(k8s-w2 노드에 배포되었음)실습 2. 사용자가 생성한 컨테이너가 pause 컨테이너의 네트워크 네임스페이스를 공유해서 사용하는지 확인하기배포된 워커 노드에서 docker ps로 내용을 확인해보면 내가 yaml 파일에 명시하지 않은 pause 컨테이너가 자동으로 생성된 것이 보인다.kubectl describe pod myweb2 명령어를 통해 해당 Pod의 상세 정보를 확인해봐도 두 개의 컨테이너 정보만 확인할 수 있다.해당 Pod의 각 컨테이너 IP를 확인해보면 netshhot, nginx 컨테이너의 IP가 동일하다는 것을 알 수 있다.각 프로세스를 NGINXPID, NETSHPID 변수에 넣고 각 컨테이너의 네임스페이스 정보도 확인해보았다.  아래 스크린샷으로 확인할 수 있는 내용은 다음과 같다.cgroup, user 네임스페이스는 따로 격리하지 않는다.ipc, net 네임스페이스는 파드 내의 컨테이너 간 공유한다.mnt, uts, pid 네임스페이스는 컨테이너별로 격리한다.pause 컨테이너는 IPC, Network 네임스페이스를 생성하고 유지한다. → 나머지 컨테이너는 해당 네임스페이스를 공유하여 사용한다.유저가 실행한 특정 컨테이너가 비정상적으로 종료되어 컨테이너 전체에서 공유되는 네임스페이스에 문제가 발생하는 것을 방지한다.참고도서 쿠버네티스 완벽 가이드도서 매니징 쿠버네티스: 창시자가 알려주는 쿠버네티스 클러스터 현장 운영 기법도서 클라우드 네이티브를 위한 데이터 센터 네트워크 구축도서 쿠버네티스 입문https://ssup2.github.io/theory_analysis/Overlay_Network_VXLANhttps://ikcoo.tistory.com/101https://jonnung.dev/kubernetes/2020/02/24/kubernetes-pod-networking/https://speakerdeck.com/devinjeon/kubernetes-neteuweokeu-ihaehagi-1-keonteineo-neteuweokeubuteo-cniggaji"
323,"골든래빗 출판사로부터 책을 제공받아 작성했습니다.&quot;나는 세상을 약한 자와 강한 자로 나누지 않고, 성공한 자나 실패한 자로 나누지 않고, 무엇을 만들거나 만들지 못하는 자로 나누지 않는다. 나는 세상을 배우는 자와 배우지 않은 자로 나눈다.&quot; by. 벤자민 바버개발자로 살아남기.어리바리 우당탕탕 신입사원 시절을 지나 곧 3년 차 엔지니어에 접어드는 지금, 진로에 관한 생각과 고민이 깊어지던 찰나에 만난 등대 같은 책이다.책을 통해 지금 내가 맡은 직무와 삶에 대해 얼마나 만족하고 있는지 돌아보고 향후 원하는 바를 달성하려면 어떻게 목표를 세우고 시간 관리를 해야 하는지, 스페셜리스트 또는 제너럴리스트로의 커리어는 어떻게 그려야 하는지에 관한 내용들을 정리할 수 있었다.저자는 책에서 죽을 때까지 코딩에만 집중하는 커리어가 아닌, '성장하는 30년 커리어 패스'를 제안한다. 처음 10년은 실력을 쌓으며 성장하는 시기, 다음 10년은 다른 개발자를 리딩하는 시기, 마지막 10년은 다른 사람들을 돕고 서포트 하는 시기로 마무리된다.하지만 시간보다 중요한 것은 성장이라고 강조한다. 성장이란 역량이 늘어난다는 뜻이고, 균형 있는 역량이란 지식, 숙련도, 경험이 골고루 늘어나는 것이다.마음만 먹으면 강연이나 책으로도 다른 사람들의 경험을 간접적으로도 충분히 습득할 수 있는 시대다. 나를 이끌어줄 누군가가 없다고 실망할 시간에 간접 경험을 통해 얻은 정보와 지식들을 잘 기억하고 있다가 직접 경험을 할 상황이 생겼을 때 적용하면서 얻는 내 경험을 차곡차곡 축적하면 된다.더불어 빠르게 변하는 IT업계에서 롱런 하기 위해 유행보다는 기본 지식을 쌓는데 시간을 투자하고, 주어진 일의 앞뒤를 생각하는 비판적 사고를 하도록 노력하라는 부분이 인상 깊다.시키는 대로 영혼 없이 일 하는 대신 '왜 이 일을 해야하는지', '어떤 방식으로 일하는 것이 최선인지' 다각도에서 고민하는 사고 방식을 습관은 모든 일을 더 깊게 들여다 볼 수 있다고 한다.마지막으로 훌륭한 개발자는 절대 엔지니어링 역량만 가지고는 될 수 없다는 점 또한 꼭 유념해야겠다. 결국 모든 것은 사람이 하는 일이기에 시간이 지날수록 매니지먼트 역량, 즉 소프트 스킬이 점점 더 중요해진다. 소통, 협업, 긍정적인 자세, 프로 의식, 리더십의 중요성을 항상 잊지 말자.알라딘 개발자로 살아남기 - 한글과컴퓨터, 블리자드, 넥슨, 삼성전자, 몰로코 출신 개발자의 30년 커리어패스 인사이트 (패스트캠퍼스 The Red 콜라보) / 박종천 (지은이) 골든래빗(주) 2022-01-01"
324,"들어가기에 앞서로그란?커널, 서비스, 애플리케이션 등 시스템에 발생한 이벤트를 분류하여 기록한 파일이다.시스템에 특정 이벤트에 대한 기록이 있으면 해당 이슈가 발생한 시기와 이유를 확인할 수 있다.로그의 필요성운영적인 측면시스템에 장애가 발생했을 경우, 장애를 해결하기 위해 로그를 확인해야 한다.시스템의 성능을 개선하는 용도로도 사용 할 수 있다.보안적인 관점사용자의 허가되지 않은 접근 시도에 대한 추적과 감사를 수행할 수 있다.침해사고 발생 시 침해사고의 원인과 침입경로, 피해상황 등을 파악할 수 있는 중요한 단서가 된다.로그 관리 데몬리눅스 시스템이 init프로세스에서 systemd로 바뀌면서 로그와 관련된 데몬도 syslog에서 rsyslog에 의해서 처리되도록 변경되었다. (성능과 보안성이 향상되었음)최신 버전 리눅스에서는 systemd가 사용되면서 rsyslog에 systemd-journal이 추가되었다.systemd-journal은 시스템에서 발생되는 모든 로그를 기록하며, 로그를 텍스트 형태로 저장하지 않고 바이너리 파일 형태로 저장한다.System Event ➟ systemd-journald ➟ rsyslogd ➟ Log filessystemd 시스템에서 로그는 rsyslogd와 systemd-journald 두 데몬에 의해서 관리된다.시스템에서 이벤트가 발생하면 모두 systemd-journald로 전달된다.systemd-journald는 부팅이 시작되는 순간부터 로그를 수집한다.이후, rsyslogd로 syslog를 전달하여 각 파일 별로 로그를 저장한다.로그 파일 위치로그를 수집하는 데몬에 따라서 로그가 저장되는 위치가 다르다.Kernel Log Message, Syslog Message, Service Message ➟ systemd-journald로  전달이후 systemd-journald 데몬은 /run/log/journal 디렉토리에 모든 로그를 저장한 파일인 저널(journal) 데이터 파일 생성하고, 저장한 로그 중에서 syslog 형태의 로그를 rsyslogd로 전달rsyslogd에 의해 수집되는 로그는 /var/log 디렉토리에 각 syslog에 해당하는 로그 파일들을 생성하고 저장rsyslogd에 의해서 수집되는 로그의 파일 위치rsyslogd에 의해 수집되는 로그는 보통 syslog라고 부른다.rsyslogd는 /etc/rsyslog.conf를 참고하여 /var/log 디렉토리에 로그 종류별로 각각 텍스트파일로 저장한다.아래는 rsyslogd에 의해 처리되는 로그의 파일 위치이다./var/log/messages: 대부분의 로그 기록(인증, 메일, cron, 부팅, 디버깅과 관련된 로그 제외)/var/log/secure: 인증과 관련된 로그 기록/var/log/maillog: 메일과 관련된 로그 기록/var/log/cron: 주기적인 작업과 관련된 로그 기록/var/log/boot.log: 부팅 과정에서 발생한 로그 기록systemd-journald에 의해서 처리되는 저널(journal) 데이터 파일 위치systemd-journald에 의해 수집되는 로그를 저널 데이터라고 부른다.저널 데이터는 /run/log/journal 디렉토리에 바이너리 파일 형태로 저장된다.저널 데이터 파일이 저장되는 /run 디렉토리는 메모리 기반파일시스템인 tmpfs로 마운트 되어 있으므로 시스템 재부팅시 저널 데이터 파일은 삭제된다.Logrotate지정된 로그 파일에 계속해서 로그를 쌓게 되면 로그 파일의 크기가 과도하게 커질 수 있다. 이럴 경우 로그 파일을 읽어오기 위해 보다 많은 메모리가 필요할 뿐 아니라 로그를 확인하고 분석하는 것도 어려워진다. 따라서 로그 파일의 크기가 커지지 않도록 제한할 필요가 있다.로그 파일이 생성된 후 일정 기간이 지나거나 로그 파일의 크기가 일정 크기게 도달할 경우 로그 파일을 백업하고, 새롭게 로그 파일을 생성하여 새롭게 로그를 저장하도록 해야한다. 또한 백업된 파일도 일정 기간이 지나거나 개수가 많아질 경우 삭제하도록 설정해야 한다. 이 과정을 로그 파일의 순환(Logrotate)라고 한다.로그 파일의 순환 과정'logrotate'라는 유틸리티를 사용하여 이루어진다. 이 유틸리티는 사용자가 수동으로 실행하는 것이 아니라 cron 작업에 의해 하루에 한 번씩 실행하도록 등록되어 있다.logrotate가 실행될 때 로그 파일의 크기가 너무 크거나 혹은 일정 기간이 지나면 현재 로그 파일 이름 뒤에 날짜가 추가 되고, 날짜가 추가되기 전의 파일 이름으로 된 새로운 빈 파일이 생성된다.Logrotate 설정 과정/etc/logrotate.conf 파일을 사용하여 설정한다. 이 파일의 내용은 아래와 같다.1 로그 파일을 순환 시킬 기간에 대한 설정(daily, weekly, monthly, yearly)2 순환된 로그 파일을 보관할 기간에 대한 설정(1에서 설정한 기간 단위 사용)3 로그 파일 순환 후 새로운 로그 파일 생성4 순환된 파일의 파일명 변경 옵션(YYYYMMDD)5 순환된 파일을 압축하여 보관하는 옵션6 로그 순환에 대한 추가 설정 파일이 저장된 디렉토리7 사용자의 로그인/로그아웃 정보를 저장하는 wtmp 로그 파일의 순환 설정8 로그인 실패 기록을 저장하는 btmp 로그 파일의 순환 설정이 설정 파일에는 wtmp, btmp 로그 파일에 대한 설정만 포함되어 있고 기타 로그 파일에 대한 설정은 6번에 포함되어 있다. 6번 항목이 지정하는 디렉토리에는 logrotate에 의해 순환되는 파일들의 추가 설정 파일이 저장된다. 이 파일들은 logrotate.conf 파일의 전역 설정이 적용되고, 각 설정 파일에서 순환시킬 로그 파일의 경로와 각 로그에 해당하는 개별 설정을 적용한다.만약 전역 설정과 개별 설정이 서로 다른 설정 값을 저장할 경우, 전역 설정 대신 개별 설정이 적용된다.실습로그 데이터 순환 및 S3 백업목표매일 자정에 Nginx와 wtmp 로그를 순환시키고, 어제 날짜로 새로 생성된 로그 파일을 지정된 S3 버킷에 백업하기전제 조건사용 환경: AWSEC2(Amazon Linux2), S3 버킷 준비, IAM 권한 확인nginx 설치sudo yum update -yamazon-linux-extras list | grep nginxsudo amazon-linux-extras install -y nginx1 -ynginx -vsudo service nginx startservice nginx statusEC2 리눅스 서버 시간대 변경(linux 2 AMI)설정상 편의를 위해 관리자 권한으로 변경  $ sudo su서버 시간대를 서울 기준으로 변경(ZONE=&quot;Asia/Seoul&quot;)  # vi /etc/sysconfig/clock인스턴스가 현지 시간 정보를 참조할 때 표준 시간대 파일을 찾을 수 있도록 /etc/localtime과 표준 시간대 파일 사이에 심볼 링크 생성# ln -sf /usr/share/zoneinfo/Asia/Seoul /etc/localtimeAWS 콘솔에서 인스턴스 재부팅AWS configure 설정AWS 액세스 키가 없을 경우 생성 (참고)AWS CLI 사용을 위해 필요한 절차로컬에 다운로드 받은 액세스 키 파일을 열고, 터미널에서 aws configure 설정 (참고)Secret Access Key는 타인에게 노출되지 않아야 함/nginx.conf에서 user를 nginx에서 root로 변경$ sudo su위치: vi /etc/nginx/nginx.conf미변경시 /var/log/nginx/error.log에 13: Permission denied 로그가 찍힘service nginx restartLogrotate 프로세스 설정 파일 설정(NGINX)vi /etc/logrotate.d/nginx# vi /etc/logrotate.d/nginx/var/log/nginx/*log {    daily // 일 단위로 rotate 진행    rotate 10 // 로그 파일을 10개만 저장하고 나머지는 삭제    missingok // 로그 파일이 발견되지 않을 경우 에러처리 하지 않음    create 0640 root root // 로그 파일 생성시 0644 권한, root 사용자, root 그룹으로 생성    notifempty // 로그 내용이 없어도 rotate 진행    dateext // 백업 파일명에 날짜가 기입되도록 함    dateyesterday // 백업 파일명의 날짜를 어제 날짜로 지정    dateformat -%Y%m%d // date형식 지정(YYYYMMDD 형식이 아닌 다른 형식으로 사용시 지정)    sharedscripts // 로그 파일이 여러 개 있어도 스크립트를 공유하여 postrotate 스크립트를 한 번만 실행    postrotate // rotate 실행 후 스크립트 파일 실행        YESTERDAY=$(date -d yesterday '+%Y%m%d')        LOGFILE=&quot;/var/log/nginx/access.log-${YESTERDAY}&quot;        ##        echo &quot;${LOGFILE}&quot;        echo &quot;${YESTERDAY}&quot;        ##        if  -f ${LOGFILE} ; then                sudo /usr/bin/aws s3 cp ${LOGFILE} s3://{버킷명}/${YESTERDAY}/access-${YESTERDAY}.log                echo &quot;${LOGFILE} 파일이 s3에 복사되었습니다.&quot;        else                echo &quot;${LOGFILE} 파일이 존재하지 않습니다.&quot;        fi        ##        /bin/kill -USR1 cat /run/nginx.pid 2&gt;/dev/null 2&gt;/dev/null || true    endscript}### Logrotate 프로세스 설정 파일 설정(WTMP)- wtmp: 사용자들의 로그인, 로그아웃 정보와 시스템 관련 정보를 기록하는 로그- wtmp 로그는 last 명령어를 사용하여 확인- ```vi /etc/logrotate.conf```vi /etc/logrotate.confsee &quot;man logrotate&quot; for detailsrotate log files weeklyweeklykeep 4 weeks worth of backlogsrotate 4create new (empty) log files after rotating old onescreateuse date as a suffix of the rotated filedateextuncomment this if you want your log files compressed#compressRPM packages drop log rotation information into this directoryinclude /etc/logrotate.dno packages own wtmp and btmp -- we'll rotate them here/var/log/wtmp {    daily    dateext    dateyesterday    create 0664 root utmp    rotate 10    missingok    notifempty    #compress    prerotate        sudo rm -rf /var/log/wtmp-*.log        sleep 1        sudo last -f /var/log/wtmp &gt;&gt; /var/log/wtmp-$(date -d yesterday '+%Y%m%d').log    endscript    postrotate        YESTERDAY=$(date -d yesterday '+%Y%m%d')        LOGFILE=&quot;/var/log/wtmp-${YESTERDAY}.log&quot;        ##        echo &quot;${LOGFILE}&quot;        echo &quot;${YESTERDAY}&quot;        ##        if  -f ${LOGFILE} ; then                sudo /usr/bin/aws s3 cp ${LOGFILE} s3://{버킷명}/${YESTERDAY}/wtmp-${YESTERDAY}.log                echo &quot;${LOGFILE} 파일이 s3에 복사되었습니다.&quot;        else                echo &quot;${LOGFILE} 파일이 존재하지 않습니다.&quot;        fi    endscript}/var/log/btmp {    missingok    monthly    create 0600 root utmp    rotate 1}system-specific logs may be also be configured here.```매일 자정(00:00)에 로그가 순환 되도록 설정/etc/cron.daily의 기본 값은 이른 아침 시간에 적용 되는 것으로 보임매일 자정마다 하루치 로그가 적재되도록 관리할 것이므로, /etc/cron.daily/에 있는 logrotate를 임의 위치(나의 경우 /usr/logrotate/)에 디렉토리 생성 후 이동mkdir -p /usr/logrotate/mv /etc/cron.daily/logrotate /usr/logrotate/vi /etc/crontab 아래 내용 작성하여 내가 정한 시간에 순환 되도록 적용  0 0 * * * root /usr/logrotate/logrotate  테스트logrotate 강제 실행logrotate -f /etc/logrotate.conflogrotate 실행 모드-f    강제 실행-d    디버그 모드 (실제로 실행 되진 않음)-v    실행과정 화면에 표시결과참고도서 엔터프라이즈 리눅스 핵심 운영 가이드 vol.1(테크넷과 함께 하는)https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-configure-files.htmlhttps://freedeveloper.tistory.com/340https://ssomtitch.tistory.com/6https://www.nginx.com/resources/wiki/start/topics/examples/logrotation/https://blog.o3g.org/server/logrotate%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A1%9C%EA%B7%B8-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/https://developer111.tistory.com/30https://askubuntu.com/questions/24503/specify-the-time-of-daily-log-rotatehttps://jinane.tistory.com/11https://m.blog.naver.com/ncloud24/220942273629"
325,"Kubernetes Advanced Networking Study(KANS)의 1주차 내용을 학습하며 정리한 내용입니다.컨테이너 격리도커도커란, 가상실행 환경을 제공해주는 오픈소스 플랫폼이며, 도커에서는 이 가상실행 환경을 컨테이너라고 부른다. 좀 더 정확히 표현하자면 도커 이미지를 기반으로 실행되는 컨테이너화 된 프로세스라고 할 수 있다. 💡 운영체제에서 프로세스는 하나의 작업 단위이다. 그렇다면 프로그램과 프로세스의 차이는 뭘까? 프로그램은 하드디스크 같은 저장장치에 저장되어 있는 정적인 상태고, 프로세스는 실행을 위해 메모리에 올라온 동적인 상태다. 폰노이만 구조에서 프로그램이 실행된다는 것은 해당 코드가 메모리에 올라와서 작업이 진행된다는 의미다. 따라서 누군가가 작성한 프로그램이 실행되면 프로세스가 된다.도커 이미지만 있다면 환경의 영향을 받지 않고 다양한 환경에서 컨테이너를 기동시킬 수 있기 때문에 이식성이 높다.도커 아키텍처컨테이너컨테이너란, 호스트 OS상에 논리적인 구획을 만들어 애플리케이션을 작동시키기 위해 필요한 라이브러리나 애플리케이션 등을 하나로 모아 마치 별도의 서버인 것처럼 사용할 수 있게 만든 것이다.컨테이너는 호스트 OS의 리소스를 논리적으로 분리시켜 여러 개의 컨테이너가 공유하여 사용한다. 오버헤드가 적기 때문에 가볍고 고속으로 작동한다는 것이 특징이다.호스트 OS vs 도커 컨테이너 vs 가상머신일반적으로 물리 서버에 설치한 호스트 OS의 경우 하나의 OS 상에서 움직이는 여러 애플리케이션과 같은 시스템 리소스를 사용한다. 이때 작동하는 여러 애플리케이션은 데이터를 저장하는 디렉토리를 공유하고, 서버에 설정된 동일한 IP 주소로 통신한다. 그렇기 때문에 여러 애플리케이션에서 사용하고 있는 미들웨어나 라이브러리 버전이 다른 경우, 각 애플리케이션이 서로 영향을 받지 않도록 주의해야 한다.가상 머신은 기존 호스트 OS에 하이퍼바이저를 설치하고, 그 위에 게스트 OS와 패키징한 VM을 만들어 실행하는 방식인 하드웨어 레벨의 가상화를 지원한다. 그렇기 때문에 보안은 더 좋지만, 오버헤드가 크고 무겁고 느리다는 단점이 있다.반면, 컨테이너 사용시, 하드웨어 에뮬레이션 없이 리눅스 커널을 공유해서 바로 프로세스를 실행한다. 즉 운영체제를 제외한 나머지 애플리케이션 실행에 필요한 모든 파일을 패키징한다는 점에서 OS레벨 가상화를 지원한다. 호스트 OS의 커널을 공유하지만, 개별적인 user space를 가지고, 가상화된 공간을 생성하기 위해 리눅스 기능인 pivot-root, namespace, cgroup을 사용함으로써 OS나 디렉토리, IP 주소 등과 같은 시스템 자원들을 마치 각 애플리케이션이 점유하고 있는 것처럼 보이게 할 수 있다.💡 Docker는 Linux 커널 기술을 베이스로 작동한다.namespace: Docker는 컨테이너라는 독립된 환경을 만들고, 그 컨테이너를 구획화하여 애플리케이션 실행 환경을 만드는데, 그때 사용하는 기능이 Linux 커널의 namaspace다. 이것은 한 덩어리의 데이터에 이름을 붙여 분할함으로써 충돌 가능성을 낮추고, 쉽게 참조할 수 있게 할 수 있게 하는 개념이다.cgroups: Docker에서는 물리 머신 상의 자원을 여러 컨테이너가 공유하여 작동한다. 이 때 사용하는 기능이 Linux 커널 기능인 ‘control groups(cgroups)’이다. 리눅스에서는 프로그램을 프로세스로서 실행하는데, 프로세스는 하나 이상의 스레드 모음으로 움직이게 된다. cgroups는 프로세스와 스레드를 그룹화하여, 그 그룹 안에 존재하는 프로세스와 스레드에 대한 관리를 수행하기 위한 기능이다. 또한 계층 구조를 사용하여 프로세스를 그룹화하여 관리할 수도 있다.결론적으로 컨테이너 기술과 서버 가상화 기술은 매우 비슷하지만 목적이 다르다고 볼 수 있다. 컨테이너 기술은 애플리케이션의 실행 환경을 모음으로써 이식성을 높이고 확장성이 좋은 환경에서 작동하는 것을 지향하는 반면, 가상화 기술은 서로 다른 환경을 어떻게 효율적으로 에뮬레이트할 것인지를 지향한다. (격리 수준은 컨테이너보다 가상머신이 더 높다고 볼 수 있다.)컨테이너 격리 실습사전 준비 사항: vagrant로 ubuntu 설치 → Ubuntu 배포 관련 Vagrantfile 파일 다운로드시 Powershell에서 Invoke-WebRequest 대신 curl 사용하기Powershell에서 curl 명령어는 Invoke-WebRequest로 alias 되어 있는데, 나의 경우 그냥 del alias:curl로 alias를 해제하고 curl 명령어를 그대로 실행하였다.실습 1. 터미널 2개를 띄워 Host와 Container의 Namespace 정보가 다른 것을 확인하기▪️ PID namespace: PID란, 리눅스에서 각 프로세스에 할당된 고유 ID이다. 여기서 PID namespace는 PID와 프로세스를 격리시킨다. namespace가 다른 프로세스끼리는 서로 액세스할 수 없다.▪️ Network namespace: 네트워크 디바이스, IP 주소, 포트 번호, 라우팅 테이블, 필터링 테이블 등과 같은 네트워크 리소스를 격리된 namespace마다 독립적으로 가질 수 있다. 이 기능을 사용하면 호스트 OS 상에서 사용 중인 포트가 있더라도 컨테이너 안에서 동일한 번호의 포트를 사용할 수 있다.▪️ UID namespace: UID(사용자 ID), GID(그룹 ID)를 namespace별로 독립적으로 가질 수 있다. namespace 안과 호스트 OS상의 UID/GID가 서로 연결되어 namespace 안과 밖에서 서로 다른 UID/GID를 가질 수 있다. 예를 들어 namespace 안에서는 UID/GID가 0인 root 사용자를, 호스트 OS 상에서는 일반 사용자로 취급할 수 있다.▪️ Mount namespace: Linux에서 파일 시스템을 사용하기 위해서는 마운트가 필요하다. 마운트란 컴퓨터에 연결된 기기나 기억장치를 OS에 인식시켜 이용 가능한 상태로 만드는 것이다. Mount namespace는 마운트 조작을 하면 namespace 안에 격리된 파일 시스템 트리를 만든다. 다른 namespace 기능과 마찬가지로 namespace 안에서 수행한 마운트는 호스트 OS나 다른 namespace에서는 액세스할 수 없게 되어 있다.▪️ UTS namespace: namespace 별로 호스트명이나 도메인명을 독자적으로 가질수 있다.▪️ IPC namespace: 프로세스 간의 통신(IPC) 오브젝트를 namespace별로 독립적으로 가질 수 있다.ipc, mnt, net, pid, uts가 다르다.터미널1 (Ubuntu Container)터미널2 (Host Shell)hostname이 다르다.터미널1 (Ubuntu Container)터미널2 (Host Shell)NET(네트워크 환경)이 다르다.터미널1 (Ubuntu Container)터미널2 (Host Shell)실습 2. 컨테이너가 독립된 리눅스 환경을 보장받는 프로세스라면, 호스트에서 컨테이너(프로세스)를 종료할 수 있는지 확인하기- 터미널1 (Ubuntu Host)!(https://images.velog.io/images/200ok/post/e8aa3a27-6aac-49f6-af43-8e24160c9335/image.png)docker run —rm -it ubuntu bash 명령어 실행 후, 컨테이너 내부에서 아래 내용 실행!(https://images.velog.io/images/200ok/post/2430e0ec-0eb4-4773-9470-a14ac7724b28/image.png)- 터미널2 (Host Shell)!(https://images.velog.io/images/200ok/post/7d94fa91-1057-46d0-8b2a-860080c68ff4/image.png)!(https://images.velog.io/images/200ok/post/82f82e9f-2fc9-4731-bbc3-22e78ac761b2/image.png)!(https://images.velog.io/images/200ok/post/f7d4a0c5-225e-49c5-a871-9abf36bd272b/image.png)호스트에서 컨테이너에서 동작하는 sleep 종료- 터미널1 (Ubuntu Container)   !(https://images.velog.io/images/200ok/post/eaaf8733-6e6d-4bd5-aafb-f6fb957839ae/image.png)sleep 프로세스가 사라진 것을 알 수 있다. 즉, 호스트에서 컨테이너 프로세스를 컨트롤 할 수 있다.참고도서 완벽한 IT 인프라 구축을 위한 Docker도서 쿠버네티스 완벽 가이드도서 쉽게 배우는 운영체제도서 IT 엔지니어를 위한 네트워크 입문https://docs.docker.com/get-started/overview/#docker-architecturehttps://netpple.github.io/docs/make-container-without-docker/https://wiseworld.tistory.com/53https://www.youtube.com/watch?v=DmZnOg5Ced8https://www.44bits.io/ko/keyword/linux-container"
326,"한빛미디어 &lt;나는 리뷰어다&gt; 활동을 위해서 책을 제공받아 작성된 서평입니다.이 책은 중소기업이나 스타트업 등 소규모 조직에서 오픈소스를 활용해 적은 예산으로도 자체 네트워크 보안 관제 체계를 실제 구축하는 것을 목표로 작성되어 있다. 실제로 네트워크 구축 보안 체계를 구축하지 않는 경우 발생할 수 있는 보안 위협과 피해 사례를 통해 필요성을 강조하는 것을 시작으로 초심자도 전체적인 숲을 볼 수 있도록 간략한 네트워크 보안 배경 지식에 대한 내용도 서술되어 있다.또한 물리적인 환경 구성 전, 독자의 PC에서 가상머신 환경을 통해 보안 시스템을 구축하고 운영해볼 수 있는 경험을 제공하여 실제 환경 구축 전 시행착오를 줄일 수 있게끔 도와준다. 이때는 VirtualBox와 GSN3를 사용한다.이후 실제 데스크톱이나 서버를 준비하여 물리적인 방화벽 장비를 만들어 보기도 하고 ELK(Elasticsearch+Logstash, FileBeat+Kibana) 스택으로 SIEM을 구축하고 운영하는 과정을 설명하는 등 최신 트렌드에 맞는 내용 또한 빠지지 않고 담겨 있다.예상되는 대상 독자로는 실제로 네트워크 보안 시스템을 구축하고 보안 관제를 하려는 중소기업과 그 내용을 배우고자 하는 관련 전공자 학생이다. '처음 배우는'이라는 제목이 붙어 있지만, 정말 네트워크나 운영체제(리눅스)를 처음 배우는 사람이라면 설명이 간략한 경우가 많으므로 이해하기 버거운 부분이 있을 것으로 보인다."
327,"한빛미디어 &lt;나는 리뷰어다&gt; 활동을 위해서 책을 제공받아 작성된 서평입니다.&quot;아키텍처는 정답도, 오답도 없다. 오직 트레이드오프만 있을 뿐.&quot;학습 과정이나 실무에서도 늘 정답만을 찾으려고 노력했던 내 머리를 '띵'하게 만들었던 책 속의 한마디.실제로 우리 서비스에 REST와 메시징 중 어느 게 더 나은지, 마이크로서비스가 딱 맞는 아키텍처 스타일인지는 구글을 아무리 뒤져봐도 알 수 없다. 배포 환경이나 회사의 문화, 예산, 기간, 개발자 스킬 등 여러 가지 팩터들이 영향을 미치기 때문이다. 이것이 아키텍처가 어렵다는 말이 나오는 이유가 아닐까 싶다.전반부에는 이런 모호함 속에서 아키텍처를 구축하거나 기존 아키텍처의 타당성을 검증하기 위해 아키텍처의 특성을 식별하고 구체적으로 정의할 수 있는 기초 지식과 아키텍트가 특정 비즈니스 문제에서 올바른 선택을 할 수 있도록 다양한 아키텍처 스타일의 트레이드 오프를 중점적으로 학습할 수 있다.반면 위와 같은 기술적인 부분뿐만 아니라 개발자나 다른 이해관계자들과 협력하는데 필요한 여러 가지 기법과 소프트 스킬에 대한 내용이 비교적 자세하게 서술된 대목 또한 인상 깊다.아키텍트가 아무리 훌륭한 아이디어를 갖고 있다 한들 결국 그들에게 자금을 댈 고객사 관리자와 그 아이디어를 실제로 구현할 개발자들이 납득하지 못한다면 결국 빛을 볼 수 없기 때문이다.실제로 책 후반부에는 아키텍처를 보기 좋게 도식화하는 방법부터 파워포인트나 키노트 같은 도구로 효과적인 프레젠테이션을 하는 법, 프로젝트의 리더로서 개발팀을 효과적으로 이끌어가기 위해 알아둬야 할 기본 테크닉, 고객사 임원 같은 핵심 비즈니스 이해관계자들과의 협상 스킬까지 유능한 소프트웨어 아키텍트가 되기위한 지침들이 쓰여있다.끝으로 아키텍트가 되고 난 후의 커리어 패스 관리를 위한 팁까지 알차게 담겨 있기에 연차와 관계없이 아키텍트 희망하는 사람이라면 이 책을 통해 다양한 인사이트를 얻을 수 있으리라 생각한다."
328,"영진출판으로부터 책을 제공받아 작성했습니다.현업에서 매일같이 AWS를 사용하고 있지만, 사실 AI 관련 서비스는 아직도 어렵고 낯설게 느껴지는 부분들이 많다. 그래서인지 책 제목을 보자마자 AI 알못에 울렁증까지 심한 나에게 딱 적합한 책이라는 생각이 들었고 받자마자 읽어보게 되었다.이 책은 AI와 관련해서 AWS가 현재 어떤 서비스를 제공하고 있는지 얕게나마 파악할 수 있도록 돕는다. 본격적으로 AWS의 AI 서비스를 써보기 전, AI가 무엇인지 그리고 AI와 머신러닝은 어떤 관계를 맺고 있는지부터 쉽게 설명하여 초심자들의 흥미를 이끌어낸다.물론 도중에 선형회귀, 로지스틱 회귀 같은 현기증을 유발하는 단어가 등장하지만 정말 맛보기 수준으로 훑고 지나가기에 수포자라도 자신감을 잃지 않아도 된다.일반적으로 머신러닝이나 딥러닝을 사용한다고 하면 Python이나 R 같은 프로그래밍 언어를 이용해 스스로 모델을 만드는 모습을 많이 떠올리는데, 뿐만 아니라 웹 브라우저 조작만으로 모델을 만들거나 이 책에서 주로 다루게 되는 많은 Amazon AI 서비스들처럼 사전에 학습이 끝난 모델을 사용할 수도 있다.이 말은 즉 머신러닝 알고리즘을 이용해 내가 직접 모델을 만들거나 학습 데이터를 준비하지 않아도 머신러닝을 위해 AWS에서 이미 학습시킨 준비된 서비스를 사용할 수 있기 때문에 개인 앱이나 기업에서도 쉽게 AI적인 기능을 구현할 수 있다는 뜻이다.이 책은 AWS를 사용해보았지만, AI를 모르거나 어려워하는 나 같은 초심자들을 위해 SDK 사용 준비부터 Rekognition, Comprehend, Textract, Translate, Transcribe, Polly, Lex, Forecast, Personalize, SageMaker, Deep Learning AMI까지 AWS의 전반적인 AI 서비스를 쉽게 따라하며 가볍게 맛볼 수 있도록 도와준다.비록 3장 이후부터는 AWS 공식 문서를 통해서도 진행할 수 있는 튜토리얼이 대부분이지만, 공식 문서 내용조차도 이해하기 버거운 독자들에겐 큰 도움이 될 것이라고 생각한다.다만 AWS는 서비스 업데이트가 굉장히 빈번하고 빠르게 진행되기 때문에 튜토리얼 분량이 많은 이 책의 경우 수명이 길지 못할 것으로 보인다. 때문에 이 책을 통해 실습 하고자 하는 경우 가급적 빠르게 진행을 해야 버전 문제에 따른 실습 오류를 방지할 수 있을 것이다."
329,"길벗출판사 &lt;16차 개발자 리뷰어&gt; 활동을 위해서 책을 제공받아 작성된 서평입니다.제목 그대로 쿠버네티스의 모든 기능을 총망라하는 완벽 가이드, 종결자.그동안 수많은 쿠버네티스 관련 서적들을 접해왔지만 이토록 체계적이고 꼼꼼하게 쓰여진 책은 없었다. 특히 풍부한 그림과 다양한 예시를 통해 알기 쉽게 설명하기 때문에 그동안 러닝커브의 압박을 느끼던 입문자들도 부담 없이 체계적으로 쿠버네티스를 학습할 수 있을 것이다.다만, 중급자 이상의 경우 800P가 넘는 분량이기에 처음부터 끝까지 각 잡고 읽기 보다는 실무에서 어렵거나 모르는 개념을 만났을 때 사전처럼 활용하기 좋아 보인다.개인적으로 특히 좋았던 부분은 부록에 수록된 &lt;자주 묻는 질문과 답변&gt; 부분인데, 약 260개의 Q&amp;A를 통해 실무에서도 필요한 내용을 편리하게 확인하여 활용할 수 있을 것으로 기대된다.또한 헬름, 데이터독, 프로메테우스, ArgoCD, 스피네이커, 이스티오 등 쿠버네티스 주변 기술에 대한 기본 개념들까지도 충실히 서술된 부분 또한 마음에 쏙 든다. 자주 손이 가는 책이 될 것 같다."
330,"한빛미디어 &lt;나는 리뷰어다&gt; 활동을 위해서 책을 제공받아 작성된 서평입니다.디지털 트랜스포메이션이 산업계의 주요 화두로 떠오르는 요즘, 클라우드를 사용하는 기업들이 급속도로 증가하고 있다. 데이터 센터에서 대량의 장비를 3~5년 주기로 사전 구입하는 시대가 지나고 필요할 때 필요한 만큼의 리소스를 클릭 한 번으로 구매할 수 있는 시대가 도래한 것이다.대게 클라우드 서비스 제공 업체들은 사용한 만큼만 비용을 지불한다는 개념으로 서비스를 판매한다. 다만, 여기에 숨겨진 함정은 사용 여부와 관계없이 배포한 리소스에 대해 비용을 지불해야 하는 경우가 많고, 엔지니어의 버튼 한 번이나 코드 한 줄을 실행하는 것만으로도 회사의 비용을 쉽게 지출할 수 있다는 것이다.핀옵스는 이러한 클라우드 흐름에 맞춰 자연스럽게 등장했다. 이제는 소수의 인원이 구매 결정을 내리는 방식이 아닌 재무, 운영, 개발자, 경영자에 이르기까지 조직 내 모든 사람이 재무 관리에 참여해야 한다.이 책은 재무팀과 기술팀 모두가 클라우드 재무관리에서 각자의 역할을 이해할 수 있도록 쉽게 설명을 하고 있다. 결과적으로 조직이 혁신을 늦추지 않고도 클라우드 지출을 관리하고 최적화하여 발전시킬 수 있는 로드맵을 제시하고 있다.내용 중 대표적인 퍼블릭 클라우드 서비스 제공업체인 AWS, Azure, GCP에서 제공하는 서비스들이 제공하는 할인 혜택들을 간단히 정리해주는 부분들도 좋았고, 단순히 리소스 삭제나 이동을 하는 것뿐만 아니라 태그나 레이블 사용 등을 통해서도 사용량과 요금을 최적화 할 수 있음을 알게 되었다.개발자, 엔지니어 뿐만 아니라 실제로 클라우드를 사용하고 있거나 클라우드로 전환하고자 하는 기업의 재무, 구매를 담당하는 사람들도 큰 부담없이 읽을 수 있는 책이다. 만약 클라우드를 도입해야 하거나 비용, 운영 문제를 개선해야 한다면 책에서 제시하는 다양한 방법을 적용해볼 수 있을 것이다."
331,"골든래빗 출판사로부터 책을 제공받아 작성했습니다.첫인상비록 현재는 개발자가 아닌 인프라 엔지니어의 길을 걷고 있지만, IT 업계로의 첫발을 디딜 당시 가장 먼저 도전했던 언어가 바로 자바였다. 낯선 개념은 둘째치고 멋모르고 등록했던 부트캠프에서 자존감과 멘탈이 와장창 박살 날 정도로 고생을 해서인지 코딩에 울렁증이 생겨버린 원인이 되어버린 언어이기도 하다.그러다 우연한 기회로 이렇게 자바를 다시 마주할 날이 오다니 감회가 새롭다. 일단 가볍게 책을 훑어보며 느낀 첫인상은 정말 친절하다는 것. 특히 웹 브라우저만 있으면 되는 &lt;선수 수업&gt;부터 왕기초 입문자들을 배려하기 위해 많은 노력했다는 점을 엿볼 수 있다. (설치 과정에서도 많은 낙오자가 발생한다는 사실을 귀신같이 알고 있는 저자)&quot;반복해서 사용하면서 익숙해지고 흥미가 생기는 게 먼저입니다. 일단 사용해보면서 코딩에 친숙해지고 몇 가지라도 용어를 익힌다면 목표 달성입니다.&quot;세상 스윗하다. 여러모로 고통 받았던 n년 전 과거에도 이런 책이 존재했다면 나도 그리 쉽게 개발자로의 진로를 포기하지 않았을수도 있었을텐데(..?) Anyway, 아래는 자바 울렁증을 극복하기 위해 천천히 따라하며 새롭게 익힌 내용을 요약한 내용 일부이다.요약별도록 선수수업다른 자바 프로그래밍 책과 두드러지는 차별점은 선수 수업 부분이다. 처음 자바에 입문을 했을 때 환경설정과 환경 변수라는 단어부터 머릿속이 아파지는 느낌이 들었는데, 이러한 설정들은 프로그래밍을 시작하는 단계에서는 절대 이해를 할 수 없었기 때문에 무작정 따라 하기만 했던 기억이 난다. 하지만 신기한 것은 이러한 설정 과정은 프로그램을 몇 번 돌려보면 금방 이해하기가 쉬워진다. 그래서 선수 수업 파트를 보며, 환경설정 없이 먼저 프로그램이 돌아가는 과정을 보고, 모든 프로그래밍의 작은 과정 하나하나가 얼마나 중요한지를 먼저 맛보기로 보여줌으로써 처음 입문하는 사람들에게 첫 도약의 부담감을 줄여주는 것 같았다. 리플릿이라는 플랫폼도 가입하기도 쉬우며, 나중에 큰 프로젝트를 진행하면서도 자잘한 작은 테스트 코드 용도로도 사용하기 좋았다. 코드 작성을 진행하는 단계에서도 세세한 print/println에 대한 차이도 명확하게 나와있었으며 중간중간 도움을 주는 명언들도 있었기에 자신감 또한 북돋아 주는 과정이었다. 선수 수업의 책답게 예시 코드에 중략이 없어서 중복되는 코드들을 반복하며 프로그래밍을 선수 수업하기에 적절해 보였다.0. 환경설정환경설정 챕터를 보았을 때, 정말 기초부터 알려주는 친절함에 가슴이 뭉클해졌다. 사용자 변수와 시스템 변수를 설명해 주는 책이라니! 자바뿐만 아니라 컴퓨터의 기본지식을 알려줌으로써 책을 읽는 입문자는 자신이 배우려는 분야에 자신도 모르게 지식을 넓혀가고 있는 것이다. 그리고 이런 지식들은 앞으로의 프로그래밍에 정말 도움이 될 것이다.1. 자바 기초 프로그래밍01. hello java world~전기신호부터 시작하여 이진법까지의 핵심적인 프로그래밍 언어에 대한 지식을 재미있게 알려주며 왜 우리가 코드를 작성하는지에 대한 기본을 잡아준다.앞서 말한 이진법을 통하여, 바이트에 대한 간결하지만 정확한 설명으로 데이터 처리방식을 제시하고있으며, 이에 이어 왜 자료형이 존재하는지(데이터공간에 대한 자료구조의  기본)에 대해 알기 쉽게 알려주고 있다. 전공기본책이 아니면 알수없지만 프로그래밍을 배워가며 전반적으로 나온는 ‘인코딩’ ‘디코딩’ 같은 단어에 대한 설명들이 빠지지않고 주석으로 나오고 있다. 다양한 자료형을 세세하게 알려주며, ‘형’에 대한 기본 베이스를 굳게 잡아줌으로써 ‘형’의 변환에 대한 연결이 자연스러워진다.04. 연산자~다양한 연산자의 기호를 다양한 예시를 통해 설명해주고 있다. 명제같은 다양한 비유를 통해 좀더 다가가기 쉬운 설명을 해주고있다. 단단한 기초지식을 생성함과 동시에 중간중간에는 복합 대입 연산자라는 물음표도 던져주면서, 기초를 더 단단하게 다지도록 도와주는 느낌을 받았다. 또한 기초 프로그래밍 과정에서 겪을 수 있는 논리연산자의 주의점을 알려줌으로써 초보자들의 마음을 이해해 주는 친절함이 돋보였다. 콘솔 설명 부분에서는 출력뿐만이 아닌 스캐너 부분에 대한 설명을 계속해서 해주면서 후에 나올 단계에 좀 더 대비하는 것 같았다.06. 제어문~제어문의 올바른 사용법과, 가장 많이 발생하는 0은 나눌 수 없다는 오류의 처리까지 포괄하는 지식을 알려주며, 단순한 제어가 아닌 실제로 프로그래밍을 제어하는 방법을 알려주는 단계였다. 예시코드에는 다양한 기호를 통해 상세한 설명이 나와있고, 조금이라도 복잡한 부분은 다양한 영역 비유를 통해 이해를 돕고있다. 변수의 다양한 범위를 설명해 주며 ‘주석’을 적극 활용하여 실제 오류코드가 아닌 주석을 풀면 오류가 나는 프로그래밍의 순서를 설명해 주는 것이 인상적이었다.총평프로그래밍의 'ㅍ'자도 모르는 입문자들을 위한 맞춤 눈높이 교재이다. 단순한 문법 학습으로 끝이 아닌 배운 내용을 활용해 직접 프로그램을 만들어볼 수 있는 구성으로 엮여있어 성취감을 얻을 수 있다.구매처📘 Must Have 『이재환의 자바 프로그래밍 입문』​📎 골든래빗 https://bit.ly/3xoPGWc​📎 교보문고 https://bit.ly/2VgWdEG​📎 예스24 https://bit.ly/3f1WHWg​📎 알라딘 https://bit.ly/3ybW9ES​📎 인터파크 https://bit.ly/2UVrVaW​"
332,"한빛미디어 &lt;나는 리뷰어다&gt; 활동을 위해서 책을 제공받아 작성된 서평입니다.책의 구성본 도서를 통해 다음 질문에 대한 답을 얻을 수 있다.CHAPTER 1. 새로운 네트워크 아키텍처의 동기새로운 애플리케이션의 특징액세스-애그리게이션-코어 네트워크의 개념액세스-애그리게이션-코어 네트워크에서 애프리케이션이 실패하는 경우CHAPTER 2. 클로스: 새로운 세상을 위한 네트워크 토폴로지클로스 토폴로지의 개념과 액세스-애그-코어 토폴로지와의 차이점클로스 토폴로지의 특징데이터센터 네트워킹의 클로스 토폴로지의 결과CHAPTER 3. 네트워크 분리네트워크 분리의 개념네트워크 분리가 중요한 이유네트워크 분리를 위한 주요 활성 기술네트워크 분리를 위한 하드웨어 시장의 핵심 주체분리된 스위치와 기존 스위치의 차이점CHAPTER 4. 네트워크 운영체제 선택클라우드 네이티브 NOS의 기본적인 요구사항오픈플로와 소프트웨어 정의 네트워킹의 개념과 어떤 상황에서 사용할 수 있고 없는지에 대한 내용분리된 스위치에서 선택 가능한 NOS클라우드 네이티브 NOS의 요구사항과 여러 모델들과의 비교CHAPTER 5. 라우팅 프로토콜 선택라우팅의 동작 방식라우팅 프로토콜의 종류클로스 토폴로지에 맞는 라우팅 프로토콜언넘버드 인터페이스의 개념과 이것이 필요한 이유적합한 라우팅 프로토콜 선정 방법CHAPTER 6. 네트워크 가상화네트워크 가상화란 무엇인가네트워크 가상화의 용도네트워크 가상화 외 다른 선택지네트워크 가상화에서의 제어 평면 선택브리징과 라우팅에서의 VXLAN의 동작 방식CHAPTER 7. 컨테이너 네트워킹리눅스에서 사용 가능한 컨테이너 네트워크 구성다양한 선택의 제약과 성능 특성CHAPTER 8. 멀티캐스트 라우팅멀티캐스트 라우팅의 개념 및 유니캐스트 라우팅과의 차이점멀티캐스트를 사용하는 이유모던 데이터 센터의 멀티캐스트 라우팅이 어려운 이유멀티캐스트의 중앙 라우팅 프로토콜인 프로토콜 독립 멀티캐스트 산재모드(protocol-independent multicast sparse mode)의 동작방식클로스 토폴로지에 멀티캐스트 라우팅을 배치하기 위한 필요 조건CHAPTER 9. 데이터 센터 에지에서의 삶클로스 토폴로지가 외부 네트워크와 연결되기 위한 방법에지에 라우팅 프로토콜을 배치하는 모범 사례기업이 하이브리드 클라우드 내의 연결성을 제어하는 방법CHAPTER 10. 네트워크 자동화네트워크 자동화에 대한 개념과 필요한 이유네트워크 자동화를 배우기 위해 프로그래밍 능력이 필요한지에 대한 내용네트워크 자동화가 어려운 이유네트워크 자동화의 이점들을 점진적으로 탐구할 수 있는 방법적합한 네트워크 자동화 도구 선택자동화된 절차의 올바른 동작을 보장할 수 있는 방법CHAPTER 11. 네트워크 관측성관측성의 개념과 신경 써야 하는 이유네트워크 관측성에서의 도전 과제CHAPTER 12. 네트워크 디자인 재고클라우드 네이티브 데이터 센터의 기초가 되는 디자인 원칙CHAPTER 13. OSPF 배치데이터 센터에서 OSPF가 유용한 경우OSPF 구성을 위한 주요 디자인 원칙OSPFv2와 v3의 차이점과 사용 방법현재 라우팅 스택에서 OSPF 구성 방법컨테이너를 위한 라우팅을 제공하기 위한 OSPF 구성 방법OSPF를 이용한 라우터 소프트웨어 업그레이드 방법CHAPTER 14. 데이터 센터에서의 BGPASN, 커뮤니티, 속성, 최적 경로와 같은 BGP 용어의 의미데이터 센터에서 eBGP 또는 iBGP를 사용해야 하는가데이터 센터에서 BGP를 사용할 때 ASN 넘버링 스킴이란데이터 센터에서 사용하기 위한 BGP 타이머 수정 방법CHAPTER 15. BGP 배치BGP의 핵심 구성 개념클로스 네트워크에서 BGP를 구성하기 위한 방법언넘버드 BGP 동작 방식큐브 라우터와 같은 호스트에서 동작하는 BGP 스피커에서의 BGP 피어 구성 방식예약된 유지 보수에 맞춰서 네트워크가 정상적으로 종료하기 위한 BGP 구성 방식CHAPTER 16. 데이터 센터에서의 EVPNEVPN은 무엇이며 왜 널리 사용되는가?EVPN을 배치하기 위한 제어 평면 모델EVPN 지원을 위해 BGP가 구축하는 것EVPN 브리징과 전통적인 802.1Q 브리징의 차이점 이중 연결 호스트 지원 방법CHAPTER 17. 네트워크 가상화 배치EVPN 브리징과 라우팅을 네트워크에 구성하는 방법네트워크 가상화를 위한 주요 라우팅 프로토콜 구성 방식CHAPTER 18. 네트워크 구성 검증네트워크 케이블링 검증인터페이스 구성 검증라우팅 구성 검증네트워크 가상화 검증애플리케이션 연결성 검증느낀점분명 클라우드 네트워킹 전문가가 '쉽게 알려주는' 실무 기법이라고 쓰여있으나, 네트워크 지식이 부족하거나 나같은(아직 갈 길이 먼 주니어 인프라 엔지니어) 사람에게는 딥하게 느껴지는 부분들이 많았음.하나하나 이해하며 읽어 나가기엔 속도가 너무 나지 않았기에, 당장 관심이 가는 부분(네트워크 가상화, 컨테이너 네트워크, 네트워크 자동화 등)만 발췌하여 읽은 소감으로는 기존에 어렴풋이 알고 있던 개념을 강화시킬 수 있는 새로운 인사이트를 얻을 수 있었음. 예를 들어 단일 호스트 컨테이너 통신에 브리지를 사용하는 대신 Macvlan을 사용할 수 있다든지.지금 내 수준으로는 설명이 친절하지 않게 느껴지므로(...) 내공이 더 쌓인 뒤에 다시 봐야 할 책.대상 독자네트워크 아키텍트, 네트워크 운영자, 네트워크 애플리케이션 개발자."
333,"2022-04-26화살표 함수() =&gt; {} vs function () {}const double = function (x) {  return x * 2}console.log('double: ', double(7))// double: 14const doubleArrow = (x) =&gt; {  return x * 2}console.log('doubleArrow', doubleArrow(7))// doubleArrow: 14_화살표 함수는 return과 그 뒤에 단순 실행문만 있을 때 아래와 같이 축약할 수 있음_const doubleArrow = (x) =&gt; x * 2 // 매개변수가 x 하나일 때 괄호도 지울 수 있다.console.log('doubleArrow', doubleArrow(7))// doubleArrow: 14_화살표 함수의 축약형으로 객체 데이터를 반환할 때는 소괄호로 한 번 감싸줘야한다._const doubleArrow = x =&gt; ({  name: 'Jinyoung'} )"
334,"2022-04-25조건문 if elseconst a = random() //import된 random 함수if (a === 0) {  console.log('a is 0')} else if (a === 2) {  console.log('a is 2') } else {  console.log('rest...') // 나머지 매개변수}삼항연산자const a = 1 &lt; 2if a {  console.log('참')} else {  console.log('거짓')}console.log(a ? '참' : '거짓')조건문 switchif (a === 0) {  console.log('a is 0')} else if (a === 2) {  console.log('a is 2')} else if (a === 4) {  console.log('a is 4') } else {  console.log('rest...')}// 위 조건문과 동일한 결과를 갖는 switch문switch (a) {  case 0:    console.log('a is 0')    break  case 2:    console.log('a is 2')    break  case 4:    console.log('a is 4')    break  default: console.log('rest...')}반복문 Forfor (시작조건; 종료조건; 변화조건) {}for (let i = 0; i &lt; 3; i += 1) {  console.log(i)}// 0, 1, 2const ulEl = document.querySelector('ul')for (let i = 0; i &lt; 3; i += 1) {  const li = document.createElement('li')  li.textContent = `list-${i + 1}`  ulEl.appendChild(li)}출력 결과list-1list-2list-3"
335,"2022-04-21함수특정 동작(기능)을 수행하는 일부 코드의 집합(부분)function// 함수 선언function helloFunc() {    //실행 코드  console.log(1234);}// 함수 호출helloFunc(); // 1234function returnFunc() {  return 123; // 반환}let a = returnFunc(); // 함수 호출(실행)console.log(a); // 123// 함수 선언function sum(a, b) { // a와 b는 매개변수(Parameters)  return a + b;}// 재사용!let a = sum(1, 2); // 1과 2는 인수(Arguments)let b = sum(7, 12);let c = sum(2, 4);console.log(a, b, c); // 3, 19, 6기명 함수//함수 선언function hello() {  console.log('Hello~');익명 함수//함수 표현let world = function () {  console.log('World~');}// 함수 호출hello(); // Hello~world(); // World~"
336,"2022-04-20데이터 종류String (문자 데이터)따옴표를 사용함let myName = &quot;Jinyeong&quot;;let email = 'moonchess@naver.com'let hello = `hello ${myName}?!`console.log(myName); // Jinyeongconsole.log(email); // moonchess@naver.comconsole.log(hello); // hello Jinyeong?!Number (숫자 데이터)정수 및 부동소수점 숫자를 나타냄let number = 123;let opacitiy = 1.57;console.log(number); // 123console.log(opacity); // 1.57Boolean (불린 데이터)true, false 두 가지 값밖에 없는 논리 데이터let checked = true;let isShow = false;console.log(checked); // trueconsole.log(isShow); // falseUndefined값이 할당되지 않은 상태를 나타냄let obj = { abc: 123 };console.log(abc); // 123console.log(xyz); // undefinedNull어떤 값이 의도적으로 비어있음을 의미let empty = null;console.log(empty); // nullObject (객체 데이터)여러 데이터를 Key:Value 형태로 저장함let user = {//Key : Value,  name: 'Jinyeong',  age: 94,  isValid: true};console.log(user.name); // Jinyeongconsole.log(user.age); // 94console.log(user.isValid); // trueArray (배열 데이터)여러 데이터를 순차적으로 저장함let fruits = 'Apple', 'Banana', 'Cherry';console.log(fruits0); // 'Apple'console.log(fruits1); // 'Banana'console.log(fruits2); // 'Cherry'변수와 예약어변수데이터를 저장하고 참조(사용)하는 데이터의 이름var, let, const //재사용이 가능//변수 선언let a = 2;let b = 5;console.log(a + b); // 7console.log(a - b); // -3//값(데이터)의 재할당 가능let a = 12;console.log(a); // 12a = 999;console.log(a); // 999//값(데이터)의 재할당 불가const a = 12;console.log(a); // 12a= 999;console.log(a); // TypeError: Assignment to constant variable.예약어특별한 의미를 가지고 있어, 변수나 함수 이름 등으로 사용할 수 없는 단어let this = 'Hello'; // SyntaxErrorlet if = 123; // SyntaxErrorlet break = true; // SyntaxError"
337,"2022-04-19transition: 속성명 **지속시간** 타이밍함수 대기시간;요소의 전환(시작과 끝) 효과를 지정하는 단축 속성transition-property  전환 효과를 사용할 속성 이름을 지정 기본값 all 속성이름 전환 효과를 사용할 속성 이름 명시 transition-duration전환 효과의 지속시간을 지정, 단축형으로 작성할 때 필수 포함 속성기본값 0s 전환 효과 없음시간 지속시간(s)을 지정 transition-timing-function전환 효과의 타이밍(Easing) 함수를 지정기본값 ease 느리게 - 빠르게 - 느리게linear 일정하게ease-in 느리게 - 빠르게ease-out 빠르게 - 느리게ease-in-out 느리게 - 빠르게 - 느리게 transition-delay전환 효과가 몇 초 뒤에 시작할지 대기시간을 지정기본값 0s 대기시간 없음시간 대기시간(s)을 지정"
338,"2022-04-18display:flex 가 부여된 요소는 Flex Container가 되고, Flex Container의 자식 요소는 Flex Items가 된다.이때 Flex Items는 수평으로 쌓이게 된다. displayFlex Container의 화면 출력(보여짐) 특성flex 블록 요소와 같이 Flex Container 정의inline-flex 인라인 요소와 같이 Flex Container 정의 flex-direction주 축을 설정기본값 row 행 축 (좌 =&gt; 우)row-reverse 행 축 (우 =&gt; 좌)column 열 축 (위 =&gt; 아래)column-reverse 열 축 (아래 =&gt; 위) flex-wrapFlex Items 묶음 (줄 바꿈) 여부기본값 nowrap 묶음(줄 바꿈) 없음wrap 여러 줄로 묶음wrap-reverse wrap의 반대 방향으로 묶음 justify-content주 축의 정렬 방법기본값 flex-start Flex Items를 시작점으로 정렬flex-end Flex Items를 끝점으로 정렬center Flex Items를 가운데 정렬space-between 각 Flex Item 사이를 균등하게 정렬space-around 각 Flex Item의 외부 여백을 균등하게 정렬 align-content교차 측의 여러 줄 정렬 방법기본값 stretch Flex Items를 시작점으로 정렬flex-start Flex Items를 시작점으로 정렬flex-end Flex Items를 끝점으로 정렬center Flex Items를 가운데 정렬space-between 각 Flex Item 사이를 균등하게 정렬space-around 각 Flex Item의 외부 여백을 균등하게 정렬 align-items주 축의 정렬 방법기본값 stretch Flex Items를 교차 축으로 늘림flex-start Flex Items를 각 줄의 시작점으로 정렬flex-end Flex Items를 각 줄의 끝점으로 정렬center Flex Items를 각 줄의 가운데 정렬orderFlex Item의 순서기본값 0 순서 없음숫자 숫자가 작을 수록 먼저flex-growFlex Item의 증가 너비 비율기본값 0 증가 비율 없음숫자 증가 비율flex-shrinkFlex Item의 감소 너비 비율기본값 1 Flex Container 너비에 따라 감소 비율 적용숫자 감소 비율flex-basisFlex Item의 공간 배분 전 기본 너비기본값 auto 요소의 Content 너비단위 px, em, rem"
339,"2022-04-15position요소의 위치 지정 기준기본값 기준 없음, staticrelative 요소의 자신을 기준absolute 위치 상 부모 요소를 기준 (위치 상 부모 요소를 꼭 확인)fixed 뷰포트(브라우저)를 기준sticky 스크롤 영역 기준z-index요소의 쌓임 정도를 지정기본값 auto 부모요소와 동일한 쌓임 정도숫자 숫자가 높을 수록 위에 쌓임position 속성을 사용한 요소의 display가 자동으로 변경됨position 속성의 값으로 absolute, fixed가 지정된 요소는, display 속성이 block으로 변경됨"
340,"2022-04-13box sizing요소의 크기 계산 기준을 지정기본값 content-box 요소의 내용(content)으로 크기 계산border-box 요소의 내용 + padding + border로 크기 계산overflow요소의 크기 이상으로 내용이 넘쳤을 때, 보여짐을 제어하는 단축 속성기본값 visible 넘친 내용을 그대로 보여줌hidden 넘친 내용을 잘라냄scroll 넘친 내용 잘라냄, 스크롤바 생성auto 넘친 내용이 있는 경우에만 잘라내고 스크롤바 생성display요소의 화면 출력(보여짐) 특성각 요소에 이미 지정되어 있는 값 block inline inline-blockflex 플렉스 박스 (1차원 레이아웃)grid 그리드 (2차원 레이아웃)none 보여짐 특성 없음, 화면에서 사라짐opacity요소 투명도기본값 1 불투명0~1 0부터 1 사이의 소수점 숫자font-weight글자의 두께(가중치)기본값 normal, 400 기본 두께bold, 700 두껍게100 ~ 900 100단위의 숫자 9개, normal과 bold 이외 두께font-size글자의 크기기본값 16px 기본 크기단위 px, em, remline-height한 줄의 높이, 행간과 유사숫자 요소의 글꼴 크기의 배수로 지정단위 px, em, rembackground-image요소의 배경 이미지 삽입기본값 none 이미지 없음url(&quot;경로&quot;) 이미지 경로background-position요소의 배경 이미지 위치방향 top, bottom, left, right, center 방향단위 px, em, rembackground-size요소의 배경 이미지 크기기본값 auto 이미지의 실제 크기단위 px, em, remcover 비율을 유지, 요소의 더 넓은 너비에 맞춤contain 비율을 유지, 요소의 더 짧은 너비에 맞춤background-attatchment요소의 배경 이미지 스크롤 특성기본값 scroll 이미지가 요소를 따라서 같이 스크롤fixed 이미지가 뷰포트에 고정, 스크롤 X"
341,"2022-04-12border: 선-두께 border-width 선-종류 border-style 선-색상 border-color요소의 테두리 선을 지정하는 단축 속성, 선의 크기에 따라 요소의 크기도 커짐border-width요소 테두리 선의 두께medium 중간 두께thin 얇은 두께thick 두꺼운 두께단위 px, em, %border-style요소 테두리 선의 종류기본값 none 선 없음solid 실선dashed 파선border-color요소 테두리 선의 색상기본값 black 선 없음색상 선의 색상transparent 투명border-radius요소의 모서리를 둥글게 깎음기본값 0 둥글게 없음단위 px, em, vw"
342,"2022-04-11width, height요소의 가로/세로 너비기본값 auto 브라우저가 너비를 계산단위 px, em, vwmax-width, max-height요소가 커질 수 있는 최대 가로/세로 너비기본값  none 최대 너비 제한 없음단위 px, em, vwmax-width, max-height요소가 작아질 수 수 있는 최소 가로/세로 너비기본값  0 최소 너비 제한 없음단위 px, em, vwCSS 단위px 픽셀% 상대적 백분율em 요소의 글꼴 크기rem 루트 요소(html)의 글꼴 크기vw 뷰포트 가로 너비의 백분율vh 뷰포트 세로 너비의 백분율단축 속성margin요소의 외부 여백(공간)을 지정하는 단축 속성, 값으로 음수 사용이 가능하다.기본값 0 외부 여백 없음auto 브라우저가 여백을 계산, 가로(세로) 너비가 있는 요소의 가운데 정렬에 활용함단위 px, em, vwmargin의 단축 속성margin: top, right, bottom, leftmargin: top, bottom left, rightmargin: top left, right bottommargin: top right bottom leftpadding요소의 내부 여백(공간)을 지정하는 단축 속성, 내부 여백이 커질 수록 요소의 크기도 커짐기본값 0 외부 여백 없음단위 px, em, vw% 부모 요소의 가로 너비에 대한 비율로 지정margin의 단축 속성padding: top, right, bottom, leftpadding: top, bottom left, rightpadding: top left, right bottompadding: top right bottom left"
343,"2022-04-08CSS 기본 문법선택자 {속성: 값}선택자스타일(CSS)을 적용할 대상(selector)속성color 같은 스타일의 종류를 입력값blue 같은 스타일의 값을 입력선택자 {속성: 값; 속성: 값;}중괄호를 이용해 스타일 범위의 시작과 끝을 지정한다선택자_기본 *  전체 선택자모든 요소를 선택ABC 태그 선택자태그 이름이 ABC인 요소 선택.ABC 클래스 선택자HTML class 속성의 값이 ABC인 요소 선택#ABC 아이디 선택자HTML id 속성의 값이 ABC인 요소 선택선택자_복합ABCXYZ 일치 선택자선택자 ABC와 XYZ를 동시에 만족하는 요소 선택ABC &gt; XYZ 자식 선택자선택자 ABC의 자식 요소 XYZ 선택ABC XYZ 하위(후손) 선택자선택자 ABC의 하위 요소 XYZ 선택, '띄어쓰기'가 선택자의 기호ABC + XYZ 인접 형제 선택자선택자 ABC의 다음 형제 요소 XYZ 하나를 선택ABC ~ XYZ 일반 형제 선택자선택자 ABC의 다음 형제 요소 XYZ 모두를 선택선택자_가상 클래스ABC:hover 가상 클래스 선택자 HOVER선택자 ABC 요소에 마우스 커서가 올라가 있는 동안 선택ABC:active 가상 클래스 선택자 ACTIVE선택자 ABC 요소에 마우스를 클릭하고 있는 동안 선택ABC:focus 가상 클래스 선택자 FOCUS선택자 ABC 요소가 포커스가 되면 선택ABC:first-child 가상 클래스 선택자 FIRST CHILD선택자 ABC 형제 요소 중 첫째라면 선택ABC:last-child 가상 클래스 선택자 LAST CHILD선택자 ABC 형제 요소 중 막내라면 선택ABC:nth-child(n) 가상 클래스 선택자 NTH CHILD선택자 ABC 형제 요소 중 (n)째라면 선택ABC:not(XYZ) 부정 선택자 NOT선택자 XYZ가 아닌 ABC 요소 선택선택자_가상 요소ABC::before 가상요소 선택자 BEFORE선택자 ABC 요소의 내부 앞에 내용을 삽입ABC::after 가상요소 선택자 AFTER선택자 ABC 요소의 내부 뒤에 내용을 삽입선택자_속성 선택자ABC 속성 선택자선택자 ABC을 포함한 요소 선택"
344,"2022-04-06블록(상자) 요소가로 세로 값 지정 가능, 여백 사용 가능div 특별한 의미가 없는 구분을 위한 요소h1~6 제목을 의미하는 요소, 숫자가 작을수록 더 중요한 제목을 정의p 문장을 의미하는 요소ul(Unordered List) 순서가 필요없는 목록의 집합을 의미li 목록 내 각 항목인라인(글자) 요소왼쪽에서 오른쪽으로 수평으로 쌓임img 이미지를 삽입하는 요소, src=&quot;삽입할 이미지의 경로&quot; alt=&quot;삽입할 이미지의 이름&quot;a 다른/같은 페이지로 이동하는 하이퍼링크를 지정하는 요소 href=&quot;링크 URL&quot; target=&quot;링크 URL의 표시(브라우저 탭) 위치&quot;span 특별한 의미가 없는 구분을 위한 요소br 줄바꿈 요소인라인 블록 요소가로 세로 값 지정 가능, 여백 사용 가능, 왼쪽에서 오른쪽으로 수평으로 쌓임input 사용자가 데이터를 입력하는 요소input type=&quot;text&quot;일 때, value=&quot;미리 입력된 값&quot; placeholder=&quot;사용자가 입력할 값의 힌트&quot;input type=&quot;checkbox&quot;일 때, 뒤따르는 텍스트를 클릭해도 input 기능을 쓸 수 있게끔 하기 위해 label이라는 인라인 요소로 감싸준다input type=&quot;radio&quot;일 때, checkbox와는 다르게 사용자에게 체크 여부를 그룹에서 1개만 입력 받을 수 있음, name이라는 속성으로 그룹을 생성해 묶을 수 있다.테이블 요소표 요소, 행(Row)과 열(Column)의 집합tr 행을 지정하는 요소, 열을 감싼다td 열을 지정하는 요소"
345,"2022-04-05파일만 생성하면 프로젝트가 시작되지 않음 폴더를 만든 후, 폴더 선택확장 프로그램(Extension) 설치Auto Rename TagBeautifyVSCode 공식 한글 패치Live Sever기본 폼! + Tab Key&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div&gt;    &lt;h1&gt;123&lt;/h1&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;img + Tab key&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;빈 태그&lt;img&gt; = &lt;img&gt;&lt;img/&gt;HTML5에서는 혼용 가능표준 문법적으로는 문제가 없지만 하나의 방식으로 통일해서 쓰자!의미적 요소&lt;header&gt;&lt;/header&gt;&lt;section&gt;&lt;/section&gt;&lt;div&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;기능적 요소&lt;img src=&quot;&quot; alt&quot;&quot;&gt;div의 기본 값: 블록 요소(상자), 레이아웃 구조를 만든다span의 기본 값: 인라인 요소(글자)&lt;img src=&quot;&quot; alt&quot;&quot;&gt;전역 속성titie, class, id, tabindex, data 등class&lt;div class=&quot;이름&quot;&gt;&lt;/div&gt;-&gt;css파일에서 *.이름 *형태로 불러올 수 있음id&lt;div id=&quot;이름&quot;&gt;&lt;/div&gt;-&gt;css파일에서 #이름 형태로 불러올 수 있음title&lt;div title=&quot;이름&quot;&gt;a&lt;/div&gt;-&gt;css파일에서 title=&quot;hello&quot; &lt;- 선택자를 입력하는 요소{  color: red; &lt;- 스타일 입력 요소 (전역 속성)}형태로 불러올 수 있음title 속성: 요소의 설명, a에 마우스를 갖다대면 &quot;이름&quot;이 뜨게 됨html파일과 css파일 연결 방식(선언 방식)링크 방식html 파일 - head 태그 안에link + tab key&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;이 나오고href=&quot;&quot;안에 ./main.css (상대경로) /main.css (절대경로) 같은 병렬로 링크를 가져옴빠르지만 언제 뭘 먼저 가져올 줄 모른다는 특징이 존재임베디드 방식html 파일 - head 태그 안에&lt;style&gt;     title=&quot;hello&quot; {      color: blue;    }유지보수에 악영향을 끼칠 수 있다인라인 방식body 안에&lt;div title=&quot;hello&quot; style=&quot;color: red;&quot;&gt;1234&lt;/div&gt;장점: 불러올 필요가 없다단점: 선택자 우선순위 때문에 임베디드 방식과 마찬가지로 유지보수에 악영향을 끼칠 수 있다임포트 방식css파일에서@import url(&quot;경로&quot;);CSS의 @import 규칙으로 CSS 문서 안에서 또 다른 CSS 문서를 가져와 연결하는 방식때문에 직렬 방식이다링크 방식으로 가져왔을 때, 후에 임포트 방식이 안에 있다는 걸 알아서 상대적으로 느리다혼자 코드를 작성할 때는 쓰지 않는다css 파일이 순서대로 필요한 특수한 상황에 이 직렬 방식을 쓴다에밋 문법태그 이름이 div인 경우 .heropy(class 이름) 입력, div가 아닌 경우 태그 이름.heropy 입력  &lt;div class=&quot;heropy&quot;&gt;&lt;/div&gt;자동 입력됨  ul&gt;li*7{$}-&gt; 아래로 변환  &lt;ul&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;    &lt;li&gt;5&lt;/li&gt;    &lt;li&gt;6&lt;/li&gt;    &lt;li&gt;7&lt;/li&gt;  &lt;/ul&gt;7{$} -&gt; 에밋 문법ul &gt; li:nth-child(5) {  background-color: red;}nth-child(숫자)로 특정 순서 선택 가능div &gt; div:nth-child(3) -&gt; 세 번째 자식 요소 + div tag가 붙어있는가 + div의 자손인가div &gt; div 자손 선택자div div 후손 선택자ex) div div:nth-child(2) -&gt; 두 번째 자식 요소 + div tag가 붙어있는가 + div의 후손인가div:nth-child() = 콜론이 하나가 붙어있으면 가상 클래스 선택자div::after = 콜론이 두 개가 붙어있으면 가상 요소상속의 개념&lt;div style=&quot;color: red;&quot;&gt;1  &lt;div&gt;2    &lt;div&gt;3      &lt;div&gt;4&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;글자(문자) CSS 속성의 값 자동 상속되어 2,3,4의 색도 빨강이 된다."
346,"2022-04-04HTML (Hyper Text Markup Language)페이지의 제목 문단 표 이미지 동영상 등 웹의 구조를 담당CSS (Cascading Style Sheets)실제 화면에 표시되는 방법(색상, 크기, 폰트, 레이아웃 등)을 지정해 콘텐츠를 꾸며주는 시각적인 표현(정적)을 담당JS (JavaScript)콘텐츠를 바꾸고 움직이는 등 페이지를 동작시키는 동적 처리를 담당특수 문자 용어~ Tilde` Backtick, Grave! Exclamation mark@ At sign# Sharp, Number sign$ Dollar sign% Percent sign^ Caret ~의 이상&amp; Ampersand* Asterisk- Hyphen, Dash_ Underscore, Low Dash= Equals sign&quot; Quotation mark' Apostrophe: Colon; SemiColon' Comma. Period, Dot? Question mark/ Slash| Vertical bar\ Backslash() Parenthesis{} Brace Bracket&lt;&gt; Angle Bracket"
347,"*2022-03-30*dev에서 새로 만든 레포지토리인 git-flow-practice를 clone 해온다.git clone https://github.com/moonofchess/git-flow-practice.git해당 디렉토리로 이동.cd git-flow-practice현재 main에 위치한 걸 확인할 수 있다.$ git branch* mainGit flow는 프로젝트 설정을 하기 위한 초기화가 필요하다.git flow init이후 몇몇 질문에 대답해 명명규칙을 정한다. 이때 기본값을 사용하길 권장한다.이제 배포(release)를 위한 기능(feature) 개발을 시작해준다.일반적으로 새 기능 개발은 develop에서 시작한다.$ git branch* develop  mainfizzbuzz라는 새 기능의 개발을 시작해준다git flow feature start fizzbuzzdevelop에 기반한 새 기능 branch를 생성 후 그 branch로 전환된다.$ git branch  develop* feature/fizzbuzz  main기능 파일을 생성해준다. 이때 기능 파일은 branch 이름과 같지 않아도 상관 없다. 편의를 위해 fizzbuzz라고 명명.touch fizzbuzz.pyvim으로 기능을 위한 코드 작성vi fizzbuzz.py대충 작성 후, status 확인git statusadd와 commit을 해준다. 이때 commit은 -m 사용을 자제한다.git add fizzbuzz.pygit commitcommit에는 feat: Create fizzbuzz.py라고 쓰고 이후 기능이 수정될 때마다 해당 수정 코드를 설명해주는 문장을 적어준다.기능 개발이 끝났다면 기능 branch(fizzbuzz)를 develop에 병합, 기능 branch를 삭제, develop branch로 전환해준다.코드는 다음과 같다.git flow feature finish fizzbuzz위 코드를 치면 merge commit 창이 뜨게 되는데 그냥 생략해준다.이제 릴리즈를 시작하려면 아래 코드를 입력한다. $ git flow release start v0.0.1그렇게 되면 develop branch에서 release branch로 뻗어나가게 된다.release branch는 사용자에게 배포할 준비를 하기도 하고 큰 단위의 테스트를 하기도 한다.프론트엔드 같은 경우는 사용자에게 source code를 전달할 때 용량을 최대한 줄이는 게 중요하다. 이미지 리사이징, html이나 css 코드 공백 지우기 등.많은 테스트들이 끝나면 release를 바로 닫아준다.git flow release finish v0.0.1finish를 하게 되면 세 개의 창이 뜨게 되는데 첫 번째는 main(위 그림엔 master라고 표기됨)에 들어가는 merge commit이다.두 번째는 이 merge commit에 대한 라벨링이 하나 붙게 된다. 해당 버전에서 어떤 일이 일어나는지 설명하는 release note를 쓸 수 있다.세 번째는 똑같은 버전의 코드를 develop에 한 번 넣는 마지막 merge commit이다.release를 끝내게 되면 branch 상황에 develop, main만 남게 된다.$ git branch* develop  main아직 push를 해주지 않았기 때문에 다른 사람들은 어떤 일이 일어났는지 알 수 없다.그렇기에 release가 끝나게 되면, develop과 main 각각 push를 해줘야 한다.그러나 조심해야 할 건, 처음에 해당 레포지토리의 remote branch가 main뿐이라면 local에서 처음 생긴 develop이라는 branch를 전달해줘야 한다.그때 그냥 push를 하는 게 아니고 upstream set을 해서 push 해줘야 한다.local의 develop에서 remote의 develop으로 push를 할 때, remote의 develop은 처음 만들기 때문에 upstream set을 한다. 서로가 같은 develop이라는 걸 알려주는 것이다.git push -u origin develop그리고 main으로 이동해 main에도 push를 해준다.git switch maingit push origin main그렇게 하면 remote branch 상에서 main과 develop 모두 fizzbuzz.py가 생긴 걸 확인할 수 있다.+++tag를 조회한 후 push 해주면 release note가 작성된 라벨링을 확인할 수 있다.git taggit push --tags"
348,2022.03.29git 복습practice (1)    cli-practice/ 디렉토리를 생성하세요.     생성된 디렉토리에 README.txt 파일을 생성하세요.    bin/ 디렉토리를 생성하여 README.txt 를 복사하여 introduce.md 로 이름을 바꾸세요mkdir cli-practice/touch README.txtmkdir bin/mv README.txt bin/cp README.txt bin/mv README.txt indroduce.md( . . . )
349,"설명MVCM: ModelV: ViewC: Controller -&gt; ViewControllerVC에 비즈니스 로직 포함데이터 가져오기, 데이터 추가 등MVVMM: Model -&gt; 데이터V: View -&gt; ViewControllerVM: View Model -&gt; 비즈니스 로직 포함View Controller의 역할을 덜어줌구현VM에서 데이터 가져오기, 변환, 저장 등VC에서 RxSwift, Combine 등 사용하여 VM을 구독ViewModelclass FoodViewModel: ObservableObject {  var container: NSPersistentContainer!  var selectedDate: String?  @Published var foodData: FoodDTO =   init(){      print(""FoodViewModel - init()"")      fetchFoodData()  }}View(VC)// 뷰모델 관련extension ViewController {  // 뷰모델의 데이터를 뷰컨의 리스트 데이터와 연동  fileprivate func setFoodBindings() {      print(""ViewController - setFoodBinding()"")      self.foodViewModel.$foodData.sink { (updatedData: FoodDTO) in          self.foodData = updatedData          self.imgCollectionView.reloadData()      }.store(in: &amp;disposableBag)  }}"
350,"문제 링크https://programmers.co.kr/learn/courses/30/lessons/92342문제 설명10~0점 존재k점에 쏜 화살이라이언 &gt; 어피치일 경우 라이언이 k점 얻음라이언 &lt;= 어피치일 경우 어피치 k점 얻음어피치가 화살을 쏜 결과가 주어질 때라이언이 가장 큰 점수차로 이기는 경우를 리턴그 점수 차가 여러개인 경우 가장 낮은 점수를 더 많이 쏜 경우를 리턴가장 낮은 점수가 같을 경우 그 다음 낮은 점수를 더 많이 쏜 경우를 리턴풀이재귀 구현마지막 점수일 경우(0점) 다 쏨현재 점수에서이길 수 있을 경우이기거나 -&gt; 어피치보다 1개 더 많이 쏨지거나 -&gt; 안 쏨이길 수 없을 경우 -&gt; 안 쏨모두 검사했을 경우( i == 11 일 때 종료 조건)이겼을 경우 갱신, 경우의 수 모두 저장재귀 호출 이후갱신 한 번도 안됐으면 -1 리턴갱신 됐으면 저장한 모든 경우의 수를 검사가장 낮은 점수 더 많이 쏜 경우 리턴같으면 그 다음 경우 리턴후기굉장히 애먹었다일단 재귀 구현도 애먹었다점수 차이를 계산해야하는데 라이언의 고득점으로 생각 ㅜ점수 차이가 같을 경우에도 계속 갱신해주면, 자동으로 낮은 점수를 많이 쏜 경우가 결과로 나올거라고 생각했는데, 모든 결과를 직접 비교해야했다.코드import copyinfo = currArrow = 0 * 11maxArrow = -1maxDiff = float(""-inf"")def solution(n, infoo):    global info    info = infooupdateArrow(0, n)if maxDiff == float('-inf'):    return -1maxrow = maxArrow0for i in range(1, len(maxArrow)):    currrow = maxArrowi    for j in range(10,-1,-1):        if maxrowj == currrowj:            pass        if maxrowj &lt; currrowj:            maxrow = currrow            break        if maxrowj &gt; currrowj:            break             return maxrowdef updateArrow(i, remains):    global maxArrow, maxDiffif i == 11:    diff = getDiff()    if diff &lt;= 0:        return    if maxDiff &lt; diff:        maxDiff = diff        maxArrow = copy.deepcopy(currArrow)    elif maxDiff == diff:        maxArrow.append(copy.deepcopy(currArrow))    returnif i == 10: # 0점    currArrow10 = remains    updateArrow(11, 0)    currArrow10 = 0elif remains &gt; infoi:    # 가능할때    currArrowi = infoi + 1    updateArrow(i+1, remains - (infoi+1)) # 쏘거나    currArrowi = 0    updateArrow(i+1, remains) # 안쏘거나else:   # 불가능할때    updateArrow(i+1, remains) # 안쏘거나def getDiff():    score1 = 0    score2 = 0    for i in range(11):        if infoi == 0 and currArrowi == 0:            continue        # 어피치 &lt; 라이언        if infoi &lt; currArrowi:             score2 += (10-i)        # 어피치 &gt;= 라이언        else:            score1 += (10-i)    diff = score2 - score1    return diff```"
351,"문제 링크https://programmers.co.kr/learn/courses/30/lessons/12978문제 설명에지 리스트 주어짐1번 노드에서 최단 거리가 K 이하인 노드 개수 구하기풀이다익스트라처리안된 노드들 중 가장 가까운 노드 heap에서 pop인접 노드들 거리 갱신 후 push반복후기다익스트라는 봐도봐도 까먹는다코드import heapqdef solution(N, road, K):    answer = 0# 인접리스트 생성edges =  for _ in range(N+1)for s,e,d in road:    edgess.append(e,d)    edgese.append(s,d)# 최단거리 저장할 리스트dist = float(""inf"") * (N+1)dist1 = 0 # 처리여부checked = 0 * (N+1)# 현재까지 최단 거리 노드를 위한 힙 q = 0, 1# 다익스트라while q:    cd, s = heapq.heappop(q)                # 방문하지 않은 최단 노드 꺼내기     if checkeds:                          # 방문했으면 continue        continue    checkeds = 1                          # 방문 체크    for e, nd in edgess:                  # 인접 노드 갱신        diste = min(diste, cd + nd)        heapq.heappush(q, diste, e)     # 일단 넣음. 최단이면 나오겠지~ 아니면 말고# 개수 세기for d in dist:    if d &lt;= K:        answer += 1return answer```"
352,"문제 링크https://programmers.co.kr/learn/courses/30/lessons/86052문제 설명특정 방향으로 빛을 쐈을 때S이면 직진, L이면 좌회전, R이면 우회전넘어가면 반대쪽에서 돌아옴가능한 사이클의 길이를 오름차순으로 리스트에 담아 리턴풀이각 좌표마다 4방향 경로 저장모든 경로 탐색방문한적 없으면 재귀 돌면서 방문 체크재귀좌표, 방향, 깊이를 매개변수로 넘김사이클이면 종료아니면 문자에 따라 방향바꿔 재귀방문한적 있으면 continue후기그림이 복잡해서 경로를 어떻게 저장해야할지 잘 안 떠올랐다구현은 생각보다 쉬웠다코드import syssys.setrecursionlimit(1000000)dy = -1, 0, 1, 0dx = 0, 1, 0, -1w, h = 0, 0used = grid = answer = def solution(gridd):    global w, h, used, grid, answergrid = griddanswer = h = len(grid)w = len(grid0)used = 0*4 for _ in range(w) for _ in range(h)for i in range(h):    for j in range(w):        # 위 오 아래 왼        for k in range(4):            if usedijk:                continue            # 돌아~            go(i, j, k, 0)answer.sort()return answerdef go(cy, cx, d, count):    global used, answerif usedcycxd:    answer.append(count)    returnusedcycxd = 1ny = (cy + dyd) % hnx = (cx + dxd) % w# 어디로 쏠지if gridnynx == ""S"":    go(ny, nx, d, count+1)if gridnynx == ""L"":    go(ny, nx, (d-1) % 4, count+1)if gridnynx == ""R"":    go(ny, nx, (d+1) % 4, count+1)```"
353,"문제 링크https://programmers.co.kr/learn/courses/30/lessons/12913문제 설명N * 4 배열이 주어짐한 행씩 내려옴4칸 중 한 칸만 밟을 수 있음이전 열이랑 같은 열 못 밟음밟은 칸 합의 최댓값풀이이전 행에서 가능한 열들 중 최댓값 + 현재 행, 열의 값코드def solution(land):  dp = 0*4 for _ in range(len(land))  dp0 = land0  for i in range(1, len(land)):       # 10만      for j in range(4):              # 4          maxValue = float(""-inf"")          for k in range(4):          # 4              if j == k:                  continue              maxValue = max(maxValue, dpi-1k)          dpij = maxValue + landij  return max(dp-1)"
354,"문제 링크https://programmers.co.kr/learn/courses/30/lessons/92335#qna문제 설명진수 변환 후 문자열 내에서 소수 개수 판별하기풀이진수 변환스플릿소수 판별시간 초과 때문에 제곱근까지만 판별해야됨후기이것도 애먹었다...코드def solution(n, k):  answer = 0  p = n2p(n, k)  splited = p.split(""0"")    # 스플릿  for numString in splited:        if not numString:          continue      num = int(numString)      if isPrime(num):          answer += 1  return answerdef n2p(n, k):    listt = while n != 0:    q = n // k    r = n % k    listt.append(r)    n = qlistt.reverse()return """".join(map(str, listt))def isPrime(n):    if n == 1:        return False    for i in range(2, int(n ** (1/2)) + 1):        if n % i == 0:            return False    return True```"
355,"문제링크https://programmers.co.kr/learn/courses/30/lessons/92341문제설명주차장에 들어온 차, 나간 차 목록이 주어짐요금표(기본요금, 추가요금)가 주어짐차 별로 주차장 이용시간 계산안 나갔으면 23:59에 나간걸로 계산풀이들어온 시간 저장나간 경우 시간 계산 후 따로 누적 저장안 나간 차들 따로 시간 계산후 저장정렬 후 요금 계산코드import mathdef solution(fees, records):    answer = timeDict = dict()inDict = dict()for line in records:    ts, cn, io = line.split()    t = ston(ts)    # 들어감    if io == ""IN"":        inDictcn = t  # 들어간 시간    # 나옴    elif io == ""OUT"":        if cn not in timeDict:            timeDictcn = 0        timeDictcn += t - inDict.pop(cn)  # 시간 계산# 안나온거for cn in inDict:    if cn not in timeDict:        timeDictcn = 0    timeDictcn += ston(""23:59"") - inDictcn# 요금계산cns = list(timeDict.keys())cns.sort()for cn in cns:    tt = timeDictcn    ff = 0    if tt &lt;= fees0:   # 기본요금        ff = fees1        answer.append(ff)    else:   # 추가요금        ff = fees1    # 기본        tt -= fees0   # 추가시간        mm = math.ceil(tt / fees2)    # 추가요금몫        ff += mm * fees3        answer.append(ff)return answerdef ston(string):    hs, ms = string.split("":"")    h = int(hs)    m = int(ms)    return m + h * 60```"
356,"문제링크https://programmers.co.kr/learn/courses/30/lessons/76502#문제설명{}()로 이루어진 문자열 주어짐x번 회전했을때 올바른 괄호가 되는 x의 개수0 &lt;= x &lt; 문자열 길이풀이s 최대 길이가 1000이라 완전 탐색했다1번씩 돌려가면서 올바른 괄호인지 검사열리면 append, 닫히면 poppop 했을 때 짝 맞으면 OK짝 맞지 않으면 False마지막에 stack이 비어있는지 검사해야함(s의 길이가 1일때 오답)코드from collections import dequedef solution(s):    answer = 0s = deque(s)for _ in range(len(s)):    if right(deque(s)):        answer += 1    s.rotate()return answerdef right(s):stack = openSet = set(""{"", ""("", """")closeSet = set(""}"", "")"", """")while s:    curr = s.popleft()    if curr in openSet:        stack.append(curr)    else:        if not stack:            return False        prev = stack.pop()        if prev == ""{"":            if curr == ""}"":                pass            else:                return False        elif prev == ""("":            if curr == "")"":                pass            else:                return False        elif prev == """":            if curr == """":                pass            else:                return False        else:            return Falseif stack:    return Falsereturn True~"
357,"문제 링크https://programmers.co.kr/learn/courses/30/lessons/81302#fn1문제 설명5*5 크기 보드P(사람), O(빈칸), X(벽)사람끼리 거리 2칸 이내여야함풀이BFS 진행하면서 visited에 거리를 저장현재 좌표의 거리가 2보다 작을때 다음 좌표를 검사다음 좌표의 거리를 증가시킬 때 현재 좌표의 거리보다 1 증가후기오랜만에 풀어서 구현하는데 애먹었다거리를 잘못 저장해서 모두 1로 저장되도록 구현했다코드def solution(places):  answer =   for p in places:      if close(p):          answer.append(0)      else:          answer.append(1)  return answerdef close(p):    for y in range(5):        for x in range(5):            if pyx == ""P"":                if bfs(y, x, p):                    return True    return Falsefrom collections import dequedef bfs(y, x, board):dy = 0,0,-1,1dx = 1,-1,0,0visited = 0*5 for _ in range(5)visitedyx = 1q = deque()q.append(y,x)while q:    cy, cx = q.popleft()    for d in range(4):        ny, nx = cy+dyd, cx+dxd        if 0&lt;=ny&lt;5 and 0&lt;=nx&lt;5:            if not visitednynx:                if visitedcycx &lt;= 2:                    if boardnynx == ""P"":                        return True                    if boardnynx == ""O"":                        visitednynx = visitedcycx + 1                        q.append(ny,nx)                    if boardnynx == ""X"":                        pass                else:                    passreturn False```"
358,"링크https://www.acmicpc.net/problem/13459코드import sysfrom itertools import productdy, dx = -1, 1, 0, 0, 0, 0, -1, 1board = def solution():    global board    read = sys.stdin.readline    h, w = map(int, read().split())    origin_board = list(read().rstrip()) for _ in range(h)    for y in range(h):        for x in range(w):            if origin_boardyx == 'B':                sby, sbx = y, x            elif origin_boardyx == 'R':                sry, srx = y, x            elif origin_boardyx == 'O':                oy, ox = y, x    possible = False    for prod in product(2,3,0,1, repeat=10):        board = origin_boardi: for i in range(h)        by, bx, ry, rx = sby, sbx, sry, srx        for d in prod:            by, bx, ry, rx = move(by, bx, ry, rx, d)            if by == oy and bx == ox:                break            elif ry == oy and rx == ox:                possible = True                break        if possible:            break    if possible:        print(1)    else:        print(0)def move(by, bx, ry, rx, d):    # 상    if d == 0:        if bx == rx:            # b먼저            if by &lt; ry:                by, bx = move_blue(by, bx, d)                ry, rx = move_red(ry, rx, d)            else:                ry, rx = move_red(ry, rx, d)                by, bx = move_blue(by, bx, d)        else:            ry, rx = move_red(ry, rx, d)            by, bx = move_blue(by, bx, d)    # 하    elif d == 1:        if bx == rx:            # r먼저            if by &lt; ry:                ry, rx = move_red(ry, rx, d)                by, bx = move_blue(by, bx, d)            else:                by, bx = move_blue(by, bx, d)                ry, rx = move_red(ry, rx, d)        else:            by, bx = move_blue(by, bx, d)            ry, rx = move_red(ry, rx, d)    # 좌    elif d == 2:        if by == ry:            # b먼저            if bx &lt; rx:                by, bx = move_blue(by, bx, d)                ry, rx = move_red(ry, rx, d)            else:                ry, rx = move_red(ry, rx, d)                by, bx = move_blue(by, bx, d)        else:            ry, rx = move_red(ry, rx, d)            by, bx = move_blue(by, bx, d)    # 우    elif d == 3:        if by == ry:            # r먼저            if bx &lt; rx:                ry, rx = move_red(ry, rx, d)                by, bx = move_blue(by, bx, d)            else:                by, bx = move_blue(by, bx, d)                ry, rx = move_red(ry, rx, d)        else:            by, bx = move_blue(by, bx, d)            ry, rx = move_red(ry, rx, d)    return by, bx, ry, rx'''. B R O #'''def move_blue(sy, sx, d):    global board    cy, cx = sy, sx    while True:        ny, nx = cy + dyd, cx + dxd        if boardnynx == '#' or boardnynx == 'R' or boardnynx == 'B':            boardsysx = '.'            boardcycx = 'B'            return cy, cx        if boardnynx == 'O':            boardsysx = '.'            return ny, nx        cy, cx = ny, nxdef move_red(sy, sx, d):    global board    cy, cx = sy, sx    while True:        ny, nx = cy + dyd, cx + dxd        if boardnynx == '#' or boardnynx == 'R' or boardnynx == 'B':            boardsysx = '.'            boardcycx = 'R'            return cy, cx        if boardnynx == 'O':            boardsysx = '.'            return ny, nx        cy, cx = ny, nxsolution()"
359,"링크https://www.acmicpc.net/problem/17425첫 시도시간 초과import sysdef solution():    # 입출력    read = sys.stdin.readline    write = sys.stdout.write    testcase = int(read())    for _ in range(testcase):        # g(n) 출력        n = int(read())        write(f'{get_g(n)}\n')def get_g(n):    g = 0    for i in range(1, n+1):        # n 이하의 자연수 중 i로 나누어 떨어지는 수의 갯수        temp = n // i        g += temp * i    return gsolution()두번째 시도import sysdef solution():    # 입출력    read = sys.stdin.readline    write = sys.stdout.write    # 입력 받기    testcase = int(read())    numbers = int(read()) for _ in range(testcase)    max_n = max(numbers)    f = 0 * (max_n + 1)   # 약수의 합 리스트    dp = 0 * (max_n + 1)    # 더해줄 수    for i in range(1, max_n+1):        # 곱해줄 수        j = 1        while True:            # i * j : 약수로 i를 갖는 수            fi * j += i            j += 1            if i * j &gt;= len(f):                break    # dp 구하기    for i in range(1, max_n+1):        dpi = dpi-1 + fi    # 출력    for n in numbers:        write(f'{dpn}\n')solution()"
360,"문제링크https://www.acmicpc.net/problem/11505코드import sys, mathtree = a = def solution():    global a, tree    read = sys.stdin.readline    write = sys.stdout.write    n, m, k = map(int, read().split())    a = int(read()) for _ in range(n)    commands = list(map(int, read().split())) for _ in range(m+k)    h = math.ceil(math.log(n, 2))    tree_size = 2 ** (h+1)    tree = 0 * tree_size    init(0, n-1, 1)    for aa, b, c in commands:        if aa == 1:            diff = c            origin = ab-1            ab-1 = c            update(b-1, 0, n-1, 1, diff, origin)        elif aa == 2:            write(f'{get_multi(b-1, c-1, 0, n-1, 1)}\n')def init(start, end, node):    # 리프노드일때    if start == end:        treenode = astart        return treenode    # 아닐때    treenode = (init(start, (start+end)//2, node*2) * init((start+end)//2+1, end, node*2+1)) % 1000000007    return treenodedef get_multi(left, right, start, end, node):    # 포함하지 않을 때    if left &gt; end or right &lt; start:        return 1    # 포함할 때    if left &lt;= start and end &lt;= right:        return treenode % 1000000007    return (get_multi(left, right, start, (start+end)//2, node*2) * get_multi(left, right, (start+end)//2+1, end, node*2+1)) % 1000000007def update(index, start, end, node, diff, origin):    global tree    # 포함하지 않을 때    if index &lt; start or index &gt; end:        return treenode    # 리프노드일때    if start == end:        treenode = diff        return treenode    # 아닐때    treenode = (update(index, start, (start+end)//2, node*2, diff, origin) * update(index, (start+end)//2+1, end, node*2+1, diff, origin)) % 1000000007    return treenodesolution()"
361,"문제링크https://www.acmicpc.net/problem/1275코드import sys, mathtree = a = def solution():    global a, tree    read = sys.stdin.readline    write = sys.stdout.write    n, q = map(int, read().split())    a = list(map(int, read().split()))    commands = list(map(int, read().split())) for _ in range(q)    h = math.ceil(math.log(n, 2))    tree_size = 2 ** (h+1)    tree = 0 * tree_size    init(0, n-1, 1)    for x, y, aa, b in commands:        if x &gt; y:            y, x = x, y        write(f'{get_sum(x-1, y-1, 0, n-1, 1)}\n')        diff = b - aaa-1        origin = aaa-1        aaa-1 = b        update(aa-1, 0, n-1, 1, diff, origin)def init(start, end, node):    # 리프노드일때    if start == end:        treenode = astart        return treenode    # 아닐때    treenode = init(start, (start+end)//2, node*2) + init((start+end)//2+1, end, node*2+1)    return treenodedef get_sum(left, right, start, end, node):    # 포함하지 않을 때    if left &gt; end or right &lt; start:        return 0    # 포함할 때    if left &lt;= start and end &lt;= right:        return treenode    return get_sum(left, right, start, (start+end)//2, node*2) + get_sum(left, right, (start+end)//2+1, end, node*2+1)def update(index, start, end, node, diff, origin):    # 포함하지 않을 때    if index &lt; start or index &gt; end:        return    treenode += diff    # 리프가 아닐 때    if start != end:        update(index, start, (start+end)//2, node*2, diff, origin)        update(index, (start+end)//2+1, end, node*2+1, diff, origin)solution()"
362,"문제링크https://www.acmicpc.net/problem/10868코드import sys, mathtree = a = def solution():    global a, tree    read = sys.stdin.readline    write = sys.stdout.write    n, m = map(int, read().split())    a = int(read()) for _ in range(n)    commands = list(map(int, read().split())) for _ in range(m)    h = math.ceil(math.log(n, 2))    tree_size = 2 ** (h+1)    tree = 0 * tree_size    init(0, n-1, 1)    for b, c in commands:        write(f'{get_min(b-1, c-1, 0, n-1, 1)}\n')def init(start, end, node):    # 리프노드일때    if start == end:        treenode = astart        return treenode    # 아닐때    treenode = min(init(start, (start+end)//2, node*2), init((start+end)//2+1, end, node*2+1)) #% 1000000007    return treenodedef get_min(left, right, start, end, node):    # 포함하지 않을 때    if left &gt; end or right &lt; start:        return float('inf')    # 포함할 때    if left &lt;= start and end &lt;= right:        return treenode    return min(get_min(left, right, start, (start+end)//2, node*2), get_min(left, right, (start+end)//2+1, end, node*2+1))solution()"
363,"문제링크https://www.acmicpc.net/problem/2671풀이체크해야할 패턴을 함수별로 나눠서 재귀후기겁먹었는데 다행히 풀었다코드def solution():  string = input()  if check_total(string):      print('SUBMARINE')  else:      print('NOISE')def check_total(string):    # 쪼개서 체크    for i in range(1, len(string)):        s1 = string:i        s2 = stringi:        if s1 and (check_left(s1) or check_right(s1)):            if check_total(s2):                return True    # 전체만 체크    if check_left(string) or check_right(string):        return True    return Falsedef check_left(string):# 첫 100 체크if len(string) &lt; 3:    return Falseif string:3 != '100':    return False# 연속 0 체크i = 3while True:    if i == len(string):        return False    if stringi != '0':        break    i += 1# 첫 1 체크if i == len(string):    return Falseif stringi != '1':    return False# 연속 1 체크while True:    if i == len(string):        return True    if stringi != '1':        return False    i += 1def check_right(string):    if string == '01':        return True    return Falsesolution()```"
364,"문제링크https://www.acmicpc.net/problem/20164코드import sysdef solution():    read = sys.stdin.readline    num = read().rstrip()    print(rec(num, 1), rec(num, 0))def rec(num, is_min):    count = get_count(num)    if len(num) == 1:        return count    elif len(num) == 2:        num = int(num0) + int(num1)        return count + rec(str(num), is_min)    else:        result = float('-inf')        if is_min:            result = float('inf')        for s1 in range(1, len(num)-1):            for s2 in range(s1+1, len(num)):                num1 = int(num:s1)                num2 = int(nums1:s2)                num3 = int(nums2:len(num))                if is_min:                    result = min(result, rec(str(num1 + num2 + num3), is_min))                else:                    result = max(result, rec(str(num1 + num2 + num3), is_min))        return count + resultdef get_count(num):    count = 0    for i in range(len(num)):        if int(numi) % 2 == 1:            count += 1    return countsolution()"
365,문제 링크https://www.acmicpc.net/problem/3649풀이투포인터후기테스트케이스 여러개 처리를 안해줘서 좀 헤맸다코드import sysdef solution():    read = sys.stdin.readlinewhile True:    try:        x = int(read()) * 10 ** 7    except:        break    n = int(read())    parts = int(read()) for _ in range(n)    parts.sort()    if n &lt;= 1:        print('danger')        continue    s = 0    e = n-1    while True:        summ = partss + partse        if summ == x:            possible = True            break        elif summ &lt; x:            s += 1        elif summ &gt; x:            e -= 1        if s == e:            possible = False            break    if possible:        print(f'yes {partss} {partse}')    else:        print('danger')solution()```
366,"문제 링크https://www.acmicpc.net/problem/2638문제 설명board 주어짐1초마다 외부 공기와 2칸 이상 인접한 칸 사라짐풀이외부 공기 기준 BFS 반복1초마다 2칸 이상 닿는 좌표 삭제파이썬 코드import sysfrom collections import dequedef solution():    read = sys.stdin.readline    h, w = map(int, read().split())    board = list(map(int, read().split())) for _ in range(h)for answer in range(h*w):    count = 0 * w for _ in range(h)    bfs(h,w,board, count)    finished = True    for y in range(h):        for x in range(w):            if countyx &gt;= 2:                boardyx = 0                finished = False    if finished:        breakprint(answer)def bfs(h, w, board, count):    visited = 0*w for _ in range(h)    dy, dx = 0,0,1,-1,1,-1,0,0    q = deque(0,0)    while q:        cy, cx = q.popleft()        for i in range(4):            ny, nx = cy+dyi, cx+dxi            if 0 &lt;= ny &lt; h and 0 &lt;= nx &lt; w:                if boardnynx == 0:                    if not visitednynx:                        visitednynx = 1                        q.append(ny,nx)                else:                    countnynx += 1solution()```"
367,"문제 링크https://www.acmicpc.net/problem/5052문제 설명주어진 전화번호 목록이 일관성이 있으면 YES없으면 NO 출력풀이문자열 길이로 정렬 후 트라이 구현파이썬 코드import sysclass Node:    def init(self, value=0, end=False):        self.value = value        self.end = end        self.children = def __str__(self):    return f'{self.value} {self.end}'def insert(root, num):    curr = root    i = 0    while i &lt; len(num):        exist = False        for j in range(len(curr.children)):            child = curr.childrenj            if numi == child.value:                exist = True                break        if exist:            if curr.childrenj.end:                return True            curr = curr.childrenj        else:            curr.children.append(Node(numi, i==len(num)-1))            curr = curr.children-1        i += 1    return Falsedef solution():    read = sys.stdin.readline    t = int(read())    for _ in range(t):        n = int(read())        numbers = list(read().rstrip()) for _ in range(n)        numbers.sort(key=lambda x:len(x))    root = Node()    for num in numbers:        exist = insert(root, num)        if exist:            break    if exist:        print('NO')    else:        print('YES')solution()```"
368,"문제 링크https://www.acmicpc.net/problem/2042문제 설명숫자 리스트 주어짐 (100만개)수정, 구간 합 구하기 반복 (2만번)풀이세그먼트 트리init 구현리프가 아닐때 왼쪽 노드 생성리프가 아닐때 오른쪽 노드 생성재귀O(NlogN)update 구현루트 노드부터 리프 노드까지 재귀리프 노드부터 수정유니온 파인드처럼O(logN)sum 구현 구간을 나누어 재귀적으로 returnO(logN)후기처음 공부하는 자료구조여서 이것저것 찾아봤는데이해는 되는데 구현이 너무 어려웠다그래서 그냥 혼자 구현해봤다파이썬 코드import sysclass Node:    def init(self, start, end, value):        self.start = start        self.end = end        self.value = value        self.left = None        self.right = Nonedef solution():# 입력 받기read = sys.stdin.readlinen, m, k = map(int, read().split())numbers = int(read()) for _ in range(n)commands = list(map(int, read().split())) for _ in range(m + k)root = Node(0, n, sum(numbers))if n &gt;= 2:    init_child(root, numbers)for a, b, c in commands:    # b번째 수를 c로 변경    if a == 1:        update(root, b-1, c)    # b부터 c까지 합 구하기    elif a == 2:        print(get_sum(root, b-1, c-1))def init_child(curr, numbers):mid = (curr.start + curr.end) // 2left_sum = sum(numberscurr.start:mid)curr.left = Node(curr.start, mid, left_sum)right_sum = sum(numbersmid:curr.end)curr.right = Node(mid, curr.end, right_sum)if mid - curr.start &gt; 1:    init_child(curr.left, numbers)if curr.end - mid &gt; 1:    init_child(curr.right, numbers)def update(curr, b, c):# 리프 노드일 때if curr.end - curr.start == 1:    diff = c - curr.value    curr.value = c    return diffmid = (curr.start + curr.end) // 2diff = 0# 재귀적으로 자식 노드 수정if b &lt; mid:    diff = update(curr.left, b, c)else:    diff = update(curr.right, b, c)# 자식 노드 수정 후 현재 노드 수정curr.value += diffreturn diffdef get_sum(curr, b, c):# 리프 노드일 때if curr.end - curr.start == 1:    return curr.valuemid = (curr.start + curr.end) // 2# 딱 맞을 때if curr.start == b and curr.end-1 == c:    return curr.value# 왼쪽 + 오른쪽elif curr.start &lt;= b &lt; mid and mid &lt;= c &lt; curr.end:    return get_sum(curr.left, b, mid-1) + get_sum(curr.right, mid, c)# 왼쪽elif curr.start &lt;= c &lt; mid:    return get_sum(curr.left, b, c)# 오른쪽elif mid &lt;= b &lt; curr.end:    return get_sum(curr.right, b, c)solution()```"
369,"스파르팅코딩클럽 '프론트엔드의 꽃, 리액트' 2주차 강의를 듣고 작성한 글입니다.SCSS: CSS를 편하게 쓰도록 도와주는 style.필요한 모듈 설치 :yarn add node-sass@4.14.1 open-color sass-loader classnames문자열 치환 가능, &quot;&amp;&quot;으로 상위 요소에 이어 쓰기 가능$defaultSize: 20px;$className: blue;p{    font-size: #{$defaultSize};    &amp;.#{$className} {color: #{$className}}}div {  background-color: green  &amp;:hover { background-color: blue }}### styled-components: 컴포넌트 스타일링 기법. (class 이름 고민할 필요 X)- 패키지 설치 : yarn add styled-components```javascriptconst MyStyled = styled.div`  width: 50vw;  min-height: 150px;  padding: 10px;  border-radius: 15px;  color: #fff;  &amp;:hover{    background-color: #ddd;  }  background-color: ${(props) =&gt; (props.bgColor를 ? &quot;red&quot; : &quot;purple&quot;)};`;export default App;라이프 사이클: 컴포넌트가 렌더링을 준비하는 순간 ~ 페이지에서 사라질 때까지컴포넌트: 생성 → 수정(업데이트) → 사라짐(제거)라이프 사이클 함수는 클래스형 컴포넌트에서만 사용 가능.constructor() : 생성자 함수. 컴포넌트 생성시 가장 처음으로 호출.render() : 컴포넌트 모양 정의componentDidMount() : 컴포넌트가 화면에 나타나도록 함.componentDidUpdate(prevProps, prevState, snapshot) : 리렌더링을 완료한 후 실행되는 함수componentWillUnmount() : 컴포넌트가 DOM에서 제거 될 때 실행하는 함수Ref리액트에서 돔요소를 가져오려면 React.createRef() 사용.State 관리setState() : 클래스형 컴포넌트의 state를 업데이트할 때 사용하는 함수.Event Listener: componentDidMount()에 넣어주면 됨.Toy Project Nemo ProjectApp.jsimport React from &quot;react&quot;;import Nemo from &quot;./Nemo&quot;;class App extends React.Component {  constructor(props) {    super(props);this.state = {};this.div = React.createRef();  }  hoverEvent = (e) =&gt; {    console.log(e);    console.log(e.target);e.target.style.background = &quot;#eee&quot;;  };  componentDidMount() {    this.div.current.addEventListener(&quot;mouseover&quot;, this.hoverEvent);  }  componentWillUnmount() {    this.div.current.removeEvenListener(&quot;mouseover&quot;, this.hoverEvent);  }  render() {    return (                        );  }}export default App;* Nemo.js```javascriptimport React from &quot;react&quot;;const Nemo = (props) =&gt; {  const count, setCount = React.useState(3);  console.log(count);  const addNemo = () =&gt; {    setCount(count + 1);  };  const removeNemo = () =&gt; {    setCount(count &gt; 0 ? count - 1 : 0);  };  const nemo_count = Array.from({ length: count }, (v, i) =&gt; i);  return (    &lt;div className=&quot;App&quot;&gt;      {nemo_count.map((num, idx) =&gt; {        return (          &lt;div            key={idx}            style={{              width: &quot;150px&quot;,              height: &quot;150px&quot;,              backgroundColor: &quot;#ddd&quot;,              margin: &quot;10px&quot;,            }}          &gt;            nemo          &lt;/div&gt;        );      })}      &lt;div&gt;        &lt;button onClick={addNemo}&gt;하나 추가&lt;/button&gt;        &lt;button onClick={removeNemo}&gt;하나 빼기&lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  );};export default Nemo;결과 화면Toy Project BucketList에 아이템 추가App.jsimport React from &quot;react&quot;;import BucketList from &quot;./BucketList&quot;;import styled from &quot;styled-components&quot;;class App extends React.Component {  constructor(props) {    super(props);    this.state = {      list: &quot;영화관 가기&quot;, &quot;매일 책읽기&quot;, &quot;수영 배우기&quot;,    };this.text = React.createRef();  }  addBucketList = () =&gt; {    let list = this.state.list;    const new_item = this.text.current.value;this.setState({ list: ...list, new_item });  };  componentDidMount() {    console.log(this.text);    console.log(this.text.current);  }  render() {    return (                        내 버킷리스트                                                        추가하기                  );  }}const Input = styled.divmax-width: 350px;  min-height: 10vh;  background-color: #fff;  padding: 16px;  margin: 20px auto;  border-radius: 5px;  border: 1px solid #ddd;;const Container = styled.divmax-width: 350px;  min-height: 80vh;  background-color: #fff;  padding: 16px;  margin: 20px auto;  border-radius: 5px;  border: 1px solid #ddd;;const Title = styled.h1color: slateblue;  text-align: center;;const Line = styled.hrmargin: 16px 0px;  border: 1px dotted #ddd;;export default App;- BucketList.js```javascriptimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;const BucketList = (props) =&gt; {  const my_lists = props.list;  return (    &lt;ListStyle&gt;      {my_lists.map((list, index) =&gt; {        return &lt;ItemStyle key={index}&gt;{list}&lt;/ItemStyle&gt;;      })}    &lt;/ListStyle&gt;  );};const ListStyle = styled.div`  display: flex;  flex-direction: column;  height: 100%;  overflow-x: hidden;  overflow-y: auto;`;const ItemStyle = styled.div`  padding: 16px;  margin: 8px;  background-color: aliceblue;`;export default BucketList;결과 화면HW FriendTest ProjectApp.jsimport React from &quot;react&quot;;import &quot;./App.css&quot;;import Start from &quot;./Start&quot;;import Quiz from &quot;./Quiz&quot;;import Score from &quot;./Score&quot;;class App extends React.Component {  constructor(props) {    super(props);this.state = {  name: &quot;포뇨&quot;,  page: &quot;quiz&quot;,  scoreMsg: &quot;아주 친한 친구 사이:)&quot;,  list:     { question: &quot;포뇨는 5살이다.&quot;, answer: &quot;O&quot; },    { question: &quot;포뇨는 검정색 머리다.&quot;, answer: &quot;X&quot; },    { question: &quot;포뇨는 물을 좋아한다.&quot;, answer: &quot;O&quot; },    { question: &quot;포뇨는 라면을 싫어한다.&quot;, answer: &quot;&quot; },  ,  ranking:     { rank: 1, name: &quot;최수빈&quot;, message: &quot;안녕, 포뇨야!&quot; },    { rank: 2, name: &quot;배인혁&quot;, message: &quot;포뇨 HI~&quot; },    { rank: 3, name: &quot;김원필&quot;, message: &quot;안녕, 포뇨!&quot; },    { rank: 4, name: &quot;송건희&quot;, message: &quot;포뇨포뇨&quot; },  ,};  }  render() {    return (              {this.state.page === &quot;quiz&quot; &amp;&amp; }        {this.state.page === &quot;start&quot; &amp;&amp; }        {this.state.page === &quot;score&quot; &amp;&amp; (                  )}          );  }}export default App;- Score.js```javascriptimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;const Score = (props) =&gt; {  return (    &lt;ScoreContainer&gt;      &lt;Text&gt;        &lt;span&gt;{props.name}&lt;/span&gt; 퀴즈에        &lt;br /&gt;        대한 내 점수는?      &lt;/Text&gt;      &lt;MyScore&gt;        &lt;span&gt;100&lt;/span&gt;점&lt;p&gt;{props.scoreMsg}&lt;/p&gt;      &lt;/MyScore&gt;      &lt;Button&gt;랭킹보기&lt;/Button&gt;    &lt;/ScoreContainer&gt;  );};const ScoreContainer = styled.div`  display: flex;  width: 100vw;  height: 100vh;  overflow: hidden;  padding: 20px;  box-sizing: border-box;  flex-direction: column; //세로로 객체 배열  justify-content: center;  align-items: center;`;const Text = styled.h1`  font-size: 1.5em;  margin: 0px;  line-height: 1.7;  text-align: center;  &amp; span {    background-color: #ffe08c;    padding: 5px 10px;    border-radius: 30px;  }`;const MyScore = styled.div`  &amp; span {    border-radius: 25px;    padding: 5px 10px;    background-color: #ffe08c;  }  font-weight: 600;  font-size: 2em;  margin: 25px;  text-align: center;  &amp; &gt; p {    margin: 20px 0px;    font-size: 18px;    font-weight: 550;  }`;const Button = styled.button`  color: white;  padding: 10px 20px;  background-color: #6799ff;  border-radius: 30px;  margin: 10px;  border: 1px solid #b2ccff;  width: 70vw;`;export default Score;Quiz.jsimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import img from &quot;./ponyo.jpg&quot;;import TinderCard from &quot;react-tinder-card&quot;;// import SwipeItem from &quot;./SwiptItem&quot;;const Quiz = (props) =&gt; {  const num, setNum = React.useState(0);  const onSwipe = (direction) =&gt; {    console.log(&quot;You swiped: &quot; + direction);    setNum(num + 1);  };  if (num &gt; 3) {    return 퀴즈 끝!;  }  return (                  {num + 1}번 문제            {props.list.map((l, idx) =&gt; {        if (num === idx) {          return {l.question};        }      })}  &lt;AnswerZone&gt;    &lt;Answer&gt;O&lt;/Answer&gt;    &lt;Answer&gt;X&lt;/Answer&gt;  &lt;/AnswerZone&gt;  {props.list.map((l, idx) =&gt; {    if (idx === num) {      return (        &lt;DragItem key={idx}&gt;          &lt;TinderCard            onSwipe={onSwipe}            onCardLeftScreen={onSwipe}            onCardRightScreen={onSwipe}            preventSwipe={&quot;up&quot;, &quot;down&quot;}          &gt;            &lt;img src={img} /&gt;          &lt;/TinderCard&gt;        &lt;/DragItem&gt;        //   &lt;SwipeItem key={idx} onSwipe={onSwipe} /&gt;;      );    }  })}&lt;/QuizContainer&gt;  );};const QuizContainer = styled.divtext-align: center;  margin-top: 130px;  &amp; &gt; p &gt; span {    padding: 8px 16px;    background-color: #ffe08c;    border-radius: 30px;    font-weight: bold;  };const Question = styled.h1font-size: 1.5em;;const AnswerZone = styled.divwidth: 100vw;  height: 100vh;  display: flex;  position: absolute;  top: 0;  left: 0;  z-index: 1;;const Answer = styled.divwidth: 50%;  display: flex;  justify-content: center;  align-items: center;  font-size: 100px;  font-weight: 600;  color: #dadafc77;;const DragItem = styled.div`  display: flex;  align-items: center;  justify-content: center;  position: fixed;  top: 0;  left: 0;  width: 100vw;  height: 100vh;  z-index: 10;  &amp; img {    max-width: 130px;  }`;const Finish = styled.ptext-align: center;  margin-top: 300px;  font-weight: 600;  font-size: 30px;;export default Quiz;- SwipeItem.js```javascriptimport React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import img from &quot;./ponyo.jpg&quot;;const SwipeItem = React.memo(({ onSwipe }) =&gt; {  const swipe_div = React.useRef(null);  let swipe_status = &quot;ready&quot;;  let target_classname = &quot;&quot;;  let coordinate = {    start_x: 0,    start_y: 0,    end_x: 0,    end_y: 0,  };  React.useEffect(() =&gt; {    const reset = () =&gt; {      console.log(&quot;in reset&quot;);      swipe_status = &quot;ready&quot;;      coordinate = {        start_x: 0,        start_y: 0,        end_x: 0,        end_y: 0,      };      swipe_div.current.className = target_classname;      swipe_div.current.style.left = 0 + &quot;px&quot;;      swipe_div.current.style.top = 0 + &quot;px&quot;;    };    const touchStart = (e) =&gt; {      swipe_status = &quot;touchstart&quot;;      target_classname = swipe_div.current.className;      coordinate = {        ...coordinate,        start_x: e.touches0.clientX,        start_y: e.touches0.clientY,      };    };    const touchEnd = (e) =&gt; {      swipe_status = &quot;touchend&quot;;      coordinate = {        ...coordinate,        end_x: e.changedTouches0.clientX,        end_y: e.changedTouches0.clientY,      };      let diff_x = coordinate.end_x - coordinate.start_x;      let direct = &quot;left&quot;;      if (Math.abs(diff_x) &gt; 50) {        swipe_div.current.className = target_classname + &quot; swipe&quot;;      }      if (diff_x &gt; 0) {        direct = &quot;right&quot;;        swipe_div.current.style.left = diff_x + 150 + &quot;px&quot;;        swipe_div.current.style.opacity = 0;      } else {        direct = &quot;left&quot;;        swipe_div.current.style.left = diff_x - 150 + &quot;px&quot;;        swipe_div.current.style.opacity = 0;      }      window.setTimeout(() =&gt; {        reset();        onSwipe(direct);      }, 300);      return;    };    const touchMove = (e) =&gt; {      swipe_status = &quot;toucmove&quot;;      e.preventDefault();      let current_coordinate = {        x: e.touches0.clientX,        y: e.touches0.clientY,      };      swipe_div.current.style.left =        current_coordinate.x - coordinate.start_x + &quot;px&quot;;      swipe_div.current.style.top =        current_coordinate.y - coordinate.start_y + &quot;px&quot;;    };    const touchCancel = (e) =&gt; {      swipe_status = &quot;touchcancel&quot;;      reset();    };    swipe_div.current.addEventListener(&quot;touchstart&quot;, touchStart);    swipe_div.current.addEventListener(&quot;touchend&quot;, touchEnd);    swipe_div.current.addEventListener(&quot;touchmove&quot;, touchMove);    swipe_div.current.addEventListener(&quot;touchcancel&quot;, touchCancel);    return () =&gt; {      if (!swipe_div.current) {        return;      }      swipe_div.current.removeEventListener(&quot;touchstart&quot;, touchStart);      swipe_div.current.removeEventListener(&quot;touchend&quot;, touchEnd);      swipe_div.current.removeEventListener(&quot;touchmove&quot;, touchMove);      swipe_div.current.removeEventListener(&quot;touchcancel&quot;, touchCancel);    };  }, );  return (    &lt;DragItem ref={swipe_div}&gt;      &lt;img src={img} /&gt;    &lt;/DragItem&gt;  );});const DragItem = styled.div`  display: flex;  align-items: center;  justify-content: center;  position: fixed;  top: 0;  left: 0;  width: 100vw;  height: 100vh;  &amp;.swipe {    transition: 300ms;  }  &amp; &gt; div {    border-radius: 500px;    background-color: #ffd6aa;  }  &amp; img {    max-width: 130px;  }`;SwipeItem.defaultProps = {  onSwipe: () =&gt; {},};export default SwipeItem;❓ Quiz.js에 SwiptItem.js를 import해서 실행했을 경우 포뇨 이미지는 잘 뜨는데 swipe 기능이 아예 먹히질 않는다,,,❓ 무엇이 문제인지 해결하지 못해서 SwipeItem.js import 하지 않고 Quiz.js 내에서 TinderCard를 사용하여 Swipe 기능을 그냥 구현하였다.결과 화면포뇨 이미지를 좌우로 스와이프 할 때마다 문제가 바뀌며, 모든 문제가 끝났을 때 '퀴즈 끝!' 문구가 나오게 됨."
370,"스파르팅코딩클럽 '프론트엔드의 꽃, 리액트' 1주차 강의를 듣고 작성한 글입니다.Javascript 기본 개념클래스 : 상태 + 함수 로 구성class Cat {    // 생성자 함수    constructor(name) {        this.name = name;     }    // 함수    showName(){        return this.name;    }}extends로 클래스 상속super로 부모의 constructor 호출하면서 인수 전달 (this 쓸 수 있음)var, let : 변경 가능const: 변경 불가능map: 배열에 속한 항목 변환시 많이 사용. 즉, 새로운 배열 생성fiilter: 조건을 만족하는 항목들만 골라서 새로운 배열 생성concat: 배열 합치기 + ...new Set() 으로 중복 항목 제거React 프로젝트 시작전에 React 프로젝트를 시작할 때는 'nvm'를 따로 설치하지 않았는데 이번에는 설치해주었다.NVM(Node Version Manager) 란? Node.js의 버전 관리자.NPM(Node Package Manager): 수많은 third-party 패키지를 활용할 수 있게 해줌. 즉, Frontend 의존성을 관리하기 위한 패키지 매니저 →패키지를 가져다 쓰기 편하게 도와줌. ( = yarn)npm으로 yarn 설치 : npm install -g yarnyarn 버전 확인 : yarn -vyarn add global create-react-appreact 프로젝트 생성 : yarn create react-app project name컴포넌트(Component)State : 컴포넌트가 가지고 있는 데이터Props : 컴포넌트가 부모 컴포넌트로 부터 받아온 데이터 (수정 불가능)1. 함수형 컴포넌트1) 첫번째 방법function App(props){    return(        &lt;div&gt;Hi&lt;/div&gt;    );}export default App;2) 두번째 방법const App = (props) =&gt; {    return (        &lt;div&gt;Hi&lt;/div&gt;    );}export default App;2. 클래스형 컴포넌트//App.jsclass App extends React.Component {    constructor(props){        super(props);        this.state = {            list: 'A', 'B', 'C'        };    }    render() {        return (        &lt;div className=&quot;App&quot;&gt;            &lt;BucketList list={this.state.list}/&gt;        &lt;/div&gt;        );    }}export default App;CSS fileimport './style.css'; 로 선언.App{    width: 100vw;    height: 100vh;    display: flex;    flex-direction: column // 세로로 배열}ToyProject BucketListApp.jsimport React from &quot;react&quot;;import BucketList from &quot;./BucketList&quot;;import &quot;./style.css&quot;;class App extends React.Component {  constructor(props) {    super(props);    this.state = {      list: &quot;여행 가기&quot;, &quot;매일 책읽기&quot;, &quot;기타 배우기&quot;, &quot;드라마 정주행하기&quot;,    };  }  render() {return (  &lt;div className=&quot;App&quot;&gt;    &lt;div className=&quot;container&quot;&gt;      &lt;h1 className=&quot;title&quot;&gt;내 버킷리스트&lt;/h1&gt;      &lt;hr className=&quot;line&quot; /&gt;      &lt;BucketList list={this.state.list} /&gt;    &lt;/div&gt;  &lt;/div&gt;);  }}export default App;- BucketList.js```javasciptimport React from &quot;react&quot;;const BucketList = (props) =&gt; {  const my_lists = props.list;  return (    &lt;div className=&quot;lists&quot;&gt;      {        my_lists.map((list, index) =&gt; {          return (            &lt;div className=&quot;list-item&quot; key={index}&gt;              {list}            &lt;/div&gt;          );        })      }    &lt;/div&gt;  );};export default BucketList;style.css.App {width: 100vw;min-height: 100vh;background-color: #eee;padding: 32px;box-sizing: border-box;}.container {  max-width: 350px;  min-height: 80vh;  background-color: #fff;  padding: 16px;  margin: 20px auto;  border-radius: 5px;  border: 1px solid #ddd;}.title {  color: slateblue;  text-align: center;}.line {  margin: 16px 0px;  border: 1px dotted #ddd;}.lists {  display: flex;  flex-direction: column;  height: 100%;  overflow-x: hidden;  overflow-y: auto;}.list-item {  padding: 16px;  margin: 8px;  background-color: aliceblue;}* 결과 화면&lt;img src=&quot;https://images.velog.io/images/tnqls1211v/post/bc20b2ae-703a-4e1b-8a13-250d220e69a3/bucket.jpg&quot; width=&quot;30%&quot;&gt;&lt;br/&gt;### HW FriendTest- App.js```javascriptimport React from &quot;react&quot;;import &quot;./App.css&quot;;import Start from &quot;./Start&quot;;class App extends React.Component {  constructor(props) {    super(props);    this.state = {      name: &quot;포뇨&quot;,    };  }  render() {    return (      &lt;div className=&quot;App&quot;&gt;        &lt;Start name={this.state.name} /&gt;      &lt;/div&gt;    );  }}export default App;Start.jsimport React from &quot;react&quot;;const Start = (props) =&gt; {  return (                            나는 {props.name} 에 대해서                    얼마나 알고 있을까?                        시작하기            );};export default Start;- App.css```css.container {  display: flex;  height: 100vh;  width: 100vw;  overflow: hidden;  padding: 20px;  box-sizing: border-box;}.outter {  display: flex;  align-items: center;  justify-content: center;  flex-direction: column;  height: 100vh;  width: 100vw;  max-width: 400px;  border: 1px solid #eee;  padding: 0vh 30px;  box-sizing: border-box;  margin: 0px auto;}.outter h1 {  text-align: center;  font-size: 1.5em;  margin: 0;  line-height: 1.8;}.outter h1 span {  background-color: #ffe08c;  padding: 5px 10px;  border-radius: 30px;}.text-box {  padding: 10px;  margin: 25px 0px;  border: 1px solid #eaeaea;  border-radius: 30px;  width: 70%;  background-color: #eaeaea;}.button {  padding: 10px 30px;  background-color: #4374d9;  border-radius: 30px;  border: #4374d9;  color: white;}결과 화면"
