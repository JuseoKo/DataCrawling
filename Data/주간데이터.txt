1. 개요 사실 이 행동은 2020년에 이루어졌으며, 그 때 어딘가에다가 글을 썼지만 잃어버려 이곳 벨로그에 쓰기 적당한 주제기에 새로 다시쓰기로 하였습니다. 오늘의 목표는  www.(그)hub.com  에 요청을 보내고 응답받은 내용을 파싱하는 것 까지 해보겠습니다. 2. SNI 스니핑 2019년 그 시절 우리는 정부로부터 HTTPS 패킷을 감청한다는  비극적인 소식 을 들었습니다. 하지만 저는 신사답게 어떠한 시련이 저를 덮치더라도 이겨낸 뒤에 행복의 시간, 승리의 기쁨을 느껴야 합니다. SNI 스니핑 방법을 이용해서 유해사이트를 판단, 차단한다고 하였는데요. 적을 알고 나를 안다면 백전 백승이듯, 이 기능이 무엇인지 잠깐 보도록 합시다. HTTPS 통신   OSI 7계층을 보면 HTTP 밑에 TCP 프로토콜이 존재합니다. 물론, 정보의 바다에서 한 번쯤은 봤을만한 얘기죠. HTTP는 TCP 통신으로 진행됩니다. HTTPS는 TLS구요. TLS 악수   여기서 TLS Handshake에 대해 자세히 다루지 않습니다. 설명하려면 매우 귀찮으니  이거 라도 링크를 드리겠습니다. 아무튼 TLS 핸드셰이크 진행중, 클라이언트가 서버에게 보내는  Client Hello  메시지의 내용을 봅시다. 글을 쓰는 현재 회사이므로 일하는 척 해야되기 때문에 브라우저가 아닌 프로그램으로 통신해보도록 하겠습니다. 당연히 실패합니다. 브라우저가 아니라 소켓 자체가 끊거는 거니 제대로 된 통신이 불가했습니다. 하지만, 우리는 확실히 핸드셰이크 요청을 보냈죠.    Client Hello  메시지의  server_name 이라는 옵션이 있습니다. 이 주소를 통해 차단할지 말지 정하고 있으니 이 항목을 없애버린 채 통신한다면? 우회가 될 것입니다. 이제부터 그 내용을 NodeJS로 진행해 보겠습니다. DNS   일단 우린 URL 주소를 알고 있지만, 직접 TCP 소켓을 연결할 IP주소를 가져와야 합니다. 그러기 위해서 사용하는 게 DNS Lookup이지만, 이에 대한 자세한 기술적 설명은 다른 글이 더 좋으니 여기서 설명하지 않습니다. NodeJS에서는  dns 모듈 을 제공합니다. 위 코드를 실행해 보면 한 개의 IP 주소를 얻을 수 있습니다. 이제 이 주소에다가 나의 누나들, 아니. 나의 행복을 내놓으라고 요구하면 됩니다. HTTP Message 이것도 세상 많은곳에 좋은 글이 퍼져있으니 자세히 설명하진 않습니다. 추천하는 글은  이것 입니다. 위 주소에서 하나 인용해보겠습니다. HTTP 메시지는 ASCII로 인코딩된  텍스트  정보이며 여러 줄로 되어 있습니다. 즉, HTTP 통신은 TCP로 소켓을 연결하고 사람이 이해할 수 있는 문장을 규격에 맞춰 보내준다면 쉽게 HTTP 통신이 가능하다는 뜻입니다. 예를 들어, 우리가 보낼 HTTP 메시지는 이렇게 되겠네요.   이 메시지를 아까 알아온 IP 주소에다가 보내봅시다. TLS 노드에서 아주 친절하게 net 모듈, 그리고 tls 모듈을 지원합니다. 그 모듈을 사용해 연결하고 메시지를 보내봅니다. 하지만 응답받은 값을 콘솔에 찍은 걸 보면 원하는 대로 통신이 안 됩니다.     좋습니다. HTTP Message를 작성하는 배열에 User-Agent 헤더를 담아봅니다. 그러면 이상한 HTML 파일들을 우다다다 받게 됩니다. 곧 있으면 저는 누나들을 볼 수 있습니다. 아니, 이미 봤다고 해도 됩니다. 하지만 마지막 목표인 파싱까지만 해볼게요. 위코드를 실행하게 되면 응답받은 HTML코드를 아래처럼 보여줍니다.   마무리   오우야 오우야 참을 수 없습니다. 하지만 회사이기 때문에 참아야 합니다. 회사에서 월루해도 저는 오직 코딩과 공부와 공부를 정리하기만 했기 때문에 아주 틀린짓은 아닐지도 모르겠습니다. 마지막으로, 이 글을 보고 공부가 되었다면 아래 글을 참고하여 직접적인 실습이 가능합니다. (물론 성인사이트에 우회요청 하는 건 아닙니다.)  당신은 HTTP에 대해 얼마나 알고 있나요 재밌게 봐주셨다면 감사합니다. 개인적으로 저는 어떤 걸 배우면 그 동작의 원리까지 이해하고 있어야 개발하기 편했습니다. 물론, 컴퓨터를 쓴다고 CPU를 만드는 방법까지 알아야 할 필요는 없지만요.   HTTP  모듈 없이 HTTP 통신을 구현한 옛날이 생각나서 열게 된  Create HTTP Request Wrapper Challenge  입니다. 이 도전은 다음의 지식을 알아야 합니다. DNS Lookup HTTP Message Method Chaining TCP/IP 전체적으로 HTTP 통신 요청이 어떻게 이루어지는지 알고 있어야 하기 때문에 공부하기에도 매우 흥미로운 주제라 생각합니다. 어떻게 도전하나요? 이   레포지토리  를 포크합니다. 절대 http, https 모듈이나 npm 모듈을 사용해서는 안 됩니다. 본인의 폴더를 만들고 http-request.js파일을 복사합니다. 만약 테스트 명령어를 실행하여 PASS가 출력된다면 성공입니다. 테스트는 서버가 실행되고 있어야 합니다. 도전자는 어디에나 코드를 추가할 수 있지만, 기본 코드는 삭제할 수 없습니다. 서버 실행 명령어:  node server.js   테스트 실행 명령어:  node test.js ./[your name]/http-request.js   만약 당신이 PASS를 본다면 Pull Request를 생성해 주세요. 도전자가 정상적인 Wrapper 를 만든다면 다음과 같은 출력을 볼 수 있습니다.   행운을 빌어요! 1. 개요 내장된 자료구조 큐를 사용하는데 왜 이렇게 구현하는지 궁금해졌습니다. 자바 - 링크드 리스트 파이썬 - deque     2. 큐 삽입 - 싱글 연결리스트 싱글 링크드리스트로 큐를 구현하면서 가장 시간이 오래 걸린점은 가장 마지막 노드에 원소를 삽입할때 탐색해야해서 O(n)이 걸렸습니다.  이를 해결하기 위해서 가장 마지막 노드를 tail에 저장하면 되는데 이렇게 할것이면 결국 더블 링크드 리스트로 만들어서, 덱을 만들고, 필요한 기능만 사용하는 것이 유리해보였습니다. 3. 코드 1) Python 2) Java 3) JavaScript 매번 헷갈려서 빠른 정리  this.$router - vue-router 인스턴스  this.$route - 현재 라우터의 상태를 관리하는 객체  this.$router.currentRoute._value  는  this.$route  와 같습니다. 0. 개요 node_modules의 vue-router를 열어보면  vue-router.js  1. this.$router  VueRouter 의 인스턴스 입니다.    인스턴스의 여러 메서드가 있는데 자주 쓰는것만 확인해보면 back - 히스토리 백 push - 히스토리에 넣고 이동 replace - 히스토리에 넣지 않고 이동   2. this.$route 현재 라우터의 상태를 관리하는 객체로  this.$router.currentRoute._value 과 같다. 편하게 접근하라고 상단으로 빼준것 같습니다. (개인적 추측)   자주 쓰는것만 확인해보면 fullPath - 전체 url query - 쿼리 스트링 3. 정리  this.$router - vue-router 인스턴스  - 라우터 이동 및 관리에 사용  this.$route - 현재 라우터의 상태를 관리하는 객체  - 현재 라우터의 경로 및 쿼리 등 상태 확인하기 위해 사용 그냥 다 쓰고 나서 생각이 들었는데, 제가 영어에 익숙하지 않아서 헷갈리는것 같습니다. 영단어와 무슨 역할하는지를 매칭하면 헷갈리는 경우가 없을듯합니다. 1) router - 중계기 2) route - 경로   자바8에 도입된 스트림, 람다에 대해 알아봅시다. 1. 스트림 1) 정의  Oracle - stream  에 따르면 연속된 정보를 순서대로 접근하기 위한 객체입니다. 2) 연속된 정보란 바로 생각나는 것은 배열과 리스트가 있습니다. 그리고, Map, Set과 같은 컬렉션도 해당되는데 그 이유는 컬렉션 인터페이스에 내장된  default 메서드 로 구현되어있기 때문입니다.   다만, 배열은  stream 메서드가 없기 때문 에 메서드 호출 대신  Arrays.stream  정적 메서드를 호출합니다. 즉 스트림이란, 배열과 컬렉션을 순서대로 접근하기 위한 인터페이스 입니다. 참고 자바 8부터  인터페이스 default 메서드 가 추가 되었습니다. 그 이유는 이미 많은 사람들이 리스트, 셋을 사용하고 있는데  컬렉션 인터페이스에 stream을 추가하면 모두 구현해야하고, 그렇지 않으면 에러가 발생하기 때문입니다. 낮은 버전의 호환성을 위해 기본 메서드가 추가되었습니다. 그리고, Collection 인터페이스의 stream은 default 메서드 입니다. 2. 구조 0) 개요 스트림의 연산은 크게 3가지로 구분됩니다.    스트림 생성: 데이터를 스트림 객체로 변환합니다. stream메서드는 Collection 인터페이스에 default 메서드로 선언되어 있습니다.  중개 연산 - 생성된 스트림을 처리합니다. 결과를 리턴하지 못합니다.  종단 연산 - 중개 연산 결과를 종합하여 리턴합니다. 1) 스트림 생성 컬렉션 -  Collection 인터페이스 의  stream 기본 메서 드 호출 배열 -  Arrays.stream  클래스 메서드 호출 정수배열의 경우  IntStream.of  를 사용할 수 있는데 결국에는  Arrays.stream 2) 중개연산 사실 직접 해보는것이 더 좋아서 자세하게 안적습니다. forEach - 순회 filter - 조건식 필터링 map - 콜백에 따라 연산 flatMap - 중복된 스트림 1차원 평면화 reduce - 결과 취합 sorted - 정렬 3) 중단 연산 4) 예시 배열의 원소를 제곱수로 변경 3. 스트림 단점 단점이라기 보다는 스트림의 특징을 제대로 활용하지 않았을 때 발생하는 문제점입니다. 과연 반복문 사용하는것보다 항상 좋은가? 그것은 아닙니다. 1) 순회 중단에 종료가 불가능합니다.  스트림 의 정의는  연속된 정보를 순서대로 접근하기 위한 객체 입니다. 예시 처럼  1, 2, 3, 4  배열에서 3이상은 보고 싶지 않다. 순회 그만하자고  break 를 넣을 수 없고,  return 을 적어도 결국 끝까지 모두 순회합니다. 2) 동시성 관리를 위해 Atomic 자료형을 사용합니다. 만약 스트림을 순회하면서 외부 변수에 접근하려고 하면 동시성 관리를 위해 Atomic 자료형을 사용해야합니다.  Atomic 자료형은 멀티스레드 환경에서 동시성 관리를 위해 도입된 자료형으로  CAS - Compare and Swap  알고리즘을 사용합니다. (물론 아래처럼 배열의 합을 구할때는 sum()메서드 사용합니다. 그냥 예시입니다.) 4. 람다 1) 정의 람다는 함수를 하나의 식으로 표현현것 입니다. 이름이 없는 익명함수의 한 종류로 볼 수 있습니다. 람다식을 사용하는 이유는 불필요한 코드를 줄이고 가독성을 높이기 위함입니다. 2) 함수형 인터페이스 함수형 인터페이스는 추상메서드가 1개만 있는 인터페이스로 함수형 인터페이스를 통해 람다식을 생성할 수 있습니다. 3) 함수형 인터페이스를 람다로 바꾸기 위한 조건 위의 예시는 람다식으로 이렇게 변경할 수 있습니다. 4) @FunctionalInterface 만약 누군가가 인터페이스에 메서드를 하나 더 추가하면, 더 이상 람다식으로 만들 수 없고 에러가 발생합니다. 따라서,  @FunctionalInterface  어노테이션을 통해 추상 메서드가 단 1개임을 명시합니다. 추상메서드가 2개 이상이면 컴파일 에러가 발생합니다. 5. Java.util.function 패키지 자바 스트림의 연산은 Functional 인터페이스를 파라미터로 받습니다. Functional 인터페이스를 통해 람다식을 사용할 수 있습니다. Predicate - 두 개의 객체 비교 - filter Supplier - generic 타입 리턴 - Collect, Generate Consumer - 리턴값 없음 - then Function - 객체 타입 변환에 사용 - mapToLong UnaryOperator - 한개의 변수 받아 연산에 사용 - map BinaryOperator - 두개의 변수 받아 연산에 사용 - reduce  예시) map에 사용되는 UnaryOperator 함수형 인터페이스 6. 람다 단점 1) 재사용 불가 람다식은 재사용이 불가능합니다. 1. 상황 vue에서 setTimeout에 익명함수 넣고, 그 내부에서 this로 함수를 호출하면  is not a function  에러가 발생합니다.   2. 원인 자바스크립트 this는 4가지 상황에서 의미가 다릅니다. setTimeout의 첫번째 인자로 익명 함수  function() {}  을 전달했고 일반함수처럼 호출됩니다. 일반 함수 호출 - 전역 객체 메서드 호출 - 메서드를 호출한 객체 생성자 함수 호출 - 생성자가 호출할 인스턴스 apply, call, bind 메서드에 의한 간접 호출 - 메서드의 첫번째 인수로 전달한 객체 3. 해결방법 1) 화살표 함수 호출되는 상황에 따라 동적으로 this가 결정되는 일반함수와 다르게 화살표 함수는 선언 시점에 this가 정의됩니다. 화살표 함수 내부에는 this가 없기 때문에 상위 스코프로 올라가다가 가장 유사한 환경을 만나면 탐색을 그만둡니다. 가장 먼저 만나게 되는 this는 vue 인스턴스 이기 때문에 vue인스턴스가 바인딩됩니다. 2) 인스턴스 참조 음 인스턴스를 다른 변수에 참조걸어놓고 사용하는건데, 조금 비효율적 3) prototype bind 익명함수에 this를 바인딩 하는 방법 참고로 화살표함수는 바인딩 안된다. 4. 결론 this 언제 어떻게 사용되는지 잘 알아보고 화살표 함수 잘 사용하자. 1. ref란? 1) 정의 ref란 뷰에서 컴포넌트 또는 DOM에 접근하기 위해 사용하는 속성입니다.  마운트된 요소에만 적용가능합니다.  마운트 되지 않은 요소에 사용하면  ref undefined 가 발생합니다. 2) 사용법 접근 대상  ref  속성 명시 사용 대상  this.refs  로 접근  제일 많이 실수 하는 부분중 하나는 ref와 refs의 스펠링을 구분하지 못하는 것입니다. 3) 특징 대상 속성에 모두 접근가능하기 때문에 함수 호출도 가능합니다. 다만, 이렇게 되면 너무 jquery느낌이 납니다. 필요한 경우에만 사용합시다. 2. 주의할 점 1) 마운트 되지 않은 요소에 사용  v-if=false  로 렌러링 되지 않았거나,  created() 에서 사용하면  ref undefined  또는 속성이 없다는 에러를 만나게 됩니다.   2) ref, refs 스펠링 틀리는 경우 생각보다 많이 있습니다. 대상 - ref 접근할 때 - refs 3) computed 에서 사용하는 경우 이 경우도 생각보다 많은데 뭔가 렌더링 여부를 검사하고 싶은데 방법이 없나, 아 computed를 사용하면 되겠다 이런 생각으로 도달한 경우 (제가 그랬습니다. 아니면 말구) 4) watch computed와 비슷한 맥락, 뭔가 렌더링 되는 그 순간을 어떻게든 잡아보겠다라는 집념으로 watch 를 사용합니다. (저의 이야기입니다.) watch에 걸리는 일은 없습니다. 이쯤되면 이런 생각도 들었습니다. 왜 ref는 될때가 있고, 안될때가 있지... 물로 제가 공식 문서 제대로 안봐서 생긴 잘못입니다. 5) 상태 추적 어려움 jquery 처럼 직접 접근하는 방식이기 때문에 상태 추적하기가 생각보다 어려워집니다.  진짜 이거 아니면 안되겠다.그럴 때 사용합시다.  1. 개요 그냥 요즘 자바스크립트로 leetcoe 풀고 있는데 자바스크립트 제일 낯선 부분 중 하나가 정수 나눗셈. 생각없이 Math.floor  썼었는데 음수 나눗셈에서 생각과 다르게 동작합니다. 음수 나눗셈 할 일이 거의 없어서 하나씩 살펴보면   따라서, -3이 나와야합니다. 2. Math.floor  Math.floor  - 내림   MDN에 따르면  함수는 주어진 숫자와 같거나 작은 정수 중에서 가장 큰 수를 반환합니다.  이기 때문에  Math.floor(-10/3)  은 -4을 반환합니다. 양수일때는 잘 동작합니다. 3. Math.trunc  Math.trunc  - 버림   정수 부분만 반환하기 때문에 정수 나눗셈 몫 구하기에 딱 얼룹니다.  Math.floor(-10/3)  은 -3을 반환합니다. 4. ~~ (not not) bitwise not 연산자 2개를 사용하는 방법입니다.  MDN  에 따르면 bitwise not을 사용하면 x는 -(x+1)을 반환하고, 소수점을 모두 버립니다. 그래서 2번 중첩해서 사용하면 소수점을 버린 상태가 됩니다. 5. 속도 비교 1억번 연산을 10번 수행했었는데 크롬에서는 크게 차이가 없었습니다. 1) 크롬 Math.trunc - 51.58 ms not not - 51.4 ms 2) safari Math.trunc - 1345.6 ms not not - 1341.5 ms 파이어폭스에서는 하지 맙시다. 컴퓨터 터지는줄 알았습니다. 6. 정말 큰수 조, 경, 해... 1000해 까지가면 조금 이상해진다. 7. 개인적 의견 사실 브라우저에서 나눗셈 연산 1억번 10 번하는 경우 거의 드물고 이러한 연산을 알고리즘 또는, 간단한 연산으로 한정한다면, 1조 이하의 연산으로 한정한다면 빠르고, 음수 나눗셈까지 지원할 수 있는 ~~(not not)을 사용하는것이 좋을듯 그냥 생각해보니 파이썬도 음수 나눗셈 지원하려면  math.trunc 를 사용해야하는데  //  만 사용해도 문제 없었으니 알고리즘 풀때는 음수 나눗셈 할일이 크게 없는 듯 그런데 머신러닝할때는 음수 나눗셈 신경 써야 했음 .... 그래서 알고리즘 할때는 편한거 쓰고 음수 나눗셈 필요하면, 그거 지원하는거 사용하자 참고  https://codepen.io/supernova_at/post/javascript-s-double-bitwise-not-operator https://www.delftstack.com/ko/howto/javascript/integer-division-javascript/ 자바8(2014)에서 인터페이스 default method(기본 메서드)가 추가되었습니다. 1. 개요 인터페이스 기본 메서드는 default 지시어로 정의되며 구현부를 가질 수 있는 메서드입니다. 기존 인터페이스는 구현부가 없는 추상 메서드만 가질 수 있었습니다. 인터페이스 구현 객체는 인터페이스에 정의된 메서드를 반드시 구현해야합니다.  다만, 기본 메서드를 통해 구현을 변경하지 않고, 인터페이스에 메서드를 추가할 수 있게 되었습니다. 2. 목적 기본 메서드의 목적은 구현체를 변경하지 않으면서 인터페이스를 확장하는 것에 있습니다. 예를 들어 자바 8 부터 List 컬렉션에 stream이 추가 되었습니다. 이를 위해서는 ArrayList에서 stream을 구현해야하는데 기본 메서드를 통해 stream을 제공하면서 ArrayList에서는 구현하지 않아도 되어 이전버전과의 호환성이 유지됩니다. 3. 다중 상속시 주의점 자바 인터페이스는 다중 상속이 가능합니다. 다만, 다중상속시 동일한 기본메서드가 있으면 컴파일 에러가 발생합니다. 1) 기본 메서드 충돌 동일한 이름의 기본 메서드를 상속 받으면 메서드 충돌이 발생합니다.   참고로, 추상 메서드에서는 발생하지 않습니다. 2) 인터페이스에서 부모를 명시 인터페이스 둘 중 하나의 인터페이스만 사용하겠다고 명시할 수 있습니다. 3) 구현체에서 부모를 명시 구현체에서 어느 인터페이스를 사용할지에 대해 명시합니다. 4. 접근 제어자 default public, private 불가 5. 오버라이딩 public 메서드로 재정의 가능 6. 개인적인 생각 인터페이스는 추상화 정도를 높여야 하는데, 기본 메서드를 사용하면 추상화 정도가 낮아지기는 합니다. 다만, 기존 구현체를 모두 변경하지 않으면서 인터페이스를 확장할 수 있는 절충안 같습니다. 최근 자바 개발을 하면서  enum 을 정말 편하고 안전하게 사용했던 경험 이있습니다. 1. 예시 타입: 풀, 번호 1 - 이상해씨 타입: 불, 번호 4 - 파이리 타입: 물, 번호 7 - 꼬부기  타입, 번호 정보를 가지고 포켓몬의 이름을 구분하는 메서드를 작성했습니다. 그런데, 이렇게 하다보니 쓸데없이  if문 중첩 만 늘어났습니다. 그리고, 어딘가에서 누군가는  if문 다르게  사용할것 같은 불안감이 들었습니다. 마지막으로,  코드 많이 작성하는거 안좋아해서  정말 정말 줄이고 싶었습니다. 2. enum 을 사용하자 비슷한 고민을 하신분들이 있을것이라 생각하고 찾아보았습니다. 우아한 형제들 블로그의  Java Enum 활용기  을 적극 참고했습니다. enum 클래스에 식별자 작성 스트림, 람다를 통해 식별자 필터링 식별자에서 이름 반환 3. 장점 개인적으로 느낀 장점은 4. 참고  Java Enum 활용기 1. 상황 깃허브에서 클론을 받았는데 다음 에러가 발생하면서 빈 폴더만 받았습니다.  Clone succeeded, but checkout failed. You can inspect what was checked out with &#39;git status&#39;   2. 원인 맥북에서 한글 이름으로 파일명을 생성했는데, 맥과 윈도우의 한글 다루는 문제 때문에 발생했습니다. 파일명이 윈도우 환경에서 다룰수 없는 문자열 형식이었습니다. 3. 해결 깃허브의 수정 기능을 사용해서 파일명을 영어로 변경했습니다.   안되면 맥북에서 직접 변경하는 것도 좋을듯 forEach 순회중 중단 불가 forEach 동시성 보장 필요 개요 개인적으로 Stream의 forEach가 요즘 트렌드 같고, 코드양도 상대적으로 적어, 알고리즘을 풀때 자주 사용했습니다. JavaScript를 사용할 때 forEach를 사용했고 때문에 큰 문제가 없을 것으로 생각했지만 이렇게 하면 안된다고 느끼게 되었습니다. for-loop와 Stream forEach의 차이점은 다음 2개입니다. forEach 순회중 중단 불가 forEach 동시성 보장 필요 1. forEach 순회중 중단 불가 1) 문제 예를 들어 주어진 배열에서 target과 일치하는 원소를 찾고있습니다. 1) 원소가 있으면 해당 원소 반환 2) 원소가 없으면 -1 반환 2) 코드 다음과 같이 forEach 내부에서 break, return 을 사용하면 에러가 발생합니다.   2. forEach 동시성 보장 필요 1) 문제 끝말잇기를 하고 있고 틀리는 경우 바로  이전 단어와, 현재 단어  를 반환합니다. 2) 코드 forEach 내부에서는 동시성이 보장되지 않아, 외부의 변수를 변경하려고 하면 에러가 발생합니다. 이러한 경우 atomic 변수를 사용합니다. atomic은 자바 멀티스레드 환경에서 동시성을 보장하기 위해 사용하는 변수로 synchronized 대신 CAS(Compare and Swap)알고리즘을 사용합니다. 3. Atomic 변수 안써도 forEach에서 변경 가능한데? 다음 2가지와 같이  map, set, list 에 넣는 경우 배열 요소에 인덱스로 접근하는 경우   }    프로그래머스 K번째 수  문제를 보다가 알게되었습니다. 1. Array.prototype.sort() 자바스크립트 배열 정렬 메서드로 .sort() 를 사용합니다. 다만,  MDN 에 따르면 정렬 순서는  문자열의 유니코드 를 따릅니다.   2. 언제 안되는데?   오름 차순 정렬을 했는데  -1.1 이  -1  보다 크다고 나옵니다. 3. 그래서 어떻게? 두수의 비교 방법을 통해 정렬을 진행합니다. 반환값이 참이 되도록 진행됩니다. 음수 - 오름차순 양수 - 오름 차순   정말 해시 문제인가   뭔가 잘 풀리지 않았다. 개인적으로 해시의 비중이 커 보이지 않는다. 어떻게  조합의 개수 를 어떻게 구하지 문제인것 같다. 다른 글을 보았을 때 조합의 개수 구하는 공식이  (x + 1)(y + 1) - 1  이라고 합니다. 근데 그거 어떻게 구하지... 1. 조합의 개수 그거 어떻게 구하지 문제의 예시대로 다음과 같이 있으면 head_gear - 2개 eye_wear - 1개 조합의 개수는  head_gear + eye_wear + head_gear * eye_wear x + y + xy 자 중학교 때로 돌아가보면 뭐 이런것 배웠던 것 같다.  x + y + xy  에서  x(y + 1) + y x(y + 1) + (y + 1) - 1 (x + 1)(y + 1) - 1 사실, 3개부터는 힘들다.  x + y + z + xy + yz + xz + xyz  x(1 + y) + y(1 + z) + z(1 + x) + xyz x(1 + y + yz) + y+yz + z + x  x(1 + y + yz) +(1 + y+ yz) - 1 + z + x (1 + y + yz)(x + 1) +x + z -1 안할래요 못하겠어요. 2. 인수분해  나무공학 위키 에 따르면 인수분해는  어떤 원소를 다른 원소의 곱으로 표현하는 것 그리고,  미리 외워서 써먹는 것이 정신 건강 x + y + xy-&gt; (x+1)(y+1) - 1 3. 코드 반항심에 숏코딩 하려고 했는데 그것마저 잘 안된다. 1) python 2) java nginx, apache 없이 테스트 용도로 서버 굴리는데 인증서는 필요할때 개요 HTTP 메서는 3가지 속성을 가집니다. 다음은 9개의 메서드에 대한  요약표 1. 안전 안전은 메서드를 통해 호출해도 리소스를 변경하지 않는다는 의미입니다.  (요청한 리소스에 대해서만 고려하기 때문에 로그 쌓는 데이터는 고려대상은 아닙니다.)  GET, HEAD, OPTIONS, TRACE 가 해당합니다. 2. 멱등 멱등은 호출 횟수와 상관없이 결과가 동일하다는 의미입니다.  안전 속성을 가지는 메서드들은 리소스를 변경하지 않기 때문에 멱등이며 주의깊게 볼것은 PUT과 DELETE입니다. PUT PUT의 쓰임은 데이터가 없으면 생성하고, 있으면 요청 데이터로 완전히 덮어버리는것입니다. 그렇기 때문에 몇번을 요청해도 요청 데이터로 덮어쓰기 때문에 멱등입니다. DELETE delete는 데이터를 삭제합니다. 이미 삭제된 데이터를 삭제하려고 해도 삭제되었기 때문에 멱등입니다. 3. 캐시 가능 캐시 가능은 응답 결과의 캐시 여부를 의미합니다. GET, HEAD, POST, PATCH가 해당합니다. 실제로는 GET, HEAD 정도만 캐시로 사용합니다. POST, PATCH는 본문 내용까지 캐시 키로 고려해야하는데 구현이 쉽지 않습니다. TCP 전체 프로세스  TCP 프로토콜은 1974년 에 설계되었고,  1981년에 작성된 rfc793  문서에는 전체 과정이 기술되어있습니다. 사실 봐도 잘 이해는 되지 않습니다.   다음 2개에 대해 알아보겠습니다. 연결에 사용되는 - 3 way handshake 종료에 사용되는 - 4 way handshake  3 way handshake 1) 정의 3 way handshake는 클라이언트와 서버가 서로 통신할 준비가 되었음을 확인하는 과정입니다. 2) 과정 3개의 과정이 진행됩니다.  1. syn sent syn(x) 클라이언트의 상태를  syn sent 라고 부릅니다. 2. syn received ack(x+1), syn(y) 서버의 상태를  syn received 라고 부릅니다. 3. established ack(y+1) 클라이언트의 상태는  established 입니다.   3) 와이어샤크 확인 다음은  HTTP/1.1 프로토콜 로 통신할 때  3 way handshake 가 일어나는 과정입니다.  참고로 HTTP 프로토콜은 3.0까지 나왔습니다. 1.1, 2.0 - TCP 기반 3.0 - UDP 기반   1. syn sent 클라이언트는 임의의 seq 번호( 896377445 )를 생성하고, syn flag를 1로 설정 후 서버에 보냅니다.   2. syn received 서버는 클라이언트로 받은 seq번호에 1을 더한 값( 896377446 )을 ack 번호로 설정합니다. 그리고 임의의 난수( 533696001 )을 생성해서 seq 번호로 클라이언트로 보냅니다. 이때 syn, ack 플래그를 1로 만듭니다.   3. established 클라이언트는 서버로 부터 받은 seq 번호에 1을 더한 값( 533696002 ) 을 ack 번호로 설정하고 ack 플래그를 1로 설정하여 서버로 보내고 연결을 수립합니다.   4. 이후 4 way handshake 1) 정의 4 way handshake는 클라이언트와 서버가 서로의 통신을 종료하는 과정입니다. 2) 과정 1. fin-wait1 첫번째로 서버는 클라이언트에 fin번호(x)를 보냅니다. 2. close-wait, last-ack 두번째로 클라이언트는 fin에 대한 ack번호(x+1)과, 임의의 난수로 생성된 fin번호(y)를 보냅니다. 3.fin-wait2, time-wait 마지막으로 서버는 fin번호에 대한 ack 번호를 전송하고 닫기 전에 시간 초과를 기다립니다. 이전 연결을 통해 클라이언트에서 보내진 후속 패킷을 기다리기 위함입니다. 이것만 보면 3 way 인데 왜 4 way 라고 하냐 할 수 있는데요.  위키피디아 에 따르면 fin &amp; ack를 한번에 보낼수 있다고 합니다.     3) 와이어샤크 확인 1. fin-wait1 서버가 클라이언트에 fin 번호( 533696405 2. close-wait, last-ack 클라이언트가 받은 fin번호에 1을 더해 ack 번호로 설정하고( 533696406 ), 임의의 난수를 fin번호( 896377897 3. fin-wait2, time-wait 서버는 받은 fin번호에 1을 더해 ack 번호( 896377898 )로 설정하고 클라이언트에 보냅니다. 정리 사실 여기까지 대단한것은 없습니다. 결국 보내진 syn, fin 번호에 1을 더한 값을 ack 번호로 전송하고 연결을 원하는 쪽은 syn 번호를 보내고 종료를 원하는 쪽은 fin 번호를 보내면됩니다. 참고 1) syn, ack, fin 이란?    syn, ack, fin    syn, fin  번호는 32비트의 난수로 생성되며 syn 또는 fin 플래그를 1로 만들고 seq번호를 번호를 전송하면 syn, fin 번호로 사용됩니다.    ack 는 syn fin에 대한 응답으로 받은 syn, fin 번호에 1을 더한 값을 ack 번호로 전송합니다. 다음은 TCP 헤더입니다. 1.syn 번호 전송 syn 비트를 1로 만들고, seq 번호를 보내면 syn 번호로 사용됩니다. 2. ack 번호 전송 ack 비트를 1로 만들고, ack 번호(그림에서 octet 8)를 설정 후 보내면됩니다.  ack가 syn 또는 fin번호 x에 1을 더해서 반환하는 이유는 x 번호를 잘 받았고, 다음 번호 x+1를 달라는 의미입니다. 3. fin 번호 전송 2) 왜 ISN(Initial Sequence Number)는 난수로 생성될까요? 맨 처음 연결을 위해 보내는 syn 번호를 ISN이라고 부릅니다. rfc793에 따르면 시퀀스 번호는 난수이며 32 bit입니다. 이는 이전 연결의 seq와 겹치지 않기 위함입니다. 만약 매번 0부터 시작한다면, 이전 연결에서의 시퀀스와 겹쳐 구분이 되지 않을 수 있기 때문입니다. 참고 하나의 bit가 약  4마이크로세컨드마다 증가 하기 때문에 ISN의 사이클은 약 4.55시간입니다. 이에 따라 seq 번호의 수명은 최대 4.55시간입니다. 이를 통해 ISN이 유니크함을 보장할 수 있습니다. 파이썬으로 계산하면 약 4.77시간 나옵니다. 약간 다를 수 있지뭐   자바스크립트 로드 밸런서를 만들어봅시다. 다루는 내용 로드밸런서 개요 라운드 로빈 구현 스티키 세션 구현 로드 밸런서란? 1) 정의 로드 밸런서란 부하 분배 장치로 분산 시스템에서 서버에 요청을 나누는 역할을 수행합니다. 2) L4 스위치 로드밸런서는  L4 스위치 라고도 불려집니다. 스위칭은 네트워크 요청을 목적지로 전달하는 역할을 하는데, OSI 7계층에서 3계층의 주소정보인  IP , 4계층의 정보인  포트 를 사용하기 때문입니다. 3) 알고리즘 라운드 로빈 스티키 기본적으로 라운드 로빈 방식을 따르지만, 세션이 연결되면 해당 서버와 통신합니다. 해싱   요청자의 IP를 해시로 만들어서 특정 서버에만 연결되도록 합니다. 4) 구현 직접 작성해봅시다. 간단하게 작성하기 위해 자바스크립트를 이용합니다. 1. 라운드 로빈 1) 라이브러리 설치   2) 서버 파일 작성 express 서버 3개를 만듭니다. 3) 로드밸런서 - rounrobin 작성 4) 확인  concurrently &quot;node server.js&quot; &quot;node roundrobin.js&quot;      http://localhost:80  으로 로드 밸런서를 호출하면  로드밸런서가 서버를 호출하고  서버에서 반환된 결과를 확인할 수 있습니다.   5) Nginx와 비교  Nginx 는 주로 정적 파일(React.js, Vue.js의 배포 파일)을 위한 웹서버로 사용합니다.  웹서버 이외에도 여러 기능을 담당하는데 그 중  로드밸런싱 도 있습니다.  자바스크립트로 작성한 라운드로빈 과  nginx의 라운드로빈 을 비교해봅시다. brew install nginx cd ~/usr/local/etc/nginx vi nginx.conf http://express-app 을 작성합니다. brew services start nginx http://localhost:8080 에서 실행됩니다. 참고:  brew services stop nginx  로 nginx 를 종료할 수 있습니다. 2. sticky 0) 개요 sticky는 기본적으로 라운드 로빈을 따르지만, 세션이 연결된 후에는 해당서버와 고정적으로 통신하는 방식입니다. 요즘은 SPA(react, vue)기반의 토큰 방식을 주로 사용하지만, 아직 세션도 많이 사용하니 알아봅시다. 1) 서버 파일 작성 2) sticky 로드 밸런서 작성 3) 확인 concurrently &quot;node server.js&quot; &quot;node sticky.js&quot;   http://localhost  접속 4) nginx와 비교 nginx의 무료 기능에는 session sticky가 없습니다. 나중에 AWS 클라우드로 해볼께요 1. 프로젝트 생성 라이브러리는 web, lombok만 넣어주었다. swagger는 검색 잘 안된다. 참고로 spring 2.5.9로 설정했는데 swagger랑 버전 차이가 너무 많이 나면 에러발생해서 애플리케이션 실행이 안된다. 정확히 무슨 버전과 잘 맞는지는 모른다. 하나씩 내려봐야한다.   2. Enable annotation processing 롬복 사용했으니까 체크해준다. 3. build.gradle 설정 swagger 2.9.2로 넣어주었다. 4. SwaggerConfig 5. 컨트롤러 생성 6. 실행 및 확인  http://localhost:8080/swagger-ui.html  기본 세팅은 여기로 설정되어있습니다.   1. 클래스 로딩 1) 정의 클래스 로더가 .class 파일을 찾고 JVM에 메모리에 올려놓는것을 의미합니다. 2) 왜 올려 놓는가 JVM은 실행될때 모든 클래스를 메모리에 올려놓지 않습니다. 그때 마다 필요한 클래스를 메모리에 올려 효율적으로 관리하기 위함입니다. 2. 그럼 언제 클래스를 로딩하는가 1) 가이드 클래스의 인스턴스가 생성될때 클래스의 정적 변수가 사용될때 (단, 정적 변수는 final로 선언된 상수 x) 클래스의 정적 메소드가 호출될때 2) -verbose:class  -verbose:class  옵션을 사용하면 클래스 로딩을 디버그 할 수 있습니다. 3) 확인 방법 테스트 케이스 하나씩 호출 javac 컴파일 -verbose:class 옵션으로 JVM 실행 클래스가 로드되는지 확인 Tets 0. 아무것도 호출하지 않음 2개의 클래스 작성 Main, Single 컴파일 하고, 실행합니다. Test 1. 인스턴스 생성 Test 2. 정적 변수 호출 - final (X) Test 3. 정적 변수 호출 - final (O) Test 4. 정적 메소드 호출 Single 클래스가 로딩되었습니다.   Test 5. 정적 내부 클래스의 변수 호출 클래스 로딩 정리 1) 클래스 로딩 시점 클래스의 인스턴스 생성 클래스의 정적 변수 사용 (단, 정적 변수는 final로 선언된 상수 x) 클래스의 정적 메소드 호출 2) 내부 클래스 로드 여부 1. 초기화 1) 정의 클래스 초기화는 static 블록과 static 멤버 변수의 값을 할당하는 것을 의미합니다.  내부의 클래스는 초기화 대상 x 2) 언제 초기화 되는가  오라클 JLS - 초기화 시점 클래스의 인스턴스 생성 클래스의 정적 메소드 호출 클래스의 정적 변수 할당 클래스의 정적 변수 사용 (final x) 사실 위의 클래스 로드 시점과 같습니다. 클래스가 로드되면 초기화도 바로 진행됩니다. 3) 초기화 진행순서 정적 블록 정적 변수 생성자   4) 오직 한번만 클래스가 로딩됨을 보장 JLS(Java Language Specification)에 따르면 JVM에 클래스가 로딩되고 초기화될때는 순차적으로 동작함을 보장합니다. 멀티 스레드 환경에서 여러개의 스레드가 클래스를 동시에 로딩하려고 오직 한개의 클래스만 로딩됩니다. 다음 코드는 10개의 스레드가 동시에 클래스의 인스턴스를 생성합니다. 결과를 보면 10개의 스레드가 동시에 클래스 로딩을 시도해도   클래스 로딩은 한번만 수행되고, 그때 한번 초기화를 수행 합니다. 이후 인스턴스를 10개 생성합니다. 이 의미는 멀티 스레드 환경에서 스레드 세이프함을 의미합니다.     싱글톤 갑자기 왜 싱글톤이냐면,  클래스 로딩 및 초기화 과정이 스레드 세이프함을 이용하여 싱글톤 인스턴스 를 만들 수 있기 때문입니다. 1) 정의 싱글톤은 인스턴스를 오직 1개만 가지는 클래스입니다. 2) 멀티 스레드 환경 멀티 스레드 환경에서는 여러 스레드가 동시에 인스턴스 생성을 시도할 수 있고, 싱글톤 인스턴스가 여러개 생성될 수 있습니다. 3) 클래스 로딩 및 초기화가 딱 한번만 수행됨을 활용 클래스 로딩 및 초기화는 10개의 스레드가 동시에 시도해도 오직 단 한번만 수행됩니다. 이때 수행되는 초기화 과정에서 클래스의 인스턴스를 딱 한번만 생성되도록 합니다. 아래의 방법은  LazyHolder  라는 방법으로 싱글톤 인스턴스를 생성하는데 가장 권장되는 방법중 하나입니다.(다른 하나는 enum 사용) 장점 스레드 세이프 보장 필요할때 인스턴스 생성(getInstance 메소드가 호출될때) 모든 자바 버전에서 적용가능 총 정리 1) 클래스 로딩 시점 클래스의 인스턴스 생성 클래스의 정적 변수 사용 (단, 정적 변수는 final로 선언된 상수 x) 클래스의 정적 메소드 호출 2) 외부, 내부 클래스 로딩 3) 초기화 의미 static 블록 수행 static 변수 메모리 할당 4) 클래스 로딩 및 초기화 클래스가 로딩될때 초기화도 수행 클리스 로딩 및 초기화 과정은 스레드 세이프함, 여러 스레드가 동시에 시도해도, 오직 한번만 수행 5) 싱글톤 - LazyHolder 클래스 로딩 및 초기화 과정이 스레드 세이프함을 이용하는 방법 장점 스레드 세이프 (오직 1개의 싱글톤 인스턴스 생성) 필요할때 인스턴스 생성(getInstance 메서드 호출 시점) 모든 자바 버전에서 사용가능 혹시 그런적 있으신가요? 1. NAT (Network Address Translation) 1) 정의 NAT는 하나의 네트워크 주소를 다른 네트워크의 주소로 변환하는 기술입니다. 2) 왜 사용하는가? 3) 실생활 예시 정말 알게 모르게 일상생활에서 많이 사용하고 있습니다. - 공유기 - SNAT(Source NAT) - 출발지의 주소 변경 공유기로 접속하는 망은 사설망이고, 외부로 나가려면 공유기의 NAT 기능을 통해 IP주소를 할당 받아야합니다. - 로드밸런서 - DNAT(Destination NAT) - 도착지의 주소 변경 외부의 사용자는 로드밸런서의 가상IP를 보고 요청합니다. 로드밸런서는 NAT를 통해 목적지 IP를 실제 서버의 real IP로 변환합니다. 4) 동작방식   2. 정리 정리하면 ipconfig 명렁어로 확인한 IP - 사설 아이피 네이버로 확인한 IP - 공인 아이피 만약, 님이 AWS에 방화벽 설정해놓고, 특정 아이피만 접근가능하게 하려면 사설 아이피를 허용해야 할까요? 공인 아이피를 허용해야 할까요? 공유기에는 출발지의 주소를 변경해야하는 SNAT이 적용되었고 AWS 가는 시점에는 사설 아이피가 아니라 공인 아이피로 호출되기 때문에 정답은 공인 아이피 내가 그냥 사설 아이피 뚫었는데 안되어서 책 읽다가 알게되어서 반성용으로 적어봤어 참고 IT 엔지니어를 위한 네트워크 입문 - NAT/PAT 1. MAC (Media Access Control) 1) 정의 데이터 링크 2계층에서 통신을 위해  랜카드 에 할당된  고유 식별자 입니다. MAC 주소는 OSI 7계층의 2계층의 주소로 사용됩니다. 2) MAC 주소 체계   크게 2개로 나눠집니다. OUI - IEEE가 제조사에 할당 UAA - 제조사가 네트워크 구성 요소에 할당 총 48bit(6byte)로 구성됩니다.(문자 하나에 8bit-1byte) 12자리의 16진수(16진수는 하나에 4bit) 3) BIA (Burned-In Address) MAC주소는 네트워크 카드를 생산할 때 하드웨어적으로 정해져 나오기 때문에 Burned-In Address라고 부릅니다. 랜카드마다 하나의 MAC 주소를 가집니다. 고정되어 출하되지만, 결국에는 메모리에 적재되어 구동되기 때문에 운영체제에서 변경 가능합니다. 4) MAC 주소로 제조업체 찾기  링크  에서 찾을 수 있습니다.   예시의 OUI는 제가 임의로 작성한 것이기 때문에 없습니다. 2. 랜카드 MAC 주소는 OSI 7계층의 2계층(데이터 링크)에서 주소로 활용됩니다. 2계층의 장비는 랜카드가 있고 랜카드가 MAC 주소를 활용하는 방식에 대해 알아봅시다. 1) 정의 하나의 네트워크 안에서 컴퓨터간 신호를 주고 받는데 사용하는 하드웨어입니다. 2) 작동방식 전기 신호를 데이터로 만듭니다. 목적지의 MAC 주소와 출발지의 MAC 주소를 확인합니다. 랜카드의 MAC 주소를 확인합니다. 목적지의 MAC 주소와 랜카드의 주소가 맞으면 데이터를 상위 계층에서 처리할 수 있도록 메모리에 올리고, 다르면 폐기합니다. 4) 참고 랜카드는 다른 이름으로도 불려집니다. NIC(Network Interface Card, Network Interface Controller)  네트워크 카드 랜카드 - 과거에 이더넷이 LAN에서 사용되어 부르게된 이름 물리 네트워크 인터페이스 이더넷 카드 네트워크 어댑터 3. MAC 주소 중복 만약 어떠한 의도나 실수로 인해 MAC 주소가 중복되는 경우 제대로 동작하지 않을 수 있습니다. 다만, 하나의 네트워크에서만 중복되지 안으면 동작하는데 문제가 없습니다. 라우터(3계층)에서 다른 네트워크로 넘겨줄 때 출발지와 도착지의 MAC 주소가 변경되므로 네트워크를 넘어가면 기존 출발지와 도착지의 MAC 주소를 유지하지 않습니다. 4. 무차별 모드(Promiscuous Mode) 기본적으로 랜카드(NIC)는 패킷이 자신의 MAC 와 일치하지 않는 도착지를 가진 경우 자체적으로 폐기됩니다.  다만, 네트워크 상태를 모니터링을 위해 전체 패킷을 수집 분석해야하는 경우, NIC가 정상적으로 동작하면 다른 목적지를 가진 패킷을 분석할 수 없습니다. 다른 목적지를 가진 패킷을 분석하거나 수집해야하는 경우 무차별 모드로 NIC를 구성합니다. 이렇게 하면 자신의 MAC주소와 상관없는 패킷이 들어와도 분석할 수 있도록 메모리에 올려 처리할 수 잇게 됩니다.  무차별 모드 를 사용하는 가장 대표적인 프로그램에는  와이어샤크 가 있습니다. 두 개의 head of line(HOL) blocking 웹에서 HOL Blocking을 말할 때에는 두 가지 종류가 있다.  HTTP 에서의 HOL Blocking  TCP 에서의 HOL Blocking 이 두 가지는 다른 것이므로  어떤  레이어에서의 이야기인지를 명시해야할 필요가 있다. HTTP에서의 HOL Blocking  HTTP/1.1 의 요청-응답 쌍은 항상 순서를 유지하고 동기적으로 수행되어야 한다. 구체적으로 1개의 TCP 커넥션 상에서 3개의 이미지 ( a.png ,  b.png ,  c.png )를 받는 경우, HTTP 리퀘스트는 다음과 같이 된다. 하나의 요청이 처리되고 응답을 받은 후에 다음 요청을 보낸다. 이전의 요청이 처리되지 않았다면 그 다음 요청은 보낼 수 없다는 것이다. 만약  a.png 의 요청이 막혀버리게 되면  b,c 가 아무리 빨리 처리될 수 있더라도 전체적으로 느려지게 된다. 이것이 바로  HTTP/1.1 의 HOL Blocking이다.  HTTP/1.1 의  pipelining 이라는 사양은 (조건부로) 요청만 먼저 보내버리는 것으로, 이 문제를 회피하는 것처럼 보인다. 그러나 응답을 보낸 순서대로 무조건 받아야 하므로  a.png 가 막혔을 경우에 생각보다 큰 효과를 보기 어렵다. HTTP/2의 경우  HTTP/2 의 경우 요청은 하나의 연결에서 병렬적으로 보내질 수 있다. 즉,  a ~ c.png 가 모두 병렬적으로 요청되고, 응답된다는 것이다. 따라서  a.png 가 시간이 걸리는 처리에서도,  b,c.png 는 먼저 받아서 보여줄 수 있다는 것이다. 따라서  HTTP/1.1 에서의 HOL Blocking은  HTTP/2 에서는 발생하지 않는다고 말할 수 있다. 또한  HTTP/2 는 접속의  Flow Control  과 중요한 자원의 우선순위를 부여하는  Priority  를 가지고 있기 때문에 세세한 제어가 가능하다. TCP에서의 HOL Blocking  TCP 에서의 HOL Blocking은  HTTP  요청/응답을  TCP  패킷 레벨로 바꾼 거라고 생각하면 된다.  TCP 는 패킷을 전송할 때에, 전달을 보장하기 때문에 패킷이 손실되면 재전송하게 된다. 그리고 재전송이 발생하면 패킷의 순서가 역전되지 않도록 후속 패킷이 대기하게 된다. 즉,  TCP  상에서 3개의 패킷을 보낼 때, 먼저 보낸 패킷에서 손실이 발생하면 뒤도 막히게 된다. 이것이  TCP 에서의 HOL Blocking 이다. 예를 들어,  HTTP/2 로 다중화된 요청은  TCP 에서는 단순한 패킷이므로 패킷이 막히면 전체가 지연되는 문제는 피할 수 없다. 오히려 1개의  TCP  커넥션으로 전부를 처리하고 있기 때문에 여러 개의  TCP 를 사용할 때보다 영향이 클 수도 있다. 실제로 테스트를 통해 패킷 손실률이 2%일 때 (이는 끔찍한 네트워크 품질이다), HTTP/1 사용자가 오히려 더 나은 것으로 입증되었다. 그 이유는 HTTP/1이 보통 패킷을 분배하는 데 6개의 TCP 연결을 갖고 있어서 손실된 패킷이 없는 연결은 계속 사용할 수 있기 때문이다. 문제를 완화하기 위한 시도들 혼잡 제어 알고리즘 PRR과 BBR 사용 대부분의  TCP  구현에서는  CUBIC  알고리즘을 사용한다. 이 알고리즘은 패킷이 손실될 때 혼잡 제어 창을 절반으로 줄이는 것을 감소시키는  PRR 로 강화됐다.  그리고 훨씬 더 새로운 알고리즘인  BBR (Bottleneck Bandwidth and Roundtrip propagation time)  은 HTTP/2 연결에 대해 성능을 더 향상시키는 것으로 확인됐다.    구글은 BBR을 적용 후 TCP 트래픽을 강화해서 전 세계 평균적으로 YouTube 네트워크 처리량을 평균 4 %, 일부 국가에서는 14 % 이상 개선했다고 한다. 이 후에 BBRv2 알고리즘도 발표되었고, Youtube에 적용이 되었다. 다음과 같은 개선이 있다고 한다. Reduced queuing delays: RTTs lower than BBR v1 and CUBIC Reduced packet loss: loss rates closer to CUBIC than BBR v1 QUIC 프로토콜의 제안  QUIC(Quick UDP Internet Connections) 는 이름에서도 볼 수 있듯,  TCP 가 아닌  UDP 위에서 자체적으로 재전송 제어 메커니즘을 구성한다. 그리고, 그 다중화는, 처음부터 패킷 레벨의 HOL Blocking이 발생하지 않도록 설계되고 있다. 따라서  HTTP/3 의 경우 두 HOL Blocking 문제가 모두 해결된다.  HTTP/3 의 가장 큰 특징은  TCP/IP  기반의 애플리케이션 레이어 프로토콜인  HTTP 를  UCP  기반의  QUIC  위에 얹었다는 것이다. 이를  HTTP over QUIC 라고 표현하고 줄여서  HQ 라고 한다.  HTTP/2 에 있는 프레임, 스트림, 메시지 구조와 기술들은 그대로  HTTP/3 로 승계되었고, 명칭만  HQframe ,  QPACK  등으로 변경되었다. 해당 글은  백기선 님의  [개발자로 살아남는 방법] EP05. 개발자가 갖춰야 할 &quot;판단력&quot;이란? 을 보고 정리한 내용입니다. Before we begin 내 역할을 리액트 프론트엔드 개발자, 이런 식으로 제한하지 말자. 어쩌다보면 내가 Svelte를 할 수도 있고, 백엔드 개발(?)을 하고 있을 수도 있다. 내 역할을 제한하는 것은 내 기회를 좁히는 것과 같다. 제 1원칙: 모호함을 걷어내고 정보에 기반한 결정을 할 것 애매한 것, 확실하지 않은 것들을 정리하는 것이 좋다. 우리가 어떤 결정을 할 때, 근거로 삼는 문장들을 보면 분명 가정이 있을 것이다. 이렇다하는 전제 하에 ...  이 전제가 가끔 틀린다.  그래서 이 전제를 무조건 검증하는 것이 좋다. (Clarification) 이를 위해  전문가 의 조언을 받거나,  테스트 를 짤 수 있거나하면 좋다. 잠시 인생 얘기 누구와 결혼할 것인가. 이것도 정보에 기반해서 결정을 해야지, 호르몬으로 인한 상상으로 판단해서는 안된다ㅋㅋ 제 2원칙: 적절한 시간안에 결정을 내릴 것 우리가 보통 결정이 늦어지는 이유는 어려운 문제에서 완벽한 결정을 내리고 싶기 때문이다. 하지만 지금 이 순간 내가 가진 정보 안에서  조금 완벽하지 않더라도  그냥 시간 안에 결정을 하는 것이 낫다. 우리가 피드백할 수 있는 시간을 놓치고 있는 것이다. 실패했으면 그에 대한  데이터 를 쌓을 수 있는 것이고, 성공했다면 그만큼  앞질러  갈 수 있을 것이다. 제 3원칙: 당장 반드시 해야할 일과 나중에 개선할 일을 구분하라 업무의 범위(scope)를 잘 정해야 한다.  당장 할 수 있는 일과 나중에 해도 되는 일을 구분하자. 각 팀이 맡고 있는 업무가 무엇인지, 각 팀이 맡고 있는 책임이 무엇인지를 우선 알아야 한다. 왜 이 업무가 우리팀에 주어지는지, 왜 이 업무는 다른팀과 연관이 있는지 알 수 있게 되고,  결정 을 할 수 있게 된다. 이 업무는 우리팀에서 이번에 하면 좋겠다. 이 업무는 조금 미뤄도 되겠다. 이 업무는 다른팀과 같이하면 좋겠다. 이런식으로 사고할 수 있다면  주니어 레벨 을 벗어난 것이다. 그리고 전문가가 어디에 있느냐, 어느 팀이 더 많은 전문 지식을 갖고 있느냐가 중요하다. 시야를 높게 보면  어떤 팀에 이익이 되는 것은 사실 중요하지 않다 . 누가 그 문제를 잘 해결할 수 있는지가 중요하다. 제 4원칙: 실수를 인정하라 누구나 실수를 한다. 그렇기 때문에 실수를 포용할 수 있는 분위기가 되어 있어야 한다. 책임전가할 필요도 없다. 실수를 하면 빨리 고치고, 단 한마디면 충분하다. 내가 이거를 revert 했고, cherry-pick해서 배포 고치겠다. 그리고 이 이슈는 왜 발생했는지 root-cause 설명하고. 아직 root-cause 모르면 investigation 하고 있다. 남탓하지 않기. 유연한 사고. 제 5원칙: 우리가 중요하게 여기는 가치에 부합하지 않는 것에 이의를 제기하라 가만히 있으면 똑같은 사람이 되는 거다. 누군가 비난을 하는데 개입하지 않는다면 똑같은 사람이 되는 것이다. 우리는 고객 만족을 목표로 하고 있는데 고객이 원하지 않는 것을 하고 있다면? 이의를 제기하자. 이의 제기를 함으로써 그 사람, 그 팀에게 도움이 될 수 있다. 계속 나오는 얘기지만, 우리는 의견끼리 충돌하는 것이지 사람끼리 충돌하는 것이 아니다. Review 나는 감정의 노예다. MBTI 검사를 할 때, 다른 것들은 한번씩 바뀌어 나오는 경우가 있어도 F는 항상 고정이었다. 기선님이 이의를 잘 제기할 수 있는 사람은 그런 쓴 소리를 잘 들을 수 있는 사람이라고 하셨는데, 굉장히 공감이 되었다. 내가 딱 못하는 이유를 콕 집어서 말씀해주셨다. 판단을 할 때는 최대한 감정을 빼고 결정하는 연습을 해봐야 겠다.  1장에서 다루는 내용 웹 페이지가 브라우저에 로드되는 방식 HTTP가 무엇이고 HTTP/1.1까지 어떻게 진화했는지 HTTPS의 기초 기본 HTTP 도구 1.1 웹의 동작 방식 대다수의 사람이 인터넷을 서핑하고자 웹 브라우저를 사용하는 방법을 알고 있기는 하지만, 소수만이 해당 기술이 어떻게 동작하는지, 왜 HTTP가 웹의 핵심인지, 또는 왜 다음 버전(HTTP/2)이 웹 커뮤니티에서 그 정도의 흥분을 불러일으키는지 이해한다. 1.1.1 인터넷과 월드 와이드 웹 많은 사람에게 인터넷과 월드 와이드 웹은 같은 뜻이지만, 두 용어를 구분 짓는 것은 중요하다. 인터넷은 인터넷 프로토콜 (IP, Internet Protocol) 을 공유해 메세지를 라우팅하는 식으로 연결된 공용 컴퓨터의 모음이다. 인터넷은 월드 와이드 웹, 이메일, 파일 공유, 인터넷 전화 등의 여러 서비스로 구성된다. 따라서 월드 와이드 웹이 인터넷에서 가장 잘 보이는 부분이긴 하지만, 그저 일부분일 뿐이다.   HTTP는 웹 브라우저가 웹 페이지를 요청하는 방식이다. HTTP를 살펴볼 때 주로 월드 와이드 웹을 다루게 된다. 그러나 전통적인 웹 프론트엔드 없이도 서비스들이 HTTP 기반으로 구축되기 때문에 경계선은 더욱 흐려지고 있고, 이는 웹 자체를 정의하는 것이 더욱 까다로워지고 있음을 의미한다. (IoT같은 예가 있다.) 이 모든 것은 월드 와이드 웹이라는 용어가 올바르지 않게 인터넷과 자주 혼용돼 사용되더라도 크게 어긋나지 않는다는 것을 나타낸다. 1.1.2 웹을 돌아다닐 때 일어나는 일 이 책을 최대한 활용하려면 웹 탐색이 동작하는 방식을 정확히 이해해야 한다. 브라우저를 작동시켜  www.google.com  으로 이동한다고 하자. 몇 초만에 다음 그림과 같은 일이 일어날 것이다.    브라우저는  www.google.com의  브라우저가 웹 서버와 연결을 맺고 있으면 웹 사이트를 요청하기 시작할 수 있다. 이 단계에서 HTTP가 관여한다.  구글 서버가 요청받은 URL에 응답한다. 일반적으로 첫 페이지에서 돌려받는 것은 HTML 형식의 텍스트지만, 구글은 https로만 운영되기 때문에  https://www.google.com 404 Not Found 다  웹 브라우저가 반환된 응답을 처리한다. HTML을 받았다면 코드 해석을 시작하고 메모리에 해당 페이지의 내부 표현인 DOM (Document Object Model)을 구축한다.  웹 브라우저가 추가로 필요한 리소스를 요청한다. 구글은 상당히 간결하게 웹 페이지를 유지한다. 구글의 경우 이 단계에서 16개의 리소스만 요청하는데, 이러한 리소스 각각이 1 ~ 6 단계를 따라 유사한 방식으로 요청된다.  브라우저가 중요한 리소스를 충분히 얻으면 화면에 페이지를 그리기 시작한다.  페이지를 처음 표시한 후 웹 브라우저는 백그라운드에서 페이지에 필요한 다른 리소스들을 계속 다운로드하고 처리하는 대로 페이지를 업데이트한다.  완전히 로드되면 브라우저는 로딩아이콘을 멈추고, 자바스크립트 코드에서 페이지가 어떤 동작을 수행할 준비가 됐다는 표시로 사용할 수 있는  OnLoad  이벤트를 발생시킨다.  이 후로도 계속 필요한 리소스를 요청하고 받는다. 페이스북 피드가 새로고침 버튼 없이도 업데이트 되는 걸 생각하면 이해하기 쉽다. 1.2 HTTP란 무엇인가? 앞에서 언급한 것 처럼 HTTP는 하이퍼텍스트 전송 프로토콜을 의미한다. 이름처럼 처음에는 하이퍼텍스트 문서 (다른 문서로의 링크를 담은 문서)를 전송할 의도로 만들어 졌다. 하지만 개발자들이 이 프로토콜을 다른 문서 유형을 전송하는 데 사용될 수 있음을 곧 깨달았고, HTTP라는 약자가 적절하지는 않지만 바꾸기에는 너무 늦게 된 것이다. HTTP는 TCP/IP가 제공하는 안정적인 네트워크 연결에 의존하지만, 네트워크 연결이 설정되는 방법의 하부 수준 세부 사항을 다루지는 않는다. HTTP 애플리케이션이 네트워크 오류와 연결 종료를 어떻게 다룰지 염두에 둬야 하지만 프로토콜 자체는 이러한 작업까지 감안하지는 않는다. 다음 그림은 이 모델이 웹 트래픽에 연결된 방식과 HTTP가 이 모델의 어디에 들어맞는지를 대략적으로 보여준다.   HTTP는 본질적으로 요청 및 응답 프로토콜이다. 웹 브라우저가 HTTP 문법을 사용해 요청을 만들고 웹 서버로 보내면 웹 서버는 요청받은 리소스를 포함한 메시지로 응답한다. 연결을 맺은 다음 HTTP 요청의 기본 문법은 다음과 같다.  GET /page.html↵ ↵ 기호는 줄 바꿈 문자를 나타낸다. 기본 형식에서 HTTP는 이정도로 단순하다. HTTP 메서드 중 하나를 주고, 그 다음 원하는 리소스를 넣는다. 이 지점에서 기억할 것은 이미 TCP/IP와 같은 기술을 사용해 적절한 서버에 연결됐고, 단순히 그 서버에서 원하는 리소스를 요청하는 것이기 때문에 연결이 어떻게 일어나거나 유지되는지는 관계할 필요가 없다는 것이다. 맥이라면 다음과 같은 방식으로 HTTP 요청을 날려볼 수 있다. 앞서 언급한 것처럼 HTTP의 성공 비결은 서비스 수준에서 비교적 HTTP를 구현하기 쉽게 만들어준 간결함이다. 또한 HTTP가 단순하기 때문에 애플리케이션이 수많은 독립적인 웹 서비스로 쪼개지는 마이크로 서비스 아키텍처 스타일의 대유행이 이어졌다. 1.3 HTTP의 문법과 역사 1.3.1 HTTP/0.9 처음으로 공개된 HTTP의 사양은 1991년에 공표된 버전 0.9다. 이 사양의 길이는 700 단어 미만으로 짧다. GET, 문서 주소(공백 문자 없이), 캐리지 리턴 CR 과 라인 피드 LF (캐리지 리턴은 선택 사항)로 구성된 ASCII 텍스트 한줄이 전송돼야 한다. 서버는 HTML 형식의 메시지로 응답해야 하는데, 사양에는  ASCII 문자로 된 바이트 스트림 으로 정의한다. 메시지는 서버의 연결종료로 끝나야 한다. 그리고 오류 응답은 HTML 문법으로 된 사람이 읽을 수 있는 텍스트로 제공돼야 한다. 텍스트 내용 외에는 오류 응답을 성공적인 응답과 구분할 방법은 없다. 요청은 idempotent이다. (여러 번 적용하더라도 결과가 달라지지 않는다.) 서버는 연결 종료 후 요청에 대한 어떤 정보도 저장할 필요가 없다. 다음은 HTTP/0.9에서 가능한 유일한 명령이다.  GET /section/page.html↵ 1.3.2 HTTP/1.0 월드와이드웹은 거의 즉시 성공해버렸다. 대다수의 웹 서버는 벌써 0.9 사양을 훨씬 넘어선 확장을 구현했다. 1996년 5월 HTTP/1.0이 RFC 1945로 발표됐으나, 공식사양은 아니다. 이 문서의 최상단에는 다음과 같이 서술하고 있다. 이 메모는 인터넷 공동체를 위해 정보를 제공한다. 이 메모는 어떤 종류의 인터넷 표준도 명시하지 않는다. RFC의 공식 상태와 관계 없이 HTTP/1.0은 다음과 같은 몇 가지 주요 기능을 추가했다.  더 많은 요청 메서드 :  HEAD 와  POST 가 추가됐다.  선택적인 HTTP 버전 번호가 모든 메시지에 추가됨 : 이전 버전과의 호환성을 쉽게 제공하고자 Default는 HTTP/0.9로 설정됐다.  요청 및 응답 모두에 같이 보내질 수 있는 HTTP 헤더 : 요청 받은 리소스와 전송하는 응답에 대한 더 많은 정보를 제공한다.  응답이 성공적인지 등의 정보를 표시하는 3자리 응답코드 : 이 코드는 리디렉션 요청, 조건부 요청, 오류 상태를 가능하게 했다. 사실 HTTP/1.0은 새로운 기능을 정의했다기보다는 이미 일어난 일을 문서화하기 위한 것이었다. HTTP/1.0 메서드  GET  메서드는 HTTP/0.9와 거의 동일하게 남기는 했지만 헤더의 추가는 조건적인 GET을 가능하게 했다. 앞서 언급한 것처럼 사용자는 하이퍼텍스트 문서보다 더 많은 것을 GET 메서드로 얻을 수 있고, 그 외의 어떤 종류의 미디어를 다운로드하는 데에도 HTTP를 사용할 수 있다.  HEAD  메서드는 리소스 자체를 다운로드받지 않고도 클라이언트가 리소스에 대한 모든 메타정보를 얻을 수 있도록 허용한다.  POST  메서드는 클라이언트가 웹 서버에 데이터를 전송할 수 있게 해준다. POST 메서드는 콘텐츠가 HTTP 요청의 요소로서 클라이언트에서 서버로 보내지게 하며, 처음으로 HTTP 요청이 HTTP 응답과 같이 본문을 가질 수 있음을 나타낸다. HTTP 요청 헤더 HTTP/1.0은 HTTP 헤더를 도입했다. HTTP GET 요청은 다음과 같은 형식에서  GET /page.html↵ 다음과 같이 변경됐다. 또는 헤더 없이 다음과 같이 사용할 수도 있다. HTTP/1.0이 표준 헤더를 몇 가지 정의했지만, 사용자 정의 헤더를 허용한다는 것도 보여준다. 사양에는 수신자가 이러한 필드를 인지할 수 있다고 가정할 수 없으며, 무시할 수 있는 반면, 표준 헤더는 HTTP/1.0 호환 서버에서 반드시 처리돼야 한다. 고 명시적으로 서술했다. 전형적인 HTTP/1.0 GET 요청은 다음과 같다. HTTP 응답 코드 HTTP/1.0 서버의 전형적인 응답은 다음과 같다. 여기 서 자세히 볼 수 있다. 카테고리 값 코드 기술 상세 설명 1xx N/A N/A HTTP/1.0은 어떤 1xx 상태코드도 정의하지 않지만 카테고리는 정의한다 2xx(Successful) 200 OK 이 코드는 성공적인 요청에 대한 표준 응답 코드다. 201 Created 이 코드는 POST 요청에 대해 반환해야 한다. 202 Accepted 이 요청은 처리되고 있지만 아직 처리가 완료되지 않았다. 204 No Content 이 요청은 수락되고 처리됐지만 반환할 어떤 BODY 응답도 없다. 3xx(Redirection) 300 multiple choices 이 코드는 직접적으로 사용되지 않는다. 301 Moved permanently  Location  HTTP 응답 헤더는 리소스의 새로운 URL을 제공해야 한다. 302 Moved temporarily 304 Not modified 이 코드는 BODY가 다시 전송될 필요가 없다는 조건적 응답으로 사용된다. 4xx(Client Error) 400 Bad request 요청이 해석될 수 없었으며 재전송되기 전에 변경돼야만 한다 401 Unauthorized 이 코드는 보통 인증되지 않았음을 의미한다 403 Forbidden 이 코드는 보통 인증이 됐지만 접근 권한이 없음을 의미한다 404 Not found 5xx(Server Error) 500 Internal server error 요청이 서버 측 오류로 완료될 수 없다 501 Not Implemented 서버가 요청을 인지하지 못했다. 502 Bad gateway 서버가 게이트웨이나 프록시의 역할을 하며 다운스트림 서버에서 오류를 수신했다 503 Service unavailable 서버의 부하가 지나쳤거나 유지 보수를 위해 내려가 있어서 요청을 이행할 수 없었다 HTTP 응답 헤더 첫 응답 줄 다음에는 HTTP/1 헤더 응답 줄이 0줄 이상 있다. 요청 헤더와 응답 헤더는 동일한 형식을 따른다. 헤더 다음에는 두 개의 리턴 문자가 있고, 그 다음에는 본문 내용이 있다. 1.3.3 HTTP/1.1 HTTP/1.1은 HTTP 프로토콜을 최적화해 사용할 수 있도록 몇 가지 사항(지속적 연결, 필수 서버 헤더, 개선된 캐싱 옵션, 청크 인코딩 등)을 더 개선했다. HTTP/1.1을 설명하려면 자체로 책 하나가 필요하겠지만, 여기에서는 이 책의 뒷 부분에 나올 HTTP/2의 논의에 대한 배경과 맥락을 제공하는 데 필요한 요점을 다루려고 한다. 필수적인 호스트 헤더 HTTP 요청 행에서 제공된 URL은 절대 URL이 아니라 상대 URL이다. HTTP가 생성됐을 때는 하나의 웹 서버가 하나의 웹 사이트만 호스팅한다고 가정했다. 그러나 오늘날 많은 웹 서버는 여러 사이트를 동일한 서버에서 호스팅한다. 따라서 이 기능은 요청에 Host 헤더를 추가하는 방식으로 구현됐다. 이 헤더는 HTTP/1.0에서는 선택적이었지만 HTTP/1.1에서는 필수적이다. 지속적인 연결 처음에 HTTP은 단일 요청 및 응답 프로토콜이었다. 클라이언트가 연결을 맺고, 리소스를 요청하고, 응답을 받으면 연결이 종료됐다. 웹에 미디어가 더 풍부해짐에 따라 이 연결 종료는 낭비로 밝혀졌다. 이 기능은 새로운 Connection 헤더로 해결됐다. 이 헤더에 Keep-Alive를 지정함으로써 클라이언트는 서버에 추가적인 요청 전송을 허용하고자 연결을 맺은 채로 그대로 두라고 요청한다. 서버는 평상시처럼 응답하지만 지속적인 연결을 지원하는 경우  Connection: Keep-Alive  헤더를 응답에 포함한다. 연결 종료가 없어지면서 언제 응답이 완료됐는지 알기가 어려워졌으며, 응답 본문의 길이를 정의하고자 Content-Length HTTP 헤더를 사용해야 한다. HTTP/1.1은 이 절차를 표준에 추가한 데 그치지 않고 더 나아가 이 절차를 기본값으로 변경했다. 어떤 HTTP/1.1 연결이든  Connection: Keep-Alive  헤더가 응답에 없더라도 지속적인 연결을 사용 중이라고 가정할 수 있다. 어떤 이유로든 연결을 종료하고 싶다면  Connection: Close  헤더를 응답에 포함시켜야 한다. 기타 새로운 기능 HTTP/1.1은 다음을 포함하는 다른 많은 기능을 도입했다. HTTP/1.0에서 정의된 GET, POST, HEAD에 새로운 메서드 PUT, OPTIONS와 잘 사용되지는 않는 CONNECT, TRACE, DELETE가 추가됐다. 개선된 캐싱 방법을 도입해 서버가 리소스를 브라우저의 캐시에 저장해서 필요하면 나중에 재사용할 수 있도록 클라이언트에 지시할 수 있다. Cache-Control HTTP 헤더는 HTTP/1.1에 HTTP/1.0의 Expires 헤더보다 많은 옵션을 도입했다. HTTP가 상태 없는 프로토콜에서 상태를 가질 수 있게 하는 HTTP 쿠키를 도입했다. HTTP 응답에서의 문자 집합과 언어를 도입했다. 프록시 지원 기능을 도입했다. 인증 기능을 도입했다. 새로운 상태 코드를 도입했다. 후행 헤더를 도입했다. 1.4 HTTPS 개론 HTTP는 원래 일반 텍스트 프로토콜이었다. HTTP 메시지는 인터넷을 통해 암호화되지 않은 상태로 전송됐으며, 따라서 메시지가 목적지로 라우팅될 때 메시지를 보는 모든 참여자가 읽을 수 있다. HTTPS는 전송중의 메시지를 전송 계층 보안 (TLS, Transport Layer Security) 프로토콜을 사용해 암호화하는 HTTP의 보안 버전이다. HTTPS는 HTTP 메시지에 다음과 같은 세 가지 중요한 개념을 추가했다.  암호화 : 메시지는 전송 중에 제3자에게 읽힐 수 없다.  무결성 : 암호화된 메시지가 디지털 서명되고 서명이 복호화되기 전에 암호학적으로 검증되기 때문에 메시지는 전송 중에 변경되지 않는다.  인증 : 서버는 클라이언트가 메시지를 주고받으려던 바로 그 서버다. HTTPS는 공개키 암호화를 사용해 동작하므로 사용자가 처음 연결할 때 서버가 디지털 인증서 형태의 공개키를 제공할 수 있다. 브라우저는 이 공개키를 사용해 메시지를 암호화한다. 짝이 되는 개인키는 서버만이 가졌으므로 서버에서만 메시지를 복호화할 수 있다. HTTPS는 HTTP를 기반으로 하며 HTTP 프로토콜 자체와 거의 원활하게 이어진다. 기본값으로 다른 포트에서 호스팅되며 다른 URL 체계를 갖지만 암호화와 복호화를 제외하고는 HTTP가 사용되는 방식과 같다. 클라이언트가 HTTPS 서버에 접속하면 협상 단계(TLS 핸드셰이크)를 거치게 된다. 이 과정에서 서버는 공개키를 제공하고, 클라이언트와 서버는 사용할 암호화 방식에 합의하고, 그 다음 클라이언트와 서버가 미래에 사용할 공유 암호화 키를 협상한다. 1.5 HTTP 메시지를 보고 보내고 받는 용도로 쓰이는 도구 커맨드라인 도구는 한계가 있으며, 그 중 무엇도 대다수의 대규모 웹 페이지를 다루지 못한다. 텔넷보다 나은 방식으로 HTTP 요청을 보고 보낼 수 있는 여러 도구가 있다. 1.5.1 웹 브라우저의 개발자 도구 사용 개발자 도구를 열고 페이지를 로드하면 네트워크 탭은 모든 HTTP 요청을 보여주고, 그 중 하나를 클릭하면 요청 및 응답 헤더를 포함한 상세한 정보를 생성한다. HTTPS를 브라우저가 다루기 때문에 개발자 도구는 암호화되기 전의 HTTP 요청 메시지와 복호화된 후의 응답 메시지만 보여준다. 대부분의 경우 암호화와 복호화를 처리할 수 있는 적절한 도구가 있다면 HTTPS를 설정한 다음에 무시할 수 있다. 1.5.2 HTTP 요청 전송 Advanced REST client 애플리케이션은 가공하지 않은 HTTP 메시지를 보내고 응답을 보는 방법을 제공한다. Postman, Rested, RESTClient, RESTMan 등의 유사한 애플리케이션들은 모두 비슷한 기능을 갖고 있다. 1.5.3 HTTP 요청을 보고 전송하기 위한 기타 도구 브라우저 밖에서도 많은 도구를 사용할 수 있다. 일부는 커맨드라인(curl, wget, httpie)에서 동작하고 일부는 데스크톱 클라이언트(SOAP-UI)와 동작한다. 요약 HTTP는 웹의 핵심 기술 중 하나다. 브라우저는 웹 페이지 하나를 로드하고자 여러 개의 HTTP 요청을 생성한다. HTTP 프로토콜은 단순한 텍스트 기반 프로토콜로 출발했다. HTTP는 더욱 복잡해졌지만, 기본적인 텍스트 기반 형식은 지난 20년동안 변경되지 않았다. HTTPS는 표준 HTTP 메시지를 암호화한다. HTTP 메시지를 보고 전송하는 데 다양한 도구를 사용할 수 있다. 해당 글은  백기선 님의  [개발자로 살아남는 방법] EP04. &quot;협업&quot;은 어떻게 하는 것인가? 을 보고 정리한 내용입니다. Before we begin 본인이 회의에서 어느 정도 깊이까지 공유를 해야하는 지에 대해서 고민이 될 수 있다. 이럴 때 굉장히 장황하게, 굉장히 디테일하게 설명하는 경우가 있는데, 신입으로서는 나쁘지 않다. 이걸로 내가 알고 있는 지식에 대한 점검을 할 수도 있다. 너무 자세히 말하거나 덜 자세히 말하는 건 그렇게 큰 실수가 아니다. 덜 깊이 얘기하고 이게 좀 부족하다면 누군가 더 자세히 말해달라고 요청할 거다. 하지만 2-30명이 있는 회의에서는 가급적 추려서 얘기해야 한다. 내가 1분을 쓰면 30분을 쓴다고 생각하자. 제 1원칙: 빠르게 반응하기 보다는 잘 들어주기 경우에 따라서는 말을 끊어야 하는 경우도 있다. 그럴 때 어떻게 해야할까. 말을 끊어서 죄송하지만, 우리가 이런 주제로 얘기하고 있는데 ... 하며 끊어보자. 말을 끊을 때는 그만한 확신이 있어야 한다. 회의 주제와 너무 많이 틀어진 방향으로 가고 있다던지 ... 그리고 틀린 말을 하고 있더라도 끝까지 일단 들어보자. 끝까지 말을 하면 왜 자기가 그렇게 생각했는지, 말할 것이다. 그러면 말이 다 끝난 그 다음에 정정하면 된다. 그리고 역으로 만약에 내가 중요한 말을 하고 있는데 상대방이 말을 끊으러 들어온다면 &#39;정말 죄송한데 제 말 좀 끝낼게요&#39; 라고 말하면 된다. 근데 이 말도 너무 많이하면 독단적으로 보이므로 조심하자. 제 2원칙: 다른 사람 아이디어 증진시키고 활용하기 보통 이걸  Leverage  라고 부른다. 다른사람이 아이디어를 냈을 때, 아이디어를 실현시킬 수 있는 솔루션들을 추가로 제안하거나, 본인이 공감하는 부분을 강조한다던가, 좀 더 일반적으로 응용할 수 있는 부분에 대한 말을 한다던가 해보자. 제 3원칙: 서로 생각이 다르더라도 존중하기 이걸 인간 대 인간으로 충돌하고 있다고 생각하면 안된다. 의견 대 의견으로 충돌하고 있다는 것을 이해해야 한다. 우리는 항상 프로답게. 냉철하게 생각했으면 좋겠다. 내 의견이 부정당했다고 상처받지 말자.  whiteship  : 연애랑 비슷한 것 같다고? 연애를 해본지 하도 오래 돼서 모르겠네ㅋㅋㅋ 그리고 내 생각만 옳은 것이 아니다. 항상 여러가지 방법이 있는 것이다. 우리는 목적지로 가기만 하면 되는 거다. 시니어는 본인의 영향력이 다른 팀에도 미칠 수 있어야 한다. 번외로 가끔 일을 하다보면 다른 팀이 해야되는 일을 우리 팀이 하는 경우가 있다. 너무 이런걸 싫어하지 말자. 크게 상관이 없는 일이다. 회사 전체로 보면 필요한 일이다. 팀의 이익에만 국한되어서 처리된다면 딱 거기까지만 오를 수 있을 것이다. 제 4원칙: 시간을 내서 동료 도와주기 특히 팀에 처음 합류하는 사람들. 한번 말해주면 알아듣겠지? 라고 기대하면 안된다. 세 번, 네 번째에 이해하는 사람은 보통이고, 한번에 알아듣는 사람은 뛰어난거다. 10명 중 1명 꼴이다. 하나 알려줬는데 10개를 알아오거나 하나도 알려주지 않았는데 5개를 알아오는 사람은 정말 가끔있다. 거의 100명 중에 한 명 있는듯. 이 사람들은 학습하는 훈련이 되어있는 사람이다. 보통은 똑같은 것을 3-4번 알려줘야 한다. 이건 당연한 거다. 내가 설명을 잘못했을 수도 있다. 그러니 여러번 알려준다고 짜증내지 말자. 그리고 동료들이 막힌 문제가 없는지 가끔 파악을 해보자. 이걸 기술적으로 도와줄수 있으면 더 좋고. 예를 들어 내가 장애를 해결한 사례를 공유하면 좋다. 제 5원칙: 투명하고 적극적으로 정보 공유하기 뭔가 진척이 됐다 -&gt; 공유하기 이런 이슈때문에 막혀있다 -&gt; 공유하기 내가 최선을 다했다고 하더라도 내가 blame 당할 수 있다. 어떤 문제를 해결했다 -&gt; 공유하기 이건 팀의 기술력을 늘릴 수 있다. 전부 다 공유하자. 모두가 내 업무 상태를 알 수 있도록 하자. 데일리 미팅을 하는 팀이라면 정보 공유가 잘 이뤄지겠지만, 아니라면 2-3일에 한번, 최소한 일주일에 한번 공유를 해보도록 하자. Review 빠르게 반응하기 보다는 잘 들어주기 내가 조금 부족한 능력이라는 생각이 들었다. 어떻게 하면 잘 말을 끊을 수 있을 지를 항상 고민했는데, 이제는 정말 크게 논지에서 떨어지지 않는다면 끝까지 들어보고, 그 사람이 어떤 배경에서 그런 말을 하고 있는지를 이해해보도록 하자. 다른 사람 아이디어 증진시키고 활용하기 물론 맞는 말이지만, 경험 상 이렇게 하다 보면 굉장히 신나서 나도 회의에서 벗어난 이야기를 하게 되는 경우가 있었다. 논지에서 벗어나지 않도록 해보자. 서로 생각이 다르더라도 존중하기 모두가 이 내용을 알고 있는 건 아닐 것이다. 어떻게 하면 내가  의견을 내고 있는 사람 이 아닌  의견 에 대해 비판하고 있는 지를 전달할 수 있을 지 고민해봐야 겠다. 시간을 내서 동료 도와주기 내가 근무하고 있는 회사는 동료.. 라고 할 수 있는 사람이 없긴 하다. 내 기준에서는 다른 팀에 관심을 가지는 것부터 시작할 수 있을 것 같다. 그 팀에게 무언가를 요청하기 전에 내가 해줄 수 있는 일을 최대한 해서 보내준다던가 ... 투명하고 적극적으로 정보 공유하기 사실 한 2주 전에 1on1 미팅에서 들었던 내용이다. 굉장히 공감이 많이 되고, 실천하도록 노력하고 있다. 한가지 추가된 점은 내가 문제를 해결했다면, 해결 방법도 같이 공유하는 노력을 해봐야 겠다. 해당 글은  백기선 님의  [개발자로 살아남는 방법] EP03. &quot;결과&quot;를 만들어 내는 능력 을 보고 정리한 내용입니다. Before we begin 주니어로서 가져야 할 가장 좋은 자세? 물론 내가 막 성장하겠다 이런 욕구를 보여주면 좋긴 하다. 그런데 나는 한번 알려준 거는 한번에 알아들었으면 좋겠다. 이게 많이 기대하는 거라는 건 알지만, 똑같은 걸 세 번 이상 알려줘야 할 때는 많이 화가 난다. 이제는 체념했다. 다음에 또 물어볼거라고 생각한다. 그러니까 화가 안 난다. 그런데, 한번 알려준 걸 한번에 알아듣는다? 그러면 이제 시니어 입장에서 굉장히 좋아하게 된다. 기대는 안하지만 Feedback을 안하는 것은 아니기 때문에. 레이니어 체리가 맛있다. 보라색 체리와는 차원이 다르다. 먹어보고 싶네 ... 제 1원칙: 집요함과 에너지로 다른 사람에게 영감을 줄 것 이런 집요함과 에너지가 있으면 주변 사람들이 좋은 영향을 받게 된다. 최근에  토스ㅣSLASH 21 - 테스트 커버리지 100% 라는 강의를 들었는데, 굉장한 집요함을 느꼈다. 비판적인 발언과 비관적인 발언은 다르다.  회의 중에 비판적인 발언은 좋다. 네이버 Yobi 프로젝트에서 이런 논의가 있었다. &quot;리뷰를 할 때 특정 부분부터 어디까지 드래그를 해서 리뷰를 달 수 있도록 하자.&quot; 라는 기능에 대한 회의였다. 회의 초반 분위기는 이랬다. 이건 너무 만들기 어렵다. 이때 기선님은 아무리 생각해도 안되는 건 없는 것 같더라. 그래서 이때 라이언 킹의 첫번째 OST 를 틀고 아니다. 할 수 있을 거다. 우리 한번 생각을 해보자. 라고 말을 했더니 할 수 있게 되었다. 그리고 에너지를 정치나 갈등 같은 곳에서 낭비하는 경우가 많다. 이 때는 누가 이기던 지던 둘 다 손해를 보게 된다. 그 에너지를 아꼈다가 내 자기계발을 하거나 스트레스 관리를 하자. 영감을 준다는 것은 나도 저렇게 무언가를 집요하게 파서 무언가를 해내고 싶다. 이렇게 남이 생각하게 하는 것. 이건 내가 계획해서 할 수는 없는 거다. 하지만 이런 집요함과 에너지를 주변 사람에게 보여준다면 영감을 충분히 이끌어 낼 수 있을 것이다. 제 2원칙: 고객의 요구에 근거하여 분명하고 야심찬 목표를 만들 것 어려워도 고객이 요구하는 기능이 있다면 한번 목표로 세워보자. 불가능하지는 않다. 이게 과연 고객이 원하는 일인가? 이게 고객이 원하는 것에 준하는 일인가? 를 항상 생각하자. 이런 생각은 업무의 우선순위를 정할 때에도 굉장히 좋다.  야심찬 목표라는 건 척도를 가져야 한다. 얼마나 빠르게 배포를 했느냐. 얼마나 많이 성공했는가. 이런 척도를 가지고 있으면 목표를 정하기 쉽다. 이런 척도가 없다면 만들어서라도 설정해야 한다. 제 3원칙: 장애물을 식별하고 해결할 것 일을 하다보면 분명히 문제가 생긴다.  아무 문제 없이 스무스하게 프로젝트가 성공한 적이 단 한번도 없다. 그래서 planning을 믿지 않는다. 한번도 원래 계획한 일정대로 진행된 적이 없다. 일정을 내가 정한다고 하더라도 안될 여지가 무조건 있다. 일을 하다가 나오게 되는 장애물은 그 때 알게 되면 된다. 자 장애물을 발견했다. 그럼 이제 어떻게 행동해야 할까? 우선 이 사실을  공표 해야 한다. 이걸 혼자 끙끙 앓게 되면 본인이 망하는 길이다. 일단 무조건 말을 한다. 이런 문제가 생겨서 해결해야 하는데 우리 팀이 이 문제에 대한 경험이 있어서 다른 팀의 조언을 받아서 해결해야 한다. 그래서 이 정도 시간이 걸릴 것 같다. 이거 안하면 망한다. 선 보고 후 조치. 무조건 이렇게 해야한다. 일단은 바로 mitigation을 한다. 이건 뭐 그 날 on call이 한다. 그 다음 팀이 함께 오류의 근원지 Root까지 파고든다. (Root Cause Analysis) Root를 찾고 나면 해결한다. 불이 났다. 일단은 천을 덮어서 불을 껐다. 그럼 다음은 또 불이 났을 때 천으로 덮어서 끌 것인가? 아니다. 불이 왜 났는지를 파악하고, 재발 방지 대책을 세워야 한다. 잠깐 인생 강의 이 세상 어떤 업무도 내 삶보다 중요한 건 없다. 내 삶을 가장 중요하게 생각하자. 장애가 난다고 보통 사람이 죽지는 않는다. 업무시간에만 열심히 일하면 된다. 제 4원칙: 영향력있는 업무를 많이 완수할 것 그냥 하는 게 아니다.  완수 해야 한다. 가령 일이 딜레이가 될지라도 끝내는게 중요하다. 딜레이가 되었어도 일을 끝냈다면, 끝낸 이후에는 그 이전의 딜레이가 크게 문제되지 않는다.  방망이 깎던 노인 을 기억하자. 방망이를 깎아야 방망이를 사고 버스를 탈 수 있는거다. 깎다 만 방망이를 배포할 것인가? 이게 더 안좋다. 또 A라는 업무를 하면 배포가 10초가 줄어들고 B라는 업무를 하면 배포 시간이 10분이 줄어든다고 하자. 당연히 B 먼저 수행해야 한다. 이렇게 영향력이 더 높은 있는 업무를  끝내보자. 그러면서 습관으로 만들어보자. 제 5원칙: 교조주의 보다는 실용주의에 더 가치를 둘 것 교조주의( dogmatism ) 보단 실용주의( programmatism )에 더 가치를 둘 것. 클린코드에서 이렇게 하라고 했습니다. 이게 교조주의다. 방법은 항상 여러가지다. 실용적인 코드리뷰라면 아래와 같이 달 것이다. 이렇게 하면 코드를 좀 더 읽기 편할 것 같아요. 그리고 이렇게 하면 중복 코드를 더 제거할 수 있을 것 같습니다. 이렇게 근거를 들어야 한다. 문제 설명 집합 $S$ = {$a_1, \cdots , a_n$} ($1 ≤ a_i ≤ 10^{18}$, $1 ≤ n ≤ 100,000$) 이 입력으로 주어진다.  Subset XOR Maximization 예를 들어 $S = {1,3,4,6,8,11}$ 로 주어졌다고 가정해보자. 이 때, 주어진 수들을$\mod 2$ 로 계산된 벡터들로 볼 수 있다. (이진법이라는 얘기다.) $\begin{bmatrix}0&amp;0&amp;0&amp;1\end{bmatrix}, \begin{bmatrix}0&amp;0&amp;1&amp;1\end{bmatrix}, \begin{bmatrix}0&amp;1&amp;0&amp;0\end{bmatrix},$ $\begin{bmatrix}0&amp;1&amp;1&amp;0\end{bmatrix}, \begin{bmatrix}1&amp;0&amp;0&amp;0\end{bmatrix}, \begin{bmatrix}1&amp;0&amp;1&amp; 1\end{bmatrix}$ 이렇게 말이다.  주어진 수들로 RREF를 만들어보자. 단, 벡터간의 합이 아닌 XOR 연산으로 말이다. $\begin{bmatrix}1&amp;0&amp;1&amp;1\1&amp;0&amp;0&amp;0\0&amp;1&amp;1&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;1\0&amp;0&amp;0&amp;1\end{bmatrix}\rArr\begin{bmatrix}1&amp;0&amp;1&amp;1\0&amp;1&amp;1&amp;0\0&amp;0&amp;1&amp;0\0&amp;0&amp;0&amp;1\0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0\end{bmatrix}\rArr\begin{bmatrix}1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0\0&amp;0&amp;0&amp;1\0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0\end{bmatrix}$ 이제 영벡터가 아닌 행벡터들의 Leading 1 들을 살펴보면 XOR로 만들수 있는 최댓값을 쉽게 구할 수 있다. 이해를 돕기 위해 좀 더 자세히 설명해보자. 영벡터가 아닌 행벡터들은 다음과 같이 표기된다.  이 친구들을 모두 XOR 해주게 되면 다음과 같은 결과를 얻을 수 있다. 이렇게 구한 열벡터들을 XOR basis라고 한다. XOR basis를 구한 뒤, 그때부터는 그냥 Greedy하게 선택하기만 해도 쉽게 Subset XOR Maximization을 수행할 수 있다. 예제코드 c++ python3 해당 글은  백기선 님의  [개발자로 살아남는 방법] EP02. 개발자에게 필요한 &quot;기술력&quot;이란? 를 보고 정리한 내용입니다. 워딩이 다소 날카로울 수 있습니다. 나름 만족스러워서 그대로 정리했습니다. Before we begin  나는 열정이 있다. 나는 책임감이 있다.  이런 주장들은 사실 별 의미가 없다. &quot;우리 집에 황금 송아지가 있다&quot; 랑 차이가 없다. 내가 지금까지 만들어 낸 것과 지금 만들어 내고 있는 것으로 증명해보도록 하자. 나는 이렇게 이렇게 행동을 했다. 그래서 나는 협업에 신경을 썼다고 생각한다. 이렇게 주장하는 것이 훨씬 낫다. 동료 평가에도 마찬가지로 적용된다. &quot;너랑 일하기 싫어하는 사람이 OO 명이야.&quot; 이게 무슨 의미가 있는가? 이건 정말 병X같은 평가 방법이다. 차라리 직접적인 피드백을 주는게 낫지 않을까? &quot;당신이 회의에서 이러이러하게 행동하는 것이 다른사람들이 아이디어를 내는 데 꺼릴 수 있는 분위기를 조성한다. 내 생각에는 이렇게 하는 것도 좋을 것 같다.&quot; 제 1원칙: 꾸준히 수준 높은 해결책을 만들어 내는 능력 개발자로 일을 하다보면, 팀에서 맡고 있는 서비스나 플랫폼에 굉장히 다양한 이슈가 있다는 것을 깨닫게 된다.  왜 그런 문제가 발생하는가?  문제 인식부터가 시작이다. 이것도 능력이다. 여러가지 방법이 있을 것이다. 솔루션은 분명히 다양할 것. 그러면 이 다양한 솔루션들을 비교할 수 있어야 한다. 그 솔루션들을 비용으로 비교해야 한다. 비용은 시간도 될 수 있고, 운영 비용도 될 수 있을 것이다. 그러면 이 솔루션과 장단점들을 팀원들에게 제시하고, 이런 회의룰 주관해서 솔루션을 만들어 내고, 이걸 구현할 수 있는 게 바로 시니어 엔지니어다. 이렇게 솔루션을 고안해내다 보면 분명히 기술력은 증가할 수밖에 없다. 제 2원칙: 엔지니어링 원칙과 업계의 Best Practice를 받아들이기 오해의 소지가 좀 있는데, Best Practice라는게 결코 트렌드를 좇아라 라는 말이 아니다. 그럼 엔지니어링 원칙은 뭘까?  DRY : Don&#39;t Repeat Yourself 중복 제거와 관련된 원칙.  KISS : Keep it Simple Stupid 시스템을 최대한 단순하게 구현하기. 누구나 이해할 수 있는 코드를 작성하기.  YAGNI : You ain&#39;t gonna need it 오버 엔지니어링에 관한 원칙.  SOLID : SRP, OCP, LSP, ISP, DIP 객체지향원칙. 다들 알 것 같고... 업계에서 Best Practice라는 것은 refactoring, TDD까지는 아니더라도 테스트를 만드는 것. 이정도까지인 것 같다. DDD 얘기가 계속 나오는데, DDD는 사실 쉽지 않다. 한번도 DDD로 설계된 프로젝트를 본적이 없다. DDD 공부하고 싶으면  Get Your Hands Dirty on Clean Architecture  보면 좋을 듯. 트렌드니까 적용한다는 이유면 안된다. 이게 우리의 플랫폼에 적용했을 때, 어떤 이득이 있는지 계산이 떨어지고, 그때서 적용해야 한다. 위에서 말했듯, 솔루션의 장단점을 명확히 판별해야 한다. 잠깐 코드리뷰 얘기 리뷰가 되기 전 코드는 merge되면 안된다는 것도 Best Practice라고 생각한다. 코드 리뷰를 게을리 하면 안된다.  그의 Lazy loading 코드 리뷰 해달라. =&gt; 테스트 코드 있어? 없으면 짜와. 테스트 코드 짜왔다. 코드 리뷰 해달라. =&gt; 빌드 깨지네? 다시 해와. 이렇게 하면 부하가 좀 덜 걸린다ㅋㅋ. 제 3원칙: 지속적으로 개발 방법과 품질을 증진시키려는 노력 문제가 발생하면, 그걸 조기에 발견할 수 있게끔 개선하면 좋다. 배포할 때까지 문제가 발견이 안됐다. -&gt; 이건 기회다. 이 문제를 어떻게 하면 배포 전에 발견할 수 있을 지 고민해 보는 것이다. 이렇게 계속 개발 방법과 품질을 증진시키려는 노력을 하다보면 기술력이 높아진다. 제 4원칙: 기술력을 증진시킬 수 있는 방법을 적극적으로 찾기 기술 컨퍼런스를 가는 것도 좋은 방법이다. 온라인도 뭐 볼 수도 있겠지만, 온라인은 확실히 집중력이 떨어진다. 컨퍼런스의 장점은 내가 오로지 그 시간동안 컨퍼런스에만 집중할 수 있다는 것. 컨퍼런스가 진행 중인데 놀러 나가지는 말자. 컨퍼런스는 휴가가 아니다. 그리고 꼴보기 싫다. 내가 어디 갔는데, 경치가 그렇게 좋더라. 이게 컨퍼런스의 목적일까? 정신 좀 차리자. 제 5원칙: 동료 또는 다른 개발자의 기술력을 증진시키는 것을 돕기 회사에서 이메일을 쓸 때 업무 뿐만 아니라 회사에서 쓰고 있는 기술과 관련한 새로운 기술에 대한 이메일도 쓸 수 있다. 내가 그걸 블로그에 잘 정리했거나 다른 사람이 정리한 내용(내가 검증은 한번 해봐야 한다.). 아니면 컨퍼런스 소식 같은 것을 공유해 주는 것. ( 백기선 유튜브를 공유해도 되고ㅋㅋ ) 이게 바로 나의 기술력으로 이어지게 된다. 예를 들어 리액트에 나온 새로운 기능을 공유를 한다면, 내가 한번 써봐서 검증을 해보고 공유를 할 것이다. 이러면 나의 기술력과 팀의 기술력 모두 증진시킬 수 있다. 이게 바로 주니어와 시니어의 차이가 아닐까? 해당 글은  백기선 님의  [개발자로 살아남는 방법] EP01. 개발자에게 필요한 &quot;문화&quot; 를 보고 정리한 내용입니다. 기업이 사내 &quot;문화&quot;에 신경쓰는 이유 문화는 우리가 숨쉬는 공기만큼이나 중요하다. -​Geert Hofstede 실제로 일을 하다보면 회사마다, 팀마다 공기가 다르다는 것을 느낄 수 있다. 규모가 있는 회사들은  문화 에 실제로 신경을 많이 쓴다. 결국에는 비즈니스에도 영향을 끼치기 때문에. culture-fit 면접도 그러한 면에 있어서 보는 것이다. 과연 우리 회사에 잘 적응할 수 있을까? 우리 회사가 중요하게 생각하는 가치를 잘 따라줄 수 있을까? culture fit에 관련된 질문들은 우리가 해보는 것도 좋다. 그리고 culture fit 질문에는 속여서 대답하지 말자. 괜히 그랬다가 들어가서 더 힘들다. 좋은 문화를 갖추지 않으면 좋은 개발자를 갖추기 어렵기 때문에 비즈니스에도 영향을 끼치게 된다. 제 1원칙: 고객 만족 고객과 파트너가 우리에게 바라는 것이 무엇인지 이해하고, 그들이 기대하는 것 이상으로, 뛰어넘을 수 있게끔 일을 하라. 제 2원칙: 책임감 우리가 맡고 있는 업무나 미션에 책임을 다한다. 책임을 다하는 것이 무엇이냐? 내가 속한 팀에서 하고 있는 업무에 대해서 관심을 가져야 한다. 즉, 내 옆 사람이 하고 있는 일에 관심을 가져야 한다. 만약 옆 사람이 휴가를 갔는데, 장애가 터졌다? 그러면 내가 대처할 수 있어야 한다. 동료가 하고 있는 일에 관심을 가지고 업무가 어떻게 돌아가고 있는지 이해해야 한다. 그리고 휴가를 갈 때는, 내가 맡고 있던 일을 다른 사람들이 충분히 커버할 수 있도록 문서화를 하자. 휴가를 2주동안 갈건데, 정말 급한 경우에는 전화를 해라. 메일은 아침 저녁을 확인할 건데, 응답은 안할거다. 만약 내가 응답을 안해서 업무가 blocking 되는 상황이라면 ping을 줘라. 내가 자리를 비울 때, 커버할 수 있도록 문서화를 해주는 것, 다른 사람이 자리를 비울 때는 그 사람을 내가 커버할 수 있도록 관심을 가지고 있는 것. 이게 책임감이다. 우리도 이런 책임감을 가지고 일을 하자. 호의가 아니라 배려다. 당연히 해줘야 하는 것이다. 제 3원칙: 용기와 실수 실수는 누구나 저지를 수 있다. 실수를 포용할 수 있어야 용기있게 자기가 가지고 있는 생각을 공개적으로 말할 수 있다. 회의에서 아이디어가 생각났는데, 말을 못하는 것은 팀한테 손해다. 그 아이디어가 유용할 수도 있고, 틀린 아이디어더라도 포용할 수 있어야 그 다음에 그 사람이 좋은 아이디어가 생각난다면 말할 수 있다. 만약 회의에서 너무 벗어나는 이야기라면 그부분은 나중에 따로 더 자세히 얘기해보자 라고 할 수 있다. 모든 사람들이 내가 실수를 해도 안전하구나, 내가 조금 틀린 말을 해도 괜찮구나 라는 생각을 가질 수 있어야 한다. 실수를 용납하란 얘기가 실수를 맨날해도 괜찮다는 얘기는 아니다. blame하지 말자는 거다. 실수가 잦은 이유는 재발방지 대책에 대해 미흡했기 때문이다. 되도록 실수를 하지 않아야 한다. 15.0.3333.0 으로 써야 하는 버전이 15.03333.0 으로 써져서 파이프라인이 막혔고, 같은 실수가 재발했다. 이건 재발 방지 대책에 소홀했기 때문이다. 처음에 문제가 발생했을 때 우리가 재발 방지 대책에 대해서 조금 더 생각했다면, 그 코드를 merge하기 전에 알려줄 수 있는 기능을 만들어 뒀다면 이런 일은 안 일어났을 것이다. 개인적으로는 두번, 세번째 발생했을 때 이런 재발방지 대책에 대해 논의해도 괜찮을 것 같다. 실수를 용납해야 하는 이유 = 나도 그런 실수를 할 수 있거든ㅋㅋ 제 4원칙: 기술력  고객 경험을 해치지 않는 선에서  가능한 한 최첨단 기술을 제공하는 것. 만약 새로운 기술 나온다고 매번 적용해보는 게 아니다. 우리는 고객 중심적으로 생각을 해야하고, 고객이 없으면 우리가 없는 것이기 때문에 고객을 실험 쥐로 쓰면 안된다. 제 5원칙: 영향력 우리가 일을 함으로써 고객과 파트너에게 뭔가 impact, 즉 변화를 줄 수 있어야 한다. 아니라면 의미가 없는 일이다. 하면 안된다. 우리가 하는 일로 인해서 혁신을 가져다 줘야한다. 배포를 가능한 한 빠르게 안정적으로 하는 것도 다른 팀원들이 만든 기능을 고객에게 빨리 전달할 수 있는 거다. 이런것도 impact를 준다고 할 수 있다. 이게 의미가 있는 일인가 없는 일인가를 늘 판별하자. 물론 주어진 일은 대부분 어떻게든 타고 타고 가다보면 business에 impact를 줄 수 있는 일이다. 하지만 이걸 이해하지 못하고 일을 하면 시야가 좁아질 뿐이다. 이런 걸 이해하는 것이 시야가 넓어지고, 의사소통할 때 이해력도 좋아진다. 제 6원칙: 측정 우리가 일을 제대로 하고 있는지, 아닌지는 파트너, 플랫폼 또는 핵심 비즈니스 척도를 통해 측정할 수 있다. 그리고 측정해야만 한다. 이런 걸 수치화해서 우리가 잘 하고 있는가, 어떤 문제가 있는가, 등을 항상 체크해야 한다. 이렇게 일을 하면 계속 나아질 수밖에 없다. 만약 일을 했다면 그 성과를 보여주는 report를 작성하는 것도 업무에 포함시켜야 한다. 특히 내가 아이디어를 제안했고, 내가 그걸 구현해 냈다면, 이걸 report를 통해 증명해내는 것은 정말 필요한 것 같다. 팀원들이 좋아하더라. Environment GCP, Intel Broadwell debian-10-buster-v20220310 기본적으로 root 권한( sudo su )으로 작업했습니다. 1. nginx &amp; certbot 설치  apt-get update  apt-get install nginx  apt-get install software-properties-common  add-apt-repository ppa:certbot/certbot  apt-get update 2. 파이썬 설치 아마 이 단계에선 파이썬이 설치가 되어있을 것으로 예상됩니다.   python --version 파이썬이 설치가 안되어있다면 설치해줍니다.  apt-get install python 버전 확인 후 만약 파이썬 2가 설치되어 있다면 위 명령어, 3이 설치되어 있다면 아래 명령어로 실행합니다.  apt-get install python-certbot-nginx  apt-get install python-certbot3-nginx 3. react 빌드하기 git을 설치하고, 코드를 받아옵니다. 이미 있다면 넘어갑니다.  apt-get install git  git config --global user.name i4song  git config --global user.email i4song@gmail.com  git clone https://github.com/i4song/i4song-blog.git node.js를 설치합니다. 이미 있다면 넘어갑니다.  apt-get install -y build-essential  apt-get install curl  curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash --  apt-get install -y node.js npm을 설치합니다. 이미 있다면 넘어갑니다.  apt-get install npm yarn을 설치합니다. (npm으로 생성한 프로젝트라면 넘어갑니다.)  npm install -g yarn 해당 프로젝트가 있는 폴더로 이동하고 빌드합니다.  cd i4song-blog  yarn  or  npm install  yarn run build  or  npm run build 4. nginx 설정(for react) 도메인 이름으로 config 파일을 작성하고 심볼릭 링크를 생성합니다.   vi /etc/nginx/sites-available/i4song.com   sudo ln -s /etc/nginx/sites-available/i4song.com /etc/nginx/sites-enabled/i4song.com 5. certbot으로 인증서 발급  certbot --nginx -d i4song.com  1 을 입력한다면 http 연결을 https로 리다이렉트 하지 않습니다.  2 를 입력한다면 http 연결을 https 로 리다이렉트 시킵니다. 6. 인증서 자동갱신 설정(crontab) 아래와 같이 설정하면 매월 인증서를 갱신하게 됩니다.  crontab -e  1 1 1 * * certbot renew --renew-hook &quot;sudo service nginx restart&quot; 단위 테스트에 접근하는 방법은 두가지 뚜렷한 견해로 나뉜다. 각각 고전파(classical school)과 런던파(London school)로 알려져 있다. 고전파는 모든 사람이 단위 테스트와 테스트 주도 개발에 원론적으로 접근하는 방식이기 때문에 &#39;고전&#39;이라고 한다. 런던파는 런던의 프로그래밍 커뮤니티에서 시작되어서 &#39;런던&#39;이라고 한다. 우선 단위 테스트 정의로 시작해보자. 이 정의가  고전파 와  런던파 를 구분 짓는 일이다. 2.1 &#39;단위 테스트&#39;의 정의 단위 테스트는 다음과 같이 중요한 세 가지 속성이 있다. 작은 코드 조각을 검증하고, 빠르게 수행하고, 격리된 벙식으로 처리하는 자동화된 테스트다. 여기서 처음 두 속성은 논란의 여지가 없다. 무엇이 빠른 건지는 논쟁거리가 될 수도 있지만 그리 중요한 건 아니다. 대중의 의견이 크게 다른 것은 세 번째 속성이다.  격리 문제는 단위 테스트의 고전파와 런던파를 구분할 수 있게 해주는 근원적 차이에 속한다. 저자는 고전적 스타일을 선호한다고 하는데, 그 까닭은 2.3절에서 설명한다. 2.1.1 격리 문제에 대한 런던파의 접근 코드 조각을 격리된 방식으로 검증한다는 것은 무엇을 의미하는가? 런던파에서는 테스트 대상 시스템을 협력자에게서 격리하는 것을 일컫는다. 즉 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을  테스트 대역 (Test Double)으로 대체해야 한다. 이런 식으로  동작을 외부 영향과 분리해서 테스트 대상 클래스에만 집중 할 수 있다. 테스트 대역(Test Double)이란? 테스트를 작성하다 보면 외부 요인이 필요한 시점이 있는데, 다음은 외부 요인이 테스트에 관여하는 주요 예이다. 테스트 대상에서 파일 시스템 사용 테스트 대상에서 DB로부터 데이터를 조회하거나 데이터를 추가 테스트 대상에서 외부의 HTTP 서버와 통신 이런 시점에서 복잡성을 줄이고 테스트를 용이하게 하는 단순화된 버전이 바로 테스트 대역(Test Double)이다. 다음 그림은 일반적으로 격리가 어떻게 이뤄지는지 보여준다.   이 방법의 한가지 이점은 테스트가 실패하면  코드베이스의 어느 부분이 고장났는지 확실히 알 수 있다 는 것이다. 즉, 확실히 테스트 대상 시스템이 고장난 것이다. 클래스의 모든 의존성은 테스트 대역으로 대체됐기 때문에 의심할 여지가 없다. 또한 단위 테스트 격리에는 작지만 유익한 부가적인 이점이 더 있다. 한 번에 한 클래스만 테스트하라는 지침을 도입하면  전체 단위 테스트 스위트를 간단한 구조로 할 수 있다. 다음 그림은 일반적으로 어떤지 보여준다.   온라인 상점을 운영한다고 가정하자. 샘플 애플리케이션에는 고객이 제품을 구매할 수 있다는 간단한 use case가 하나 있다. 상점에 재고가 충분하면 구매는 성공으로 간주되고, 구매 수량만큼 상점의 제품 수량이 줄어든다. 제품이 충분하지 않으면 상점에 아무 일도 일어나지 않는다. 다음 테스트는 고전적인 스타일로 작성됐으며 일반적인 3단 구성인  준비, 실행, 검증  패턴 (AAA 패턴)을 사용한다. 보다시피 준비 부분은 의존성과 테스트 대상 시스템을 모두 준비하는 부분이다. 이 코드는 단위 테스트의 고전 스타일 예로, 테스트는 협력자(Store 클래스)를 대체하지 않고 운영용 인스턴스를 사용한다. 따라서 Customer만이 아니라  Customer와 Store 둘 다 효과적으로 검증 한다. 그리고 두 클래스는 서로 격리돼 있지 않다. 이제 런던 스타일로 예제를 수정해보자. 동일한 테스트에서 Store 인스턴스는 테스트 대역, 구체적으로 목으로 교체해본다. 사람들이 흔히 테스트 대역과 목을 동의어로 사용하지만, 기술적으로는 그렇지 않다. 테스트 대역은 실행과 관련없는 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어다. 목은 그러한 의존성의 한 종류일 뿐이다. 검증 단계도 바뀌었고 중요한 차이점이 여기에 있다. 여전히 이전과 같이 customer.Purchase 호출 결과를 확인하지만, 고객이 상점에서 올바르게 했는지 확인하는 방법이 다르다. 이전에는 상점 상태를 검증했다. 지금은  Customer와 Store간의 상호 작용 을 검사한다. 즉, 고객이 상점에서 호출을 올바르게 했는지 확인한다. 고객은 구매가 성공하면 이 메서드를 한 번만 호출해야 하고(Times.Once), 구매가 실패하면 절대로 호출하면 안 된다(Times.Never). 2.1.2 격리 문제에 대한 고전파의 접근 단위 테스트의 속성을 다시 한번 살펴보자. 단위 테스트는 작은 코드 조각을 검증한다. 신속하게 수행하고, 격리된 벙식으로 진행한다. 세 번째 속성에 대한 해석이 분분한 것 외에, 첫 번째 속성에도 다양한 해석이 가능하다. 각각의 모든 클래스를 격리해야 한다면 테스트 대상 코드 조각은 당연히 단일 클래스이거나 해당 클래스 내의 메서드여야 한다. 때에 따라 한 번에 몇 개의 클래스를 테스트할 수 있기는 하다. 일반적으로 한 번에 한 클래스로 테스트하는 지침을 따르려고 노력해야 한다. 고전적인 방법에선 코드를 꼭 격리하는 방식으로 테스트해야 하는 것은 아니다. 대신 단위 테스트는 서로 격리해서 실행해야 한다. 이렇게 하면 테스트를 어떤 순서든 가장 적합한 방식으로 실행할 수 있으며, 서로의 결과에 영향을 미치지 않는다. 예를 들어 어떤 테스트가 준비단계에서 데이터베이스에서 고객을 생성할 수 있고, 이 테스트가 실행되기 전에 다른 테스트의 준비 단계에서 고객을 삭제할 수도 있다. 이 두 가지 테스트를 병렬로 실행하면 첫 번째 테스트가 실패하는데, 이는 두 번째 테스트의 간섭 때문이다. 격리 문제에 대한 이러한 해석에는 목과 기타 테스트 대역을 적당히 쓰려는 견해가 있다.  테스트 대역을 사용할 수 있지만, 보통 테스트 간에 공유 상태를 일으키는 의존성에 대해서만 사용하는 것이다.  공유 의존성, 비공개 의존성, 프로세스 외부 의존성, 휘발성 의존성 공유 의존성: 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성 비공개 의존성: 공유하지 않는 의존성 프로세스 외부 의존성: 애플리케이션 실행 프로세스 외부에서 실행되는 의존성 휘발성 의존성은 다음 속성 중 하나를 나타내는 의존성이다. 개발자 머신에 기본 설치된 환경 외에 런타임 환경의 설정 및 구성을 요구. (DB, API ...) 비결정적 동작을 포함. (난수 생성기, ...)   2.2 단위 테스트의 런던파와 고전파 종합하면 세 가지 주요 주제에 대해 의견 차이가 있다. 격리 주체 단위의 크기 테스트 대역 사용 대상 런던파 단위 단일 클래스 불변 의존성 외 모든 의존성 고전파 단위 테스트 단일 클래스 또는 클래스 세트 공유 의존성 2.2.1 고전파와 런던파가 의존성을 다루는 방법 고전파에서는 공유 의존성을 테스트 대역으로 교체한다. 런던파에서는 변경 가능한 한 비공개 의존성도 테스트 대역으로 교체할 수 있다.   그리고 의존성에 대해 한 가지만 다시 강조해본다. 모든 프로세스 외부 의존성이 공유 의존성의 범주에 속하는 것은 아니다.  공유 의존성은 거의 항상 프로세스 외부에 있지만, 그 반대는 그렇지 않다. 하지만 이 책에서 달리 명시하지 않는 한, 공유 의존성과 프로세스 외부 의존성이라는 용어는 서로 바꿀 수 있게 사용한다.  실제 프로젝트에서 프로세스 외부가 아닌 공유 의존성은 거의 없다. 의존성이 프로세스 내부에 있으면 각 테스트에서 별도의 인스턴스를 쉽게 공급할 수 있으므로 테스트 간에 공유할 필요가 없다. 마찬가지로 공유되지 않는 프로세스 외부 의존성은 일반적으로 접할일이 없다. 이 정의를 토대로 두 분파의 장점을 비교해보자. 2.3 고전파와 런던파의 비교 런던파의 접근 방식은 다음과 같은 이점을 제공한다. 입자성이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인한다. 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다. 모든 협력자는 테스트 대역으로 대체되기 때문에 테스트 작성 시 걱정할 필요가 없다. 테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다. 2.3.1 한 번에 한 클래스만 테스트하기 런던파는 클래스를 단위로 간주한다. 이로인해 자연스럽게 클래스를 테스트에서 검증할 최소 단위로도 취급하게 된다. 이런 경향은 이해되기는 하지만 오해의 소지가 있다. 테스트는 코드의 단위를 검증해서는 안된다. 오히려 동작의 단위, 즉 문제 영역에 의미가 있는것, 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다. 테스트는 해결하는 데 도움이 되는 문제에 대한 이야기를 들려줘야 하며 이 이야기는 프로그래머가 아닌 일반 사람들에게 응집도가 높고 의미가 있어야 한다. 예를 들어 다음은 응집도가 높은 이야기의 예다. 우리집 강아지를 부르면, 바로 나에게 온다. 이제 다음을 비교해보자. 우리집 강아지를 부르면 먼저 왼쪽 앞다리를 움직이고, 이어서 오른쪽 앞다리를 움직이고, 머리를 돌리고, 꼬리를 흔들기 시작한다... 두 번째 이야기는 말이 안된다. 실제 동작 대신에 개별 클래스 (다리, 머리, 꼬리)를 목표로 할 때 테스트가 이렇게 보이기 시작한다. 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기 테스트 대역을 쓰면 클래스의 직접적인 의존성을 대체해 그래프를 나눌 수 있으며, 이는 단위 테스트에서 준비해야 할 작업량을 크게 줄일 수 있다. 모두 사실이지만, 이 추리는 잘못된 문제에 초점을 맞추고 있다. 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다. 이는 틀림없이 문제의 징후가 맞으며, 목을 사용하는 것은 이 문제를 감추기만 할 뿐 원인을 해결하지 못한다. 2.3.3 버그 위치 정확히 찾아내기 우려할만 하지만 큰 문제는 아니다. 테스트를 정기적으로 실행하면 버그의 원인을 알아낼 수 있다. 게다가 테스트 스위트 전체에 걸쳐 계단식으로 실패하는 데 가치가 있다. 버그가 테스트 하나뿐만 아니라 많은 테스트에서 결함으로 이어진다면, 방금 고장 낸 코드조각이 큰 가치가 있다는 것을 보여준다. 이는 코드 작업시 명심해야 할 유용한 정보다. 2.3.4 고전파와 런던파 사이의 다른 차이점 고전파와 런던파 사이에 남아있는 두 가지 차이점은 다음과 같다. 테스트 주도 개발을 통한 시스템 설계 방식 과도한 명세 문제  테스트 주도 개발 테스트 주도 개발은 테스트에 의존해 프로젝트 개발을 추진하는 소프트웨어 개발 프로세스다. 이 프로세스는 세 단계로 구성되며, 각 테스트 케이스마다 반복해서 적용한다. 추가해야 할 기능과 어떻게 동작해야 하는지를 나타내는 실패 테스트를 작성한다. 테스트가 통과할 만큼 충분히 코드를 작성한다. 이 단계에서 코드가 꺠끗하거나 명쾌할 필요는 없다. 코드를 리팩터링한다. 통과 테스트 보호하에서 코드를 안전하게 정리해 좀 더 읽기 쉽고 유지하기 쉽도록 만들 수 있다. 런던 스타일의 단위 테스트는 하향식 TDD로 이어지며, 고전파는 일반적으로 상향식으로 한다. 그러나 고전파와 런던파 간의 가장 중요한 차이점은 과도한 명세 문제, 즉 테스트가 SUT의 구현 세부 사항에 결합되는 것이다. 런던 스타일은 고전 스타일보다 테스트가 구현에 더 자주 결합되는 편이다. 이로 인해 런던 스타일과 목을 전반적으로 아무 데나 쓰는 것에 대해 주로 이의가 제기된다. 이 책에서 다루는 내용은 어떤 단위 테스트 기술이 좋은지를 구별하는 데 도움이 될 것이다. 테스트에 대한 비용 편익 분석 (cost-benefit analysis) 공통적인 안티 패턴을 피하는 방법 1.1 단위 테스트 현황 단위 테스트를 작성해야 하는가? 단위테스트는 이젠 대부분의 회사에서 필수로 간주될 정도로 당연한 것이다. 단위 테스트를 적용해야 하는 지는 더 이상의 논쟁거리가 아니다. 한번 작성하고 버리는 프로젝트가 아니라면 단위 테스트는 늘 적용해야 한다. 논쟁은 다음과 같이 바뀌었다. 좋은 단위 테스트를 작성하는 것은 어떤 의미인가? 좋은 테스트와 좋지 않은 테스트의 차이는 취향이나 개인적인 선호도의 문제가 아니라 현재 작업중인 중대한 프로젝트의 성패를 가르는 문제다. 이 책에서는 이상적인 단위 테스트에 대해 정확하고 과학적인 정의를 다룬다. 이 정의가 실제 사례에서 어떻게 적용되는 지 살펴본다. 1.2 단위 테스트의 목표 흔히 단위 테스트를 작성하는 것이 더 나은 설계로 이어진다고 한다. 이는 사실이다. 그러나 단위 테스트의 주목표는 아니다. 더 나은 설계는 단지 좋은 부수 효과일 뿐이다. 코드를 단위 테스트하기 어렵다는 것은 비교적 높은 정확도로 저품질 코드를 가려낸다. 코드를 단위테스트하기 어렵다면 코드 개선이 반드시 필요하다는 것이다.대표적인 예로 강한 결합 (tight coupling)이 있을 것이다. 단위 테스트의 목표는  소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것 이다. 지속 가능하다는 것이 핵심이다. 테스트가 없는 코드는 처음에는 발목을 잡을 것이 없으므로 빨리 시작할 수 있다. 그러나 시간이 지나면서 점점 더 많은 시간을 들여야 처음에 보여준 것과 같은 정도의 진척을 낼 수 있다. 결국 개발 속도가 현저히 느려진다. 개발속도가 빠르게 감소하는 현상을  소프트웨어 엔트로피 라고도 한다. 소프트웨어에서 엔트로피는 품질을 떨어뜨리는 코드 형태로 나타난다. 코드베이스에서 무언가를 변경할 때마다 엔트로피는 증가한다. 지속적인 정리와 리팩터링 등과 같은 적절한 관리를 하지 않고 방치하면 시스템이 점점 더 복잡해지고 무질서해진다.  테스트는 이러한 경향을 뒤집는 역할을 한다. 테스트는 안전망 역할을 하며, 대부분의 회귀에 대한 보험을 제공한다. 여기서 한가지 단점이 있는데, 이러한 테스트는 초반에 노력이 필요하다는 것이다. 그러나 장기적으로 보면 그 비용을 메울 수 있다. 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인 일부 테스트는 아주 중요하고 소프트웨어 품질에 매우 많은 기여를 한다. 그 밖에 다른 테스트는 그렇지 않다. 프로젝트에 테스트를 더 많이 실행하더라도 단위 테스트의 목표를 달성할 수는 없다. 테스트의 가치와 유지 비용을 모두 고려해야 한다. 여기서 비용은 다음과 같은 활동에 드는 시간에 따라 결정된다. 기반 코드를 리팩터링할 떄, 테스트도 리팩터링하라. 각 코드 변경시 테스트를 실행하라. 테스트가 잘못된 경고를 발생시킬 경우 처리하라. 기반 코드가 어떻게 동작하는지 이해하려고 할 때는 테스트를 읽는 데 시간을 투자하라. 이런 높은 유지보수 비용으로 인해 테스트의 순 가치가 0에 가깝거나 심지어 0보다 작은 테스트를 만들기 쉽다. 지속 가능한 프로젝트 성장을 위해서는 고품질 테스트에만 집중해야 한다. 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표 커버리지 지표는 테스트 스위트가 소스 코드를 얼마나 실행하는지를 백분율로 나타낸다. 커버리지 지표는 중요한 피드백을 주더라도 테스트 스위트의 품질을 효과적으로 측정하는 데 사용될 수 없다. 코드를 단위 테스트하는 것과 같은 상황이다. 즉,  커버리지 지표는 괜찮은 부정 지표지만 좋지 않은 긍정 지표다. 1.3.1 코드 커버리지 지표에 대한 이해 가장 많이 사용되는 커버리지 지표로  코드 커버리지 가 있으며,  테스트 커버리지 로도 알려져 있다. 이 지표는 하나 이상의 테스트로 실행된 라인 수와 제품 코드베이스의 전체 라인 수의 비율을 나타낸다. 코드 커버리지 = 테스트 스위트가 실행한 코드 라인 수 / 전체 라인 수 ex) 4/5 = 80% ex) 3/3 = 100% 1.3.2 분기 커버리지 지표에 대한 이해 분기 커버리지는 코드 커버리지의 단점을 극복하는 데 도움이 되므로 코드 커버리지보다 더 정확한 결과를 제공한다. 분기 커버리지 지표는  if 문과  switch 문과 같은 제어 구조에 중점을 둔다. 분기 커버리지 = 통과 분기 / 전체 분기 수 ex) 1/2 = 50% 1.3.3 커버리지 지표에 관한 문제점 분기 커버리지로 코드 커버리지보다 더 나은 결과를 얻을 수 있지만, 테스트 스위트의 품질을 결정하는 데 어떤 커버리지 지표도 믿을 수 없는 이유는 다음과 같다. 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다. 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다. 다음은 검증이 없는 테스트를 보여주는 다소 극단적인 예제다. 이 테스트에서는 코드 커버리지와 분기 커버리지가 둘 다 100%이다. 그러나 아무것도 검증하지 않기 때문에 전혀 쓸모가 없다. 만약 각각의 코드에 대해 철저히 검증한다고 하면 신뢰할 수 있을까? 아니다. 두 번째 문제는 모든 커버리지 지표가 테스트 대상 시스템이 메서드를 호출할 때  외부 라이브러리가 통과하는 코드 경로를 고려하지 않는다는 것 이다. 이는 커버리지 지표가 외부 라이브러리의 코드 경로를 고려해야 한다는 것이 아니라, 해당 지표로는 단위 테스트가 얼마나 좋은지 나쁜지를 판단할 수 없다는 것을 보여준다. 커버리지 지표로 테스트가 철저한지 또는 테스트가 충분한지 알 수는 없다. 1.3.4 특정 커버리지 숫자를 목표로 하기 테스트 스위트 품질을 결정하기에 커버리지 지표만으로는 충분하지 않다는 것을 깨달았을 것이다. 특정 커버리지 숫자를 목표로 삼기 시작하면 위험 영역으로 이어질 수 있다.  커버리지 지표를 보는 가장 좋은 방법은 지표 그 자체로 보는 것이며, 목표로 여겨서는 안 된다. 시스템의 핵심 부분은 커버리지를 높게 두는 것이 좋다. 하지만 이 높은 수준을 요구 사항으로 삼는 것은 좋지 않다. 그 차이는 미미하지만 매우 중요하다. 1.4 무엇이 성공적인 테스트 스위트를 만드는가? 개발 주기에 통합돼 있다. 코드베이스에서 가장 중요한 부분만을 대상으로 한다. 최소한의 유지비로 최대의 가치를 끌어낸다. 1.4.1 개발 주기에 통합돼 있음 자동화된 테스트를 할 수 있는 방법은 끊임없이 하는 것 뿐이다. 모든 테스트는 개발 주기에 통합돼야 한다. 이상적으로 코드가 변경될 때마다 아무리 작은 것이라도 실행해야 한다. 1.4.2 코드베이스에서 가장 중요한 부분만을 대상으로 함 시스템의 가장 중요한 부분에 단위 테스트 노력을 기울이고, 다른 부분은 간략하게 또는 간접적으로 검증하는 것이 좋다. 대부분의 애플리케이션에 가장 중요한 부분은 비즈니스 로직(도메인 모델)이 있는 부분이다. 비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다. 다른 모든 부분은 세 가지로 나눌 수 있다. 인프라 코드 데이터베이스나 서드파티 시스템과 같은 외부 서비스 및 종속성 모든 것을 하나로 묶는 코드 이 중 일부는 단위 테스트를 철저히 해야 할 수 있다. 예를 들어 인프라 코드에 복잡하고 중요한 알고리즘이 있을 수 있으므로, 테스트를 많이 하는 것이 좋다. 그러나 일반적으로 도메인 모델에 관심을 더 많이 갖는 것이 옳다. 1.4.3 최소 유지비로 최대 가치를 끌어냄 단위 테스트에서 가장 어려운 부분은 최소 유지비로 최대 가치를 달성하는 것이다. 이것이 이 책에서 말하려는 핵심이다. 테스트를 빌드 시스템에 통합하는 것만으로는 충분하지 않으며, 도메인 모델에 높은 테스트 커버리지를 유지하는 것도 충분하지 않다. 또한 가치가 유지비를 상회하는 테스트만 스위트에 유지하는 것이 중요하다. 이 속성은 두 가지로 나눌 수 있다. 가치 있는 테스트 (더 나아가, 가치가 낮은 테스트) 식별하기 가치 있는 테스트 작성하기 1.5 이 책을 통해 배우는 것 이 책을 통해 스위트 내의 모든 테스트를 분석하는 데 사용할 수 있는 기준들을 설명한다. 이 기준들이 기초다. 그러고 나서 새로운 관점에서 많은 테스트를 볼 수 있으며, 어떤 것이 프로젝트에 기여하고 어떤 것을 리팩터링해야 하거나 완전히 제거해야 하는 지 알 수 있을 것이다. 디자이너에게는 그라데이션이 조화롭고 유용하게 되는 원리를 아는 것이 중요하다. 이 포스트는 그라데이션 디자인에서 일반적으로 해야 하는 것과 하면 안되는 것에 대해서 얘기를 해본다. 한 공간에서의 색 배치   매끄러운 그라데이션을 만들기 위해 항상 부드러운 색 전환을 사용하고자 한다.  그라데이션을 너무 여러 색으로 덮지 않는다. 두개나 세개의 단계만 사용하도록 한다. 조화로운 색 전환만큼 중요한 건 없다는 것을 항상 고려하며 작업하자. 보색을 사용한 그라데이션   많은 디자이너들이 그라데이션에 보색을 사용하여 유쾌한 대비를 만들어 낸다. 종종 몇몇 디자이너들은 그라데이션에 보색만을 사용한 두 단계로 나타내는데, 이건 중앙에 회색빛을 만들고, 눈에 불쾌감을 준다. 이 문제를 해결하기 위해서는 그라데이션에 새로운 단계를 추가해야 한다. 컬러 휠에서 색상을 선택해보면 도움이 될것이다.   사용자의 눈을 위한 가이드 우리는 종종 아름답고 조화로운 배경을 만들기 위해 시각적 측면만을 위해 그라데이션을 사용하지만 앱이나 웹사이트의 사용자 흐름을 제어하는 데 사용할 수 있다.   개발 환경 에디터 현재  VS code vi 나  vim 버전 관리 시스템 git은 저장소가 분산되어있어 공동작업에 굉장히 유리하다. 기능면에서는 git이 우월하나 시스템이 복잡하고, 배우기 어려울 수도 있다. 꼭 알아두면 좋은 명령어 저장소를 만드는 방법 코드를 커밋하고 푸시하는 방법  브랜치를 작성하고 전환하고 병합하고 rebase하는 방법 추가적으로 커밋메세지를 잘 작성하는 방법을 배워두면 좋다. 좋은 git 커밋 메시지를 작성하기 위한 7가지 약속 가능하면 텍스트 환경에서 사용하는 것도 배워두자.  Shell ohmyzsh : 손이 많이 가는 shell설정을 굉장히 간편하게 할 수 있다. Terminal client iterm이 가장 좋았다. Virtual box internet explorer 를 돌릴 방법은 존재하지 않기 때문에  internet explorer parallels  에 비해서는 기능이 부족하나 굳이 돈내고 쓸만큼 필요하진 않다. Node.js 여러 버전의 node 버전을 관리할 수 있어야 한다. nvm n : 이게 내 취향에는 더 맞았다. 부가 프로그램 LICEcap: 화면캡쳐프로그램 캡쳐할 영역을 선택하는 기능 커서도 캡쳐가 되어야 하고, 클릭한 순간을 강조해서 보여줄 수 있으면 좋다. 다행히 프론트엔드는 다른 분야보다 도구의 제한이 적다. (like XCode) 프론트엔드 개발자라는 직업이란? 프론트엔드 개발자는 애플리케이션이 사용자와  맞닿는 지점 을 만들고 책임지는 사람. 다양한 사용자가 웹 애플리케이션을  차별 없이  사용할 수 있도록 해야한다. 공부해야 하는 것들.. 디자인 영역도 공부를 해야하고, 사용자 경험, 배포와 같은 분야도 공부를 해야한다. 대부분의 사람은 적당한 성능과 손쉬운 사용을 좋아한다. 백엔드는 critical한 문제가 아니라면 별로 눈에 띄지 않는다. 하지만 클릭이 안되거나 드래그가 안된다면 이거 불편하네 라고 바로 인식되어 버린다.. 사용자가 직접 보는 비주얼적인 영역이 많기 때문에, 디자이너와 협업할 일도 많고, 백엔드에 대한 지식도 충분해야 한다. 데이터베이스, 인증, 파일을 제외한 부분이 프론트로 옮겨지고 있으며, javascript도 계속 발전하며, html, css도 계속 진화하고 있다. 즉, 계속 공부해야 한다. 부트캠프에서 한번 배웠다고 끝나지 않으며, 스스로 공부하는 방법을 익혀야 한다. 프론트엔드 개발자의 장점을 알아보자 인기 있다는 것 또한 웹 애플리케이션은 프론트엔드에서 완성된다. 이런 굉장히 중요한 일을 하고 있다는 것에서 오는 만족감도 크다. 업무에서의 장점 공부 방법 프론트엔드 개발은 배울 게 너무 많다. 네이버 메인의 경우 겨우 30여개의 html tag를 사용하고 있다. 40개정도면 어지간한 웹페이지는 사용할 수 있다.   즉, 시험범위를 줄이자.  = 국영수 위주로 공부  또한 시간이 날때마다 공식문서를 읽자.  = 교과서 위주로 공부 읽는 방법에 대해서는 한번에 완벽하게 읽기보다는 자주 읽는 것을 권장한다. 이것저것 많이 경험해보는 것이 중요하다. 기업에서는 늘 경력자를 찾는다. 여기서 경력의 의미는 특정 프레임워크를 얼마나 사용해봤고, 얼마나 능숙하게 사용할 수 있는지. 코드를 많이 읽는 것 기존 코드의 규칙을 따르는 것이 중요하다. 다행히 프론트엔드 분야는 다른 사람의 코드를 읽기 굉장히 편하다. 개인 프로젝트를 해보는 것 기업은 프레임워크나 버전 선정에 있어서 보수적으로 접근할 수 밖에 없다. 책임은 내가 지면 되니까 최신의 기술을 써볼 수 있다.  프로젝트를 선정할 때는 지금 나한테 가장 중요한 것으로 정한다. 새로운 기술을 공부하고 싶다면, 하나 골라서 만들어본다. 블로그 잘 알고 있는 기술이라고 생각되어도 글로 써보면 아닌 경우가 많다. 실용주의 프로그래머 - 고무오리 디버깅 같은 맥락이다. 불특정 다수에게 해당 기술에 대해 가르치는 것이 굉장히 좋다. 글 작성에 있어서 원칙 * 정확한 지식만을 전달한다. * -&gt; 글에 첨부할 자료를 저절로 얻게 된다. 트렌드 프론트엔드 개발분야가 어려운 이유는 트렌드가 상당히 빨리 변화하기 때문이다. 앞으로 뭐가 뜰지는 모른다. 하지만 남들보다 조금 빨리 접해볼 수는 있다. Github 트렌딩 주 3회 이상 보기. 트렌드를 정리해서 보내주는 메일링 리스트를 구독, 유명한 sns 계정을 팔로우하자. 가능하면 영문으로 된 자료가 좋다. 추천 twitter 계정 @GeekNewsBot, @estima7, @WebPlatformNews, @dan_abramov, @nodejs_ko, @paul_irish, @addyosmani, @JavaScriptDaily, @devsfarm, @smashingmag, @nodejs, @thoughtbot, @openjsf, @gaeraecom, @taggon 채용공고를 자주 읽어보자. 기술을 빠르게 익히는 법 ex. 리액트 방식으로 생각하기 그 다음 아주 쉬운 예제부터 공부한다. 왜 이렇게 작성했는지 연구하고, 조금씩 바꿔보고 해보자. 그냥 복붙만 하다보면, 아주 오래 후에도 계속 그렇게 가져다가 쓰기만 한다. 협업 디자인  자주 사용하는 스타일을 컴포넌트로 만들어두고, 이 과정에서 디자이너를 참여시킨다. 피드백과 수정은 피할 수 없으니 최소규모로 계속 반복하라. 백엔드 백엔드 개발자와 일할 때에는 api위주로 소통한다. 안된다는 말은 가능하면 참자. 조건부터 변경해 본다. (기한 연장) 안된다면, 요구를 변경한다. (기능 축소) 번외) 풀스택 개발자 풀스택 개발자라는 말은 김밥, 라면, 돈까스, 짜장면, 초밥을 다 파는 식당과 같다. 하지만 풀스택이 될 정도로 백엔드 지식을 갖추는 것은 중요하다. 문제상황 사실 switch에서 문자열을 쓰는 방법은 굉장히 다양하다. map을 써서 enum 형태로 반환되는 함수를 쓸 수도 있을 것이고, 아예 switch 자체를 구현할 수도 있을 것이다. 하지만 오늘 공부한 내용은 좀 활용가치가 높은 것 같아서 기록해두려고 한다. switch는 특성상 case 다음에 무조건 상수 표현식이 있어야 한다.    그렇기 때문에 일반적인 함수로는 다음과 같은 코드를 만들 수 없다. constexpr 이란? C++11에 constexpr 이라는 키워드가 추가되었다. constexpr은 변수 또는 함수의 값을 컴파일 시점에 도출하여 상수화 시켜주는 아주 강력한 기능이다. 컴파일 시점에 상수로 처리되기 때문에 switch case 문에서도 상수로 취급된다! 이를 통해 다음과 같은 코드를 만들 수 있다. constexpr을 함수에 사용할 때 제약사항 constexpr을 사용하는 데 있어서 몇가지 제약사항이 있는데 간단하게 정리하고 마무리한다. 반환값이 무조건 Literal Type이어야 한다. virtual로 재정의된 함수가 아니어야 한다. 재귀 함수로 사용할 수 있다. 함수에 constexpr을 붙일 경우 inline을 암시한다. C++11에서는 함수 본문에 지역변수를 둘 수 없고, 하나의 return 구문만 있어야 했다. 위 제약은 C++14에서 사라졌다. 구현 예시 다음은 백준의 17347번  Text Editor 를 풀이한 코드이다. Reference  Microsoft Docs - constexpr(C++)  [C++] switch 문에서 문자열 사용하기 (Feat. constexpr)  2021 년 연말 회고  를 읽고 아침부터 동기부여를 받아서 뒤늦게 나도 한번 써보고 싶어졌다. (쓰다보니 재밌다!) 2021년은 정말 지금까지의 내 인생 중 가장 많은 일이 일어났던 해가 아니었나 싶다. 아무래도 코로나 때문에 외부활동이 적어지면서, 뭔가 자기계발에 열중했던 것 같다.  그냥 하나씩 되돌아보며 내년 목표도 세워볼 겸 몇 자 적어본다. SKKRYPTO 정말 많은 것을 배운 학회활동이었다. 너무 좋은 사람들을 만났다. 블록체인에 대해 공부한 것보다 좋은 사람들을 만날 수 있던 게 훨씬 좋았던 것 같다.  링크드인이 아주 풍요로워졌다. 그리고 인간 관계에 대해서 참 많은 고민을 하고 성장할 수 있는 계기가 되었던 것 같다.  GroundX KIR   올해 했던 것 중에 제일 아쉬운 프로젝트이다.  프로젝트를 시작할 당시 내가 너무 덜 준비된 상태였고, 프론트엔드에 대한 기본적인 이해도 부족했다.  프로젝트 시작하기 전에 해커톤이 아닌 작은 토이프로젝트 하나라도 완성을 하고 시작했다면 어땠을까 하는 아쉬움이 남는다. 하지만 덕분에 정말 많은 스터디를 했었고, 너무 많이 배웠다.  정말 건강한 사람들과 갖는 건강한 모임이었어서 이 조직에 있는 내내 행복했다. KPMG Lighthouse   해커톤 특전으로 단기 인턴을 했다.  개발 회사가 아닌 회계법인이어서 사실 별 기대는 안했다. 가기 전에도 카카오 엔터프라이즈 인턴을 쓰려고 버둥댔다. 하지만 여기에서도 정말 많이 배울 수 있었다. 여기에서는 단기 인턴이다보니 혼자 간단한 토이 프로젝트정도 되는 업무를 진행했었다. 아무런 책임 없이 혼자서 하다보니 상당히 많은 시행착오를 겪었고, 어떤 라이브러리를 써야 할지부터 OS X와 Windows간의 호환성같은 걸 처음 고민해본 프로젝트였다. 또 여러가지 공부를 병행하며 진행했었는데, 이때 배운 일렉트론이라는 라이브러리를 적용해보면서 처음으로 데스크탑 앱을 만들어보기도 했다. 만약 앞으로 내가 사이드 프로젝트를 진행한다면 여기서의 경험이 정말 도움이 많이 될 것 같다. Musetown Onboarding   학교에서 실리콘밸리 개발인턴을 모집한다는 글을 발견했고, 요구 스택이 나랑 너무 잘 맞아서 보자마자 무지성으로 지원서류를 넣었다. 1차 면접은 라이브 코딩테스트 + 기술 인터뷰로 진행됐다. 라이브 코딩테스트에서 문제를 읽자마자 바로 풀이가 떠오르지 않았는데, 후.. 준비 좀 할걸.. 이라는 생각이 들었다. 그리고 일단은 Constraints가 $O(N^2)$ 으로 뚫렸기 때문에 차근차근 Naive한 풀이를 작성했다. 아 좀 개선할 여지가 분명히 있을 것 같다.. 라는 생각이 들었고, 차근차근 손으로 테스트케이스를 만들던 중 최근에 공부한 $FWHT$라는 알고리즘을 적용할 수 있는 문제 같았다. 제한시간 내에 코드를 쓸 수는 없었기에, 함수의 원형만 선언하고 코드를 작성했다. 정해는 그리디하게 접근해서 O(log N) 이었다 다행히 1차 면접을 통과했고, 2차는 대표님과 인터뷰를 진행했다. 2차다보니 Soft-skill에 관한 질문이 대부분이었고, 나름 잘 대답한 것 같다고 생각하고 있었다. 그 결과 2차까지 통과했다!! 🥳🥳 지금 온보딩을 시작한지 3주정도 시간이 지났는데, 매일매일 정말 많이 공부하고 있다. 근데 하나도 따분하지가 않다. 너무 즐겁다. 대표님과 사수님이 적응하는 데 큰 도움을 주셔서인것 같다. 더 열심히 일해서 더 열심히 배워야겠다! Studying Group   올해는 스터디를 진짜 많이 했다.  SKKRYPTO 5, 6기끼리 Spring, React, Typescript 스터디를 진행했었고 같이 KIR을 준비한 형들이랑 클린코드, 리팩터링같은 책들을 읽었고 학회 외적으로는 프론트엔드, Effective Typescript 스터디를 진행했다. 지금은 디자인패턴 스터디를 진행하고 있다. 굉장히 많은 스터디들을 해보면서 스터디를 잘 진행할 수 있는 방법에 대해 깨달아버렸다. 어떤 강의를 보거나 책을 읽거나 할 때에 가장 중요한 점은  기록하는 것 이다. 내가 이해한 내용에 대해서 기록해 두는게 가장 중요한 것 같다. 두번째는  발표하는 것 이다. 내가 쓴 글을 발표해보면서 이해를 확실히 했는지 알 수 있고, 여기에 다른 사람의 발표가 합쳐지면서 좀 더 완성된 인사이트를 얻을 수 있다. Velog 2021년부터 글을 좀 본격적으로 쓰기 시작했다. Velog라는 플랫폼을 선택한 것은 두 가지 이유가 있는 것 같다. 마크다운으로 글을 작성하기 때문에 마우스가 없어도 글을 쓰기 굉장히 편하다. 생각보다 트렌딩에 올라가기 쉬워서 동기부여가 정말 잘된다. 2021년동안 트렌딩에 6개 정도 글이 올라간 것 같다.  모바일 UI･UX 디자인 시 고려해야 할 가이드라인 48가지  유용한 리액트 패턴 5가지  Modal에 관한 간단한 고찰 이 세 글은 정말 혼신의 힘을 들여서 작성한 글이었는데, 많이 좋아해주셔서 정말 뿌듯했다.   또 생각치도 못하게 핏자라는 플랫폼에서 내 게시물을 리포스팅해도 되냐는 연락도 받았었다.  핏자 페이스북 너무 영광이었고, 뿌듯했다! 2022년 목표 이번에 Musetown 인턴십(사실 확정인지 아닌지 잘 모르겠다.)을 진행하게 되었는데, 여기에 정말 온 힘을 쏟아 붓고 싶다. 웹캠도 하나 장만했고, 의자도 거금을 들여 바꿨다. 딱 세 개가 올해 목표인 것 같다.  Musetown에서 열심히 일하기 군대 제때 가기 운동하기 (적어도 일주일에 2~3번) 군대.. 더이상 미룰 수 없다.. 이제는 가야한다.. 인턴십이 끝나는 대로 바로 군대로 넘어갈 것 같다. 그리고 운동은 올해 우울증에 시달리면서 살이 말도 안되게 많이 쪘는데, 슬슬 몸이 좀 흉측해져가고 있는 것 같다. 정신 상태가 정상궤도에 들어왔으니, 이제는 몸도 정상궤도에 올려놓을 시간이 된 것 같다. 1. Cookie &amp; Session 기반 인증 쿠키를 통해 클라이언트 로그인 상태를 유지시킬 수 있지만, 가장 큰 단점은 쿠키가 유출 및 조작당할 위험이 존재한다는 것이다. 개인정보를 HTTP로 주고 받는 것은 위험하다. 세션은 비밀번호 등 클라이언트의 인증 정보를 쿠키가 아닌 서버 측에 저장하고 관리한다. 서버는 클라이언트의 로그인 요청에 대한 응답을 작성할 때, 인증 정보는 서버에 저장하고 클라이언트 식별자인 JSESSIONID를 쿠키에 담는다. 이후 클라이언트는 요청을 보낼 때마다, JSESSIONID 쿠키를 함께 보낸다. 서버는 JSESSIONID 유효성을 판별해 클라이언트를 식별한다. 장단점 쿠키를 포함한 요청이 외부에 노출되더라도 세션 ID 자체는 유의미한 개인정보를 담고 있지 않다. 그러나 이를 중간에 탈취하여 클라이언트인척 위장할 수 있다는 한계가 존재한다. 각 사용자마다 고유한 세션 ID가 발급되기 때문에, 요청이 들어올 때마다 회원정보를 확인할 필요가 없다. 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해진다. 2. JWT 기반 인증 JWT(JSON Web Token)란 인증에 필요한 정보들을 암호화시킨 토큰을 의미한다. JWT 기반 인증은 쿠키/세션 방식과 유사하게 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별한다. 인증 과정 클라이언트 로그인 요청이 들어오면, 서버는 검증 후 클라이언트 고유 ID 등의 정보를 Payload에 담는다. 암호화할 비밀키를 사용해 Access Token(JWT)을 발급한다. 클라이언트는 전달받은 토큰을 저장해두고, 서버에 요청할 때 마다 토큰을 요청 헤더 Authorization에 포함시켜 함께 전달한다. 서버는 토큰의 Signature를 비밀키로 복호화한 다음, 위변조 여부 및 유효 기간 등을 확인한다. 유효한 토큰이라면 요청에 응답한다. 장점 Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다. 인증 정보에 대한 별도의 저장소가 필요없다. JWT는 토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증됬음을 증명하는 서명 등 필요한 모든 정보를 자체적으로 지니고 있다. 클라이언트 인증 정보를 저장하는 세션과 다르게, 서버는 무상태가 된다. 확장성이 우수하다. 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다. OAuth의 경우 Facebook, Google 등 소셜 계정을 이용하여 다른 웹서비스에서도 로그인을 할 수 있다. 모바일 어플리케이션 환경에서도 잘 동작한다. 단점 쿠키/세션과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해진다. Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다. 토큰을 탈취당하면 대처하기 어렵다. 토큰은 한 번 발급되면 유효기간이 만료될 때 까지 계속 사용이 가능하기 때문이다. 특정 사용자의 접속을 강제로 만료하기 어렵지만, 쿠키/세션 기반 인증은 서버 쪽에서 쉽게 세션을 삭제할 수 있다. 3. 보안 전략 JWT 사용시 상기한 단점들을 극복하기 위해 다양한 전략을 채택할 수 있다. 각각의 전략은 장단점이 상이하기 때문에, 서비스의 특성을 고려하여 보안 수준을 높일지 사용자의 편의성을 높일지 결정해야 한다. 짧은 만료 기한 설정 토큰의 만료 시간을 짧게 설정하는 방법을 고려할 수 있다. 토큰이 탈취되더라도 빠르게 만료되기 때문에 피해를 최소화할 수 있다. 그러나 사용자가 자주 로그인해야 하는 불편함이 수반된다. Sliding Session 글을 작성하는 도중 토큰이 만료가 된다면 Form Submit 요청을 보낼 때 작업이 정상적으로 처리되지 않고, 이전에 작성한 글이 날아가는 등의 불편함이 존재한다. Sliding Session은 서비스를 지속적으로 이용하는 클라이언트에게 자동으로 토큰 만료 기한을 늘려주는 방법이다. 글 작성 혹은 결제 등을 시작할 때 새로운 토큰을 발급해줄 수 있다. 이를 통해 사용자는 로그인을 자주 할 필요가 없어진다. Refresh Token 클라이언트가 로그인 요청을 보내면 서버는 Access Token 및 그보다 긴 만료 기간을 가진 Refresh Token을 발급하는 전략이다. 클라이언트는 Access Token이 만료되었을 때 Refresh Token을 사용하여 Access Token의 재발급을 요청한다. 서버는 DB에 저장된 Refresh Token과 비교하여 유효한 경우 새로운 Access Token을 발급하고, 만료된 경우 사용자에게 로그인을 요구한다. 해당 전략을 사용하면 Access Token의 만료 기한을 짧게 설정할 수 있으며, 사용자가 자주 로그인할 필요가 없다. 또한 서버가 강제로 Refresh Token을 만료시킬 수 있다. 그러나 검증을 위해 서버는 Refresh Token을 별도의 storage에 저장해야 한다. 이는 추가적인 I/O 작업이 발생함을 의미하기 때문에 JWT의 장점(I/O 작업이 필요 없는 빠른 인증 처리)을 완벽하게 누릴 수 없다. 클라이언트도 탈취 방지를 위해 Refresh Token을 보안이 유지되는 공간에 저장해야 한다. 4. 정리 장점 단점 Cookie &amp; Session 서버에서 Session 통제 가능   네트워크 부하가 낮음 세션 저장소 사용으로 인한 서버 부하 JWT 인증을 위한 별도의 저장소가 필요 없음   별도의 I/O 작업 없는 빠른 인증 처리   확장성이 우수함 토큰의 길이가 늘어날 수록 네트워크 부하 특정 토큰을 강제로 만료시키기 어려움 Reference  JWT 장점과 단점  서버 인증(세션/쿠키 기반)  Refresh Token과 Sliding Sessions를 활용한 JWT의 보안 전략  Refresh Tokens: When to Use Them and How They Interact with JWTs  인증 방식 : Cookie &amp; Session vs JWT  jwt.io  23570. Grid Triangle  Platinum 3 문제 분석 ICPC Regional Seoul 2021 E번이었다.. 대회 중에 못 푼게 너무 한이 돼서 진짜 열심히 업솔빙한 문제였다. 우선 문제 조건부터 정리를 해보자. 문제에서는 Grid Triangle을 다음과 같이 정의한다.  There exist three different positive integers $X$, $Y$, $Z$ such that for every pair of the three points of the triangle, you can rotate and translate the cuboid of size $X × Y × Z$ in parallel with the grid system so that the pair are diagonally opposite (and so the farthest way) vertices of the cuboid. 번역을 해보자면 다음과 같다. 삼각형의 세 점의 각 쌍에 대해서 세 개의 다른 $X$, $Y$, $Z$ 가 존재해서 그 변을 적절히 돌리거나 이동시켰을 때 격자에서 $X × Y × Z$ 직육면체의 대각선에 평행하게 만들 수 있어야 한다. 여기서 직육면체의 대각선은 어떤 면의 대각선이 아닌 직육면체에서 가장 먼 두 점을 잇는 대각선을 의미한다. 문제는 ${(x, y, z)| -A ≤ x ≤ A, -B ≤ y ≤ B, -C ≤ z ≤ C}$를 만족하는 점으로 이루어진 Grid Triangle의 개수를 찾는 문제였다.  풀이 일단 세 점 중 하나는 무조건 원점이므로 다른 두 점이 갖춰야 할 기본적인 조건에 대해서 생각해보자. 만약 한 점이 $(x, y, z)$라고 할 때, 다른 한 점은 $(\pm y, \pm z, \pm x)$ 뭐 대충 이런 식으로 될 것이라고 기대할 수 있다. 같은 축에 같은 숫자가 오면 안되기 때문이다. 그러면 여기에서 우리는 $x&lt;y&lt;z$일 때, $x+y$가 $z$라고 예상할 수 있다. 여기부터가 중요한데, 케이스가 꽤 많이 나뉜다.. 문제를 풀기 위해 해결해야할 가장 중요한 세 가지 경우만 나열하고 글을 마무리 하려 한다. 풀이를 직접 알려줘버리면 너무 쉽게 끝나기 때문이다..  3 6 6 80 3 9 9 80 3 4 4 64 내가 이 세 개를 체크를 안해서.. 8번이나 (대회 포함 13번..) 절었기 때문에.. 앞으로 푸실 분들은 이 케이스들을 꼭 체크해보면 좋을 것 같다... 고찰 icpc 본선 후기를 따로 쓸 게 없다.. 내가 맡은 문제가 이거 하나였고.. 이거 하나를 못풀었었다.. 굉장히 아쉽고.. 또 아쉬운 대회였다..  Codeforces Round #755 (Div. 2, based on Technocup 2022 Elimination Round 2)  Virtual Participation 후기입니다. A. Mathematical Addition 00:03  A solved B. Coloring Rectangles 00:08  B Wrong answer 그리고 비슷한 시도로 계속 트라이를 했다.. 뭔가 잘못된게 있다고 생각하며.. 00:12  B Wrong answer 00:14  B Wrong answer 00:16  B solved C. Two Arrays 엥 B보다 너무 쉬웠다. 그냥 입력받아서 정렬한 다음에 해당하는 숫자 쭉 보다가 안되면 NO를 출력하면 되는 문제였다.  00:22  C solved D. Guess the Permutation  솔직히 보자마자 좀 멘붕왔다. 00:50  D Wrong answer 이분탐색 과정에서 깔끔치 못했던 실수를 발견했다. 바로 고쳐서 다시 제출했다.  짜는 동안 아 쿼리 보내는 거 함수로 하나 만들까..라는 고민을 5번쯤 했는데, 5번 다 하니까 더 이상 쿼리를 쓸일이 없었다.  00:56  D solved E. Game with Stones 문제 제목을 보고 아니 설마 그런디??? 하며 신나게 문제를 읽었고, 어중간한 지식으로는 건들지 말라는 누군가의 목소리가 들렸다. 바로 포기했다. 후기  14555. Just as Tic Tac Toe  Diamond 4 문제 분석 풀이 이걸 그나마 최적화를 한다고 하면, 빈도수 배열을 만들어 저장한 뒤, $(a,b)$의 쌍만 구해 c와 비교하는 식의 풀이가 될 것이다. 이는 $O(N^2)$이 될 것이다.  앞에서 말했듯, N은 50만이어서 이런 풀이가 택도 없다. Z_2  \cdots Z_2$ 끼리의 곱으로 생각할 수 있고, 이를 수행해주는 알고리즘이 바로 FWHT(Fast Walsh Hadamard Transform)이다. 이에 관한 정리는  Fast Walsh Hadamard Transforms  여기에 내가 할 수 있는 최대한 자세히 정리해뒀다. 이게 끝이다. 두 집합의 xor set을 구하고 원래 배열과 중복없이 모든 순서쌍을 세기만 하면 되는 문제이다. 고찰 풀고 있는 알고리즘 리스트( Platinum V  이상) 게임 이론 ( 34 / 104 ) 본 글은  코드포스 블로그 를 번역, 정리한 글입니다. 오타, 오역은 댓글로 피드백 부탁드립니다. 솔직히 번역 진짜 자신 없었습니다.. 본 글을 이해하기에 앞서 DFT/FFT에 대한 이해가  무조건 필요 합니다. FWHT가 무엇일까? 만약 두개의 집합$(1,2,2)$와 $(3,4,5)$를 갖고 있고 둘 사이에서 일어날 수 있는 가능한 모든 xor을 구한다면, 결과는 $(1,1,2,4,5,6,6,7,7)$이 될 것이다. 이를 흔히 xor convolution이라 부르고, 이를 naive하게 구현한다면 $O(n^2)$에 할 수 있다.  FWHT는  흑마법  FFT 트릭을 이용해 이를 $O(n\log n)$에 하도록 만들어준다.  그러면 이게 왜 되는 걸까? 그리고 이걸 왜 알아야 할까? 우선 첫 번째 질문에 대답해보자. FFT에 대한 두가지 사실을 알고난 다음이지만.. Fact 1 우선 $(1+2x)$ 와 $(3+4x)$를 곱한다고 하자. 우선 사이즈를 4로 맞춰 줘야 한다. 그리고 나서 point-value form으로 만들고, pointwise 곱셈을 해준뒤, 다시 inverse FFT를 통해 원래 값을 구한다.  첫 단계에서 이 곱셈의 최종 크기가 3인 걸 알기 때문에 우리는 적어도 3개의 point-value 쌍들이 필요할 것이다. 만약 이렇게 크기를 바꾸지 않는다면? 우리는 $(3+10x+8x^2)$ 대신에 $(11+10x)$를 얻게 될 것이다. 그 이유를 찾아보자면 우리가 1과 -1이라는 1의 제곱근밖에 사용하지 않기 때문일 것이다. 여기에는 $x^2=1$이라는 식이 존재하기 때문에 이차 항이 상수항에 기여를 하면서 &quot;사라지게&quot; 된다. 여기서의 교훈은, 만약 우리가 충분히 세밀한 근을 사용하지 않는다면, 더 높은 고차항이 &quot;사라지게&quot; 된다는 것이다. Fact 2 크기 n의 일변수 다항식의 경우 우리는 n개의 값이 필요했다. (fft에서는 분할정복을 위해 1의 거듭제곱근을 사용한다.) 예를 들어 10,20과 30,40을 각각 $x$, $y$에 사용한다면, $P(10,30)$, $P(20,30)$, $P(10,40)$, $P(20,40)$이 각각 $1$, $x$, $y$, $xy$로 $P(x,y)$를 유일한 형태로 표현 가능하다. 심지어 우리는 10,20을 $x$, $y$ 둘 다에도 사용할 수 있으며, 이 또한 멀쩡히 작동할 거다. 여기서의 교훈은 다변수 다항식의 FFT는 그저 값들을 좀 묶어서 계산하는 일반 FFT일 뿐이라는 것이다. 드디어 FWHT 다항식 곱셈에서 $ax^i$와 $bx^j$의 곱은 $abx^{i+j}$로 합쳐진다. 우리는 이런 병합을 모든 가능한 쌍들에 대해 수행하고 $x$의 차수에 따라 묶어서 정리한다. Fact 1 을 다시 되돌려 생각하면, 우리가 만약 숫자를 1과 -1만 사용한다면 $x^2=1$ 때문에 $x^p_i⋅x^q_i=x^{(p+q) \mod 2}_i$가 저절로 달성된다! 정리하며.. 진짜 진짜 번역하는 건 세상에서 제일 어려웠는데, 막상 하고나니 내용 자체는 별로 어렵지도 않고 FFT에 대한 지식이 있는 누구든 이해할 수 있는 내용인 것 같다. 빨리  Just as Tic Tac Toe  문제를 풀러 가야겠다.. 1. GraphQL이란? GraphQL은 API용 쿼리 언어이자 기존 데이터로 이러한 쿼리를 수행하기 위한 런타임입니다. GraphQL은 API의 데이터에 대한 완전하고 이해하기 쉬운 설명을 제공하고, 클라이언트가 필요한 것을 정확하게 요청할 수 있는 기능을 제공하며, 시간이 지남에 따라 API를 더 쉽게 발전시키고 강력한 개발자 도구를 활성화합니다. - GraphQL 공식홈페이지 GraphQL은 우선 SQL과 마찬가지로 쿼리 언어이다. 하지만 그래프큐엘과 SQL의 사용성 측면에서 큰 차이가 있다. 우선 SQL은 데이터베이스에 저장된 데이터를 효율적으로 가져오는 것이 목적이지만, 그래프큐엘은 웹 클라이언트가 데이터를 서버로부터 효율적으로 가져오는 것이 목적이다. 그래서 SQL은 백엔드에서 작성 및 호출하지만 그래프큐엘은 클라이언트에서 작성하고 호출한다. 그렇기 때문에 그래프큐엘이 대체하는 것은 기존의 쿼리 언어들이 아닌 REST API이다. 그렇다면 프론트엔드에서 무엇이 불편했길래 메타( 구 페이스북 2. GraphQL이 나오게 된 배경 기존의 REST API는 리소스와 URI를 조합하여 요청을 보내면 이에 대응하는 응답을 JSON이나 XML 형식으로 넘겨주었다. REST API의 가장 큰 강점은 예측 가능하고 일정한 정보와 작업을 요청하는 것이였다. 하지만 여기서 생기는 문제는 정해진 응답만을 받을 수 있다는 것이다. 예를 들어 A의 전화번호 정보를 받기위해서 A의 모든 정보를 받아야할 수 있다. 이렇게 필요없는 정보까지 받기 위해서 불필요한 리소스(시간, 통신비)가 생긴다.(Overfatching) 이러한 다른 모양의 다양한 요청과 응답이 필요한 서비스들이 많이 생겨났고 그로인한 리소스들을 줄이기 위해서 GraphQL이 각광받게 되었다. REST API vs GraphQL 3. GraphQL의 구조 3-1. Query 쿼리 / Mutation 뮤테이션 REST API의 경우에는 데이터 CRUD를 하기위해 get, post, put, delete를 사용하지만 GraphQL은  Query 와  Mutation Example Query(요청 쿼리 / 응답 데이터)   위 그림과 같이 쿼리와 받은 데이터는 동일한 형태이다. 이렇게 명확하고 직관적인 응답 데이터를 받을 수 있는 이유는 그래프큐엘을 통해 서버가 클라이언트가 원하는 필드를 정확히 알 수 있기 때문이다. Mutation(요청 뮤테이션 / 응답 데이터) createReview  필드가 새로 생성된 리뷰의 stars 와 commentary 필드를 반환한다. 이는 하나의 요청으로 필드의 새 값을 변경하고 쿼리할 수 있기 때문에 기존 데이터를 변경하는 경우 특히 유용하다. 프래그먼트(요청 쿼리) 3-2. Introspection 인트로스펙션 4. 정리 장점 그래프큐엘은 기존의 REST API가 필요한 데이터를 받기 위해서 여러번 요청을 보내야 했던 것(Underfetching)을 한번의 요청으로 발아올 수 있습니다. 필요하지 않은 데이터까지 포함된 데이터 덩어리를 받아오지(Overfetching) 않고 원하는 데이터만 선택적으로 받아올 수 있습니다. 가장 큰 장점은 인트로펙션 기능을 통해서 API 명세의 공유가 자동화 된다는 점이다. 이 부분은 개발의 생산성이 향상되어 백엔드 - 프론트엔드의 협업이 더 쉬워질 것이다. 단점 File 전송 등 Text 만으로 하기 힘든 내용들을 처리하기 위해서는 외부 서비스에 의존하거나 복잡해진다. 고정된 요청과 응답만 필요할 때는 Query 요청의 크기가 REST API 보다 더 커진다. 마무리 오늘 알아본 결과 그래프큐엘은 매우 훌륭하고 좋은 언어이자 서비스지만 만능은 아니다. 어떤 정보를 제공하느냐에 따라 REST API와 그래프큐엘의 효율성이 왔다갔다한다. 서로 다른 모양의 다양한 요청과 응답이 많다면 그래프큐엘이 효율적이지만 HTTP와 HTTPS에 의한 캐싱을 잘 활용하고 싶거나 요청의 구조가 정해지지 않았을 때는 REST API가 효율적일 가능성이 높다. 하지만 하나의 솔루션만을 선택할 필요없이 백엔드 서버에 두가지 솔루션을 모두 사용할 수 있다. 그러니 우리는 새로운 도구를 얻었고 기존의 도구와 잘 활용한다면 더 나은 서비스를 제공할 수 있을 것이다!! Protocol 프로토콜은 둘 사이에 이야기하는 약속이다. 두 컴퓨터 사이에 중용한 정보를 주고 받기 전에 합을 맞추는 준비동작이라고 보면 된다. 네트워크에서 사용자에게 제공하는 네트워킹 프로토콜 서비스는 두가지가 있다. 바로 TCP와 UDP이다. TCP 신뢰성 보낸 정보가 확실히 수신자에게 전달된다. 수신자의 받는 속도에 의존적이다 비용이 비싸다 컴퓨팅 리소스 / 네트워크 리소스가 많이 든다. UDP 속도가 빠르다 하지만 받는걸 보장 못한다 (신뢰성 X) 위와 같은 특징 때문에 전화(음성 전화)에서 많이 사용한다. 몇개 유실되도 괜찮다 교환 방식 circuit switching  정해진 인원 이 일정한 성능의 속도를 보장하기 위한 네트워크 교환 방식 전화와 같이 지속적으로 데이터를 주고 받는 네트워크에서 사용한다. packet switching 성능이 보장되지는 않아도  최대한의 인원 이 사용하기 위한 네트워크 교환 방식 인터넷과 같이 데이터를 지속적으로 받지 않는 네트워크에 유리하다. 패킷 스위칭에서 생기는 문제 (Delay)  processing delay 라우터에서 패킷을 처음 받았을 떄 패킷을 검사하는 딜레이 라우터 성능 개선을 통해 줄일 수 있다.  queueing delay 큐에서 자기 차례가 될 때까지 기다리는 딜레이 사용자가 사용하는 패턴에 따라 딜레이가 생기기 때문에 개선하기 힘들다. 큐가 넘치는 패킷 유실이 발생 / 패킷 유실의 90% 이상이 여기서 발생  transmission delay 자기 차례에서 파이프에 온전히 나갈 때까지 걸리는 딜레이 밴드위드 늘리기  propagation delay 다음 라우터까지 걸리는 딜레이(빛의 속도 / 길이) TCP에서 데이터 유실이 생기는 경우 TCP의 경우 데이터의 전달을 보장하는데 데이터 유실이 발생한 경우 어떻게 데이터를 전달을 보장할까? 데이터 유실이 생긴 경우  네트워크 엣지 에서 유실된 패킷을 다시 전송해준다. 네트워크 계층 네트워크 계층 - 프로토콜 애플리케이션 계층 이메일, 웹 브라우저와 같은 프로세스 계층을 의미한다. 클라이언트 / 서버 아키텍처 서버 고정된 IP주소를 가져야한다. 클라이언트 IP주소를 갖되 고정되지 않아도 된다. 웹브라우저 연결 방법 IP주소(어떤 컴퓨터인지)와 포트 넘버(컴퓨터 안의 어떤 프로세스인지)가 필요하다. DNS란 시스템에 의해서 기존의 우리가 사용하는 URL을 IP주소로 연결된다. 포트넘버를 아무것도 입력안하면 80번이 기본값이다. 모든 웹서비스가 80번 포트를 사용하는 이유 DNS가 IP주소까지만 찾아주므로 포트넘버는 기본값을 사용한다 네트워크 계층이란 하위 계층에서 상위 계층에 기능을 제공한다. 앱 계층에서 필요한 트랜스포트 계층의 서비스   데이터가 전달 보장 (이것만 제공, 이것마저 TCP만 제공 UDP는 미제공)   타이밍 / 시간 용량 보안 HTTP hypertext transfer protocol(트렌스포트 레이어) TCP 서비스 사용 TCP 커넥션 필요 stateless HTTP conection non-persistent HTTP persistent HTTP TCP conection이 사용할 떄마다 만들고 죽여서 사용하는지 계속 유지시키는지 여부 Why? 다크 모드를 설정할 수 없는 웹사이트가 대부분이지만 많은 웹사이트들이 다크모드를 지원하고있다. 다크 모드를 구현하려면 어두운 테마에 맞는 디자인이 추가적으로 들어간다. 추가적인 리소스를 쏟으면서 다크 모드를 구현하는 이유가 무엇일까? 우리가 어두운 곳에서 핸드폰을 할 때 핸드폰 밝기를 낮춘 경험이 있을 것이다. 바로 주변이 어두운 경우 우리의 눈은 빛에 예민해진다. 예민한 눈에 계속해서 밝은 빛을 비추면 눈이 쉽게 피로해지며 눈 건강에도 좋지 않다. 하지만 어두운 곳이 아님에도 빛에 예민한 사용자들이 있다. 이러한 사용자들은 라이트 모드 밖에 없는 웹사이트를 이용할 때 우리가 어두운 곳에서 밝기가 고정된 핸드폰을 하는 느낌을 받게 될 것이다. 그렇기에 웹 접근성을 높이기 위해서 다크 모드를 설정 가능하도록 구현해야한다. 개발 진행 개발 환경 Next.js Typescript Emotion ThemeProvider 이번 프로젝트에서 Emotion을 스타일 라이브러리로 사용하고 있다. 테마 스타일를 적용하기 위해 Emotion에서 제공하는 ThemeProvider 컴포넌트를 커스텀하여 사용했다. ThemeProvider에 Theme을 제공하게 되면 자식 요소에서 해당 Theme을 받아서 사용할 수 있되어 추후 Theme 수정시 일괄적으로 생상 변경이 가능하므로 유지보수에 편리하다. 고려 상황들 window 객체와 Next.js ReferenceError: window is not defined  라는 에러를 만나게된다. Next.js는 기본적으로 SSG를 지원하기 때문에 브라우저 환경에서 사용할 수 있는 window 객체 사용 불가능하다. 사용자 테마 감지 prefers-color-scheme 을 이용해 확인할 수 있다.  Type error Typescript와 ThemeProvider를 같이 사용할 때 테마의 타입을 제공하지 않으면 css props에서 theme의 값을 사용할 수 없다.  공식문서 를 확인해보면  props.theme 을 의도적으로 비워뒀기 때문이다. type-safe를 위해서 비워뒀고 우리가 해당 타입을 정의해서 사용해야한다. Code _app.tsx 파일 설정 CustomThemeProvider.tsx 구현 theme.ts 테마 파일 설정 Global style 설정 위의 코드처럼 css props를 구조분해 할당을 이용하여 theme 값을 받아와서 사용할 수 있다.    프로젝트 개요 쇼핑몰의 주요 기능을 구현해보는 프로젝트입니다.  Github 주소 기술 스택 프레임워크 Next.js 쇼핑몰 컨셉상 검색을 통한 유입 유저가 많다는 것을 생각하여 SSG 또는 SSR을 통해 SEO가 가능한 React 기반 프레임워크인 Next.js를 선정하였다. 추가적으로 Next.js는 자체적인 라우팅 시스템이 있어 기본 React로 구현하는 것보다 아키텍처가 제한된다. 이런 점은 새롭게 배워야한다는 불편함이 있지만 길게 봤을 때는 내가 Next.js를 사용했다는 점 하나만으로 타인이 내 프로젝트의 아키텍처를 볼 때 비교적으로 예상 가능하게 만들어준다는 장점이 있다. 타인 뿐만 아니라 3~4개월 후의 내가 보고 다시 유지보수하기에도 쉬워진다. 언어 Typescript 단순하게 보면 Javascript에 정적타입이라는 컨셉을 추가한 언어다. 하지만 정적타입이라는 컨셉이 추가되면서 개발자한테 정말로 많은 생상성 향상을 제공한다. 명시적인 정적타입을 지원하면서 코드의 가독성을 높이고 TS에서 JS로의 컴파일 단계에서 오류를 포착할 수 있게 되었다. 스타일 라이브러리 Emotion 퍼포먼스가 좋다 라는 이유로 Emotion을 사용하기로 했다. 상태관리 Apollo Client Apollo를 이용하여 간단하게 상태관리 설정이 가능하다. 최근 리덕스 툴킷을 사용하려고 기본 설정을 한 적이 있었는데 리덕스 툴킷이 기존의 리덕스의 기본 설정이 너무 코드가 길고 러닝커브가 크다는 이유에서 등장했고 그에 맞게 러닝커브도 줄고 보일러 플레이트의 크기도 줄었다. 하지만 Apollo와 비교하니 리덕스는 아직도 너무 큰 러닝커브와 보일러 플레이트가 필요했다.  데이터 패칭 Apollo &amp; GraphQL 장점 몇가지를 소개하자면 우선 PlayGround라는 GUI 인터페이스를 기본으로 제공한다. 제공하는 DOCS를 통해 쿼리들와 뮤테이션들의 정보를 확인할 수 있고 SCHEMA를 통해 테이블들의 타입 확인이 가능하다.   그리고 GraphQL을 사용하여 필요한 데이터를 위한 쿼리문을 프론트엔드에서 작성해서 사용하므로 언더패칭, 오버패칭을 방지할 수 있다. 다음과 같이 원하는 데이터를 골라서 사용할 수 있다. gql 사용하여 쿼리문을 프론트엔드에서 작성하므로 프론트엔드 개발자가 데이터를 직접 다룰 수 있게 되어 자유도가 올라간다. 코드 스타일 Prettier &amp; ESLint husky &amp; lint-staged 코드 스타일 컨벤션을 강제하기 위해 ESLint를 사용한다면 Husky와 Lint-staged는 Git을 통한 코드 공유를 할 때 ESLint 규정에 어긋나지 않은 코드만 배포할 수 있도록 강제성을 부여한다. husky와 lint-staged를 이용하여 git commit이 명령어가 실행되기 직전에 Staged된 파일들에 우리가 원하는 검사를 하게된다. 여기서 우리가 원하는 검사란 ESLint 체크다. 만약 ESLint 체크를 했을 때 에러를 띄우면 git commit이 실행되지 않고 멈추게 되고 통과를 해야지 git commit 명령어가 끝까지 완료하게 된다. 폴더 구조 Let&#39;s use Next.js  프로젝트 사이트 둘러보기 깃헙 보러가기 다시 한번 Next 이번에 조은님이 실습 위주의 스터디를 열어주어서 열심히 참여를 해봤다. 주요 기술 스택은  Next.js 와  Typescript ,  useSWR ,  styled-component 였다. 이전에 Next js를 사용해 본적이 있지만 왜 사용해야 하는지를 생각하지 않고 사용을 했고 경험이 많이 부족했었기에 Next의 이점을 제대로 파악하지 못했다. 하지만 이번 기회에 조은님의 기깔나는 설명을 들으면서 Next와 좀 더 친해지는 기회가 됬었다. Futurama API 첫 주차에  sample apis 사이트 의 wines api를 사용하여 조은님이 강의를 진행하고 비슷한 beers api를 이용하여 복습 및 과제를 진행하였고 첫 주차 마무리 과제로  Futurama API 를 이용하여 개별 사이트를 만들어 보는 과제를 진행했다. 이전의  wines 와  beers  API와는 다르게 futurama api는 모든 엔드포인트가 다른 구조의 데이터를 뱉어서 페이지를 구성하는 재미가 있었다. 그 중 신경쓴 엔드포인트를 소개해보도록 하겠다. Character Episodes Questions 실제로 문제를 풀어볼 수 있게 진행하면 너무 재밌겠다!! 라는 생각이 들었다. 과제에 재미가 빠지면 섭하지 않나? 그래서 원하는 대로 구현을 했다. 문제 수는 28개의 문제였기에 7문제씩 4페이지로 나눴다. 누군가는 굳이?라고 생각할 수 있지만 최근에 친구의 부탁으로 32문항의 설문을 진행한적이 있는데 몇번을 그만두고 싶었는지 모른다. 문제는 32문항이라는 문항 수보다는 한페이지에 있다보니 그림하나 없는 논문을 읽는 느낌마저 들었다. 그래서 굳이 4페이지로 나눠서 페이지를 구현해보았다. 하지만 개별 문제들과 페이지네이션과 결과 페이지를 따로 컴포넌트로 나눴기때문에 따로 상태관리 라이브러리 없이 구현하는데 너무 힘들었다. 이전에 프로젝트를 할 때 당연하게 상태관리 라이브러리를 사용했었는데 이번 기회를 통해 필요성을 확실히 느끼는 프로젝트가 되었다. 마무리 이번 프로젝트를 통해 오랜만에 리액트기반 환경에서 개발을 해보았다. 한동안 바닐라 자바스크립트를 통해서 개발을 진행했는데 비교적으로 코드를 깔끔하게 짜기가 좋았고 아케텍처가 제한적이기 때문에 몇개월이 흘러서 봐도 코드를 이해하기 쉽겠다는 생각이 들었다. 그리고 기본 리액트보다 라우팅을 기본적으로 제공하기 때문에 한번 익숙해지면 새로운 프로젝트를 시작하는 허들이 낮아졌다고 생각한다. 거기다 SSG를 이용한 SEO에 강점도 갖고 있기때문에 현재 프론트엔드 개발을하는데 필수로 알아둬야하는 스택 중에 하나라고 생각된다. 배경  프론트엔드스쿨 하지만 슬라이드를 상단 내비게이션 바의 영역을 침범하기위해 position: absolute를 주었더니 위치는 올라갔지만 내비게이션 바를 덮어버리면서 네비게이션바가 나오지 않게 되었다. 그래서 네비게이션 바 밑으로 보내기위해서 슬라이드에 z-index: -1;을 주니까 원하는데로 내비게이션바 아래로 내려갔지만 슬라이드 내부의 a태그가 눌리지 않게 되는 상황을 마주하게되었다.  내비게이션바에도 position을 설정하고 슬라이드와 내비게이션 바에 z-index를 주면서 원하는대로 구현을 했지만 z-index에 음수값을 주었을 때 a태그가 왜 작동을 하지 않는지에 대해서 의문이 생겨 찾아보게 되었다. 추론  MDN 문서 를 읽으면 flex 혹은 grid 컨테이너 요소의 자식 요소 중에 z-index가 auto가 아닐 경우 쌓임 맥락(stack context)가 생성된다고 한다. 쌓임 맥락 안의 자식 요소는 해당 규칙에 의해서 쌓이게 된다고 정의되어 있다. 하지만 부모요소의 아래로 쌓이게 되는 점에 대해서는 설명이 없다. 그래서 직접 실험해보고       알게된 점을 바탕으로 정리해보겠다. HTML 구성 상황 1 a태그도 잘 클릭이 되며 alert도 잘 작동한다. 상황 2 상황 3 상황 4 이번엔 부모 요소가 아닌 조상 요소에 display: flex;가 있을 때도 z-index: -1;인 요소가 아래로 깔리는지 확인해보겠다; 상황 5 이번엔 div의 배경색은 없애고 body에 배경색을 bisque로 줘서 어디까지 내려가는지 확인해보겠다. 상황 6 더 정확한 확인을 위하여 감싸던 div요소를 없애고 body에 flex를 줘서 확인해보겠다. 결론 display: flex 또는 grid인 컨테이너의 자식 요소에 z-index: -1;를 주면 body 아래까지 내려가지만 시각적으로는 body위에 있는 것처럼 보인다. 마무리 쌓임 맥락 MDN 문서 변수 선언 우리는 변수를 선할 때  var ,  let ,  const  키워드를 사용한다. ES6에서 let, const가 도입되기 전에는 var가 오랬동안 유일하게 변수 선을 위해 사용되어 왔다. 하지만 ES6이후에 대부분의 코드에서 var를 사용하지 않고 있다. 오늘은 왜 var를 꺼려하는지에 대해서 알아보겠다. var의 특징 1. 호이스팅 후 초기화 자바스크립트에서 호이스팅은 꽤나 중요한 개념이다. 호이스팅은 단순 번역으로 끌어올린다라는 의미다. 자바스크립트에선 인터프리터가 변수와 함수의 메모리 공간을 선언하기 전에 미리 할당하는 것을 의미한다. 그렇기 때문에 var, let, const 모두 호이스팅이 일어난다. 하지만  var 의 경우 호이스팅 후 변수를  undefined 로 값이  초기화 되기 때문에 선언 전에 참조가 가능해진다. 한마디로 변수의 선언 위치가 자유로워지고 이 변수를 내가 undefined로 할당을 한건지 아니면 원하는 값으로의 할당이 아직 이루어지지 않았는지 확인이 힘들다. 2. 중복 선언 let과 const의 경우 선언한 변수를 다시 선언하는 경우 에러를 발생한다. 하지만 var의 경우   변수 이름이 중복 되어도 에러가 발생하지 않는다. 이 특성 때문에 원치않게 이미 선언한 변수의 값에 영향을 미치게 되어도 실수를 알아차리기 힘들다. 3. 스코프 let, const의 경우는  블록 레벨 스코프 를 갖고, var의 경우  함수 레벨 스코프 를 갖게 된다. 이 부분은 예제를 먼저 보겠다. for문이 실행되면서 a 또는 b 가 0인 스코프, 1인 스코프, 2인 스코프 ... 들을 생성해줍니다. let을 사용한 경우는 for문의 범위가 적용되기 때문에 이미 for문이 다 실행되었어도 이전의 스코프의 a 값을 참조하지만 var의 경우 함수 레벨 스코프이므로 for문이 실행되면서 생성한 스코프를 빠져나와서 최좀의 b를 참조하게 되어 예상한 결과와 다르게 나온다. 정리 var의 경우 호이스팅 후 undefined로 초기화가 되어 해당 undefined가 내가 할당했는지 자동으로 초기화된 값인지 확인이 어렵고 var로 동일한 변수 이름을 중복하여 선언이 가능하므로 var로 변수 선언 시 이전의 변수 값에 영향을 미치는 건지 모호해진다. 그리고 블록 레벨 스코프가 아닌 함수 레벨 스코프이기 때문에 필요하지 않은 전역변수가 많아질 수 있고, 비동기처리시 원하지 않게 동작할 수 있다. 모던 자바스크립트 DEEP DIVE(도서 이웅모 저) https://developer.mozilla.org/ko/docs/Glossary/Hoisting https://velog.io/@yonyas/Javascript-for문과-setTimeout-동시에-쓸-때-var와-let의-차이 문제 링크  https://www.acmicpc.net/problem/9095 문제 설명 문제 정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 1+1+1+1 1+1+2 1+2+1 2+1+1 2+2 1+3 3+1 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오. 입력 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다. 출력 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다. 문제 풀이 1 1 따라서 답은 1. 2 1 + 1 2 답은 2. 3 1 + 1 + 1 1 + 2 2 + 1 3 답은 4. 4 1 + 1 + 1 + 1 1 + 1 + 2 1 + 2 + 1 2 + 1 + 1 1 + 3 3 + 1 2 + 2 답은 7이다. 4의 답은 3, 2, 1의 답을 합친 것과 같다. 그 이유는 4의 답의 구성은 3의 답 구성에 1을 더한 것, 2의 답 구성에 2를 더한 것, 1의 답 구성에 3을 더한 것들로 구성되어 있기 때문이다. 다시 한번 4의 답 구성을 보자.   1 + ( 1 + 1 + 1 )   1 + ( 1 + 2 )  1 + ( 2 + 1 )  1 + ( 3 )  2 + ( 1 + 1 )  2 + ( 2 )  3 + ( 1 ) 그렇기 때문에 입력값 중 최대값까지의 답을 구하고서 순서에 맞게 출력값을 붙여주면 된다. 코드 미디어 쿼리   미디어 쿼리를 이용하면 위처럼 화면의 넓이 값에 따라 css에 변화를 줄 수 있다. 사용방법은 매우 간단하지만 반응형 웹페이지를 만들 떄 정말로 도움이 많이 되는 기능이다. 일거리를 절반은 아니더라도 20%는 줄여준다는 체감이 든다. CSS Animation transition, tranform 이전에 프로젝트할 때는 애니메이션을 크게 쓸일이 없었다. 단순히 카드이미지 위에 호버하면 크기가 약간 커지는 정도가 다였기 때문에 애니메이션에 대해서 이렇게 자세히 알아본건 이번이 처음이였다. 단순히 transition, transform과 hover만 이용해도 css를 동적으로 만들 수 있다.   @keyframes 여기에  @keyframes 를 이용한다면 더 자유롭게 원하는 애니메이션을 만들어줄 수 있다.   perspective 지금까지는 2차원의 움직임이였다. 하지만 perspective를 이용하면 3차원을 움직이는 것처럼 꾸밀 수 있어진다.   위와 같이 perspective를 이용해서 물체와 나와의 거리감을 표현할 수 있다. 마무리 오늘은 이렇게 css의 애니메이션 요소들에대해서 배웠다. 이전에는 자주 이용하지는 않았지만 애니메이션 요소를 잘 이용하면 웹페이지를 더 지루하지 않아 보이게 만들어줄 수 있어 다음 프로젝트에 적절히 이용해보면 좋을 것 같다. 워킹백워즈 포트폴리오 오늘은 우테코의 임동준 코치님의 워크샵을 진행했다. 주제는  워킹백워즈 방법으로 역량 순서대로 작성하는 포트폴리오 였다.  워킹백워즈 란 말을 처음 들어봐서 검색해 보았더니 작업을 역순으로 진행하느 것이라고 한다. 이 방법을 통해 오늘 포트폴리오를 만드는 것이 아니라 앞으로 프론트엔드스쿨의 3개월동안 나는 어떤 역량을 얻고싶은지 정하고 그 역량들을 얻으려면 무엇을 해야하는지 고민해보는 시간을 갖었다. 막연했던 3개월간의 계획이 구체화되었고 당장 앞으로의 1주일동안 무엇을 해야할지가 정해졌다. You don&#39;t know JS 책 읽기 읽은 후 블로그에 기록하기 프론트엔드스쿨 첫 수업 이두희님 특강 오늘 프론트엔드 스쿨 첫 수업이 있었다. 이두희님의 특강에서 좋은 코딩 공부팁들을 공유해주셨다. 그중에 가장 와닿았고 꼭 실천하고싶은 팁이 하나있었다. 스택오버플로우에서 살아라 영어로 코드를 공부하는데에 익숙해져라. 현재 IT강국은 미국인만큼 영어로된 양질의 자료들이 많다. 그리고 현재 두희님은 블록체인에 빠져있다고한다. 최근 몇년 전부터 여러 멘토급의 개발자분들께서 빠져있는 분야다. 그 분들을 모두 같은 얘기를 한다. 바로  블록체인은 스마트폰과도 같다. 우리의 삶을 바꿔놓을 것이다. 라는 말이다. 아직 블록체인에 대해서 잘 모르지만 더 관심있게 찾아봐야할 것 같다. HTML/CSS 강의 이전에 프로젝트를 하면서 알게된 내용들이 많았지만 다시 한번 공부하고 애매하게 알게된 부분을 다시 한번 짚고 넘어가는 시간이었다.  마무리 앞으로 3개월동안 프론트엔드스쿨에 몰입과 집중해 한단계 성장하자.🚀 1. Modal   그래서  react-dom 의  createPortal 을 사용해서 기본의 컴포넌트 트리에서 벗어나게 직관적으로 모달을 구현해보려고 한다. 2. 구현 코드 우선 리액트 프로젝트 파일 내부의  public/index.html 파일에 root 밑에  &lt;div id=&quot;modal&quot;&gt;&lt;/div&gt;  컨테이너를 추가한다. 그리고 Modal 컴포넌트의 반환 값을 createPortal   실행해보면 시각적으로는 똑같지만 html element를 보면 모달이 기존의 컴포넌트 트리에서 빠져나온 것을 확인할 수 있다. 3. Modal 배경 스크롤 막기   모달도 잘 만들었는데 뒤에 배경이 스크롤이 된다면 완성도가 많이 떨어져 보일 것이다. 그래서 모달의 글의 마지막은 스크롤을 막는 방법이다. 3-1. 구현 방법   body 태그의 css를  position 을 fixed로 변경하고,  top 을 현재 스크롤 위치로 하고  overflow-y: scroll;   width: 100%; 을 추가하면 스크롤 방지를 할 수 있다. 해당 css를 변경할 때는 useEffect를 사용할 것이다. 모달이 사라질 때에는  useEffect의 return 을 사용해  body의 cssText를 리셋 시킨 다음  window.scrollTo 를 이용해 현재 스크롤 위치로 이동시키면 된다. 3-2. 구현 코드 4. 마무리   프로그래밍을 잘 모르는 사람이 볼 때는 모달을 컴포넌트 트리에서 빼든 안 빼든 css적으로 동일하다면 상관없을 것이다. 하지만 이런 사소한 부분 하나 하나 모여 코드의 완성도와 깔끔함이 결정된다고 믿기에 이 방법이 좋은 프로그래밍이라고 생각한다. https://codingbroker.tistory.com/126 http://yoonbumtae.com/?p=3776 1. 갑자기 책을 읽는 이유🧐 난 책을 좋아하지 않는다. 소설보다는 영화를, 설명서보다는 언박싱 브이로그를 보는 걸 더 좋아한다. 그래서 프로그래밍 공부를 할 때도 책보다는 인터넷 강의를 보면서 공부했다. 하지만 프로젝트들을 하면서 새로운 것을 익히고 써먹을 때마다 혹은 알고리즘 공부를 할 때마다 자바스립트에 대한 공부가 부족하다는 것이 느껴졌다. 그래서 이번에 자바스크립트 기초 공부를 하기 시작했다. 그래서 여러가지 자바스크립트 서적과 강의를 추천받아서 알아보다가 You don&#39;t know JS를 알게되었다. 지금 읽고 있는데 생각보다 재밌고 생각보다 유익해서 실제로 프로젝트에 바로 적용할 수 있을 법한 팁들도 많이 존재해서 단순히 읽고 끝내는 것이 아니라 정리가 필요하다가 느꼈다. 바로 시작한다. 2. 1장 타입과 문법📕 1. 1절 타입 내장 타입 자바스크립트에는 7가지 내장 타입이 있다. null undefined boolean number string object symbol(ES6부터 추가) 값 타입은 &#39;typeof&#39; 연산자로 알 수 있다. 하지만  null 의 경우  object 로 반환된다.  typeof null === object // true 값이 없는 vs 선언되지 않은 위의 예제에서 보면  b; 는 선언되지 않았기 때문에 에러를 던진다. 하지만  typeof b; 의 경우에는 에러를 던지지 않고  undefined 를 반환한다. 이를 이용하면 유용한 safe guard를 만들 수 있다. 1번의 경우 에러를 던지지만 2번의 경우 단순히 if문을 넘어서 프로그램이 진행된다. 2. 2절 값✍️ 특수 값 글자아님(Not a Number) 보다는  유효하지 않은 숫자 NaN !== NaN 값 vs 레퍼런스 YOU DON&#39;T KNOW JS(카일 심슨 지음) 1. 이전 줄거리 &amp;nbsp이전에 우리는  Webpack 을 사용해서  CRA Typescript tslint 가 아닌  eslint 를 사용할 것이여서 약간의 차이가 존재한다. 출처를 보시려면  여기 를 클릭해주세요. 이전 글을 아직 보지 않았다면  Webpack으로 React 프로젝트 만들어보기(❌CRA) 를 먼저 보고와주세요! 2. 타입스크립트 적용하기 2-1. 패키지 설치 npm i -D typescript @babel/preset-typescript ts-loader fork-ts-checker-webpack-plugin  typescript : Typescript(타입스크립트) 필수 라이브러리  @babel/preset-typescript : babel(바벨)에서 Typescript(타입스크립트)를 빌드하기 위해 필료한 라이브러리  ts-loader : Webpack(웹팩)에서 Typescript(타입스크립트)를 컴파일 하기 위해 필요한 라이브러리  fork-ts-checker-webpack-plugin : ts-loader의 성능을 향상시키기 위한 라이브러리 2-2. Webpack 설정하기  webpack.config.js 를 열고 아래와 같이 설정합니다. 2-3. tsconfig.json 파일 설정하기  &amp;nbsp 루트 디렉토리 에 tsconfig.json 을 만들고 아래와 같이 수정합니다. 2-4. babel 설정하기 &amp;nbsp  루트 디렉토리 의  .babelrc 를 아래와 같이 수정합니다. 2-5. Typescript 스타일 코딩 &amp;nbsp React 에서  Typescript 를 사용하기 위해  ./src/App.jsx 를  ./src/App.tsx 로 이름을 변경하고 아래와 같이 수정합니다. 2-6. 실행해보기 npm start &amp;nbsp위의 명령어를 실행하고 인터넷 브라우저에서  http://localhost:8080/ 로 들어가면  Hello World! 가 보이면 정상적으로 잘 작동하는 것이다. npm run build &amp;nbsp그리고 빌드를 했을 때  dist  폴더가 생성되는 지 확인해주면 됩니다. 3. 마치며 https://dev-yakuza.posstree.com/ko/react/typescript/ 1. React? CRA로 만들면 되잖아?🤔 2. Webpack으로 프로젝트 생성하기💻 &amp;nbsp우선 한가지 밝히자면 이번 글은 한 곳에서 너무나도 잘 설명이 되어 있기 때문에 많은 부분이 비슷하다. 하지만 내가 다시 한번 정리하는 차원 + 따라하다 나온 이슈 하나 해결 이 두가지 이유로 글을 적고있다. 원본은 이후 출처에 게시하겠지만 지금 바로 원본이 보고 싶으시다면  여기 로 가시면 됩니다. 2-1. 프로젝트 폴더 생성🗂 2-2. 필요한 패키지 설치📚  패키지 설명  react ,  react-dom : React 개발에 필요한 필수 패키지  webpack : Webpack(웹팩) 라이브러리  webpack-cli : Webpack(웹팩)을 명령어로 조작하기 위한 라이브러리  html-webpack-plugin : Webpack(웹팩)에서 HTML을 다루기 위한 플러그인  webpack-dev-server : Webpack(웹팩)으로 로컬에서 개발하기 위한 테스트 서버  babel-loader : Webpack(웹팩)에서 babel(바벨)을 다루기 위한 라이브러리  @babel/core : babel(바벨)로 컴파일하기 위한 라이브러리  @babel/preset-env : babel(바벨)로 컴파일시 어떤 타겟으로 지정할지 설정하는 라이브러리  @babel/preset-react : React(리액트)를 babel(바벨)로 컴파일하기 위한 라이브러리  rimraf : Mac과 윈도우즈에서 동일한 명령어로 폴더를 삭제하기 위한 라이브러리 2-3. package.json 설정📏 &amp;nbsppackage.json 파일에 Webpack을 동작시키기 위한 script를 추가합니다.  script 명령어 설명  &quot;start&quot;: &quot;webpack server --mode development&quot; : npm start 또는 npm run start로 실행되는 스크립트입니다. Webpack(웹팩)의 개발 서버를 development 모드로 실행시킵니다. Webpack(웹팩)을 실행시킬 때는 항상 모드( development  또는  production )를 설정해야합니다.  &quot;prebuild&quot;: &quot;rimraf dist&quot; : npm run build로 build 스크립트를 실행하면 build 스크립트전에 이 스크립트가 실행됩니다. pre와 post로 스크립트 실행전, 실행후 실행시키고 싶은 스크립트를 실행시킬 수 있습니다. 저는 빌드후 생성되는 폴더를 지우고 다시 만들기 위해 사용하고 있습니다.  &quot;build&quot;: &quot;webpack --progress --mode production&quot; : npm run build로 실행되는 스크립트입니다. Webpack(웹팩)을 production 모드로 실행시켜 번들링(bundling)합니다. –progress은 빌드 진행 과정을 모니터링하기 위한 옵션입니다. 2-4. Webpack 설정하기 &amp;nbsp루트 폴더에  webpack.config.js  파일을 생성하고 다음과 같이 설정합니다. 2-5. babel 설정하기⚙️ &amp;nbsp루트 디렉토리에  .babelrc 를 생성하고 아래와 같이 설정합니다. &amp;nbspbabel(바벨)로 컴파일 할 때, targets을 지정해줬어요. 브라우저의 상위 버전 두개(예: IE 11, 10)와 한국(KR)에서 5% 이상의 점유율을 가지고 있는 브라우저에 대응하여 컴파일되도록 설정했어요. 그리고 &quot;@babel/react&quot;을 통해 React(리액트)도 컴파일될 수 있도록 설정했어요. 2-6. HTML 만들기 React(리액트)를 사용할 HTML 파일을  ./src/index.html 에 생성하고 다음처럼 수정합니다. 2-7.React 파일 만들기📒 &amp;nbsp  ./src/App.jsx 를 생성하고 아래와 같이 수정합니다. 2-8. 실행해보기🖥 npm start 그리고 인터넷 브라우저에서  http://localhost:8080/로 &amp;nbsp npm start 가 잘 작동한다면  build 도 해보자. npm run build &amp;nbsp실행되면 ./dist/ 폴더와 하위에  index.html 과  /js/app.js 가 생성된 것을 확인할 수 있다. 또한  index.html 을 열어보면 우리가 만든  index.html 과는 다르게  &lt;script type=&quot;text/javascript&quot; src=&quot;/js/app.js&quot;&gt;&lt;/script&gt; 이 추가된 것을 확인할 수 있다. 3. 마치며🥳 &amp;nbsp이제 웹팩으로 리액트 프로젝트를 만들 수 있다 정도인 것 같다. 웹팩을 더 공부해서 앞으로는 내가 원하는 프로젝트를 가볍게 시작할 수 있다면 좋을 것 같다.👍 https://dev-yakuza.posstree.com/ko/react/start/ https://stackoverflow.com/questions/59611597/error-cannot-find-module-webpack-cli-bin-config-yargs 1. husky? lint-stage? 이거 뭐야?🌝 &amp;nbsp우리는  ESLint 를 프로젝트에 적용시킬 때는 협업하는 모든 사람들이 같은 규칙 내에서 코딩을 하는 것을 예상한다. 하지만 가끔은 규칙을 지키지 않고 깃헙에 코드를 푸시할 때가 생긴다. 내 경우에도 가끔 오랜 코딩에 지쳐서 깜빡하고 ESLint 확인을 안하고 푸시할 때가 있었다. 뿐만 아니라 내가 직접 본 적은 없지만 어떤 팀에서는 전혀 규칙을 지키지 않고 코딩을 하는 사람도 있다고 한다.(그럼 왜 굳이 ESLint를 적용시켰을까...🥲) &amp;nbsp그래서 우리는 git commit 또는 git push와 같은  git 이벤트가 일어나기 전 에 우리가 원하는  스크립트를 실행 하기 위해서  git 이벤트 사이에 갈고리(hook)를 걸어주는 것 이다. 이것을 git hook 제어라고 한다. 우리는 이런  git hook  제어를 위해서  husky  라이브러리를 사용할 것이다.  &amp;nbsp그러면  lint-staged 는 뭐냐? 우선 stage 상태를 이해해야한다. 파일들이 git add로 커밋 대상이 된 상태를 stage 상태라고 한다. stage 상태의 git 파일에 대해 lint와 우리가 설정해둔 명령어를 실행해주는 라이브러리다.  2. husky &amp; lint-staged 사용하기😍 2-1.husky &amp; lint-staged 설치하기💻 &amp;nbsp이제 실질적인 코드들을 살펴보자. 우선  husky &amp; lint-staged 를 설치하자. npx mrm lint-staged &amp;nbsp여기서  mrm 이란 오픈소스 프로젝트의 환경 설정을 동기화 하기 위한 도구이다.  mrm 을 이용하면 lint-staged와 husky를 간편하게 설정해줄 수 있다.👍 &amp;nbsp위 명령어를 실행하면  .husky 폴더가 생기고  package.json  파일에 다음과 같은 코드가 추가로 생길 것이다. 2-2. husky 설정하기✅ &amp;nbsphusky는  .husky mrm .husky  폴더를 보면  pre-commit  파일에 다음과 같은 명령어가 있을 것이다. 위의 설정대로  git commit 을 하기전에  npx lint-staged  명령어를 실행할 것이다. 2-3. lint-staged 설정하기✅  lint-staged 는 약간 설정이 필요하다. 기본적으로는  package.json  파일에 위와 같이 설정이 된다. 만약  .js 파일에  eslint 만 사용한다면 위처럼 놓고 사용해도 되지만 나는 타입스크립트를 이용할 것이므로  .ts  파일과  .tsx  파일 둘 다 검사할 것 이고  prettier 도 사용하므로 다음과 같이 변형해서 사용했다. 2-4. Test해보기🌻 &amp;nbsp이제 제대로 작동하는지 확인을 해보겠다. &amp;nbsp위의 사진을 보면 우리가 설정한대로 git commit를 하기 전에  stage 상태 에 있는  .ts 와  .tsx 파일들을 대상으로  eslint --fix 와  prettier --write  명령어를 실행하고 있다. 그러다가 eslint 규칙상 에러가 난 부분이 있어  git commit 을 못하게된 상황이다.  한마디로 아주 잘 작동한다!! 😎 3. 마치며🥳 &amp;nbsp이렇게  husky 와  lint-staged  라이브러리를 이용하여  eslint 를 강제로 할 수 밖에 없게 설정을 해보았다. 꼭 강제한다는 부분 말고도 내가 따로 eslint를 실행하지 않아도 자동으로 명령어를 실행해준다는 점도 매우 매력적이라고 생각된다. https://go2zo.github.io/blog/2021/05/23/husky-v6/ https://github.com/typicode/husky/issues/949 https://taegon.kim/archives/10276 https://dev-syhy.tistory.com/57 https://shiningjean.tistory.com/86 1. ESLint가 뭐야?🧐 ESLint는  문법적으로 문제가 있는 코드를 찾아주는 도구 다.  2. 왜 사용하는 거야? &quot;아니 코드 잘 돌아가고 빨리 작성하기만 하면 되는거 아니야?&quot;🤨 코딩 컨벤션을 유지 시켜주며 추가적으로  문법적인 오류 나  안티 패턴 ,  변수 범위  등을 정적 분석을 통해 런타임 에러를 사전에 발견할 수 있게 도와준다.👍 3. ESLint 사용하기(feat. typescript) 3-1. 패키지 설치하기💻 eslint는 정말로 좋은 협업 라이브러리다. 하지만 git정도로 배우는 것이 어렵다고 생각한다. 최대한 필요한 부분만 간단하게 설명하도록 할께요. 우선 eslint 관련 패키지들 설치하기! 패키지 설명✍️  eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint-import-resolver-typescript : 정확한 에러는 기억이 안나는데 해당 패키지를 설치하지 않으면 에러가 발생했었어요... 나중에 정확한 이유를 기입하겠습니다...ㅜ  eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-import eslint-plugin-jsx-a11y : JSX 내의 접근성 문제에 대해 즉각적인 AST 린팅 피드백을 제공해줘요  eslint-config-airbnb : airbnb사의 코딩규칙을 사용하게 해줘요  eslint-config-prettier eslint-plugin-prettier : prettier에서 인식하는 오류를 ESLint가 출력해주게 해줘요 📌 혹시  CRA 로 프로젝트를 생성했다면  eslint-plugin-react ,  eslint-plugin-react-hooks ,  eslint-plugin-import ,  eslint-plugin-jsx-a11y  는 CRA에서 지원해주므로 제외하고 설치해주면 되요! 3-2. ESLint 설정하기🤟  모든 패키지를 설치했다면 이제 설정을 해줘야합니다. 여러가지 방법이 있지만 저는  .eslintrc.json  파일을 생성하는 것을 선호해서 해당 방법으로 진행해볼께요  우선  .eslintrc.json  해당 파일을 프로젝트의 최상위 폴더에 생성해줍니다. 그 이후  아래의 텍스트를 붙여 넣어주시면 됩니다ㅎㅎ ESLint 설정 옵션 설명✍️  env Docs 를 링크해둘께요. 그리고 선언하지 않은 전역변수를 사용할 때 경고하지 않도록,  globals 를 이용하여 사용자 전역 변수를 추가할 수 있어요.  parser Espree Babel 과 함께 사용되는  babel-eslint ,  Typescript  구문 분석을 위해 사용되는  @typescript-eslint/parser 가 있어요.  &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;  plugins plugins 에 추가하여 사용할 수 있어요.  &quot;plugins&quot;: [&quot;@typescript-eslint&quot;, &quot;import&quot;]  extends  eslint:all 과  eslint:recommended 는 ESLint에 기본으로 제공해주고 있어요. 하지만 ESLint는  eslint:all 을 프로덕션 용도로 사용하지 않는 것을 권장하고 있어요.  parserOptions  ecmaVersion : 사용할 ECMAScript 버전을 설정  sourceType : parser의 export 형태를 설정  ecmaFeatures : ECMAScript의 언어 확장 기능을 설정  globalReturn : 전역 스코프의 사용 여부 (node, commonjs 환경에서 최상위 스코프는 module)  impliedStric : strict mode 사용 여부  jsx : ECMScript 규격의 JSX 사용 여부  rules  &quot;off&quot;  또는  0 : 규칙을 사용하지 않음  &quot;warn&quot;  또는  1 : 규칙을 경고로 사용  &quot;error&quot;  또는  2 : 규칙을 오류로 사용  규칙에 추가 옵션이 있는 경우에는 배열 리터럴 구문 을 사용하여 지정할 수 있습니다.  settings 3-3. ESLint 실행하기🚀 만약 eslint 명령어를 사용할 수 없다면 eslint를 전역 설치해주시면 될거에요. npm i -g eslint eslint 명령어 뒤에 --fix 옵션을 붙이면 발생한 에러를 자동으로 고쳐줘요. 하지만 모든 에러를 고쳐주진 않아요...🥲 4. 마치며 https://velog.io/@kyusung/eslint-config-2#환경env https://velog.io/@xortm854/Typescript-React-Eslint-환경설정-2편-ESLint-Prettier-설정 https://eslint.org/docs/user-guide/getting-started https://velog.io/@kmlee95/React-Typescript-eslint-prettier설정 https://pravusid.kr/typescript/2020/07/19/typescript-eslint-prettier.html https://overcome-the-limits.tistory.com/entry/협업-ESLint-Prettier-Airbnb-Style-Guide로-코드-컨벤션-설정하기 https://tech.kakao.com/2019/12/05/make-better-use-of-eslint/ 1. prettier란😍? prettier는 간단하게  코드 스타일을 관리해주는 도구 다.  탭너비 를  2칸 으로 사용할지  4칸 으로 사용할지 혹은  &#39; 을 쓸지  &quot; 를 정해서 관리할 수 있다. 2. prettier가 필요한 이유🥸 코딩을 하다보면 혼자서 코딩을 하더라도 코딩이  일관성 2. prettier 사용법💻 우선 우리 프로젝트에 prettier를 설치해야한다. npm i -D prettier (저는 npm 유저여서 npm 기준으로  설명을 진행할께요...😅) 그 후에 prettier를 설정하기 위해 최상위 디렉터리에  .prettierrc  singleQuote : 문자열 입력시  &quot;  를 쓸지  &#39;  를 사용할지 설정할 수 있어요. 저는  &#39;  를 사용하기에  true 로 설정해 놓았습니다.  semi : 세미콜론(;) 사용에 관한 설정이에요. 저는 사용하므로  true  로 놓고 사용해요.  tabWidth : 들여쓰기의 크기를 정할 수 있어요. 저는 2칸으로 놓고 써요. 4칸으로 놓고 쓰면 들여쓰기가 중첩될 시에 코드 뒷부분이 안보이는 경우가 생기더라구요....ㅜ  trailingComma : 객체 또는 배열이 여러줄로 구성되어 있으면 다음과 같이 맨 마지막 줄에 쉼표를 붙여줄지 설정할 수 있어요.  none  이면 쉼표를 붙이지 않고,  es5  이면 객체, 배열을 사용하게 될 떄 쉼표를 붙이고,  all  이면 함수를 사용 할 때 인자를 전달 할 때도 쉼표를 붙입니다.  printWidth : 줄 바꿈할 폭의 길이를 설정해줄 수 있어요.📏 저는 아래와 같이 설정해 놓고 사용합니다. 제가 주로 사용하는 옵션들 말고도 많이 있으니  Docs 를 링크하도록 할께요.😉 3. 마치며 prettier는 정말로 코드의 질을 높여주는 것 중에 가장 가성비가 좋다. 이렇게 간단한데 코드는 정말로 43.1324배는 깔끔하고 이뻐진다. 정.말.로. 진심이다. 아직 사용하지 않는 분들이라면 꼭 한번 사용해보기를 추천한다. https://react.vlpt.us/basic/27-useful-tools.html https://velog.io/@kyusung/eslint-prettier-config https://prettier.io/docs/en/options.html 1. 어렵다 어려워 알고리즘..😫 알고리즘의 풀이를 보다보면 가끔  시간 복잡도 란 단어 또는  O(N) 하지만 이제는 양심에 찔려 시간복잡도에 대해서 정리를 하고 넘어가고자 한다. 2. 시간 복잡도란?🧐  시간 복잡도 는 기본적인 연산을 수행하는데에 어떤 고정된 시간이 걸릴 때, 알고리즘에 의해서 수행되는 기본  연산의 개수 를 세어 예측할 수 있다. 그러므로  걸리는 시간의 총량 과 알고리즘에 의해 수행되는 기본적인  연산의 개수 는  최대 상수 인자 만큼 다르다. - 위키피디아, 시간복잡도 따라서 시간 복잡도는 연산의 개수의 최대 상수의 인자로  알고리즘의 효율성을 판단하는 기준 이라고 볼 수 있겠다. 3. 시간 복잡도의 종류 시간 복잡도는 크게   O(빅오)  ,   Ω(오메가)  ,   Θ(쎄타)   라고 불리는 3가지의 표기법을 가지고 있다. 이 중에 주로   빅오 표기법  을 이용하여 복잡도를 표기한다. 그러므로 우리는   빅오 표기법  에 대해서만 알아보겠다!🙂 4. 빅오 표기법   빅오 표기법  은   점근적 상한  을 의미한다. 쉽게 말하자면   최악의 경우  에 걸리는 시간을 표기하는 방법이다. O(1), O(logN), O(N), O(N*logN), O(N^2), O(N^3), ..., O(2^N), O(N!)   빅오 표기법  O(1)  부터   O(N\*logN)  까지는 괜찮은 알고리즘의 시간 복잡도이고,   O(N^2)  부터는 안 좋다고 생각하면 될 것이다.     O(N^2)  부터는 요소가 늘어날수록 연산의 횟수가 기하급수적으로 늘어난다. 그러므로 안 좋은 시간 복잡도를 갖고 있다면 요소가 적다면 괜찮을지 몰라도 요소가 늘어나면 기하급수적으로 늘어나는 연산 횟수를 감당하지 못하게 될 것이다. 4. 시간 복잡도 계산 방법 단순 계산  let sum = (N + 1) * N / 2; 위의 코드는  (N+1) 에서  한 번 ,  * N 에서  한 번 ,  / 2 에서  한 번 ,  대입 연산 이  한 번  합쳐서  총 4번 4 = O(1)  이므로, 위 코드의 시간 복잡도는  O(1) 이다. 두번째 코드는  sum=0 에서  한 번 ,  int i=1 에서  한 번 ,  i++ 에서  N번 ,  sum+=i 에서  N번  합쳐서 총   2N+2   번의 연산이 수행된다.  2N+2 의  최대 차항 을 계수 없이 표기하면  N 이므로 빅오표기법으로 표현하면   O(N)  이다. 반복문 안의 반복문 코드는 바깥쪽 반복문이  logN N + N/2 + N/4 + … + 1 = 2N 번  반복하고, 빅오표기법으로 표기하면   2N = O(N)  이다. 바깥쪽 반복문은  N번  반복하고, 안쪽 반복문은  i의 값에 따라 0부터 N-1까지  변하며, 안쪽 반복문은 해당하는 i만큼 반복하므로,  0+1+2+…+(N-1) = N*(N-1)/2 번  N*(N-1)/2 = O(N²)  이다. 5. 마치며 &quot;이건 시간복잡도가 O(N)이니 괜찮을 것 같네여~_😉 &quot;_ 라고 아는 척하기 좋을 것 같다ㅎㅎㅎ https://www.zerocho.com/category/Algorithm/post/57ea2987fdea850015313534 https://medium.com/humanscape-tech/코드의-시간-복잡도-계산하기-b67dd8625966 https://ko.wikipedia.org/wiki/시간_복잡도 https://www.bigocheatsheet.com   컴파일 하기 전까지 제네릭에는 Integer, Double... 아무튼 타입이 중첩되어 있다. 반박 시 자바스크립트. -  오찌(26)   Generic, who are you? 제네릭(Generic). 사전을 찾아보면  신약으로 개발한 약이 특허 기간이 만료되어 동일 성분으로 다른 회사에서 생산하는 약. 제형이 같을 수도 다를 수도 있지만, 약효 동등성이나 생동성 실험을 거쳐 생산되므로 약효는 본래의 약과 동일하다.  라고 한다. 물론 지금 말하고자 하는 제네릭이 저거일 리는 없다.  나는 개발자지 약사가 아니다. 자바에서 말하는 제네릭도 사실 의약에서 말하는 제네릭과 그 의미 자체는 비슷하다고 할 수 있다. 제네릭을 직역하면 무엇인가? 언젠간 인류를 지배할지도 모르는 우리의 위대한 AI  파파고 에게 제네릭이 뭐냐고 물어보면 이렇게 대답한다. 그렇다. 제네릭은 포괄적이라는 뜻이다. 그래서 약품의 제네릭이 &quot;동일 성분을 가진 포괄적인 약품&quot;을 가리키느라 제네릭이라는 단어를 쓰는 걸 지도 모르겠다. 다시 본론으로 돌아와서, JDK 1.5부터 도입된 자바의(물론 자바에서만 쓰이는 개념은 아니다.) 제네릭(포괄적)은 어떤 의미로 쓰이는 걸까? 답은 바로  포괄적(일반화된) 타입 이다. 좀 더 쉽게 풀어서 말하자면 특정 타입을 미리 지정하는 것이 아니라 일반화(generalize)해서 사용하는 것이라고 할 수 있다. 제네릭을 사용하면 클래스 내부에서 사용할 타입을 외부에서 정의해줄 수 있다. 우리가 흔히 쓰는 List 타입을 보자. 라이브러리에 정의된 List 타입을 따라가 보면 다음과 같이 정의되어 있다. List에서 &lt;&gt;안에 들어간 E가 바로 제네릭이다. 그렇다. 우리는 그동안 의식하지 않고도 제네릭을 사용하고 있었다. 제네릭은 왜 필요한가? 제네릭이 없다고 가정하자. 우리는 List 안에 들어갈 데이터의 타입을 정의하고 싶다. 만약 제네릭이 없다면 String을 가지는 List, int를 가지는 List... List 안에 들어갈 타입이 늘어날 때 마다 새로운 List를 정의해 주어야 한다. 또는, 모든 클래스의 상위 타입인 Object 타입을 가지는 List를 만들어야 한다. (실제로 JDK 1.5 이전의 컬렉션 - 로(Raw) 타입 - 은 이런식으로 구현이 되어 있다.) 모든 타입에 대한 컬렉션을 새로 구현해 주는 것은 말도 안되는 일이고, 만약 제네릭이 없어서 Object의 컬렉션으로 구현하게 되면 문제가 뭘까? 제네릭이 없을 경우 리스트 안에는 Object 타입으로만 들어가므로, 넣어 준 자료를 꺼내고 나서 다시 int 형으로 변환해 주어야 한다. 이렇게 매번 형변환을 해주면 문제가 뭘까? 우선 자료를 기존 자료형으로 add할 때 Object로 변환하고, Object형을 다시 꺼내서 기존 타입으로 형변환 하는 과정이 모두 리소스를 소모하는 과정으로, 성능을 떨어뜨리는 원인이 된다. 단순히 성능만 떨어뜨리는 것이 아니다. (기존 타입) -&gt; Object로는 더 상위의 타입으로 형변환 하므로 문제가 생기지 않지만, 자료를 꺼낼 때 Object -&gt; (기존 타입)으로 형변환 하는 변환 과정은 문제가 생길 수 있다. 만약 int형을 넣었는데 꺼내서 명시적 형변환을 String으로 해준다면? 당연히 int형을 String으로 형변환 하려고 하니  ClassCastException  이 발생할 것이다. 만약 이 과정을 컴파일러가 잡아낼 수 있다면 차라리 다행이다. 컴파일 에러는 어플리케이션이 아예 돌아가지 않고 오류를 체크할 수 있기 때문에 가장 저렴한 에러라는 것을 기억하자. 하지만 이 형변환 과정은 컴파일 과정에서 체크조차 할 수 없다.  놀랍게도 컴파일에는 문제가 없다!  단지 int로 집어넣은 자료를 꺼내면서 String 타입으로 형변환하려고 하니 해당 라인에서 예외가 발생할 뿐이다. Exception in thread &quot;main&quot; java.lang.ClassCastException: class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader &#39;bootstrap&#39;)  at WithoutGeneric.main(WithoutGeneric.java:9) 9번 라인  String data = (String) rawList.get(0)  에서 ClassCastException이 발생하는 것을 볼 수 있다. 이처럼 Object -&gt; 하위 타입 으로의 형변환은 비검사 형변환으로 컴파일러가 검사할 수 없기 때문에 안전하지 않으며 런타임에서 예외를 유발한다. 이펙티브 자바 같은 책에서 로 타입을 사용하지 말라고 하는 이유가 다 이런 이유다. 제네릭의 사용 자, 그렇다면 안전하지도 않고 성능이 뛰어나지도 않은 저 컬렉션을 제네릭을 사용하는 방식으로 바꿔보자. 사용법은 간단하다. 클래스나 메서드를 작성할 때  List&lt;E&gt; 와 같이 &lt;&gt; 사이에 제네릭 타입을 집어넣어주면 된다. 실제 코드에서 사용할 때는 &lt;&gt; 자리에 사용하고자 하는 타입을 넣어주면 된다. (ex_  List&lt;Integer&gt; ) &lt;&gt; 사이에 들어가는 타입의 이름은 크게 상관이 없으며, 일반적으로 대문자 한 글자로 사용하지만 반드시 한 글자만 사용해야 할 이유는 없다. 예를 들어 &lt;E&gt;가 될 수도, &lt;El&gt;가 될 수도 있다. 다만 일반적으로 널리 쓰이는 제네릭 타입들이 존재한다.  타입  설명  &lt;T&gt;  타입(Type) 의 의미로 사용  &lt;E&gt;  원소(Element) 의 의미로 사용  &lt;K&gt;  키(Key) 의 의미로 사용  &lt;V&gt;  값(Value) 의 의미로 사용  &lt;N&gt;  숫자(Number) 의 의미로 사용  &lt;S&gt;, &lt;U&gt;, &lt;V&gt;  두 번째, 세 번째, 네 번째에 선언된 타입의 의미로 사용 또한 제네릭 자리에는 특별히 제한되어 있지 않다면 모든 참조 타입이 올 수 있다. int, double과 같은 기본 타입(Primitive)은 올 수 없다. 이 타입들을 사용하기 위해서는 박싱된 기본 타입인 Integer, Double 등을 사용해 우회해야 한다. 바로 사용해보자. 리스트를 제네릭 리스트로 만들어 줬더니, int로 집어넣은 자료를 String으로 꺼내려고 하니 타입이 다르다면서 컴파일이 되지 않는다. 그렇다고 String으로 강제로 형변환을 해주려고 하니 형변환도 되지 않는다. (상위 - 하위 타입 관계에서는 비검사 형변환이 가능하지만 int와 String 사이에는 불가능하다.) 이번엔 올바르게 사용해보자. 컴파일 오류 없이 정상적으로 작동하며, 제네릭을 사용하지 않았을 때 처럼 올바른 타입으로 설정하더라도 형변환을 해줘야 하는 부가적인 작업이 없다. 제네릭 사용을 통해 우리는 불필요한 비검사 형변환을 제거했으며, 안전하지 않은 타입이 들어오는 것을 컴파일 시점부터 막아 타입 안정성을 확보했다. 제네릭의 작동 원리 분명히 클래스를 정의할 때는  T  라고 한 글자 넣었을 뿐인데 실제 코드에서 &lt;&gt; 안에 Integer를 넣어주니 Integer만 넣고 뺄 수 있는 컬렉션이 되었다. 대체 제네릭은 어떻게 동작할까? 뭐야 내 제네릭 돌려줘요   제네릭의 동작을 알기 위해서는 먼저 타입 소거(Type Erasure)라는 개념에 대해 알아야 한다. 놀랍게도, 우리가 아무리 제네릭을 써줘도 실제 코드는 런타임에 타입에 대한 정보가 소거된다. 자바 컴파일러는 코드를 검사하여 타입 오류가 없으면 제네릭을 Object 타입으로 치환하여 소거한다. 이 코드가 이렇게 변한다. (타입 소거 이전의 코드에서 (E) 로 비검사 형변환을 해주는 부분이 있는 것에 대한 의문을 가질 수 있는데, ArrayList 안의 필드들은 기본적으로 Object로 선언되어 있어서 내보낼 때 형변환을 해주어야 한다. 이에 대한 이유와 형변환 방법 역시 다음 게시물에서 후술하도록 하겠다.) 다시 말하자면 앞서 신나게 까댔던 로 타입과 마찬가지로 제네릭을 사용한 모든 타입이 Object 타입으로 변한다는 소리다. (Object 타입으로 변하지 않는 경우도 있는데, 이 경우에 대해서는 다음 게시물에서 후술하기로 한다.)  아니 이게 무슨 소리야? 분명히 제네릭으로 타입 안정성을 확보한다며? 타입 정보를 소거하면 어떻게 안정성을 확보할건데? 일단 진정하자. 런타임에 타입 소거를 한다고 해도, 컴파일 시점에 타입을 특정하여 안전하지 않은 타입이 들어오지 못하도록 하는 것 만으로 타입 안정성은 확보가 됐다. 런타임은 별개의 문제다. 코드를 다시 보자. 앞서 이 코드가 왜 위험했을까? int -&gt; Object -&gt; String 이라는 잘못된 형변환을 컴파일러가 잡아내지 못하기 때문이다. 지금은 저 형변환이 컴파일러가 잡아내지 못하는 비검사 형변환이지만, 만약 data를 꺼낼 때 잘못된 타입이라고 컴파일러가 경고해 준다면? 사용자는 당연히 컴파일을 위해 올바른 타입인 int로 형변환을 할 것이다. 자, 그럼 문제는 사라졌다. 당연하지만, 컴파일 언어인 자바는 컴파일이 되고 나면, 런타임에서 임의로 &quot;코드의 추가&quot;는 불가능하다. 따라서 컴파일 시점에서 타입 안정성을 확보했다는 것은, 이후 런타임에서 타입을 신경쓰지 않고 사용이 가능하다는 소리다. 따라서 타입 소거를 하더라도 문제 없이 프로덕션을 실행할 수 있다. 여기서 하나의 중요한 의문이 들어야 한다.  Object로 바꿨으면 꺼낼때도 Object인데 타입이 안 맞지 않나? 이 의문이 들지 않았으면 안된다! 분명히 타입 소거를 하면서  제네릭이 들어간 모든 타입을 Object로 치환하여 소거한다  라고 했다. 따라서, 컬렉션에 들어가 있는 자료의 타입은 모두 Object가 된다. 앞서 제네릭이 없었을 적의 정상적으로 작동하는 코드를 가져와보자. rawList에는 Object로 들어가 있기 때문에 get을 해준 뒤 int로 비검사 형변환을 해주는 것을 볼 수 있다. 제네릭 사용 시에도 런타임에서는 rawList와 같은 형태로 바뀌기 때문에, 타입 소거 시에도 rawList처럼 형변환을 해주어야 한다. 그래서 돌려드렸습니다 자, 컴파일 시 지정된 타입을 Object로 바꿨으니, 돌려줄 때 다시 타입을 바꿔서 돌려줘야 한다. rawList에서는 이 일을 사용자가 직접 비검사 형변환을 통해 해줬다. 하지만 제네릭을 사용할 때는 그럴 필요가 없다. 컴파일러는 타입 소거 과정에서 필요한 형태, 즉 원래 제네릭에 넣어서 지정했던 타입의 형태로 자동 형변환을 해준다. 이게 무슨 소리냐면, 이렇게 컴파일된 코드가, 타입 소거를 통해 이렇게 바뀌고, 이렇게 int로 형변환되어 사용된다. 이 모든 과정은 컴파일러가 자동으로 처리해주며, 사용자는 이런 과정에 대해 파고들어갈 필요가 없다. 마지막 코드에서 Object -&gt; int의 형변환 역시 비검사 형변환이니 안전하지 않을 수 있는 것 아니야? 라고 할 수 있다. 하지만 다시 한번 생각해보면, 컴파일을 통과하고 런타임에 진입한 이상 우리는 모든 코드에서 타입에 대한 안정성을 확보했으므로, genericList는 무조건 int를 받아서 int를 내보낸다는걸 보장할 수 있다. 따라서 int data에 Object인 genericList.get(0)을 형변환해서 할당해주더라도 우리는 이 데이터가 int인지를 검사할 필요가 없다. 왜냐? 당연히 int니까. 물론 리플렉션을 통한 검사 등 예외 상황이 있지만 이는 일반적으로는 고려 할 필요가 없는 상황이며, 상황 별 우회 방법 또한 존재한다. 그런데 왜 귀찮게 타입 소거를 해요? 앞서 말했듯이 제네릭은 JDK 1.5부터 도입되었다. 그 말인 즉, JDK 1.4까지 작성했던 코드는 제네릭이 존재하지 않는다는 얘기다. 제네릭에 타입 소거가 없다면, 제네릭이 없는 코드와 있는 코드의 호환이 불가능하다. 따라서 자바는 하위 호환성을 위해 타입 소거라는 방식을 택했다. 애초에 타입 소거를 채택하지 않았다면 위에 말했던 리플레션을 통한 검사 등의 예외에 안전했겠지만, 처음 언어를 설계할 때 제네릭이라는 개념을 집어넣지 않은 자바로서는 어쩔 수 없는 선택이다. 제네릭이 1.5에 도입되었다고 1.4까지의 코드를 안드로메다로 보내버릴 수는 없는 법이니까. 지금까지 제네릭이 무엇인지, 어떤 원리로 작동하는 지에 대해 간단히 살펴보았다. 하지만 아직 제네릭에 대한 내용은 끝나지 않았다. 제네릭의 바인딩, 배열을 이용해 제네릭 컬렉션을 만드는 방법 등 심화된 내용이 남아있다. &quot;그냥 무슨 타입이 올 지 모르니 미정으로 둔다&quot; 라는 개념으로 쓸 때는 몰랐지만, 재네릭이란 녀석 정말 쉬운 개념이 아니다. 제네릭에 대한 더 자세한 내용은 다음 게시물에서 알아보도록 하자.  언제가 될 지는 모르지만   추상 클래스 추상 클래스란? 자바에는 abstract라는 특수한 키워드를 붙여서 생성하는 추상 클래스(Abstract Class)가 존재한다. 클래스면 클래스고, 추상화 한거면 인터페이스지, 대체 추상 클래스란 뭘까? 추상 클래스를 이해하기 위해서는 먼저 &quot;추상화&quot;라는 개념에 대해서 짚고 넘어가야 한다. 본래 추상화라 함은 미술에서 대상의 구체적인 형상을 나타낸 것이 아니라 점, 선, 면, 색과 같은 순수한 조형 요소로 표현한 것을 말한다. 자바에서 말하는 추상화도 마찬가지다. 대상의 구체적인 실체를 표현하는 것이 아닌, 대상의 개념만을 표현하는 것을 추상화라고 할 수 있다. 정확한 이해를 위해 IT용어사전을 참고하자.  추상화 방식에 따라 데이터 추상화(data abstraction)와 절차 추상화(procedural abstraction)로 나뉜다. 데이터 추상화는 하나의 데이터와 관련된 조작 및 표현 유형을 결합하는 방식이다. 예를 들어, 학번, 이름, 생일, 연락처, 주소, 성적 등 모든 항목을 언급하기보다 ‘학생’이라는 항목(개체)으로 결합하여 추상화한다. 절차 추상화는 세부적인 실행 절차를 단순화하는 방식이다. 예를 들어, 라면 조리를 설명할 때마다 가스레인지 켜기, 냄비에 물 넣기, 물 끓이기, 라면과 스프 넣기 등 세부 절차를 모두 언급하면 너무 복잡하다. 따라서 이를 ‘라면 조리’라고 추상화하여 간단하게 표현하는 것이다. [네이버 지식백과] 추상화 [abstraction, 抽象化] (IT용어사전, 한국정보통신기술협회) 설명을 보면 딱 대표적으로 인터페이스 - 구현체의 관계가 떠오르지 않는가? 리스트를 예로 들어보자. 우리는 실제 코드에서 사용할 때 ArrayList나 LinkedList같이 정확히 정의되고 구현된 리스트를 사용하지만 타입으로 정의할 때는 일반적으로 이 구현체들의 인터페이스인 List 타입을 사용하곤 한다. List 인터페이스는 add, remove 같은 동작이 어떤 식으로 작동하는지 알 필요가 없다. 그저 추가, 제거라는 기능의 &quot;추상적인 개념&quot;만 가지고 있으면 되고, 해당 개념의 상세 구현은 구현체에서 하게 된다. 이렇게 인터페이스의 사용은 자바의 대표적인 추상화의 사례라고 볼 수 있다. 추상 클래스란 간단히 말하자면 모든 부분을 완벽하게 구현하지 않고 일부분을 추상화시켜 상속받는 클래스에서 구현을 완성하도록 정의한 클래스라고 할 수 있다. 혹자는 클래스를 설계도에 비유한다면 추상 클래스는 미완성 설계도라고 비유하기도 한다. 여기서 구현이 미완성이라는 것은 메서드를 추상 메서드로 선언 해두고 실제 구현은 해당 클래스를 상속받는 클래스에서 하도록 하는 것을 의미한다.  잠깐, 추상 메서드란? 추상 클래스는 미완성 클래스기 때문에 생성자를 통한 생성이 불가능하다. (그렇다고 생성자가 없다는 것은 아니다! 추상 클래스 자체의 생성자만을 이용한 인스턴스 생성이 안 될 뿐이다. 또한 상속받은 클래스의 인스턴스를 추상 클래스의 타입으로 선언하는 것도 가능하다.) 당연한 소리다. 미완성 부분이 존재하는 객체를 실체화 하는 것은 있을 수 없는 개념이다.  Foo foo = new Foo(); // 불가능하다. 추상 클래스는 abstract 키워드를 붙이는 것, 추상 메서드의 사용이 가능하다는 것, 자체 생성자를 사용한 인스턴스 생성이 불가능 하다는 점을 제외하면 일반적인 클래스와 같고, 상속 역시 일반 클래스를 상속할 때와 마찬가지로 사용하면 된다. 즉, 추상 클래스도 생성자 자체를 가질 수는 있으며(단지 이걸 호출해서 추상 클래스 객체를 만들지 못할 뿐), 필드를 가지고 있고 구현이 완료된 메서드를 가질 수 있다. 상속받은 클래스에서는 일반 클래스의 상속처럼 부모 클래스의 생성자, 필드, 메서드를 호출할 수 있다. (private이 아니라면) 아니 그래서, 그냥 클래스랑 상속도 같으면 이걸 왜 쓰는데? 우선 당연하게도, 추상 메서드의 사용이 필요할 때 사용한다. 같은 개념의 동작을 가지고 있는데, 동작의 내용과 결과가 다른 상황에서는 같은 이름으로 묶어놓고 구현만 다르게 해서 사용할 수 있다. 예를 들어 보자. &quot;적금&quot;이라는 개념에는 기본적으로 &quot;이자&quot;가 따른다.  이자라는 개념이 존재하지 않는 적금? 그건 그냥 장롱에다가 돈봉투를 꽁쳐두고 묵히는 것과 다를 것이 없다.  하지만, 적금은 각종 상품마다 그 이율이 다르다. 금융 관련 프로그램을 만드느라 군적금, 청년희망적금이라는 두 가지 적금 기능을 구현해야 할 필요가 있다고 생각해보자. 어차피 매 달 돈을 넣고, 만기가 되면 그 금액에 따라 일정 퍼센트의 이자를 받는 것은 공통된 로직이다. 다만 이자의 이율이 다를 뿐이다. 이율이 다른 것 때문에 군적금과 청년희망적금을 모두 따로 따로 구현할 필요가 있을까? 공통된 부분을 &quot;적금&quot;이라는 개념으로 묶으면 된다.  이렇게 구현하고 보니, 어차피 매 달 일정 금액을 납입하는 메서드는 납입 금액 만큼 계좌 내의 금액을 증가시키는 똑같은 로직인 것 같아 추상 메서드로 만들 필요가 없을 것 같다. 이제 InstallmentSavings를 상속받는 클래스에서 구현하고자 하는 적금 상품에 만기 메서드를 구현해서 사용하면 된다. 그런데 &quot;어차피 일반 클래스를 상속해도 메서드를 재정의 해서 입맛에 맞게 사용할 수 있는거 아냐?&quot; 라고 말할 수도 있다. 하지만 이렇게 묻고 싶다.  그 메서드를 하위 클래스에서 재정의해서 사용한다고 어떻게 보장하십니까?   저 적금 클래스를 추상 클래스로 만들지 않고, 이율이 정해지지 않았으므로 expire 메서드가 그냥 입금 총액을 반환한다고 구현해보자. 군 적금은 연 이율 5% 짜리 상품이다. 따라서 InstallmentSavings를 상속받는 군 적금 클래스 MilitaryInstallmentSavings는 5%에 맞게 expire를 재정의해야 한다. 하지만 만약 메서드 오버라이딩을 하지 않는다면? 이렇게 해도 이 클래스는 사용이 가능하다. inputMoney도 가능하고, expire도 가능하다. InstallmentSavings 클래스를 상속받는 클래스들이 expire를 재정의해서 알맞게 사용하도록 하고자 하는 의도와는 전혀 다른 결과가 나오는 것이다. 따라서 마치 인터페이스의 구현체 처럼 상속받는 클래스에서 필수적으로 구현해야 하는 부분을 지정하고자 하는 의도를 가진다면 일반 클래스의 상속 대신 추상 클래스와 추상 메서드를 사용해서 해결할 수 있다. 그런데 아까 추상 메서드 없이도 추상 클래스 사용이 가능하다면서요? 맞다. 추상 메서드 없어도 추상 클래스 사용이 가능하다. 그러면 위에서 말한 필수적으로 구현해야 하는 부분을 반드시 재정의하도록 지정하기 위해 추상 클래스를 사용하는 목적에 부합하지 않는다. 그러면 그런 경우에는 추상 클래스는 사용하는 경우가 없을까? 하지만 추상 메서드가 없다고 해도 추상 클래스만의 기능이 모두 사라지는 것이 아니다. 다시 상기해보자. 추상 클래스는 인스턴스를 생성할 수 없다. 추상 메서드 없어도 추상 클래스를 만들면 인스턴스 생성을 막을 수 있다.  근데 솔직히 이 목적으로 사용할거면 애초에 묶을 이유로 있을까? 인터페이스와의 차이 앞서 인터페이스도 대표적인 추상화 케이스라고 했는데, 추상 클래스와 인터페이스 둘 다 그 자체로는 생성자를 통한 인스턴스 생성을 하지 못한다. 또한 선언만 있고 구현은 없는 메서드를 가진다. 그리고 해당 부분은 자식 클래스가 반드시 재정의해서 사용해주어야 한다. 그렇다면 추상 클래스와 인터페이스는 어떤 차이가 있을까? 사실 기본 개념부터가 다르다. 추상 클래스는 상속(extends)이고 인터페이스는 구현(implements)이다.  상속은 extends라는 단어에서 알 수 있듯 상속을 받아서 추가적으로 확장을 하는 개념이고, 구현은 기능의 개념을 정의해두고 해당 인터페이스를 구현한 구현체 클래스에서 세부 사항을 정의해서 사용하는 개념이다. 물론 추상 클래스도 추상화된 메서드가 있으므로 인터페이스처럼 전부 추상으로 만들어 두고 상속받는 클래스에서 세부 사항을 전부 구현하는 식으로 만들 수 있고, 인터페이스도 인터페이스에 선언된 메서드 외에 다른 로직들을 구현체에서 확장할 수 있다. 하지만 각각이 하는 핵심적인 기능에 주목하여 개념을 이해하도록 하자. 또한 구조도 다르다. 추상 클래스는 기본적으로는 클래스 인 만큼 인스턴스 필드 + 일반 메서드의 형태를 가지고 있고, 여기에 추상 메서드가 더해지는 구조다. 또한 인스턴스를 생성할 수 없더라도 기본적으로는 클래스인 만큼 생성자를 정의하고, 정의한 생성자를 상속받는 클래스에서 super로 사용할 수 있다. 하지만 인터페이스는 인스턴스 필드를 가지지 않는다. 물론 인터페이스에도 &quot;필드&quot;는 만들 수 있으나, 이렇게 정의된 필드는 접근 제어자를 붙이지 않아도 무조건 static final로 작동, 즉 인스턴스 필드가 아닌 상수로 작동한다. 인터페이스는 인스턴스 구현이 없으니 당연하다. 또한 추상 메서드는 직접 호출만 못하지 간접적으로 사용할 수 있는 생성자를 만들 수 있지만, 인터페이스에는 생성자를 작성할 수 없다. 작성하려고 하면 컴파일 에러가 발생한다. 또한 인터페이스의 메서드는 기본적으로 추상 메서드다. 자바 7까지는 모든 메서드가 추상 메서드였으며, 자바 8부터 default 메서드가 추가되었지만, default 선언을 하지 않은 메서드들은 모두 추상 메서드다.  여기서 잠깐, 인터페이스의 default 메서드 자바 8 버전부터 추가된 인터페이스의 메서드로, 아무 접근제어자도 붙이지 않을 때의 default 접근 제어자의 의미가 아니며, default라고 명시하여 사용할 수 있다. 기본적으로 public으로 작동하며 일반 메서드처럼 내부 구현을 가진다. 클래스 상속을 할 때 처럼 하위 클래스에서 공통적으로 사용하는 구현을 넣어주기 위해 default 메서드를 사용하는 경우가 있는데, default가 메서드가 등장하게 된 배경은 인터페이스로 이루어진 레거시 라이브러리의 유지 보수(새 기능이 추가되어야 하는데 메서드를 그냥 추가하면 해당 라이브러리를 쓰는 모든 코드가 추가된 메서드를 재정의해서 사용해야 한다.)를 위해 도입된 개념이므로, 그러한 개념으로는 사용하지 않는 것이 좋다. 그리고 추상 메서드는 상속이고 인터페이스는 구현인 만큼, 추상 메서드는 다중 상속이 불가능하지만 인터페이스는 다중 상속(상속이라는 의미에는 안맞지만)이 가능하다는 차이점도 있다. 추상 클래스와 인터페이스를 고르는 기준은? 우선 다중 상속이 필요할 경우 당연히 인터페이스를 선택한다. 추상 클래스는 다중 상속을 지원하지 않는다. 추상 클래스와 인터페이스를 고르는 기준은 개발자마다 다 조금씩 다르겠지만, 그래도 어느 정도 보편적인 기준을 잡을 수는 있다. 구글링을 해보면 Is-A 관계( 가 ~인)에는 추상 클래스와 상속을, Has-A 관계( 가 ~할 수 있는)에는 인터페이스를 사용해라 라는 말이 있는데, 사실 명쾌하게 와닿지는 않는다. 조금 더 풀어서 설명하자면, 서로 관련성이 높은 클래스들의 공통 부분을 하나로 묶자면 추상 클래스를 통한 상속 쪽이, 객체들간의 상태에 관련성은 크게 없으나, 공통된 행동 쪽에 집중하여 구현한다면(ex_ Comparable, Comparator 처럼 관련성이 거의 없는 클래스들에서도 공통적으로 구현하여 사용하는 등) 인터페이스 쪽이 더 맞지 않나 생각한다. 내가 생각하기에 가장 확실한 기준은 공통된 필드와 메서드가 필요한지 여부라고 생각한다. 인터페이스는 인스턴스 필드를 가질 수 없는 만큼, 하위 클래스들이 공통적인 필드 값을 가지도록 구현하고 싶다면 추상 클래스로 구현하는 쪽이 하위 클래스마다 필드를 복사 붙여넣기 하는 것 보다 더 효과적일 것이다. 또한 인터페이스에 default 메서드가 생겼다고 하더라도 공통 부분을 모으는 용도로 사용하는 것이 좋은 방법은 아니기 때문에, 구현이 같은 메서드가 여러개 있어서 중복 구현을 줄이고 하나로 모으고 싶을 때는 인터페이스 대신 추상 클래스를 사용하는 것이 더 좋은 선택이라고 생각한다. default를 해당 용도로 사용하지 않는다는 전제 하에, 인터페이스는 공통된 메서드라 하더라도 모든 메서드를 다 선언만 해놓고 구현체에서 같은 내용으로 재정의 해야 하기 때문이다. 자바를 쓰는 사람이라면 다들 알다시피, 기본적으로 Set과 Map은 자료의 순서를 보장하지 않는다. 1, 2, 3 순서로 자료를 넣어도 3, 2, 1 순서로 출력이 될 지, 2, 3, 1 순서로 출력이 될지 모른다는 얘기다. 순서를 보장하고 싶다면 LinkedHashMap, LinkedHashSet과 같이 Linked 형태로 된 구현체를 사용해야 한다. 블랙잭 미션을 하다 보니 Map을 사용할 일이 있었다. 플레이어의 승,무,패 결과를 플레이어를 key로, 결과를 value로 넣은 뒤에 출력시에는 플레이어 순서대로 출력을 해주기 위해 LinkedHashMap을 사용했다. 그런데 결과 출력을 위해 view에다가 넘겨줘야 하니까 getter로 꺼낼 때는 불변의 참조가 끊긴 Map을 만들어주기 위해 Map.copyOf를 사용해서 넘겨주었다. LinkedHashMap을 복사해서 주니까 복사본도 LinkedHashMap일거라고 생각했다. 그런데 웬걸, view에서 Map을 받아서 출력을 해보니 순서가 뒤죽박죽. 매 번 출력시마다 순서가 달라졌다. 결국 라이브러리 코드를 직접 까보고 나서야 문제를 알았다. Map.copyOf는 ImmutableCollections에서 자체적으로 정의된 MapN을 반환한다.   Map.copyOf는 인자로 들어온 Map이 LinkedHashMap이든, HashMap이든, EnumMap이든 ImmutableCollections.MapN 이라는 자료형을 반환한다. (빈 맵이면 EmptyMap을, entry가 1이면 Map1을 반환) 그런데, MapN은 LinkedHashMap처럼 순서를 보장하지 않는다. 따라서 LinkedHashMap을 copyOf로 복사해서 반환해주면 LinkedHashMap을 유지하지 못하고 그냥 HashMap을 반환해 주는 것과 다름이 없어지는 것이다. 나는 결국 이 부분을 해결하기 위해서 귀찮은 작업을 해주어야 했다. 복사하고자 하는 Map을 먼저 LinkedHashMap 생성자에 다시 인자로 넣어주고, Collections.unmodifiableMap 메서드에 집어넣어서 참조가 끊어진 unmodifiable을 만들어 주는 방법으로 반환해 주었다. 이렇게 하면 원본 참조를 끊고, 수정이 불가능하면서도 LinkedHashMap의 성질을 유지하고 있는 Map을 반환할 수 있다. 그런데 Collections.unmodifiableMap은 어떻게 LinkedHashMap의 성질을 유지할까? 답은 Collections 객체의 내부 코드를 직접 찾아보고 나서 찾게 되었다. Collections.unmodifiableMap은 자체적으로 구현된 UnmodifiableMap 이라는 구현체를 반환하게 되는데, 이 UnmodifiableMap 구현체는 copyOf 생성자로 받아오는 Map안의 요소를 가져와서 Map을 재구성하는 것이 아니라, 인자로 받는 Map의 참조를 필드로 저장하고, 필드로 저장된 Map의 수정 메서드들을 호출하지 못하도록 Map의 메서드들을 다시 implements 해준다.  그래서 UnmodifiableCollection이 참조를 끊지 못한다고 말했던 것이다. 다시 본론으로 돌아와서, 생성자에서 인자로 받는 Map을 그대로 필드에 저장하기 때문에, 해당 Map이 LinkedHashMap이든 EnumMap이든 또는 다른 어떤 Map이든 UnmodifiableMap 안에서 해당 Map의 메서드를 호출하면 되므로 그 성질을 그대로 사용할 수 있게 되는 것이다.  참고   try-finally란 자바에는 close를 호출해 직접 닫아줘야 하는 자원이 있다. ex) InputStream, OutputStream, java.sql.Connection 위 코드는 BufferedReader를 사용해준 뒤에 close를 호출해 직접 닫아주는 코드다. 하지만 위 방법대로 close를 호출하게 되면 문제가 발생할 수 있다. BufferedReader는 사용 중 IOException이 발생할 수 있는데, 만약 br.readLine() 메서드에서 IOException이 발생하게 되면 메서드가 종료되므로 close가 호출되지 않고 스트림이 메모리에 남아있게 된다. 따라서 예외가 발생하더라도 자원을 닫을 수 있도록 해줘야 하는데, 전통적으로 try-finally 문을 사용해서 close 처리를 해주었다. finally 블록은 try, catch 블록이 끝난 뒤 실행할 로직을 정의해 주는 블록이다. 따라서 이제 IOException이 발생하게 되더라도 상위 메서드로 IOException 객체를 던져준 뒤 finally 메서드를 종료하게 된다. 그렇다면 만약 close를 여러 번 호출해야 하는 상황이 오면 어떻게 될까? 코드가 굉장히 지저분해지게 될 수 있다. 사실 가장 큰 문제는 이런 것들이 아니다. 다시 맨 위의 inputString 메서드로 돌아가 보자. inputString 메서드의 try 블록을 실행하던 도중 기기에 문제가 생긴다면 readLine이 정상적으로 실행되지 못하고 예외를 던지게 되고, 같은 이유로 finally 블록의 close 메서드도 예외를 던지게 된다. 만약 이 예외들을 catch해서 상위 메서드에서 예외 정보를 체크해본다면, finally 블록에서 터진 예외가 try 블록에서 생긴 예외를 집어 삼켜서 finally 블록의 예외만 체크하게 된다. try 블록에서 터진 예외로 인해 finally 블록에서 예외가 발생했음에도 불구하고 최초 원인인 예외를 체크하지 못하게 되는 것이다. 물론 적절한 코드를 통해 최초 원인 예외를 체크할 수는 있지만, 코드가 너무 더러워지기 때문에 추천하는 방법은 아니다. 실제로 다음과 같은 방법으로 체크해 보았다.   발생하는 예외를 main의 catch 블록에서 체크해서 printStackTrace를 호출했는데, 14번 라인, 즉 finally 블록에서 던져진 NullPointerException을 catch 하고 try 블록의 IllegalArgumentException은 무시된 것을 볼 수 있다. 정리하자면 try-finally는 가독성을 해칠 가능성이 높으며, 예외 처리 로직을 작성하기에 미묘한 결점이 존재한다. 해결책: try-with-resources 이러한 try-finally 방식의 단점을 보완하기 위해 자바 7 버전부터는 try-with-resources가 도입되었다. try-with-resources를 사용하기 위해서는 사용하는 자원이 AutoCloseable 인터페이스를 구현해야 한다. AutoCloseable 인터페이스는 단지 close 메서드 하나만을 정의해 놓은 간단한 인터페이스이며, 자바 라이브러리와 서드파티 라이브러리의 수많은 클래스와 인터페이스는 이미 AutoCloseable을 구현하거나 확장해두었다. 따라서, close가 필요한 자원 클래스를 커스텀 할 일이 있다면 AutoCloseable을 반드시 구현할 것을 권장한다. 그렇다면 이 try-with-resources는 어떻게 사용해야 할까? 앞선 inputString 메서드를 try-with-resources 방식으로 재구성해보았다. 놀랍게도 코드의 가독성이 대단히 좋아졌다! 또한 가독성 뿐만이 아니다. 예외가 발생했을 때 디버깅 하기에도 더 편리하다. 아까 가정한 상황처럼 inputString 메서드의 readLine과 close 모두에서 예외가 발생하는 경우, close(물론 코드 상으로는 보이지 않지만) 호출 시 발생하는 예외는 숨겨지고 readLine의 예외가 기록된다. 이렇게 숨겨진 예외는 무시되는 것이 아니라, suppressed 상태가 되어 stackTrace 시 숨겨졌다는 메시지로 출력된다. suppressed 상태가 된 예외는 자바 7부터 도입된 getSuppressed 메서드를 통해 가져와서 사용할 수 있다. 다음의 테스트 코드를 보자.   직접 throw 한 NullPointerException이 catch되어 출력되며, 이 때 close 메서드에서 던지는 IllegalArgumentException은 Suppressed: 태그 뒤로 출력되는 것을 볼 수 있다. try-with-resources와 catch try-with-resources 구조 역시 기존 try-finally 처럼 catch를 병용해서 사용할 수 있다. 정리 close를 통해 회수해야 하는 자원을 다룰 때는 try-finally를 사용하는 대신  반드시  try-with-resources를 사용하자. 보다 가독성 좋으며, 쉽고 정확하게 자원을 회수할 수 있다. 또한 커스텀 자원을 회수해야 하는 경우 AutoCloseable 인터페이스를 구현하는 것을 잊지 말도록 하자.   예전에 방학을 맞아서 잠깐 간단한 todolist 사이드 프로젝트를 했었다. 디자인은 거의 velopert 님의 todolist를 따오듯이 하고, 몇가지 기능 정도 추가해서 만든 조잡한 프로젝트였다. (방학이 다 지나는 바람에 AWS에 빌드도 못했다.) 프론트엔드는 React로, 백엔드는 SpringBoot로 진행을 했었는데, 이번에 소스코드를 정리하다가 이 당시에 한번에 프론트엔드와 백엔드를 모두 빌드했던 것이 생각나서 그 방법을 까먹기 전에 정리하고자 이 글을 쓴다. 일반적으로 팀 단위 프로젝트로 빌드를 한다면 프론트엔드와 백엔드를 분리해서 서버를 따로 올린 뒤 따로 따로 빌드를 하겠지만, 이 당시에 나는 혼자서 사이드 프로젝트를 진행하는 만큼, 서버를 따로 분리해서 제각기 빌드를 한 뒤 따로따로 실행해서 http 통신으로 데이터를 주고받는 일을 하기 보다는 전체 SpringBoot 프로젝트 구조 안에 view 부분만 React로 만들어서 내부로 집어넣어 주는 것이 좋겠다고 생각했다. Maven이 아닌 Gradle을 사용했고, Java 버전은 11, 프로젝트를 만들던 당시에는 Node.js 12 버전을 사용했던 것 같은데 어쨌든 현재 환경 기준으로 Node.js v14.18.1, npm v6.14.15를 사용했다. SpringBoot 프로젝트 생성 SpringBoot 프로젝트를 생성한다. 나는  Spring Initializr  Gradle을 기준으로 설명할 것이므로, Maven이 아닌 Gradle을 고르는 것을 잊지 말자. SpringBoot 프로젝트 안에 프론트엔드 파일, 즉 React 프로젝트가 들어갈 디렉토리가 있어야 한다. 프로젝트 최상단에 front-end 라는 폴더를 만들어주었다. 백엔드 코드는 다른 프로젝트들과 마찬가지로 프로젝트 폴더 내에서 작성하면 되고, 프론트엔드 코드는 front-end 폴더 아래에서 기존 React 프로젝트를 작성하는 것 처럼 작성해주면 된다. React 프로젝트 생성 front-end 디렉토리로 이동해서 React를 설치한다. 터미널을 열어서 다음과 같이 작성한다.  npx create-react-app 프로젝트명   참고로 React 프로젝트 명은 대문자를 사용하면 안되기 때문에, 폴더 이름에 맞춰서 프로젝트 명을 &quot;front-end&quot;라고 지어주었다. 그 뒤 React로 프론트엔드 코드를 작성해주면 된다. SpringBoot 빌드 시에 React 빌드하도록 설정 현재 상태로는 프로젝트 디렉토리는 통합되어 있지만, SpringBoot를 빌드하면 백엔드 서버만 빌드되고 프론트엔드는 따로 npm을 통해 빌드해야 한다. 이를 하나로 합쳐보자. build.gradle에 다음과 같이 작성한다. 기본적으로 프론트엔드 빌드는 npm install(최초 설치 이후에는 생략 가능) -&gt; npm run build 의 과정으로 이어지는데, 위 코드는 해당 과정을 SpringBoot 빌드 시에 함께 실행하도록 해준다. appNpmInstall task에서는 npm install을, npmBuild task에서는 npm run build를 실행한다. 이렇게 한다고 해서 SpringBoot의 view로 React가 나오지는 않는데, 빌드된 결과를 SpringBoot의 빌드 디렉토리로 옮겨주어야 하기 때문이다. copyWebApp task를 실행하면 빌드된 파일들을 build/resources/main/static 디렉토리로 옮겨서 SpringBoot 프로젝트에서 사용할 수 있도록 해준다. 맨 아래에   가 있기 때문에, appNpmInstall -&gt; npmBuild -&gt; copyWebApp 순으로 빌드 과정이 실행된다.  url 에러 바로잡기 문제는 이렇게 빌드를 완료하더라도 프론트엔드 코드가 정상적으로 작동하지 않는다는 점이다. 정확히는 딱 메인 페이지만 작동하고 그 외의 페이지는 작동하지 않는다. React에서 Router를 이용하여 페이지 이동을 설정해 주어도 빌드한 웹 상에서 페이지를 이동하면 404 에러가 발생한다. 이는 실제 빌드하고 있는 Spring에서 해당 URL에 대한 Mapping 처리가 되어있지 않기 때문이다. 이는 URL에 대한 추가적인 처리를 해주는 것으로 해결할 수 있다. WebController는 에러가 발생하면 index.html로 이동하도록 유도한다. 이제 다시 빌드를 실행하면 정상적으로 React와 Spring Boot가 합쳐진 웹 어플리케이션이 작동한다. 자동차 경주 미션과 로또 미션을 진행하면서 필연적으로 collection을 많이 사용하게 된다. 그리고 이런 collection을 사용하면서 참조, 복사 등과 관련된 문제가 종종 발생하곤 한다. 특히나 객체의 불변성을 유지하고자 할 때 이 문제는 두드러진다. 불변 객체를 만들기 위해 필드를 private final로 유지하더라도 collection을 사용하는 경우에는 불변성이 보장되지 않는다.  참고 그래서 collection의 복사본을 만드는 일은 중요하다. 복사본을 만듦으로써 참조를 끊고, 의도하지 않은 수정이 영향을 끼치는 일이 없도록 만들 수 있다.  물론 이 복사는 아니다.   collection을 복사하는 방법에는 여러 가지가 있다. 가장 간단하게는 new 키워드를 사용하여 새로운 객체를 만들어 복사해주는 방법이 있다. (앞으로 편의상 collection의 복사에 대한 모든 설명은 리스트를 기준으로 설명하기로 하자.) new와 copyOf new 키워드를 통한 복사는 기존 리스트, 즉 파라미터로 넣어준 리스트와의 참조를 끊어준다. 이 때 새로 생긴 리스트는 객체의 추가, 제거, 변경이 가능한 평범한 리스트로, 단지 원본 리스트와의 참조만 끊어진 리스트일 뿐이다. 따라서 이 리스트는 가변이다. new 키워드 외에 collection의 자체적인 정적 메서드로 copyOf라는 메서드가 존재한다. 메서드 이름에서 알 수 있듯이 이 메서드는 collection의 복사본을 반환한다. copyOf 메서드 역시 new 키워드를 통한 복사처럼 기존 객체와의 참조를 끊어주는 역할을 한다. 하지만 copyOf는 단순히 참조를 끊는 것을 넘어 한 가지 역할을 더 해주는데, 반환하는 collection을 Immutable로 만들어준다. copyOf 메서드를 뜯어보자. copyOf 메서드는 ImmutableCollections라는 객체의 listCopy 메서드를 호출한다. 이름에서 알 수 있듯이, ImmutableCollections는 불변이다. 한번 더 들어가서 ImmutableCollections.listCopy를 뜯어보면, 복사 원본인 coll이 AbstractImmutableList면서 SubList가 아니면 coll을 그대로 반환하고, 아닌 경우에는 coll을 배열로 변환해 준 뒤 List.of를 호출해서 반환한다. List.of는 메서드로 들어온 배열을 불변 리스트로 만들어준다. coll이 AbstractImmutableList의 구현체인 경우 List.of를 호출하지 않는 것을 볼 수 있는데, 이는 AbstractImmutableList에서 add, remove 등의 메서드를 호출할 경우 UnsupportedOperationException을 던지도록 이미 설계되어 있기 때문이다. 어? 그렇다면 AbstractImmutableList의 instance인 경우 복사 시에 참조를 끊지 않는 것이 아닌가? 라고 생각할 수 있다. 그렇다. coll을 그대로 반환하기 때문에 참조를 끊지 않는다. 하지만 복사 시에 참조를 끊어주는 이유를 생각해 본다면 이해할 수 있다. 복사 시 참조를 끊지 않으면 참조 원본이 변했을 때 복사한 리스트가 변할 수 있다. 따라서 복사 전 리스트가 이미 불변이므로 굳이 참조를 끊어줄 필요가 없다. 때문에 ImmutableList를 List.copyOf로 복사할 때는 따로 참조를 끊어주지 않는다. 즉, List.copyOf는 리스트를 복사해서 &quot;불변&quot;으로 던지는 것을 핵심으로 한다. 물론, 복사 시 복사 원본이 AbstractImmutableList의 인스턴스일 경우가 흔하지 않으므로 일반적으로는 원본과의 참조 역시 끊어준다고 볼 수 있다. 그렇다면 unmodifiable collection과의 차이는? 리스트를 getter 등으로 반환 시에 리스트에 수정을 가해서 필드 값이 변하도록 하지 못하도록 Collections.unmodifiableList() 메서드를 통해 unmodifiable로 만들어서 반환 해주는 경우가 종종 있다. unmodifiableList와 같은 unmodifiable collection 역시 add, remove 등의 리스트 수정 메서드를 호출할 경우 UnsupportedOperationException이 발생한다. 그렇다면 unmodifiableList와 List.copyOf를 사용하는 데 차이가 없지 않느냐는 의문이 생길 수 있다. 하지만 둘은 결정적인 차이점을 가지고 있는데, List.copyOf는 (불변성이 보장되지 않을 경우) 원본과의 참조를 끊어주지만, Collections.unmodifiableList()로 만든 리스트는 참조가 끊어져 있지 않다. 따라서, Collections.unmodifiableList()로 반환한 리스트를 직접 수정할 수는 없지만, 참조 원본을 수정할 수 있다면 불변성을 깨뜨릴 수 있다. &quot;unmodifiable&quot;이지 &quot;immutable&quot;이 아님에 주의하자. 정리 new 원본과의 참조를 끊는 복사를 한다. 복사한 객체는 가변이다. copyOf 원본과의 참조를 끊는 &quot;불변&quot; 리스트를 복사한다. 복사 대상이 불변 리스트인 경우 참조는 유지된다. Collections.unmodifiableList ... 수정 불가능한 리스트를 복사한다. 복사 대상과의 참조는 유지된다.   금요일은 강의와 포수타가 있는 날이다. 그리고 주말을 맞이하는 경건한 날이기도 하다. 이번 주도 수고 많았습니다 모두. 불금 최고.  덕몽어스 하실분은 DM을 학습로그 말하기와 로또 피드백 오전에는 페어와 학습로그 말하기를 하는 시간, 네오의 로또 피드백 강의가 있었다. 학습로그 말하기는 메타인지 능력 향상을 위해 하는 활동인데, 그간 본인이 학습한 내용을 정리해서 페어에게 이야기하고, 서로 그에 대해 피드백을 해주는 시간을 가진다. 나는 페어였던 필즈와 오랜만에 다시 만나 학습로그 말하기를 했는데, 내가 말한 주제는 불변 객체에 관해 학습한 내용 정리였다.  불변 객체를 미친듯이 우려먹는 것 같지만 넘어가자 학습로그 말하기가 끝나고는 로또 피드백 강의가 있었다. TDD와 리팩토링을 연습하는 과정을 로또 미션 시작부터 간략하게 진행해 나가는 강의였다. 나와 필즈는 로또 미션을 시작할 때 가장 작은 단위인 LottoNumber부터 시작을 했는데, 꽤 많은 크루들이 나처럼 LottoNumber부터 시작을 했다고 말했다. 다만 처음 개발을 할 때 가장 작은 단위인 LottoNumber 부터 캐치해서 시작하는 것이 일반적이지 않다는 의견도 있었다. 리팩토링 강의의 핵심은 리팩토링 과정에서 컴파일 에러나 테스트 실패를 최소화하라는 이야기였다. 이전에는 리팩토링을 한번 하면 테스트 다 깨지고 컴파일 에러가 나고 그 에러들 수정하다가 시간 다 가는 일이 다반사였는데, 우선은 기존 코드를 그대로 놔두고 메서드나 필드를 복붙해서 새로 만들어서 로직을 리팩토링하고 리팩토링이 끝나면 원래 코드를 지우는 식으로 코드 안정성을 유지하면서 리팩토링 하는 것이 좋다고 한다. 포수타 금요일은 포수타가 있는 날이다. 오늘의 포수타 주제는 근로장학이었다. 우테코에서는 근로장학을 운영한다. 원래 서비스 근로, 리뷰 근로, 영상 근로 이런게 있었는데 이번에는 인스타그램을 운영하는 그... 뭐였더라 이름이 기억이 안나는데 여튼 홍보 관련된 근로가 생겼고, 서비스 근로 팀도 한 팀 더 늘어났다고 한다. 사실 근로장학에 대해서는 우테코 들어오기 전부터 우테코 브이로그 같은 영상을 보면서 관심이 있었어서 공고가 올라오는 대로 지원해야겠다는 생각을 가지고 있었다. 근로장학으로 들어오는 돈을 차곡차곡 모아서 맥북을 사려는 소소한 목표도 있었다. 하지만 최우선적으로 집과 루터회관과의 거리를 본다고 하니... 의정부가 집인 나는 아무래도 힘들 것 같다 😭 (그래도 혹시나... 기대해 봐도 좋을까요...?) 로또 미션 끝 회고를 한창 쓰고 있던 도중, 로또 미션 2단계도 merge가 되었다는 알림이 왔다. 음... 뭔가 어디에 손을 댈지 모르겠는 코드가 손 댈곳이 없는 코든가 싶기도 하고... 와중에 merge가 되면서 반영은 못했는데, 이번 미션에서 나와 리뷰어 모두 놓치고 있는 부분이 있다는 걸 알아챘다.   모든 로또는 출력시에 오름차순으로 정렬되고 있었다... 반면 내 코드에는 로또 순서가 아무렇게나 되어 있었다. 다른 크루들이 HashSet을 쓰네 List를 쓰네 LinkedHashSet을 쓰네 얘기하던 이유가 이런 이유 때문이었구나... 사실 출력하는 과정에서 먼저 sort를 하고 출력하면 되는 부분이라 LottoNumber 클래스에 Comparable&lt;&gt;을 구현해서 compareTo를 오버라이딩한 뒤 view의 출력 부분에서 stream에 sorted를 끼워넣으면 되는거라 어려운 부분은 아니었는데, merge가 되는 바람에 따로 수정은 하지 못할 것 같다. 로또 미션은 확실히 이전 자동차 미션보다는 어려웠다. 특히나 수동 로또 구매 로직을 집어 넣으면서 머리를 좀 싸맸던 것 같다. 그만큼 얻어가는 부분도 많았고, 데일리 미팅 조에서 크루들끼리 이런 저런걸로 토론하면서 코드에 대해 이야기를 나누면서 얻게 되는 것도 많았다. (오늘도 스터디 전에 서로 리뷰어에게 받은 코드리뷰를 나누면서 여러 이야기를 했다.) 확실히 이렇게 코드에 대해서 서로 대화를 나누고 좋은 점을 흡수 할 수 있다는 점이 우테코 최고의 장점인 것 같다. 다음 미션은 블랙잭인데, 대충 훑어봐도 블랙잭 미션부터 난이도가 급격히 상승하는 것 처럼 보인다. 미션에 돌입하기 전에 로또 미션에서 내가 짠 코드를 한번 더 돌아보고 객체지향에 관련된 내용을 조금 더 공부하면서 블랙잭 미션을 알차게 준비해야 할 것 같다. 로또 미션이 일찍 끝난 만큼 블랙잭 페어 때 페어에게 폐가 되지 않도록 미리미리 준비할 필요가 있어 보인다.   오늘은 수업이 없어서 약간 널널한(?) 날이었다. 그 덕에 데일리 미팅이 끝나고는 다시 잠들어서 수면을 보충하는 시간을 가졌다. 며칠 잠을 안자고 무리한 것도 있어서 꿀맛같은 낮잠이었다. 우테코를 하는 1년동안 이것 하나만큼은 그 누구보다 잘하고 싶다 후니가 마스터로 진행한 오늘의 데일리 주제는 &quot;우테코를 하는 1년동안 이것 하나만큼은 그 누구보다 잘하고 싶다!&quot; 에 관한 이야기었다. 다들 이런 저런 이야기를 했는데, 내가 이야기한 것은 &quot;우테코 하는 1년동안 발표 하나만큼은 남들보다 잘하고 싶다&quot; 였다. 원래 대학교 때 졸업 프로젝트도 내가 다 ppt 제작과 발표를 맡았어서 어느 정도 자신이 있긴 한데, 그래도 발표할 때 떨리거나 부족한 점이 많기는 하다. 사실 지금 진행중인 이펙티브 자바 스터디도 어떻게 보면 매주 발표를 해야 하니 발표 실력을 향상시킬 수 있는 시간이라고 볼 수 있어서 발표 자료를 꽤나 심혈을 기울여서 만든 편이다. (나는 근데 다들 ppt를 만들어올 줄 알았는데 의외로 만든 사람이 몇 없었다는...  그렇다고 마크다운이 성의없다거나 하는게 아니다! 정리본으로 보기에는 마크다운이 훨씬 좋다! ) 그런 의미에서 테코톡도 기대가 된다. 레벨 1에서는 아직 내가 아는 것도 많이 없고 개인적으로 하고 싶은 주제들도 레벨 1과 크게 관련이 없었어서 하지 않았는데, 레벨 2, 레벨 3으로 가서는 테코톡을 좀 빡세게 준비해서 하고 싶다. 유튜브에 박제까지 될테니 허투루 준비할 수가 없다. 발표 얘기를 하니까 어떤 크루가 테코톡 10번 가냐는데 그렇게 까지는 못하겠고... 2번 3번은 해볼만 할지도? 로또(수동) 피드백 로또 2단계 수동 구매 미션의 피드백이 왔다. 사실 2단계 미션이 수동 로직을 추가한 것에 지나지 않고, 1단계에서 이미 어느정도 리팩토링을 한 상태였기 때문에 피드백으로 들어온 내용이 많지는 않았다. 내가 질문했던 부분에 답변해주시고 몇가지 개선점을 닉이 지적해주신정도...? 근데 뭔가 내 코드가 맘에 안드는 이 기분은 뭘까...   원래는 에러 메시지를 static으로 열어 놓고 테스트 메서드의 hasMessage에 넣어서 메시지까지 테스트를 했다. 메시지 테스트는 페어였던 필즈가 제시했던 방법인데, RED -&gt; GREEN 으로 TDD를 진행할 때 똑같이 IllegalArgumnetException을 반환해도 에러의 이유가 다른 경우를 테스트할 때, 의도하는 에러가 발생하지 않았는데도 테스트가 GREEN으로 통과하는 경우를 방지하는 방법이었다. 다만 나와 필즈가 했던 것 처럼 에러 메시지 상수를 테스트 코드에서 쓰지 말고 테스트 코드에서는 하드코딩하라는 피드백이 있었다. 하긴, 어디서 봤는지는 모르겠는데 테스트 코드의 expected 부분에는 최대한 하드 코딩하는것이 좋다는(프로덕션에서 가져다 쓰면 오류가 나도 테스트를 통과할 가능성이 생겨서) 이야기를 본 것 같다. 일단은 피드백 내용을 반영하고 다시 코드 리뷰 요청을 했는데 음... 뭘까 이 찝찝함은? 하지만 코드를 계속 봐도 더 손댈만한 부분을 찾기가 힘들다. 나의 비루한 자바 실력 덕분인가... 잘하는 친구 어떻게 무시하나 저녁 7시, 선배 크루 몇 분께서 &quot;잘하는 친구 어떻게 무시하나&quot; 라는 주제로 특강(?)같은, 가볍게 이야기하는 시간을 만들어주셨다. 확실히 우테코에 다같이 들어왔지만, 각자의 실력에 차이가 있다보니 자연스럽게 서로가 서로의 코드를 비교하고 본인의 부족한 점을 비교하게 되는 것 같다. 나 역시도 다른 크루들의 코드나 블로그 정리를 보면서 감탄하다가도 내 코드를 보고 한숨짓는 경우가 있었을 정도다. 오늘 대담은 3기 크루셨던 신세한탄과 티케가 본인의 경험담, 그리고 4기 크루들이 미리 작성한 질문에 대한 Q&amp;A를 진행해주셨는데, 두 문장으로 요약이 가능할 것 같다. &quot;빨대&quot; &quot;오히려 좋아&quot; 잘하는 사람이 있다면 본인과 비교하면서 자괴감을 가지지 말고, 그 사람의 장점을 내 것으로 체득할 수 있도록 빨대를 열심히 꼽을 것. 그리고 항상 &quot;오히려 좋아&quot;라는 마인드를 가질 것. 레벨 2, 3 계속 올라갈수록 더 다양한 개념들을 배우고 그만큼 잘하는 사람들이 훅 치고 나갈텐데, 그럴 때마다 오히려 좋아의 마인드로 더 많이 배울 수 있는 계기로 만들어야겠다는 생각이 들었다. 물론 제일 좋은 것은 내가 남들이 빨대 꼽을만큼 잘하는 사람이 되는 거라고 생각한다. 목표는 그거다.   거의 1주만에 회고를 쓴다. 왜냐하면 아팠기 때문이다. 지난 주 초반부는 데일리도 죄다 빠지고 강의도 못들을 정도로 아파서 약먹고 페어 프로그래밍과 리팩토링 잠깐 잠깐 한 것 외에는 잠만 잘 정도였고, 후반부에는 회고보다는 스터디 준비하고 로또 미션 리팩토링을 하느라 시간을 보냈기 때문이다. 왜 아프냐고?   오미크론 확진자가 거의 20만명씩 나오는 이 시기에 놀라운 일은 아니다만, 뭐 어쨌든 그렇게 됐다. (다행히 이 글을 쓰고 있는 시점에서는 격리해제) 그간 우테코 하느라 밖에 잘 나가지도 않다가 졸업식 한번 나갔다 왔는데 거기서 걸려서 왔다. 운도 지지리도 없지... 오미크론으로 우세종이 변하고 나서 코로나가 안아프다는 소리를 들어서 걱정하지 않았었는데, 아니었다. 진짜 엄청 아팠다. 독감 한번 걸린적 없던 나라서 그런가 이런 증상에 익숙치가 않았다. 목이 미친듯이 부어서 침도 삼키기 힘들 정도... 여러분 몸관리 잘하세요 증말... 로또 1단계 미션으로 배운 것 캐싱 로또 번호는 1 45까지 총 45개다. 다른 나라 로또는 어떤지 모르겠고 우리 나라에서도 스피또는 다른 방식이고 그렇지만 뭐 여튼 로또 6/45의 규칙은 1 45의 숫자 6개를 고르는 것이다. 그렇다면, 어쨌든 간에 로또 미션에서 사용하는 LottoNumber(로또 번호 VO)의 개수는 45개라는 소리다. 처음에는 그냥 무작정 인스턴스를 만들었는데, 코드 리뷰 과정에서 45개의 객체를 미리 캐싱해놓고 가져다 쓰면 되지 않겠냐는 의견을 받았다.   오, 생각해보니 그렇다. 계속 LottoNumber의 인스턴스를 만드는 것 보다, 미리 1 45의 LottoNumber를 만들어 놓고 필요할 때 참조로 가져다 쓰는 것이 훨씬 빠르고 리소스 낭비도 적다. 처음에는 List의 형태로 만들었는데, 지금이야 1 45로 연속적인 숫자지만 연속적이지 않을 경우에 문제가 되고, 값을 찾아올 때 값-1 로 인덱싱을 해줘야 한다는 단점이 있어서 Map의 형태로 바꿔주었다. 캐싱에 대한 더 자세한 내용이 궁금하다면  이곳 을 참고하면 좋을 것 같다. 상속보다는 조합을   나와 내 페어 필즈는 LottoTicket과 WinningLotto 클래스가 내부 구조가 거의 비슷하니까 LottoNumbers 라는 추상 클래스를 만들어놓고, 그걸 상속해서 구현하는 식으로 했었다. 하지만 리뷰로 받은 내용은, 상속도 좋지만 조합으로 풀어나가는 것이 더 좋다는 피드백이었다. 이 부분에는 이펙티브 자바에도 같은 내용이 있었고, 현재 진행중인 이펙티브 자바 스터디에서도 다룬 내용이어서  관련 내용을 첨부 한다. DTO 생성 방식 나는 DTO 사용을 좋아한다. 아무리 변경 가능성을 최소화하는 방향으로 도메인을 설계했더라도, 도메인에 들어있는 비즈니스 로직이  뷰로 넘어가는 것에 대해 경계하기 때문이다. (내 코드 작성이 조그만한 사이드 이펙트의 가능성도 방지하고 싶어하는, 약간 보수적인 감이 있긴 하다.) 그래서 이번에도 DTO를 사용하려고 했는데, 아직은 사용하지 않았다. 생성 방식에 대한 고민 때문이었다.   원래는 당연히 도메인 외부에서 DTO를 생성했었는데, 생각해보니 도메인 안에 DTO를 반환하는 toDTO와 같은 메서드가 있으면(실제로 DTO -&gt; entity의 경우 toEntity 메서드를 사용하는 예제들을 보았다.) getter를 쓰지 않고 좋지 않을까? 라는 생각을 해서 질문을 남겼다. 그리고 돌아오는 답변은...   그렇다. 도메인 내에서 DTO를 만들어주는 방식은 안티 패턴인 것 같다. &quot;도메인 객체는 순수한 상태여야 합니다.&quot; 라는 생각을 하지 못해서 저런 방법을 생각했던 것 같다. 도메인과 뷰를 분리하기 위해서 DTO를 사용하는데 DTO 자체가 뷰와 연관이 있는 만큼(뷰가 달라지면 DTO의 모양도 달라져야 하므로) 도메인에서 DTO를 사용하는 것은 목적에 부합하지 않는다 라고 정리할 수 있을 것 같다. 로또 2단계 미션 1단계가 merge되고, 2단계 미션도 진행했다. 2단계 미션은 자동 로또 뿐 아니라 수동 로또를 생성하기. 이 부분에서 가장 애먹었던 부분이 수동 로또 구매 개수와 수동 로또 번호를 어떤 식으로 관리할건가였다. 온갖 클래스를 다 설계해보면서 고민해보았는데, 너무 많은 클래스 추가는 난잡한 것 같고 추가한 클래스는 LottoOrder. 수동 구매와 자동 구매 장 수를 저장하는 로또 주문 클래스를 만들었다. 이 부분을 객체로 만들게된 영감은 유튜브에서 본 &#39;우아한객체지향&#39; 이라는 세미나에서, 예제 코드에 주문, 배달 같은 모든 상태가 객체로 관리되고 있던 부분에서 따왔다. 처음에는 사용자가 입력한 수동 로또 번호도 필드로 넣어주려고 했는데, 그러면 유효성 검증 등의 부분에서 복잡해서 번호의 유효성 검증은 로또 생성시에 될 수 있도록 따로 객체를 만들지 않고 뷰에서 이중 리스트의 형태로 받아와서 처리하도록 했다. 그 외에는 DTO를 추가하는 등 자잘한 리팩토링을 하고 PR을 날렸다. 작성한 코드가 많지는 않았지만 수동 기능을 추가하는 부분은 쉽지 않았다... 아마 내일 쯤 코드 리뷰가 오지 않을 까 싶은데, 이번 주는 내가 만족할 수 있을 때 까지 최대한 코드 리팩토링 위주로 진행하는 것을 목표로 해야할 것 같다. 오빠는 변한다지만 객체는 변하지 말자  사진 출처   불변 객체(immutable object). 말 그대로 한 번 생성되면 값이 변하지 않는 객체를 말한다. 우리는 일반적으로 불변 객체로 만들기 위해 할당 이후에 변하지 않는 값에 final 키워드를 붙여서 사용하고자 한다. 하지만 과연 이렇게 사용하면 모두 불변 객체가 될까? 우선 위키백과의 정의를 먼저 찾아보자. 객체 지향 프로그래밍에 있어서 불변객체(immutable object)는 생성 후 그 상태를 바꿀 수 없는 객체를 말한다. 반대 개념으로는 가변(mutable) 객체로 생성 후에도 상태를 변경할 수 있다. 객체 전체가 불변인 것도 있고, C++에서 const 데이터 멤버를 사용하는 경우와 같이 일부 속성만 불변인 것도 있다. 또, 경우에 따라서는 내부에서 사용하는 속성이 변화해도 외부에서 그 객체의 상태가 변하지 않은 것 처럼 보인다면 불변 객체로 보기도 한다. 예를 들어, 비용이 큰 계산의 결과를 캐시하기 위해 메모이제이션(Memoization)을 이용하더라도 그 객체는 여전히 불변하다고 볼 수있다. 불변 객체의 초기 상태는 대개 생성 시에 결정되지만 객체가 실제로 사용되는 순간까지 늦추기도 한다. 위키백과 결국 불변 객체의 핵심은  &quot;생성 후 객체의 상태가 변하지 않는다.&quot;  라고 할 수 있다. 자바에는 대표적인 불변객체로 String 등이 있다. 오잉? String 변수에 새 문자열을 할당시킬 수 있는데 무슨 소린가요? 라고 할 수 있겠지만, String은 사실 불변 객체로, String은 따로 String constant pool에서 관리되며 String 변수가 문자열 리터럴을 직접 담고 있는 것이 아닌, String constant pool 내에 일치하는 문자열을 참조만 할 뿐이다. 할당하는 문자열 리터럴 값이 바뀐다면 String 변수는 새로운 객체를 참조한다. 따라서 String은 불변이다. 그런데 이런 불변 객체를 왜 사용해야 하는 걸까? 불변 객체를 사용해야 하는 이유 단순하다. 불변 객체의 상태는 생성된 시점으로부터 파괴되는 시점까지 그대로 유지된다. 즉, 프로덕션에서 해당 객체가 가진 값을 변하지 않게 하려는 추가적인 노력을 필요로 하지 않는다.  Thread-Safe하다. 기본적으로 멀티스레딩 환경에서의 문제는 여러 스레드가 같은 객체에 접근하여 데이터를 쓰는 작업을 할 때 발생한다. 여러 스레드에서 값을 수정하기 때문에 객체의 상태가 훼손되어 해당 객체를 공유하는 다른 스레드에도 영향을 끼치는 것이다. 하지만 불변 객체는 상태가 변하지 않으므로 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없어 안심하고 공유할 수 있다. cache, map의 key, set의 원소 등 변하지 않아야 하는 구성요소로 적합하다. cache, map의 key set의 원소 등으로 사용되는 객체의 상태가 변한다면 로직을 깨지 않기 위해 추가적인 작업을 진행해주어야 한다. 불변 객체를 사용한다면 그런 작업을 고려하지 않아도 되어 해당 자료구조를 더 편하게 사용할 수 있다. 예측가능하다. side-effect의 가능성이 적다. 객체가 불변 객체가 아니어서 setter가 열려있는 등 다른 코드에서 해당 객체의 값을 수정 가능하다면, 의도하고자 하지 않은 방향으로 프로그램이 작동할 수 있다. 불변 객체를 사용하면 값을 예측할 수 있으므로 예상치 못한 값으로 인한 side-effect의 가능성이 적어진다. 불변 객체를 만드는 방법 이펙티브 자바에서는 클래스를 불변으로 만들기 위해 다음의 다섯 가지 규칙을 따르라고 한다. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다. 즉, setter 등의 메서드를 사용하지 않는다. 클래스를 확장할 수 없도록 한다. final 클래스로 선언 등의 방법으로 상속을 막는다. 모든 필드를 final로 선언한다. 모든 필드를 private으로 선언한다. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면, 클라이언트가 그 객체의 참조를 그대로 반환받도록 하지 말고 방어적 복사를 수행해야 한다. reference 타입이나 collection은 final이어도 불변이 아니다. 가장 많은 사람들이 헷갈리는 부분이 모든 필드가 final이면 불변 객체가 아니냐고 하는 것이다. primitive 타입인 필드의 경우는 final을 붙여주는 것 만으로도 불변성을 보장한다. 하지만, 모든 필드가 final이어서 재할당 가능성이 없다 하더라도 그 객체의 불변성을 보장할 수는 없다. 다음의 경우를 보자. 이 객체는 불변일까? 얼핏 보기에는 불변으로 보인다. 하지만 사실은 불변성을 보장할 수 없다. 필드로 reference 타입인 Nation을 가지고 있기 때문이다. 만약 Nation 클래스가 위와 같이 population 필드가 final도 아니고 setter가 열려 있는 가변 객체라면, 이렇게 getNationality로 꺼낸 Nation의 상태를 조작하거나 참조 원본 객체를 조작하여 불변성을 깨뜨릴 수 있다. collection의 경우를 보자. 이 클래스는 로또 번호 리스트를 통해 생성할 때 방어적 복사를 해서 외부 참조도 끊겨있고, lottoNumbers 필드가 private final로 선언되어 있어 재할당이 불가능하며, 심지어 lottoNumbers의 상태를 변화시킬 수 있는 로직도 존재하지 않는다. 하지만 이 클래스는 불변하지 않다. &quot;재할당이 불가능하다 == 불변하다&quot; 가 아니기 때문이다. 외부에서 Lotto 클래스의 인스턴스에서 getLottoNumbers()를 호출하면 lottoNumbers는 private final이지만 외부로 노출된다. getter로 꺼낸 lottoNumbers는 final이지만 add, remove 등의 메서드를 사용하여 상태를 변화시킬 수 있다. List lottoNumbers가 불변 객체가 아니기 때문이다. 또한 새로운 List가 반환된 것이 아니라 lotto 인스턴스의 필드를 참조하기 때문에, getter로 꺼낸 lottoNumbers를 변화시키면 기존 객체의 상태가 변하게 된다. 따라서 이런 경우에는 반환 시 List.copyOf 등의 방법으로 방어적 복사를 해서 반환해주거나, 단순히 참조를 끊는것 뿐만 아니라 List 자체가 불변이고 싶다면 해당 List를 Collections.unmodifiableList와 같은 불변 자로구조로 만들어주는 것이 좋다. getter 등으로 반환 시 외에도 생성자에서도 마찬가지로 방어적 복사를 통해 외부 참조를 끊어주는 것이 좋다.  final은 재할당만 막아줄 분 reference 타입 또는 collection 내부의 상태의 변화까지 막아주지는 못한다는 점에 주의하자. 방어적 복사와 unmodifiableList의 차이점? (편의를 위해 List를 기준으로 설명한다. 다른 타입이나 컬렉션도 마찬가지로 작동한다.) List를 방어적 복사를 하게 될 경우 기존 객체와의 참조가 끊긴다. 즉 값이 같은 전혀 다른 객체를 생성한다. 따라서 이 경우 새로 반환된 객체를 수정할 수 있다. (단, 수정하더라도 복사 원본의 값이 수정되지는 않는다.) unmodifiableList는 add, remove 등의 메서드로 객체 요소를 수정하려고 하면 예외를 던진다. 따라서, getter로 unmodifiableList를 던져주면 해당 객체를 받은 쪽에서 데이터를 수정할 수 없다. 하지만 불변을 위해 unmodifiableList를 사용 시 주의해야하는 부분이 있다. 인스턴스 foo는 생성 시점에 빈 리스트를 받아서 생성하고, 리스트의 상태를 변화시키는 어떤 로직도 수행하지 않은채로 unmodifiableList를 반환하기 때문에 intsOfFooInstance의 크기는 0이어야 한다고 생각할 수 있다. 하지만 위 테스트의 결과는 테스트 실패다. unmodifiableList는 원본 객체와의 참조를 끊지 않기 때문에 생성자에 넣어준 리스트가 수정되게 되면 인스턴스 foo의 필드 리스트도 변하게 된다. 따라서 불변성을 보장하기 위해서는, 생성자에서는 방어적 복사를 하고, getter에서는 방어적 복사 또는 unmodifiableList 반환 중 선택해서 진행하는 것을 권장한다. 그렇다면 방어적 복사는 불변성을 보장하는가? 그렇지 않다. 방어적 복사를 진행하는 값이 reference 타입의 collection이라면 불변성을 보장할 수 없다. 방어적 복사는 얕은 복사를 수행한다는 점을 기억하자. collection의 요소에 변화가 일어나면 방어적 복사본에서도 불변성이 깨지게 된다. 따라서 collection의 요소 자체가 불변 객체여야만 방어적 복사시에도 불변성을 유지할 수 있다. 따라서 불변 객체를 만들 때 주의해야 할 점은 다음과 같다. primitive 타입의 필드는 final로 불변성 보장 가능 reference 타입이나 collection을 필드로 가질 경우 방어적 복사를 통해 원본 참조를 끊을 것 primitive 타입의 collection은 방어적 복사와 unmodifiable collection을 이용해 불변을 보장할 수 있지만, reference 타입의 collection은 collection 내의 요소들의 불변성도 보장되어야 함   지난주 막판은 졸업식을 다녀오고, 주말에는 피드백 받은 내용 바탕으로 코드를 수정하고, 쉴 새 없이 바빴다. 일요일 저녁에는 보이는 라디오 회식까지 해서 더 바빴다. 새벽까지 다같이 광란의 파티를 벌이는 바람에... 문제는 졸업식을 함께한 사람들이 단체로 몸살이 나서 코로나 검사를 받았더니 벌써 몇 명이나 신속항원검사에서 양성이 나왔다는 점이다. 나는 음성이 나왔지만, 문제는 유증상이다. 아침에 일어났을 때는 어제 회식의 여파라고만 생각했는데 점점 몸살기운과 인후통이 올라오고 있다... 우테코 하느라 진짜 얼마만에 나간건지도 모르겠는데 하필 그날 코로나 이슈라니... 자동차 경주 리팩토링 리뷰어 제이가 다시 한 번 리뷰를 남겨주었다. 이번에는 수정 요청 사항이 많지는 않았는데, 많지 않은 지적이 대부분 깊게 생각해볼만한 부분이었다. model과 view의 책임 먼저 String을 콤마를 기준으로 자르는 로직이 Cars(model 계층)에 있을 필요 없이 중복 검사나 유효성 검사는 model로 넘어오더라도 String을 잘라서 list로 만들어 주는 것은 view 계층에서 해도 되지 않겠냐는 의견이었다. 생각해보니 nameString을 자르는 것을 굳이 Cars에서 할 필요가 없이 Cars는 딱 자동차 생성에 필요한 list만 받아 오는 것이 맞는 것 같고, 지금 부여한 책임은 Cars에게 불필요한 책임인 것 같아서 제이의 말대로 해당 로직을 view로 옮겨주었다. 인터페이스를 활용한 테스트 CarTest와 WinnersTest는 테스트 내에서 필요에 따라 Car를 전진시키는 로직이 있는데, 현재 게임의 자동차 전진 조건이 랜덤 넘버 4 이상이기 때문에 전진이 필요한 자동차의 goOrStop() 메소드에 4 값을 넣어서 전진시켰다.   해당 부분에 대해 제이가 위와 같은 피드백을 주었다. 음... 생각해보니 제이의 말이 맞다. 지금은 해당 메소드를 호출하는 곳이 적지만, 만약 Car.goOrStop() 메소드를 수많은 테스트에서 사용하는데 전진 규칙이 바뀌게 되면 테스트를 일일이 다 찾아서 수정해야 한다. 인터페이스를 이용하여 테스트하는 방식은 예전에 데일리 미팅 크루들과 이야기를 나누어 봤었는데, 다들 랜덤 값에 대한 테스트를 못하기 때문에 대체 방법으로 인터페이스 구현체를 이용한 것이었다. 당시에 나는 랜덤이 개입하는 로직에 대해서는 모두 테스트하지 않고, goOrStop()은 어떤 값이든 호출시에 파라미터를 받아서 해당 값으로만 전진/정지를 판단했고 그에 대한 테스트를 진행했기 때문에 굳이 인터페이스로 분리하는 방식이 필요하지 않다고 느꼈었다. 하지만 생각해보니 규칙의 변경에 테스트가 유연하게 대처할 수 없는 구조라는 제이의 피드백이 옳다. 그래서 다음 링크를 참조하여 인터페이스를 사용하여 테스트를 유연하게 만들었다.  인터페이스를 분리하여 테스트하기 좋은 메서드로 만들기 이펙티브 자바 스터디 이펙티브 자바 스터디 첫 오티를 했다. 진행 방식을 확정하고 스터디 내부 규칙을 정하는 시간을 가졌는데, 확실히 여러 사람이 모여서 논의하니까 좋은 방안들이 여럿 올라왔다. 오티 전이 마침 3기 수료생 웨지의 효과적인 스터디를 하는 법 특강이었기 때문에, 다들 스터디 진행 방향에 대한 생각을 하고 오티를 들어올 수 있어서 좋았다. 우테코 4기 내에서 처음 만든 스터딘데, 이펙티브 자바 책이 워낙 방대해서 솔직히 조금 걱정이 되기는 한다. 아무래도 첫 스터디인 만큼 부족한 부분도 있을테고. 하지만 스터디를 진행하면서 부족한 점을 피드백해가며 조금씩 조정해 나간다면 효과적인 스터디를 꾸려나갈 수 있을 것 같다. 내일부터는 로또 미션 페어 프로그래밍도 시작될테고, 스터디 준비도 해야 하고... 쉴 시간 없이 바쁠 것 같다. 큰일이다. 와중에 코로나 양성까지 나오는 최악의 상황만 아니었으면 좋겠다.   어제는 바빴던데다가 피로가 몰려와서 회고를 못썼다. 확실히 요즘 코딩 + 글쓰기 + 개인공부 까지 하려니 수면이 부족하기는 한 듯 싶다. 효율적인 시간 관리가 더 필요해보인다. 자동차 경주 미션 - 2단계 자동차 경주 미션 2단계, 리팩토링에 들어갔다. 2단계의 주제가 MVC 패턴으로 리팩토링하라 였는데, 일단 (무늬만으로라도) MVC 패턴으로 코드를 짰기 때문에 코드 자체를 손볼 곳이 많은 것은 아닌 것 같았고, 개인적으로 이해가 가지 않는 부분에 대한 공부를 좀 하느라 코드를 치는 시간 보다는 생각하고 자료를 찾아보는 시간이 더 많았던 것 같다. Controller와 멤버 변수 내가 짠 코드는 MVC라고 짜기는 했지만, Controller에서 멤버 변수를 가지고 있었다. cars와 tryCount를 멤버 변수로 둔 것은 컨트롤러 메소드 전역에서 사용하고 관리하기 위한 것이었고, 코드를 짜면서 어느 부분이 문제가 되는지 전혀 생각하지 못했다. 내가 MVC 패턴에 대해 잘 이해하고 있지 않은 탓이랴. 그리고 1단계 마지막 리뷰에서 이 부분에 대한 피드백을 받았다.   솔직히 이 피드백을 받고 나서도 한참은 이해를 하지 못했다. 어차피 게임이 시작되면 반드시 자동차 이름들과 전체 라운드 수를 입력받아서 설정해야 하고, 이 값들이 게임 끝날 때 까지 사용되니까 전역으로 관리하는 것이 좋지 않을까? 하는 생각이 있었다. 이 의문점은 데일리 미팅 조원들과 이야기를 나누면서 해소하게 되었다. Controller라는 역할의 의미를 생각해 보면 정의에 부합하지 않는다. Controller에 책임을 부여한다. Controller에 멤버 변수를 넣는 것은 Controller가 객체의 상태를 가지고 있는 것이다. 이는 여러 사용자가 사용할 때의 동시성 이슈 가능성을 내포하고있다. 이렇게 정리가 가능할 것 같다. 저 세 가지 이야기의 세세한 내용은 MVC 패턴을 공부하는 김에 따로 게시글로 정리해봐야겠다. 어쨌든 이 부분에 중점을 두어서 MVC 패턴에 대해 이해하고, 컨트롤러가 최대한 본연의 역할만 할 수 있도록 리팩토링하고, 몇가지 네이밍이나 컨벤션에 대해서 리팩토링을 하고 2단계 첫 PR을 날렸다. 보이는 라디오 오후 두 시, 드디어 우테코 첫 번째 큰 산인 보이는 라디오 시간이 있었다. 어제 리허설을 했을 때 워낙 어마어마하게 준비한 팀들이 많아서 걱정이 많았다.. 심지어 오늘 아침에 노트북의 왼쪽 C 포트가 싹 뻗어버리는 바람에 충전도 안되고 허브 연결도 안돼서 이대로 망하는게 아닌가 싶었는데 어찌 어찌 고쳐서 사용하기는 했다. (학교 근로에서 컴퓨터 수리를 배웠기 망정이지...) 가짜사나이를 패러디한 &quot;가짜우테코&quot;를 기획한 우리조는 어제 리허설이 끝나고 다른 조의 어마어마한 준비성(?)에 놀라 새로 필터도 찾고 음악 세팅도 미리 준비해두었다. 연습도 엄청 했는데, 처음에는 다들 국어책 읽기였다가 점점 발전하는 연기력을 볼 수 있었다. 군필자도 아닌데 조교 역할 한 라라에게 박수를! 나도 오랜만에 군대때 기억을 살려서 연기하는게 재밌었다. (끝나고 게더타운 들어가니까 나 조교출신 아닌데 다들 조교출신이냐고 묻더라...) 중간에 더즈의 연결이 끊기는 불상사가 있었지만!! 잘 마무리하고 반응도 좋았다. 중간중간 웃참 하느라 힘들기도 했는데.. 크루들 모두 웃음 터지는 일 없이 계획한 시나리오대로 대사도 잘 치고 다른 조 크루들의 반응도 너무 좋았어서 만족스럽다. 유격에서 쓰는 악 대신 깃! 이라고 유행어(?)를 만들었는데 크루들이 많이 써줘서 기쁘기도 하다. 다른 조들의 보이는 라디오 무대도 너무 재밌었다. 온갖 패러디와 개그가 가득했고, 보이는 라디오 프로그램이 의도한대로 그 안에서 협업의 자세라든가, 자바 vs 자바스크립트라든가, 우테코에서 나올만한 여러 주제들을 잘 녹여낸 것 같았다. 아직도 기억에 남는 크루들이나 유행어가 많다. 정말 요 근래 제일 원없이 웃어본 경험이었다. 처음 보이는 라디오 한다고 할 때는 이걸 어떻게 하나 걱정도 되고, 이걸 왜 하나 하는 생각도 들었었는데, 하다보니까 재밌고 무엇보다 크루들과 친해지는 기회가 된 것 같다. 백엔드에만 사람이 70명이 넘어서 일일이 친해지기가 힘든데 데일리 미팅도 그렇고, 보이는 라디오도 그렇고 이런 식으로 팀 활동을 하면서 가까워지고 가까워지고 나면 서로간에 좋은 영향을 끼칠 수 있어서 굉장히 긍정적인 활동이라고 생각한다. 일요일에 회식도 하기로 했는데 기대된다. 이제 보이는 라디오라는 큰 산도 넘었고, 이번 주 남은 일은 2단계 PR한 것에 코드 리뷰가 오면 마저 리팩토링을 진행하는 것과, 이전부터 계획을 세웠던 이펙티브 자바 스터디를 구성하는것, 음.. 그리고 나의 졸업식! 금요일 하루는 졸업식으로 자리를 비우게 되었는데 맘 편하게 놀다가 와야겠다.   어제 일찍 잠들었는데도 불구하고 그간 새벽 코딩에 간간히 게임까지 곁들여져서 수면 시간이 부족했는지 눈을 떠보니 9시 50분이었다. 황급히 kdt 출결 찍고 세수하고 게더타운 입장. 데일리 미팅 이번 주 부터는 크루들이 데일리 미팅의 주제를 정해오는 날이 생기게 되었는데, 오늘은 어썸오가 주제로 &quot;자기가 가장 좋아하는 유튜버 추천하기&quot;를 가져왔다. 유튜브에 구독된 채널만 거의 200개에 육박하는 나는 어떤 유튜버를 골라야 하는가... 라는 생각이 들었는데, 나 혼자만 즐겨 볼만한 채널 보다는 다른 사람에게 추천했을 때 그 사람도 즐길 수 있을 만한 채널이 좋겠다고 생각해서 노래 유튜버인(노래를 잘 안 듣는 사람은 많이 없으니까...?)  예빈나다님의 채널 Package, import, class, instance 데일리 미팅이 끝나고 10시 반 부터는 자바의 기본 문법인 패키지, 임포트, 클래스, 인스턴스에 대한 네오의 강의가 있었다. 자바의 가장 기초적인 내용이라고도 할 수 있는데, 예전에 진행했던 백기선님의 라이브 스터디에서 해당 부분에 대한 내용을 velog에 정리하면서 공부했었던 터라 이해하기에 어렵지는 않았던 것 같다.  [Live-Study] #5 클래스   [Live Study] #7 패키지 다만 클래스와 인스턴스의 관계에 대해서 내가 라이브 스터디 당시에 정리했던 것에 조금 추가를 해야 할 것 같다. 나는 &quot;클래스는 설계도, 인스턴스는 그 설계도를 바탕으로 만든 객체&quot; 라고 정리를 했는데, 비슷한 뉘앙스지만, 오늘 강의를 듣고 인스턴스에 &quot;설계도를 실체화 함으로써  상태 를 가지게 한 것&quot; 이라는 설명을 추가해야 할 것 같다. 학습 로그 오후에는 브라운이 학습 로그를 소개하는 시간을 가졌다. 뭐랄까 계속 개발을 공부하다가 글쓰기에 관련된 내용을 들으니, 뭐랄까 대학교 전공 사이에 들어있는 교양 수업 같은 느낌이었다. 핵심은 &quot;메타인지 향상을 위해 학습 기록을 남기고 학습 로드맵을 그려보자&quot; 라는 주제였다. 여기서 잠깐 메타인지가 뭔데? 하는 소리가 나올 수 있어서 메타인지에 대해 짚어보면, 메타인지는 메타인지(meta認知, 영어: metacognition) 또는 상위인지는 자신의 인지 과정에 대해 관찰 · 발견 · 통제 · 판단하는 정신 작용으로 &quot;인식에 대한 인식&quot;,&quot;생각에 대한 생각&quot;,&quot;다른 사람의 의식에 대해 의식&quot;, 그리고 고차원의 생각하는 기술(higher-order thinking skills)이다. (출처: 위키백과) 라고 한다. 한 마디로 정리하자면, 자신의 생각에 대해 판단하는 능력이라고 할 수 있다. 브라운은 내가 무엇을 알고 무엇이 부족한지 알 수 있어서 메타인지가 중요하다고 이야기했다. 어제 우리 데일리 미팅 조의 크루들이 모여서 코딩하면서 서로 궁금했던 부분에 대해 토론한 부분이 메타인지 능력을 향상시키는 활동이라고 볼 수 있을 것 같다. 우테코에서는 메타인지 능력 향상을 위해 학습로그 작성을 한다. 그런데 각자 블로그에 학습로그를 남기라고 할 줄 알았는데 아예 학습로그 작성을 위한 플랫폼이 있어서 놀랐다. 확실히 우테코는 단순히 코딩 스킬을 향상시는 것만 중요하게 생각하지 않고, 개발자 자신의 성장을 위해 다양한 활동을 중요시 한다는 생각이 들었다. 학습로그 작성은 매일 해도 좋고, 한 미션이 끝난 이후에 회고를 하면서 적어도 좋다고 하는데, 나는 매일은 무리인 것 같고(회고는 매일 쓰고 있지만...) 그렇다고 한 미션이 끝난 이후에 작성하기에는 학습한 내용을 바로바로 적지 않아서 까먹는 부분이 있을 것 같아서 미션 중간 중간에 새로운 내용이나 피드백을 받았을 때 정리하는 차원에서 작성하면 좋다고 생각한다. 예를 들면 오늘 내가 @ParameterizedTest에 대해 정리한 글을 작성한 것처럼. 확실히 글로 정리하는 것이 좋은게, 더 깊이있는 학습을 할 수 있고 머릿속에 더 오래 남길 수 있는 것 같다. @ParameterizedTest로 예시를 들어보면, 관련된 포스트를 작성하기 전에는 TDD 강의때의 예시 코드처럼 @CsvSource에 무조건 delimiter를 지정해서 사용했었다. 그렇게 사용해도 크게 문제가 없었고, default delimiter가 지정되어 있다는 사실을 몰랐기 때문이다. 그런데 @ParameterizedTest에 대해 포스팅을 하기 위해 더 찾아보니, 애초에 @CsvSource의 Csv가 Comma Sperated Value로, 기본적으로 delmiter를 지정하지 않아도 콤마를 기준으로 값을 분리해서 테스트 한다는 사실을 알게 되었다. 덤으로 문자열을 구분자로 쓰는 delimiterString이 있다는 사실도. 이런식으로 글로 정리하고 넘어가기 위해 더 깊게 알아보고 공부를 하는 장점이 있다고 생각한다. 이런 식으로 공부한 내용은 그냥 주입된 내용보다 조금 더 기억에 오래 가지 않을까? 그리고 또 하나 장점이 있을 것 같은게, 내가 몰랐던 부분에 대해 모아보기 쉬울 것 같다. 보통 어떤 내용에 대해 궁금해서 찾아보더라도, 나중에 가면 까먹어서 다시 찾아봐야 하는 상황이 발생하기 쉬운데, 플랫폼이 어떻든 학습 로그로 정리해두면 결국 내 블로그에서 모아볼 수 있기 때문에 필요한 내용을 좀 더 쉽게 찾을 수 있겠다는 생각이 든다. 결론은, 학습 로그 열심히 써야겠다. 이 User 클래스는 이름이 공백이거나 10자를 넘어가면 IllegalArgumentException을 throw 하도록 하는 규칙을 가지고 있다. 이 검증 과정을 모두 테스트하려면 어떻게 해야 할까? 세 경우 모두 기본 로직 자체는 User 객체를 생성하고, 그 과정에서 IllegalArgumetException을 던지는지를 검증하는 과정인데, 같은 로직임에도 불구하고 테스트가 세 가지나 생겨버렸다. 만약 이름의 규칙이 더 늘어난다면 어떨까? 규칙이 늘어날 때 마다 새로 테스트 메소드를 작성해줘야 할 것이다.  규칙이 많아지는 경우 뿐 아니라 단순히 테스트하고 싶은 값이 많을 경우를 생각해보자. (이런 식으로 극단적으로 테스트 하는 개발자는 없겠지만 예시니 그 부분은 넘어가자.) assertThat을 10줄이나 작성해야 한다. 이런 코드가 과연 좋은 테스트 코드일 수 있을까? @ParameterizedTest JUnit에는 이렇게 여러 개의 테스트를 한번에 작성하기 위한 @ParameterizedTest 라는 어노테이션을 제공한다. 기본적인 사용 방법은 @Test 대신 @ParameterizedTest라는 어노테이션을 사용하는 것 외에는 동일하다. 이 때 파라미터로 넘겨줄 값들을 지정해주어야 하는데, 이 역시 어노테이션을 사용해서 테스트에 주입해줄 수 있다. @ValueSource byte, short, int, long, float, double, char, boolean String, Class @CsvSource @ValueSource 로는 하나의 인수만 전달할 수 있고, 해당 인수에 따른 결과 값을 테스트할 수 없다. 다음의 코드를 보자. 여기서 두 테스트는 모든 로직과 사용하는 메소드가 같다. 단지 테스트하고자 하는 값과 기대하는 결과값이 다를 뿐이다. 이 경우에 위에서 알아본 @ValueSource만으로는 테스트가 불가능하다. 이럴 때 @CsvSource를 사용할 수 있다. 이런 식으로 작성해주면 input에 따라 expected 값이 다르게 나오는 케이스를 여러 개 테스트할 수 있다. value에 값들을 넣어주는데, 이 때 &quot;{input},{expected}&quot; 의 형태로 구분자가 있는 문자열을 입력해주어야 한다. 기본 구분자는 콤마(&#39;,&#39;)인데, 이는 CSV(Comma Sperated Value)라는 이름을 생각해보면 쉽게 이해할 수 있다. 물론 value 다음에 delimiter 값을 직접 정의해서 넣어줘서 커스텀 구분자를 사용할 수도 있다. 단 이 때 주의할 것은 delimiter 값은 String이 아닌 char 값이기 때문에 반드시 단일 문자를 넣어주어야 한다는 점이다. 만약 String을 넣어주고 싶다면 와 같이 delimiterString 값을 지정해서 넣어주면 된다. @NullSource, @EmptySource, @NullAndEmptySource @NullSource는 테스트 메소드에 인수로 null을, @EmptySource는 빈 값을, @NullAndEmptySource는 null과 빈 값을 모두 주입한다. 이 때, 원시 값(위의 byte ~ boolean) 에는 null 값이 들어갈 수 없으므로 메소드의 인수가 원시 값이라면 @NullScore, @NullAndEmptySource는 사용이 불가능하다. @NullSource @EmptySource를 모두 사용한 것과 @NullAndEmptySource는 같다. @ValueSource와 같이 사용이 가능하다. @EnumSource INCLUDE, EXCLUDE, MATCH_ALL, MATCH_ANY 표로 정리하면 다음과 같다. 인수 종류 타입 설명 value Class&lt; ? extends Enum&lt;?&gt;&gt; 테스트 할 Enum class를 넣는다. Optional이기 때문에 지정하지 않을 경우 메소드에 인수로 선언된 Enum이 들어간다. names String mode에서 검색에 쓸 문자열 또는 정규식 mode Mode INCLUDE: names.contains(name) (name과 일치하는 모든 Enum 값) // default EXCLUDE: !names.contains(name)) (name을 제외한 모든 Enum 값) MATCH_ANY: patterns.stream().anyMatch(name::matches) (조건을 하나라도 만족하는 Enum 값) MATCH_ANY:patterns.stream().allMatch(name::matches) (조건을 모두 만족하는 Enum 값) @MethodSource 여태까지 위에서 보았던 source들은 분명 유용하지만, 복잡한 object를 전달하는 것이 불가능하다. 이 때 method를 인수로 전달해주면 복잡한 인수를 전달할 수 있다. 백문이 불여일견, 일단 기본 사용 예제를 보고 넘어가자. provideStringsForIsBlank() 라는 메소드를 정의한 뒤, 이 메소드를 @MethodSource를 이용하여 테스트 메소드에 넘겨주는 기본 예제다. 위 예제를 보면서 @MethodSource의 기본 규칙에 대해 알아보자. @MethodSource에 작성하는 메소드 이름은 인수로 제공하려는 메소드 이름과 같아야 한다. 인수로 제공하려는 메소드는 static이어야 한다. 단, @TestInstance(Lifecycle.PER_CLASS)를 사용하여 클래스 단위 생성주기일 경우 인스턴스 메소드 제공이 가능하다. @MethodSource에 메소드 이름을 작성해주지 않을 경우 JUnit이 테스트 메소드 네임과 같은 메소드를 찾아서 인수로 제공한다. 만약 테스트 호출 당 하나의 인수만 제공하고자 한다면 Arguments로 추상화 할 필요는 없다. private static Stream   정리 @ParameterizedTest를 이용하면 여러 개의 테스트 케이스를 사용할 수 있다. @ValueSource: 한 개의 인수 입력 시 사용 @CsvSource: 한 개의 인수와 해당 인수를 넣었을 때의 결과값 입력 시 사용 @NullSource, @EmptySource, @NullOrEmptySource: null 또는 공백값에 대한 테스트 시 사용 @EnumSource: Enum 값에 대한 테스트 시 사용 @MethodSource: 테스트에 복잡한 인수를 제공하고자 할 때 메소드를 만들어서 사용   우테코 크루들과 서로의 테크 블로그를 공유하다 보니, 대체로 티스토리와 velog, 이 두 가지 플랫폼을 사용하고 있었다. 일반적으로 티스토리를 많이 사용하기는 하지만, velog의 마크다운 방식의 에디터도 매력있고, 심플한 디자인이 맘에 들기도 한다. 그리고 국내 개발자들이 많이 사용하는 만큼 양질의 자료도 계속 올라오는 편이다. 그리고 가장 결정적으로 티스토리보다 좋다고 느낀건 오늘 / 이번 주 / 이번 달 / 올해 의 트렌딩 게시물을 모아서 볼 수 있다는 점이다. 뭐랄까 약간 유튜브 알고리즘처럼 찾아보려고 하지 않았는데 다양한 양질의 글을 읽을 수 있는 점이 최고의 장점이라고 생각한다. 하지만 velog를 사용하면서 티스토리와 비교되는 결정적인 단점이 보였는데... 그건 바로 구독 기능이 없다는 것이다. 최근 핫한 게시물을 읽어보는 것도 물론 좋지만, 특정인에 대한 구독 기능이 없어서 얻는 단점이 많다. 물론 게시물에 대한 좋아요 기능이 있어서 좋아요를 누르면 읽기 목록에 등록되며, 브라우저의 북마크에 특정인의 velog를 추가해서 유사 구독 기능으로 이용할 수는 있지만, 타 블로그의 구독 기능처럼 누가 어떤 글을 올렸는지 일일히 찾아봐야 한다는 단점이 있다. 그래서 velog로 구독 기능을 사용할 수는 없을까 하고 찾아보다가 feedly를 이용하여 velog를 구독할 수 있는 방법을 찾게 되었다. feedly가 뭔데? feedly는 rss 리더다. rss 리더가 뭐냐고 물을 당신을 위해 지식의 보고(?) 나무위키에 적힌 설명을 가져왔다. (나무위키 꺼라.) RSS는 어떤 사이트에 새로운 콘텐츠가 올라왔을 때 해당 사이트에 방문하지 않고, RSS서비스를 통해 리더 한 곳에서 그 콘텐츠를 이용하기 위한 방법이다. 쉽게 생각하면, 여러 언론사 사이트를 모두 방문할 필요 없이 다양한 기사를 네이버뉴스 한 곳에서 볼 수 있는 것과 같다고 보면 된다. feedly로 velog rss 구독하기 우선 feedly( https://feedly.com/)로  들어가서 로그인을 진행해주자. 참고로 소셜 로그인도 가능하며, 나는 google 소셜 로그인을 진행했다. 애플을 사용하시는 분들은 애플 계정 로그인도 가능하다. 가운데에 보면 Search by topic, website or RSS link라고 쓰여진 입력칸이 있는데, 여기서 관심있는 주제를 찾아볼 수도 있고, 우리가 지금 할 RSS 링크를 통한 구독도 할 수 있다. 입력칸에 구독하고 싶은 velog의 api 주소를 입력해 주면 된다. 링크는 다음과 같다.  https://api.velog.io/rss/@velog이름 https://v2.velog.io/rss/velog이름  도 가능하다! 예를 들어 내 velog를 구독하고 싶다면 ( https://api.velog.io/rss/@ohzzi)를  입력하면 된다. 입력 후 엔터를 눌러주면   이렇게 velog 정보가 뜨고 follow 버튼을 눌러서 구독할 수 있다!   이렇게 velog 라는 새로운 폴더를 만들어서 구독을 추가해 보자. 이제 feedly 홈으로 돌아가보면,   짜잔! 정상적으로 구독이 된 것을 볼 수 있다. 이제부터는 로그인하고 나면 기본적으로 나의 구독 페이지로 이동되며, 구독한 velog의 게시물들이 다른 블로그의 구독 시스템처럼 뜨게 된다. 구독하고 싶은 velog들을 번거롭게 일일이 북마크에 등록하거나 검색하지 말고, feedly 또는 다른 rss 리더를 이용하여 간편하게 구독해보자. 북마크에는 feedly만 등록해두면 끝! 아! 참고로 velog api 주소를 입력하는 곳에 티스토리 주소를 입력하면 해당 티스토리에 대한 rss 구독도 가능하다! velog를 주로 쓰는 사람이 티스토리를 구독하고 싶을 때 사용하면 좋을 것 같다.   우테코 첫 주말을 보내고, 벌써 월요일이 되었다. 짧은 주말은 꿀맛같은 휴식을 주면서도, 코드리뷰와 개인 공부로 헛되이 보낼 수는 없던 주말이었다. 코드리뷰 지적받은 부분들 제이가 의견을 제시해준 모든 부분에 대해서 작성하고 넘어가기에는 적을 내용이 많을 것 같아서, 핵심적이고 생각이 드는 부분만 짚고 넘어가기로 하자.   사실 이 부분은 자동차 경주 미션은 아니고, 그 전에 TDD 연습으로 내준 문자열 계산기 미션 부분이어서 잘 생각하지 않고 넘어갔다. 피드백을 받고 생각해보니 이렇게 assertThat()을 여러 번 사용하는 것이 아니라 다른 테스트 방법을 적용하는 것이 훨씬 간단하게 테스트를 할 수 있었다. @ParameterizedTest를 이용한 방법으로 수정. 확실히 전에는 그냥 @Test 어노테이션 쓰고 assertThat이나 assertThatThrownBy를 무한정 남발해서 썼었는데, 테스트하는 가짓수가 적을 때는 모르겠지만 많아지면 정말 보기 어려운 코드가 된다. 이번에 TDD 공부하면서 @ParameterizedTest를 배웠는데, 중복되는 테스트 코드 제거도 쉽고 훨씬 직관적인 테스트를 짤 수 있다는 장접이 있다.   왜 이 부분을 아무 생각 없이 넘어갔을까? 아마 어차피 랜덤 값의 최대 최소 boundary로 주는 값이니까 MIN, MAX로 해도 되겠지 라는 생각이었던 것 같다. 하지만 다시 생각해보니 그냥 봐서는 이 값이 랜덤 값의 최대 최소인지, 아니면 다른 어떤 값의 최대 최소인지를 전혀 알 수 없을 것 같다. 게다가 제이의 피드백대로, 이 상수들이 Cars에서 관리되는 것도 적절하지 않은 것 같다. 생각해보면 0~9 사이의 랜덤값을 생성하는 규칙은 게임 전체에서 관리되어야 하지 Car의 일급 컬렉션인 Cars가 가지기에는 조금 부적절한 것 같아서 Controller로 옮겨주었다. 그리고 상수 이름도 더 직관적이도록 바꿔주었다. 기존에 랜덤 값을 생성하는 util 클래스로 RandomGenerator 라는 클래스를 만들어서 사용했었는데, 상수 값을 조정하는 김에 랜덤 값을 만드는 로직도 리팩토링 하기로 했다. 역시 제이의 피드백과 관련된 내용도 있었다.   그렇다 난 바보다... 물론 내가 짠 프로덕션 코드에서는 min값이 max 값보다 커서 예외가 발생하는 일은 없겠지만, 코드가 더 커지거나 다른 사람들과의 협업 과정에서 잘못된 값이 들어갈 가능성을 배제할 수 없다. 그래서 자잘한 수정을 한 컨트롤러 부분과는 다르게 랜덤 값 클래스는 뜯어고쳤다. 기존의 인자값인 min, max를 lowerBound, upperBound로 바꿔주었고, 해당 값을 generateNumber() 메소드 호출시에 인자로 받던 기존의 코드와는 다르게 필드로 만들어 주었다. 이 값들이 필드로 있으니 클래스 이름 자체도 RandomNumberGenerator로 바꾸어주었다. 그리고 정적 팩토리 메소드 패턴을 적용했다. 여기서는 확실히 정적 팩토리 메소드를 쓰는 이득이 더 크다고 생각했는데, RandomNumberGenerator 생성시에 인자로 들어가는 값이 어떤 값인지 한눈에 알아보기 위해서 생성하는 메소드의 이름을 fromBounds()로 해주기 위함이다. 정적 팩토리 메소드를 쓰는 김에 lowerBound &gt; upperBound 일 때 둘을 바꿔주는 로직도 추가했다. 그리고 컨트롤러에서 관리하는 게임 규칙인 랜덤 값 범위 상수를 가지고 RandomNumberGenerator를 만들어준 뒤 Cars.moveAll() 메소드에 인자로 전달해주었다. 이렇게 되면 Cars 에서는 와 같이 인자로 받은 RandomNumberGenerator에서 generate()만 호출해서 사용할 수 있다.   나와 연로그는 getter의 사용을 최대한 지양하기 위해 어차피 정보를 넘겨주는 목적이 콘솔 출력을 위함이므로 toString()을 오버라이딩해서 아예 출력을 위한 문자열로 바꾸는 작업을 해주었다. 그런데 제이의 &quot;출력해주는 view가 console이 아니면?&quot; 이라는 질문에 말문이 턱 막혔다. 사실 toString() 재정의로 view에 넘겨주면서도 이게 약간 편법 아닐까? 라는 생각을 하기는 했는데, 피드백을 보고 나니 확실히 콘솔 출력이 아닐 때(예를 들면 JSON으로 넘겨준다든가)를 위한 정리가 필요해보였다. 결국 Car와 Cars에서 데이터를 view로 보내주고, view에서 getter로 꺼내서 출력 형태를 만들어야 할 것 같았다. 하지만 애초에 getter를 지양했던 가장 큰 이유가 setter 뿐 아니라 getter로도 데이터의 불변성이 보장되지 않는다는 점 때문이었기 때문에 고민이 많았다. 이런 코드가 있을 때 bar가 final로 선언됐으니까 불변 객체가 아니냐고 생각할 수 있겠지만, 레퍼런스 참조를 하기 때문에 다른 클래스에서 getter로 꺼내온 뒤에 리스트에 값을 추가하거나 수정할 수 있다. 그래서 Car를 getter로 꺼내서 넘겨줘도 데이터의 불변성을 보장할 수 있도록 하는 방법을 생각하던 도중 Spring으로 프로젝트를 진행할 때 Entity를 다른 계층으로 전달할 때 Entity 자체를 넘겨주지 않고 DTO로 만들어서 넘겨주던 것이 생각났다. 어찌됐던 Car 객체의 정보가 오염되지 않도록 하면 되는 부분이기 때문에, 새롭게 DTO 클래스인 CarStatus 클래스를 만들어서 넘겨주기로 했다. 이 때, Name과 Position 모두 객체 검증 등을 할 필요가 없이 DTO를 넘겨받은 view에서 원시 값만 필요하므로 원시값으로 만들어주었다. 여기서 봉착한 또 하나의 문제는, 컨트롤러에서 view로 자동차들의 정보를 넘겨줄 때, DTO로 사용하지만 List로 묶어서 주기 때문에 final로 선언해주더라도 역시 불변이 아니라는 점이 있다. 그래서 찾아보던 도중 새로운 원소의 삽입, 기존 원소의 수정, 삭제를 방지하는 Collections.unmodifiableList 자료구조에 대해 알게 되어 해당 자료구조를 적용하였다. 이렇게 해서 view에서 CarStatus의 리스트를 순회하면서 getter로 DTO를 꺼내서 출력 가능한 형태로 만들어주었다. 두 번째 코드 리뷰에서 제이가 어떤 의견을 낼 지는 모르겠지만, 개인적으로는 불변성도 지키면서 코드도 깔끔하게 짠 것 같아서 만족스러웠다. 기타 몇가지 자잘한 수정을 남기고 오후 1시 반 경 데일리 미팅이 끝나고 두 번째 코드 리뷰 요청을 했다. 팀 브라운의 코딩 토론회?? 데일리 미팅에서 조원들끼리 첫 미션을 하면서 잘 몰랐거나 궁금했던 부분에 대해 의견을 나누어보는 시간을 가졌으면 좋겠다는 이야기가 나왔다. 그래서 오후 4시! 시간이 맞는 팀원들이 다시 게더타운에 모여서 이런저런 이야기를 나누는 시간을 가졌다. 후니, 후디, 써머, 엘리, 로마, 어썸오, 루키가 참여해주었고, 코치님인 브라운도 잠깐 들러서 이런저런 이야기를 해 주었다. 브라운이 강조하신 부분은 이렇게 모여서 이야기하면서 메타인지능력을 기르는 것이 매우 중요하다는 것! 첫 번째 얘기 주제는 후디가 다른 사람들의 의견을 듣기 위해 제기한 Random 값 테스트를 어떻게 했느냐는 주제였다. 이번 자동차 경주 미션에서 랜덤 값을 가지고 자동차의 전진 / 정지를 결정하는 부분에 대한 단위 테스트를 이야기했다. 조원들의 주된 의견을 정리하자면 랜덤 값을 테스트하는 것은 사실상 불가능하다. Car에서 랜덤 값이 필요한 부분은 전진 / 정지를 결정하는 부분이다. 따라서 해당 메소드가 (랜덤이든 아니든) 값을 인자로 받도록 하고 그 값에 따라 전진 / 정지를 결정하는 것이 맞다. 전진 / 정지 메소드가 단위 테스트에 고정 값을 넣어서 통과하면 상관없다. 그 외에도 내가 사용했던 RandomNumberGenerator와 같은 객체를 인터페이스 구현 방식으로 만들어서 실제 프로덕션 코드에서는 랜덤 값을 만드는 구현체를 사용하고 테스트 코드에서는 고정 값을 만드는 구현체를 사용하는 방법도 나왔다. 이 방법은 후니가 제시해주었는데, 상속과 의존성 주입을 통해서 랜덤 값이 들어가는 로직을 테스트하고 결과적으로 단위 테스트 뿐 아니라 전체 테스트도 구현할 수 있다는 장점이 있었다. (내가 코드를 짠 방식은 로직 안에 이미 랜덤이 들어가 있으므로 어플리케이션 테스트는 돌아가기 힘들었다.) https://steadyjay.tistory.com/6 확실히 이 부분에서 느낀게, 다양한 방법을 찾아보고 익히는 크루들이 많다는 점이었다. 학교 프로젝트를 할때는 그래도 나름 깔끔하게 코드를 짜는 편이고 이런 저런 디자인 패턴도 잘 쓰는 편이었던 내가 우테코 세계에서는 모코코...?   그 다음으로 나온 주제가 테스트를 위한 오버로딩은 허용되어야 하는가? 라는 주제였다.   &quot;프로덕션 코드에서 사용하지 않는 메소드를 순전히 테스트 코드를 위해 사용하는 것이 허용되어야 하는가?&quot; 가 핵심이었다. 예를 들어 대부분의 크루들이 Car 객체를 생성할 때 생성자에서 name을 인자로 받아서 초기화하고 position 값은 0으로 초기화해서 생성해주는데, 이 경우에 setter를 지양하다보니 setter로 position 값을 따로 바꿔줄 수 없다. 그래서 테스트를 진행할 때 0이 아닌 position이 값이 필요한 경우 생성자 오버로딩을 통해 position 값도 인자로 받는 생성자를 만들어서 테스트에만 사용하는 방식이다. 이 때 브라운도 게더타운에 함께 있어서 브라운이 한번 팀원들끼리 토론해보자며 정답은 없지만 다음 세 가지 중 본인의 의견을 가지고 토론해보자고 하였다. 실제 사용되는 코드가 아니라면 메소드 오버로딩도, 생성자 오버로딩도 안된다. 메소드 오버로딩은 안되지만 예외적으로 생성자 오버로딩은 된다. 둘 다 된다. 여기서 나는 1번의 의견이었고, 3번을 고른 크루들은 없었지만 2번을 고른 크루들은 몇 명 있었다. 토론 끝에 결론은 1번이 나오긴 했다. 내가 1번의 의견을 앞장서서 말한 편이었기 때문에 내 생각을 말하자면(앞에서 정답은 없다고 했지만)   물론 내 의견이 절대 정답은 아니다. 앞서 랜덤 테스트를 위해 테스트 상황에서만 필요한 구현체를 만들어 준 것 처럼 오버로딩을 통해 테스트를 해 주는 것도 좋은 방법이 될 수 있다. 하지만 개인적인 생각으로는, 오용의 문제도 있고 코드 가독성을 해칠 것 같아서 반대하는 입장이다. 내가 제시한 주제도 있었는데, getter의 사용을 어디까지 허용해야 하는가? 라는 주제였다. 이 부분이 크루들마다 각기 다른 부분이었다. 나처럼 getter의 사용을 극도로 지양하는 사람도 있었던 반면, 어떤 크루는 view에 객체를 전달할때는 어차피 getter를 쓸 수 밖에 없다는 입장도 있었고(나도 리뷰를 받고 나서는 view에 던지는 용도로는 getter를 사용한다.) 따로 제약 없이 필요하다고 생각하면 getter로 꺼내 쓰는 크루도 있었다. 이 역시 정답이 있는 것은 아니고 개개인의 차이인 것 같은데, 역시 그래서 나는 getter를 최대한 안쓰고 싶다. getter에 대한 이야기와 getter로 꺼낸  final 객체의 불변성을 말하던 와중에 내가 코드리뷰 이후 리팩토링에서 썼던 Collections.unmodifiableList 자료구조에 대한 이야기도 나왔다. 이 구조를 모르는 크루원들도 있었던 것 같은데 유용하게 쓰기를 바란다! 어느 정도 학술적인 얘기가 끝나고 나서부터는 서로의 이야기를 하면서 아이스 브레이킹 타임을 가졌다. 로마가 거의 메인 MC급의 진행 능력을 보여줘서, 팀원들끼리 어색함 없이 이야기를 나눌 수 있었던 것 같다. 어디 사는지부터 해서 서로의 취미, 자취하는 사람들의 요리 얘기, 맥북과 관련된 얘기까지 온갖 얘기가 다 오고갔다. 데일리 미팅의 제일 아쉬웠던 점이 길어야 30분 정도로 짧다는 점이었는데, 이렇게 충분한 시간동안 이야기를 나누니까 훨씬 친해지고 다양한 얘기도 오갈 수 있어서 좋았다. 그리고 무엇보다 좋았던건, 다양한 사람들의 코드 짜는 방식을 보고 좋은 점은 습득하면서 이야기를 나눌 수 있다는 점이었다. 학교 다니는 동안은 경험하기 힘들었던 대화였는데, 확실히 우테코의 최고의 장점이라고 볼 수 있는 것 같다. 이제 내일쯤이면 아마 2차 코드 리뷰가 올 텐데, PR이 merge 될 수도 있고 추가적인 피드백이 올 수도 있다. merge가 되고 나면 step2로 넘어가게 될 텐데, 강의로 들을 내용을 슬쩍 보니까 MVC 패턴 구현에 대한 이야기였다. MVC 패턴을 이미 적용한다고 적용한 코드지만, 패턴에 대해 확실하게 이해하지 못한 만큼, merge 이후 step2 리팩토링 시간이 기대된다.   화요일부터 시작한 우테코가 어느새 벌써 4일차. 오전에는 강의가 있고, 오후에는 페어 프로그래밍을 마무리하고 최종적으로 1차 PR을 마무리하는 시간이 있었다. 금요일에는 포수타(포비의 수다 타임...? 뭐 그런 이름이었던 것 같은데...)가 있다고 했지만, 첫 주는 페어 프로그래밍을 할 시간이 적었으므로 오늘은 포수타가 아닌 페어 프로그래밍 마무리를 하는 시간을 주는 듯 했다. TDD 강의 데일리 미팅이 끝나고 10시 반부터는 네오의 TDD(Test Driven Development: 테스트 주도 개발) 강의가 있었다. 강의는 한시간 반 정도 진행됐는데, 사실 TDD 자체가 그냥 키워드로 아 그런게 있구나 하고 듣기만 했지 학생 때 한 번도 해본 적이 없었던 개발 방식이었어서 생소했다. 그나마 학교 프로젝트나 토이 프로젝트를 할 때 테스트 코드를 꼬박꼬박 쓰기는 했던 것 같은데, TDD는 단순히 테스트 코드를 쓴다고 TDD인 것이 아니었다. TDD 자체를 깊게 설명하자면 워낙 길 것 같아서, 이 부분은 따로 강의 녹화본을 돌려보면서 정리 하려고 하고, 간단하게 설명하자면 실패하는 테스트 코드를 먼저 작성하고 그 테스트코드가 성공하도록 프로덕션 코드를 작성하는 방식이라고 할 수 있을 것 같다. 즉, 내가 기존에 개발하던 방식이   설계 -&gt; 프로덕션 코드 작성 -&gt; 테스트 코드 작성 -&gt; 테스트 실행 -&gt; 프로덕션 코드 리팩토링   의 과정을 거쳤다면, TDD 방법론을 채택하면   의 과정을 거치게 된다고 볼 수 있다. 나는 여태까지 내가 의도한 프로덕션 코드의 동작과 값을 테스트하는 용도로 테스트 코드를 사용했었는데, 그게 아니라 설계에 맞는 테스트 코드를 작성해서 테스트 실패를 하고(당연히 프로덕션 코드가 없으니까 처음에는 테스트 실패) 테스트 코드가 일단 성공하도록 프로덕션 코드를 작성해나간 뒤 모든 테스트가 성공하면 프로덕션 코드를 리팩토링 한다는 점에서 달랐다. 페어 프로그래밍을 하면서도 최대한 TDD 방법론을 채택해보려고 했는데, 사실 초반부에 작은 도메인 단위에서는 그럭저럭 잘 해나간 것 같은데 조금만 규모가 커지거나 코드가 복잡해져도 프로덕션 코드 없이 어떻게 테스트를 작성해야 할 지 막막했다. 아직은 프로덕션 코드를 바탕으로 테스트를 작성하는 것이 익숙해서 테스트 코드를 바탕으로 프로덕션 코드를 작성한다는 사고 방식이 장착되지 않은 탓이랴. 요즘 굉장히 핫한 방법론이기도 하고, 첫 강의부터 소개할 정도로 우테코에서도 중요하게 여기고 있는 듯 하니 녹화본을 다시 보면서 손에 익을 수 있도록 정리하는 시간을 가질 필요가 있을 듯 싶다. 첫 번째 페어 프로그래밍 끝! 오후에는 연로그와의 페어 프로그래밍을 마무리지었다. 프로덕션 코드의 로직을 크게 변경한 부분은 없었고, 어제 페어 프로그래밍을 마치고 서로 개인적으로 생각해 본 부분들과 오전에 TDD 강의를 들으면서 생각난 부분들을 가지고 이야기를 나누어보았다. 내가 어제 코드를 보면서 제일 신경쓰였던 부분은, 다른 validate 메소드들은 void 형으로 검증에 실패했을 때 IllegalArgumentException을 던지는 형태였다면, Cars 클래스의 validateDuplicatedName 메소드는 로 boolean 값을 던져서 상위 메소드에서 그 boolean 값을 가지고 처리를 해준다는 점이었다. 초반에 코드를 짤 때는 검증 시에 boolean 값을 던지도록 작성을 했다가 리팩토링을 미처 하지 못하고 넘어간 부분이었는데, 코드의 일관성을 위해서 이 부분을 수정해야 한다는 생각이 들었고 연로그도 동의해서 다음과 같이 수정했다. 그 외에 수정한 부분으로는, 우승자를 구할 때 참가자들 중 가장 먼 거리를 이동한 참가자의 위치를 구하는 getMaxPosition() 메소드를 수정했다. 원래 코드는 였는데, 인스턴스 변수인 max를 쓰지 않고 구할 수는 없을까 생각해 보다가 stream 메소드 중에 max() 메소드가 생각나서 연로그에게 스트림을 사용하는 방식으로 바꿔보자고 물어보았다. 고려할 부분은 max()가 Optional을 반환한다는 점인데, 나는 어차피 최소한 0 값이라도 나올테니까 예외 처리에 의미가 없다고 생각해서 get()을 그냥 쓰거나 orElseThrow()에 인자를 집어넣지 않고 쓰는게 어떨까 라고 했는데, 연로그가 그러면 그냥 orElse()로 0을 반환하는 것이 어떻겠냐는 의견을 제시해서 결과적으로는 다음과 같은 코드가 되었다. 정리하고 나니까 훨씬 깔끔한 코드가 되었다고 생각한다. 그 뒤로 몇 가지 의견을 더 나누어 보았으나, 딱히 리팩토링 할만한 부분은 없다고 생각해서 페어를 끝내고, 각자 담당 리뷰어 분께 Pull Request를 요청하고 리뷰를 요청했다. (3일동안 페어 하느라 수고 많았습니다 연로그!) 이제 자동차 레이싱 미션의 남은 기간은 페어가 아닌 나 혼자서 리뷰어분께 코드 리뷰 요청을 하고 피드백을 받아서 수정하는 과정을 반복하게 된다. 팀 프로젝트 - 보이는 라디오 어느정도 휴식을 취한 이후에, 저녁 8시 반이 되어서 zoom으로 보이는 라디오 15조 회의를 가졌다. 첫 회의때는 컨셉, 주제, 시놉시스만 정했기 때문에 이번 회의에서는 대본을 쓰고 역할을 나누는 과정을 거쳤다. 우리 조는 올바른 협업에 대한 자세 라는 주제를 정했고, 주제를 녹여내기 위한 컨셉으로는 한 때 유튜브에서 컬트적인 인기를 끌었던 &quot;가짜사나이&quot; 컨셉을 채용하기로 결정했다. 아무래도 관련된 밈이나 명대사가 많은 만큼 여러가지 조건을 만족하기 좋겠다는 판단에서였다. (그런데 컨셉 제안을 내가 해서 그런지는 몰라도 내가 가짜사나이에서의 이근 대위 역할을 맡게 됐다...) 마침 작년인가 재작년인가 블라인드에 누가 가짜사나이를 패러디한 가짜개발자 라는 유머글을 올렸어서, 거기서 대사를 몇 개 따와서 우리 아이디어와 섞었다. 처음엔 시나리오를 잘 쓸 수 있을까 걱정했는데, 막상 8명이 모여서 시나리오를 쓰고 보니까 꽤나 웃긴 시나리오가 나왔다. (당일날 다른 크루들이 잘 웃어줘야 할텐데...) 시나리오 관련해서 봉착했던 난관은 4 5분이라는 시간 제한이었다. 처음에 4 5분이라는 제한 시간을 들었을 때 &#39;5분은 너무 짧지 않나?&#39; 라는 생각을 했었는데, 정작 시나리오를 쓰고, 역할을 정한 뒤 대본 리딩을 하고 나니까 최소 시간인 4분에 한참 모자랐다. 아무리 배경 바꾸고 하는 데 시간이 소요된다고 해도 분량이 모자라서 결국 시나리오에 대사를 추가해서 해결했다. 그 과정에서 크루들의 온갖 드립이 나와서 원없이 웃은 것 같다. 대본 리딩에서의 웃참 실패는 덤이랄까. 배경까지 맞춰가면서 연습했는데, 솔직히 뭐랄까... 킹받는다. 그래도 뭔가 좋은 결과물이 나올 것 같고, 연습만으로도 재밌는 회의였다. 회의가 끝나고는 팀원들이 다들 안자고 새벽 1시까지 수다를 떠느라 시간 가는 줄을 몰랐다. 다른 팀들은 6인인데 우리 팀은 8인이어서, 현재 거리두기 제한인 6인에 걸려서 실제로는 만나지 못한다는 점을 다들 아쉬워했다. 그래서 결국 (내 주도로) 다음주에 랜선 술자리를 가지기로 결정. 미팅을 마무리지었다. 우테코 첫 주말 이제 우테코 첫 주말이다. 아마 주말이지만 쉬지는 못할 듯 하다. 코드 리뷰 답변이 오면 그에 맞춰서 리팩토링을 고민해보고, 코드를 수정해야 하기 때문이다. 음, 주말까지 공부했던 적이 언제인지는 모르겠는데, 어쨌든 주말에도 공부를 할 생각을 하니 막막하기도 하면서 한편으로는 열심히 사는 것 같아서 기분은 좋다.   페어 프로그래밍 - 자동차 경주 완성 오늘은 따로 강의나 팀 활동이 없는 날이어서, 아침에 게더타운을 이용한 데일리 미팅을 진행한 뒤에 연로그와 어제하던 페어 프로그래밍을 이어서 계속할 수 있었다. 어제 자동차 도메인인 Car 클래스에서 자기 자신의 이름과 위치를 나타내도록 출력할 때 쓰일 toString() 메소드를 재정의 하는 부분까지 완료했고, 지금 당장 Car 클래스에서 사용할 로직은 모두 구현했다고 생각했기 때문에 다음 단계로 넘어가기로 했다. 아침 열시 반부터 진행된 페어 프로그래밍은 중간에 한 번의 점심 시간과 잠깐의 쉬는 시간을 거쳐 오후 네 시가 되어서 끝났다. 사실 오늘 저녁 넘어서 까지도 작업을 하는 것을 예상했는데, 페어와 합이 잘 맞는지 생각보다 더 일찍 끝났다. 손댈 곳이 없는 완벽한 코드는 아니었고, 100% 만족스러운 코드도 아니었지만 리팩토링까지 마무리하고 나서 나와 연로그가 지금 알고 있는 지식 내에서 더 리팩토링할 만한 부분은 찾지 못했기 때문에 마감 시한 전까지 더 리팩토링할 부분이 있는지 생각해보기로 하고 작업을 마무리지었다. 프로덕션 코드를 작성하고 리팩토링하는 과정에서 엄청 다양한 디자인 패턴이나 스킬들을 사용한 것은 아니지만, 앞으로도 유용하게 쓰일 만 하고 작성하면서도 만족스러웠던 부분을 몇가지 정리해보려고 한다. 일급 컬렉션의 사용 자동차 클래스인 Car 클래스를 만들었지만, 자동차 경주에 참여하는 자동차가 여러 대인 만큼 자동차들의 목록을 관리해주는 것이 필요했다. 그냥 단순히 생각하기에는 Car 클래스를 List에 담아서 관리하는 것을 생각할 수 있었는데, 이렇게 되면 여러 대의 자동차에 명령을 내려줘야 하는 로직들, 예를 들면 모든 자동차들에게 랜덤 값을 주어서 전진 또는 정지를 결정하는 로직 등이 Car 클래스로 내려가거나 더 위의 Controller나 Service단(계층을 이렇게 나누었을 경우)에서 처리되게 되는 단점이 있어서 좋지 못한 방법이라고 생각했다. 여러 대의 자동차들을 처리하는 방법에서 나와 연로그는 쉽게 의견 일치를 보았는데, 이전에 프리코스에서 자동차 경주 미션을 진행했을 때 둘 다 일급 컬렉션을 사용해서 이 부분을 해결했기 때문이었다. 그래서 이번 미션에서도 Car의 리스트를 wrapping한 클래스 Cars를 추가하기로 결정했다.  Car에 일급 컬렉션을 적용한 부분을 살펴보자면, 와 같이 Car들을 감싼 일급 컬렉션 객체 Cars를 만들어주었다. 우선 이름 규칙에 대해서 짚고 넘어가야 하는데, 이번 미션에 주어진 이름 규칙은   였고, 자체적으로 생각하기로는 중복된 이름이나 공백을 가진 이름이 있어서는 안된다는 생각이 들어서 해당 규칙들도 추가했다. 여기서 각각의 자동차에 적용되는 이름 규칙인 5자 이하의 이름, 공백으로 된 이름을 검증하는 로직은 Car에서 구현해서 검증에 실패할 경우 IllegalArgumentException을 던지도록 작성했다. 그런데 자동차 이름이 중복되었는지 검증하는 로직은 Car에서는 불가능하다. 어떤 한 Car 객체가 생성될 때 해당 객체에서 다른 자동차들의 이름을 알아낼 수는 없기 때문이다. 따라서 중복을 체크하는 로직을 Cars에서 처리하도록 했다. 만약 Cars로 래핑하지 않았다면, 중복을 체크하는 로직은 컨트롤러에 들어있었을텐데, 래핑을 해서 관련된 비즈니스 로직을 여기서 처리하면서 더 좋은 코드가 되었다. 그리고 자동차 리스트를 Cars로 래핑하면서, 불변한 객체로 만들었다는 장점도 있다. 만약 와 같이 컨트롤러의 멤버 변수로 리스트가 들어있었다고 가정하자. 이 경우에 cars가 final로 되어 있어서 불변한 것이 아니냐 라고 생각할 수 있는데, final은 재할당만 막아줄 뿐이지 해당 멤버 변수 내의 값이 변화하는 것을 막을 수 없다. 당장 cars.add() 메소드가 먹히기 때문이다. 그런데 Cars 클래스로 래핑해주게 되면, Cars 클래스 내에는 최초 객체 생성 시점 이후에 리스트에 자동차를 추가 / 제거 하는 로직이 없기 때문에, 컨트롤러에서 자동차 리스트를 수정하지 못하도록 할 수 있다. 도메인 세분화 - 원시 값을 객체로 분리 이번 미션 레이싱 게임에서는 참가자들의 이름을 입력받은 뒤, 게임을 실행할 시행 횟수를 입력받고 해당 횟수만큼 게임을 진행한 뒤에 우승자를 가린다. 처음에는 시도 횟수만큼 controller가 게임을 진행해야 하기 때문에, 횟수 값을 int 값으로 controller에 멤버 변수로 넣어주었다. 그런데 이 경우에 문제가 생겼던 것이, 시도 횟수 값으로 올바르지 않은 값(예를 들어 문자가 들어오거나 음수가 들어왔을 때)이 들어왔을 때 처리를 하는 로직이 controller나 view에 들어간다는 점이었다. 올바르지 않은 값을 view에서 처리하는 것은 정말 좋지 않은 방법이라고 생각했고, 마찬가지로 controller 단에서는 도메인에서 발생시킨 예외를 처리하는 로직만 있어야지 직접 예외를 발생시켜서 처리하는 로직이 있어서는 안된다고 생각했다. 그러다보니 내가 연로그에게 아예 시도 횟수도 Cars 처럼 래핑해서 분리하는 것이 어떻겠냐는 의견을 냈고, 연로그가 조금 생각해보더니 흔쾌히 동의해서 시도 횟수를 다음과 같이 클래스로 분리하게 되었다. 이렇게 해주니 유효성을 검증하는 로직도 도메인에서 관리할 수 있게 되었고, 앞서 Cars 클래스를 사용할 때 처럼 시도 횟수 값이 새로운 인스턴스를 생성하지 않는 한 불변으로 유지된다는 장점도 생겼다.  시도 횟수를 TryCount로 래핑하고 나니까, Car 클래스에 멤버 변수로 들어있는 name과 position에 대해서도 같은 방법을 적용하면 좋겠다는 생각이 들었다. 처음 클래스를 만들었을 때 Car 클래스는 String name 값과 int position 멤버 변수를 가지고 있었다. 그래서 인스턴스가 생성되는 타이밍에 생성자에 인자로 받은 값을 name으로 할당하고, position 값을 초기 위치인 0으로 초기화 해주는 과정을 거쳤다. name과 position을 분리하게 되면, 각각의 검증 과정을 분리한 클래스에 일임하고 Car 클래스는 생성시에 입력받은 이름을 가지고 이름 인스턴스를 생성하고, 위치 역시 인스턴스를 생성해서 멤버 변수에 할당해주기만 하면 된다. 또한, position을 증가 시키는 비즈니스 로직을 직접 처리하지 않고 위치 객체에 &quot;한 칸 전진해라&quot; 라는 메시지만 주고, position 값을 건드리지 않게 된다. 이렇게 분리하고 봤더니 이름의 유효성을 검사하는 로직이 Name 클래스에 들어가게 되어서 도메인의 책임도 조금 더 명확해지는 것 같고(기존에는 Car 클래스에서 이름의 유효성 검증의 책임을 가졌는데, 생각해보니 Car클래스지 Name 클래스가 아닌데 생성 시 유효성 검증에 대한 책임을 진다는 점이 이상했다!) 코드 자체도 더 깔끔해진 것 같았다. 그리고 원래 Car 클래스에서 이름 유효성을 검사할 때는 validateName()이라는 하나의 메소드로 공백 검사와 길이 검사를 모두 했는데, 연로그의 의견대로 공백을 검사하는 메소드 따로, 길이를 검사하는 메소드를 validate() 메소드의 하위 메소드로 분리했다. 분리하고 나니까 각각의 검증 메소드가 의미하는 바가 조금 더 명확해지고, 클린한 코드가 된 것 같다. 자동차의 위치 또한 마찬가지었다. Position 이라는 클래스를 새로 작성해주고, Car의 인스턴스가 생성될 때 마다 새 Position 객체를 생성해서 멤버 변수로 할당되도록 해주었다. move()에 관한 부분에서 나와 연로그의 의견이 다른 부분이 있었는데, 처음 내가 Position 클래스를 작성할 때는 random한 값을 인자로 받아서 값이 전진 혹은 정지를 결정하는 기준에 해당하는지 판단하는 로직을 Position에 넣어주었던 반면, 연로그는 애초에 Car에서 기준에 해당하는지 판단한 후에, 전진해야 하는 경우면 Postion.move()를 호출해 주는 것이 맞는 것 같다는 의견을 냈다. 생각해본 결과 위치 값은 그냥 계속 증가만 시켜주면 되는 건데 전진 여부를 판단하는 로직이 Position에 들어있도록 작성한 것은 내 판단미스라는 생각이 들어서 연로그의 의견을 따라 수정했다. 아, 그리고 미션 규칙에는 매 차례마다 랜덤 값이 기준을 만족하면 한 칸씩 전진하도록 하라고 되어 있어서 처음에는 move() 메소드가 인자를 받지 않고 멤버 변수 값을 1씩 증가시키는 코드를 짰는데, 이 부분 역시 연로그가 만약 전진하는 칸 수가 달라져도 적용하기 쉽도록 전진하는 값을 애초에 인자로 받아서 그만큼 전진시키자는 의견을 내서 적용하였다. 최종적으로는 Car 객체가 다음과 같이 훨씬 깔끔하게 리팩토링되었다. 3일차 페어 프로그래밍 후기 어느 정도 적응되고 나니까 불편한 점은 크게 없고 좋은 점만 가득했다. 불편한 점이라면 인텔리제이의 Code With Me 플러그인이 온갖 버그로 말을 듣지 않아서 고생했다는 점 정도...? 어제 회고에서 이미 페어 프로그래밍의 장점들을 여럿 언급 했기 때문에 그 부분에 대한 언급은 넘어가고, 페어 프로그래밍을 진행하면서 특히나 좋았던 점 하나를 꼽자면 실수가 줄어든다는 점인 것 같다. 단순히 오타나 import 실수 같은 부분만을 말하는 것이 아니다. 예를 들어 앞서 말했듯이 Position 클래스에 전진 여부를 판단하는 로직이 포함되도록 하는 등 비효율적이거나 납득되지 않는 코드를 작성하는 것도 어느 정도 방지해 줄 수 있다. 덕분에 프리코스 때보다 훨씬 빠른 시간에 더 좋은 코드를 작성할 수 있었다. 페어랑 의견 차이가 심하거나 성격이 안맞고 했으면 힘든 부분도 있었을텐데 그런 점이 정말 하나도 없어서 좋았던 것은 덤이다. 어제는 5분씩, 오늘은 10분씩 드라이버와 내비게이터를 바꿔가면서 페어 프로그래밍을 진행했는데 매번 5분, 10분이 진짜 빠르게 지나갔고, 그러다보니 어느새 한 시간 두 시간이 훌쩍 지나가 있었을 정도로 몰입해서 코딩을 할 수 있었다. 페어를 이뤄서 좋은 합을 보여줬던 연로그에게 감사할 따름! 개인적으로 반성할 부분은 정적 팩토리 메소드를 적용해보고 싶어서 얘기를 했었는데 연로그의 &quot;그런데 여기에 그 패턴을 적용하면 어떤 이점이 있는거에요?&quot; 라는 물음에 말문이 턱 막혔던 점이다. 내가 어떤 패턴의 장단점에 대해 잘 고민하지 않고 그냥 남들이 좋다고 하니까 써야지 하는 생각을 가지고 있었던 것 같다. 메소드 하나를 분리할 때에도 그 행위로 인해 얻는 이점과 잃게되는 부분을 고민해봐야겠다는 생각이 들었다. 그리고 내일은 자동차 경주 미션에 대한 첫번째 코드리뷰가 있는데, 내 눈에는 보이지 않았지만 리뷰어들의 눈에는 얼마나 많은 리팩토링할 부분이 보일지, 그를 통해 얼마나 많은 것을 얻어갈 수 있을지 기대된다.  작성한 코드 링크 여담으로 기존에는 잠실에 있는 루터회관에서 백엔드와 프론트엔드 모두 진행했다고 들었는데, 이번 4기는 프론트엔드는 그대로 루터회관에서, 백엔드는 선릉에 새롭게 마련된 캠퍼스에서 진행된다고 한다. 개인적으로 살짝 아쉬운 점은 나에게 많은 도움을 주었던 선배가 우아한형제들에서 일하고 있어서 백엔드가 루터회관을 사용했다면 오랜만에 같이 점심 먹으면서 이런 저런 얘기를 나누기 쉬웠을거라는 정도? 그리고 2월의 모든 과정이 코로나 상황으로 인해 비대면으로 진행된다는 점도 아쉬웠다. 아무리 원격 시스템이 잘 되어있다고 하지만, 사람과 면대면으로 소통하는 것 만은 못한데다 집에만 갇혀 있는 것이 답답하게 느껴질 것 같다. Level 1 앞으로 4월 초까지 약 9주간 Level 1 과정을 진행하게 된다는 이야기를 들었다. 일정표를 살펴보니, Level 1 과정의 앞쪽은 프리코스에서 했던 과제들을 페어 프로그래밍, 리뷰어들의 코드 리뷰와 같은 과정을 거치면서 다시 해 보고, 중반부터는 새로운 미션을 진행하면서 프로그래밍 능력을 향상시키는 과정이었다. 과제의 내용 자체는 어렵지 않은 것 같은데, 기존에 익숙하지 않았던 페어 프로그래밍이나 코드 리뷰와 함께 진행해나가야 한다는 점이 신선했다. 특히 코드 리뷰는 그렇다 치고, 페어 프로그래밍이 굉장히 색다르게 다가왔는데, 페어 프로그래밍에 대한 설명을 듣고 코치인 준과 공원이 하는 페어 프로그래밍 예시를 보면서 기존에 내가 대학에서 팀 프로젝트를 하면서 했던 것은 그저 분업이지 전혀 협업이 아님을 깨달았다! 페어 프로그래밍 기존에 협업이랍시고 내가 진행했던 프로그래밍은 각자 파트를 나눠서 해당 부분에 대한 코드를 각자 짜오고, 충돌하는 부분을 모여서 조율하면서 하나의 프로그램으로 만드는 방식이었다. 나는 이 방식도 충분한 협업이라고 생각했는데, 페어 프로그래밍에 대한 설명과 예시를 듣고 나니 전혀 아니었다. 우테코에서 진행하는 페어 프로그래밍은 2인 이상의 팀원이 하나의 페어를 이루어서 코딩을 진행하는데, 하나의 컴퓨터에서 페어가 함께 프로그래밍을 진행한다. 코드를 작성하는 사람이 드라이버(Driver), 다른 한 사람(또는 3인 이상일 때는 그 이상)이 내비게이터(Navigator)의 역할을 맡아서 작업을 진행한다. 그리고 작업을 진행하면서 페어간에 역할을 수시로 변경하는 것이 핵심이었다. 나는 같은 백엔드 크루중에 &#39;연로그&#39;(우테코에서는 서로간에 닉네임을 사용한다)와 페어가 되었다. 처음에 페어가 되고 나서 서로 깃허브부터 팔로우 했는데, 연말부터 잔디가 무성히 자라 있는걸 보니 프리코스 이후로 커밋을 하나도 하지 않은 내가 부끄러워졌다... 페어를 이루고 처음에는 함께 코딩을 할 환경을 세팅하는 것이 먼저였는데, 그나마 다행인 것은 나나 연로그나 맥 유저가 아닌 윈도우 유저였기 때문에 OS의 차이에서 오는 불편함은 없다는 점이었다. 다만, 대면으로 페어 프로그래밍을 했다면 원격 관련된 세팅을 할 필요가 없었을 텐데, 비대면으로 하게 되면서 처음 써보는 IntelliJ의 code with me 플러그인을 설정하느라 조금 애를 먹었었다. 페어 프로그래밍은 신기했다. 개인적으로 내가 내 자신의 코딩 스타일중에 개선해야 할 부분이라고 생각했던 것이 작업을 시작할 때 생각을 구체화 하기 보다는 추상적으로 떠올린 아이디어만으로 일단 코드부터 작성하고 본다는 점이었는데, 페어 프로그래밍을 하면서는 무작정 타이핑 하는 것이 아니라 서로 간에 의견을 공유하면서 상대의 동의를 구한 뒤에 코딩을 시작하는 점에서 나에게 꼭 필요한 브레이크가 되는 느낌이었다. 그리고 비록 하루밖에 하지 않았지만 페어 프로그래밍을 하면서 좋았던 점이, 시야와 사고의 폭이 넓어진다는 점이었다. 서로 코드를 짜면서 놓치는 부분들을 지적해 줄 수 있었고, 각자 프로그램 구조를 만들거나 코드를 작성하는 방식이 다른데 서로의 방법을 비교하면서 더 좋은 쪽을 취사 선택할 수 있다는 점이 굉장한 장점으로 느껴졌다. 아직은 익숙하지 않아서 이런 장점이 더 극대화되지 못한 것 같지만, 몇번 더 진행하다 보면 더 좋은 시너지가 날거라고 생각한다. 물론 페어로 프로그래밍 하다가 싸우거나 하는 일은 없어야겠지. (연로그는 어떻게 생각할지는 모르겠지만) 어쨌든 한나절간의 짧은 페어 프로그래밍은 성공적이었던 것 같다. Level 1의 첫 번째 과제로 Junit을 이용한 단위 테스트 학습, 문자열 덧셈 계산기를 통한 TDD/리팩토링 학습, 프리코스때 해봤던 자동차 경주 게임 구현 이라는 과제가 나왔는데, 나와 연로그는 빠르게 문자열 덧셈 계산기 까지 완료하고 자동차 경주 게임을 구현하기 시작한 상태로 하루를 마무리했다. 생각보다 빠른 속도로 진행이 되고 있는 것 같아서 만족스럽다. 3일차 생각 내일은 따로 수업은 없는 것 같은데 아마 페어 프로그래밍을 위주로 진행하지 않을까 싶다. 금요일까지 과제를 완성해야 하기 때문에 조금 더 효율을 높여서 진행하고, 리팩토링 과정에서 오늘 내가 생각해 본 몇가지 패턴들에 대해서 연로그와 이야기를 나누어 보는 것이 좋을 것 같다. 그리고 페어 프로그래밍을 아무래도 처음 해보는 데다가, 그동안 대학교에서 진행했던 모든 프로젝트에서 내가 팀장을 맡아서 이끌어 왔기 때문에 뭔가 주도적으로 하려는 습관이 배어 있어서 혹여나 페어를 배려하지 않는 코딩을 할 수도 있겠다는 생각이 들었다. 그러지 않도록 생각하고, 또 생각하면서 작업을 진행해야겠다.   괄호 회전하기 문제 설명 다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다. (), [], {} 는 모두 올바른 괄호 문자열입니다. 만약 A가 올바른 괄호 문자열이라면, (A), [A], {A} 도 올바른 괄호 문자열입니다. 예를 들어, [] 가 올바른 괄호 문자열이므로, ([]) 도 올바른 괄호 문자열입니다. 만약 A, B가 올바른 괄호 문자열이라면, AB 도 올바른 괄호 문자열입니다. 예를 들어, {} 와 ([]) 가 올바른 괄호 문자열이므로, {}([]) 도 올바른 괄호 문자열입니다. 대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 s가 매개변수로 주어집니다. 이 s를 왼쪽으로 x (0 ≤ x &lt; (s의 길이)) 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 1,000 이하입니다. 입출력 예 s result &quot;  {}&quot; 3 &quot;}]()[{&quot; 2 &quot;[)(]&quot; 0 &quot;}}}&quot; 0 나의 풀이 아직 알고리즘 문제 풀이가 익숙하지 않은지라 처음에 문제를 딱 봤을때는 어떤 방식으로 풀어야 할 지 감이 안왔다. 생각해 보았을 때, 우선은 주어진 문자열이 올바른 괄호 문자열인지를 판별하는 것이 먼저라는 생각이 들었다. 올바른 괄호 문자열인지 판별하는 방법 자체는 의외로 간단하다고 생각했다. 괄호에는 여는 괄호( &#39;(&#39; , &#39;[&#39; , &#39;{&#39; ) 와 닫는 괄호( &#39;)&#39; , &#39;]&#39; , &#39;}&#39; )가 있는데, 닫는 괄호가 나왔을 때 앞에 나온 괄호들이 제대로 닫혀 있는지를 판단하면 된다고 생각했다. 이 과정을 for 문을 이용하여 주어진 문자열의 모든 문자에 대해서 판단을 하고, 모든 문자에 대해 테스트를 통과하면 answer 값을 1 올려주는 풀이를 생각했다. 그런데 아직 파이썬에 익숙하지 않은 탓인지, 테스트를 모두 통과했을 때 answer 값을 1 올려주는 것 보다 테스트를 통과하지 못했을 때 answer 값을 1씩 빼 주는 것이 낫겠다는 생각을 했다. (어차피 for ~ else 문을 사용하면 두 풀이에 큰 차이가 없는데 왜 그랬는지 잘 모르겠다.) 최종적으로 작성한 코드는 다음과 같다. 회전을 0회전부터 len(s)-1회전까지 len(s)번 만큼 하기 때문에, answer의 최댓값은 모든 회전에서 올바른 괄호 문자열이 되는 len(s)다. 그리고 문자열로 제공된 s값은 풀이의 편의성을 위해 collections의 deque를 import 해서 덱으로 만들어주었다 딕셔너리를 사용했는데, 매 번 if 문으로 &#39;)&#39;, &#39;]&#39;, &#39;}&#39;를 판별하기가 귀찮았기 때문이다. 매 번 if 문을 사용하기 보다 그냥 딕셔너리에 key와 value로 여는 괄호와 닫는 괄호 쌍을 저장하면 편하게 찾을 수 있겠다는 생각이 들어서, 괄호들을 저장할 딕셔너리 bracket은 닫는 괄호들을 key로, 여는 괄호들을 value로 저장해 주었다. 회전을 0회전부터 len(s)-1 회전까지 하기 때문에 매 회전마다 올바른 괄호 문자열을 판별하기 위한 len(s) 범위의 for문을 작성했다. 이 때 for의 인덱스를 사용할 필요가 없으므로 _로 대체해 주었다. for 문의 맨 처음 시작때는 characters 라는 리스트를 초기화 해 주었는데, 일종의 스택으로 사용하기 위한 리스트로 만들어주었다. 이 characters 리스트 안에는 문자열을 순회하면서 나오는 문자들을 저장해 줄 것이다. 그 후 다시 for 문을 작성해 주었는데, 해당 for 문은 문자열의 모든 문자들을 순회하면서 올바른 괄호 문자열인지 판별해주는 for 문으로 작성했다. 우선 순회하는 문자 c가 bracket에 들어있는지, 즉 닫는 괄호인지를 판단한다. 전술했듯이, 올바른 괄호 문자열인지는 여는 괄호보다 닫는 괄호를 기준으로 판정해야 하기 때문이다. 처음에는 if bracket[c] in characters: 로 characters 리스트 안에 닫는 괄호에 알맞게 해당하는 여는 괄호가 들어있는지를 기준으로 판정을 하고, 들어 있으면 그 값을 remove 해주고 들어있지 않으면 answer 값을 하나 줄여준 뒤 break로 빠져나갔었다. 그런데 이렇게 할 경우 14번 케이스가 실패했는데, 생각해보니 &quot;({)&quot; 같은 케이스, 즉 정상적으로 열고 닫는 괄호 안에 여는 괄호만 존재하는 케이스를 잡아낼 수 없었다. 그래서 생각을 다시 해 보았는데, 생각해보니 너무나도 간단한 문제였다. 올바른 괄호 문자열이려면 반드시 괄호들로 둘러쌓인 맨 안쪽은 같은 짝의 괄호들로 이루어져야 한다는 사실을 망각하고 있던 것이었다! 즉 순서대로 진행한다고 생각했을 때, 리스트의 맨 바깥쪽, 스택으로 치자면 top 값이 현재의 닫는 괄호 값과 짝을 이루면 통과하고, 만약 짝을 이루지 않는다면 올바른 괄호 문자열일 수가 없으니 for 문을 탈출하면 되는 것이었다. 이 때, characters 리스트의 -1번째 인덱스로 접근해야 하므로 빈 리스트가 아니라는 조건을 함께 넣어 주었다. (이 조건을 넣지 않을 경우 빈 리스트에서 조건문을 체크할 시 런타임 에러가 발생한다.) 따라서 if characters and characters[-1] == bracket[c]: 가 조건이 되고, 이 조건이 만족하면 characters 리스트에서 pop()으로 짝이 맞는 맨 바깥쪽 괄호를 제거해주었다. 만약 c가 bracket에 없다면(딕셔너리에 in을 사용하면 key 값을 기준으로 찾는다) 여는 괄호이므로 characters에 append 해준다. for문을 모두 통과하면 마지막으로 한가지 조건을 더 판단해주어야 하는데, 바로 characters에 문자가 남아 있는지 여부다. 이는 &#39;((({}&#39;나 &#39;(({}(&#39; 같이 완전한 괄호들이 제거된 이후에 왼쪽 괄호들만 남아있는(오른쪽 괄호만 있는 경우는 이미 앞선 조건문들에서 걸러지므로) 경우를 체크한다. 이 때, 이미 앞선 for 문에서 answer 값이 감소된 경우에 중복해서 체크하지 않도록 for ~ else 문을 사용해 주었다. 이 과정이 각 회전 당 올바른 괄호 문자열 판별이므로, 뒤에 deque의 rotate기능을 사용해서 s.rotate(-1)로 왼쪽으로 1회전 시켜주고 맨 바깥쪽 for 문의 다음 순회로 넘어가도록 했다. 채점 결과  웩! 낰! 꽉찢쭈느! 햄보칼수가업서?! 시작하기 전에  &quot;오타 수정&quot; 저도 아래 작업을 하며 오타 수정에 대한 PR을 정말 많이 보냈었습니다.   서문 안녕하세요,  지상 최강의 개발자 쥬니니 거울이 없음 제가 일하는 Belivvr는  Mozilla Hubs 거울 이 없는 것 입니다.    거울이 있었는데요? 아니 없어요 그냥 거울에 대한 질문의 히스토리 거울에 대해서는 물어보는 사람도 많았지만 대답은 아래와 같았습니다.   &quot;카메라를 꺼내서 거울 대신 쓰시면 돼요.&quot;  아... 정말 오픈소스 스러운 대답이다(?);; 직접 만든 거울    뭐야 내 머리 돌려줘요 &quot;님들, 제가 거울 만들었는데 저 왜 머리가 없어요? 도움&quot;    피들스틱: &quot;난 뇌가 없어... 너도 곧 그렇게 될거야&quot; &quot;내가 여러번 해봤는데 다른 사람 머리는 볼 수 있어도 자기 자신의 머리는 볼 수 없음&quot;  &quot;쥬니니님이 그러는데, 이 거울에 자기 얼굴이 보이는 사람은 귀신이래&quot; 한글화가 안되있음   그래서 직접 만들어서 PR을 올려버렸습니다.       그리고 새 피쳐의 발표에 제 이름이 걸려서 감사 인사와 함께 올라갔습니다.    두유노 대박? 그와중에 북한사람도 있는건가 ㄷㄷ 그리고 다시 거울  겨울 아님   지금은 개발되어 새 피쳐의 발표에 제 이름과 함께 올라갔습니다. 어케함? 위에 있던  &quot;카메라를 거울 대신 쓰세요&quot; 눈이 따라가는 속도보다 더 빨리 머리가 깜빡거려서 마치 있는 것 처럼 보이게 하는 그...  머리가 깜빡거리는게 보인다고요? 모니터도 그걸 표현해주지 않는데 뇌파로 보고계신가요?;; 그래서 거울에도 그걸 반복하게 했더니 머리가 나타났습니다.       오픈소스 컨트리뷰트에 대한 생각 좋아요와 구독 돈쭐 내주는  것 또한 컨트리뷰트 입니다. 그러니 오픈소스를 열심히 이용해주시고 많은 커뮤니케이션을 해주세요.  쥬니니님, 오늘 배당된 이력서인데요. ❗Caution 이 글은 빌리버와 관계 없이  저의 개인적인 의견 임을 밝힙니다. 면접관으로써의 요령? 면접관이 처음은 아니지만, 이렇게나 많은 이력서를 받아보고 많은 면접을 진행해보기는 처음이었습니다. 이력서만 보고 알 수 있는게 너무 적다   당연히 너무 힘들었고 곧 다른 방법들을 고민하게 됩니다. 코딩테스트냐 사전 질문이냐 그것이 문제로다 &quot;적어도 이 정도의 문제를 해결할 수 있는 능력을 지닌 사람과 면접을 진행하고 싶습니다.&quot; 라는 강한 의지일 것입니다.    비둘기가 효율적으로 비행하도록 코드를 작성하시오 지상 최강의 개발자 라고 말할 수 있을 만큼 유능하기 때문에 코딩테스트가 아닌 다른 방법을 쓰고 싶었습니다.    이... 이것이 쥬니니 엔진!... 압도되어버려! 그래서 고민끝에 사전 질문을 만들어 지원자들에게 이메일로 발송하자는 의견을 냈고, 면접에 참여하시는 분들과 함께 질문 리스트를 만들어 지원자에게 발송하게 됩니다. 사전 질문의 장점   각각의 질문에는 이유가 있었기에, 답변만 받아도 마치 면접을 본 것 처럼 더 풍부한 판단의 지표가 되어주었습니다. 지원자들에게 조언 회사는 일을 하는 곳입니다 종종  &quot;배우고 싶습니다&quot;  &quot;배우고 싶습니다&quot;  는 썩 좋은 선택이 아닐 수 있습니다. 자신감을 챙겨오세요   제 경험상 자신감이 넘치는 넘치는 사람은 두 가지 부류입니다. 사기꾼 진짜 실력이 있는 사람 그러니 그만큼 실력을 키워야겠죠. 양복 입지 마세요 이건 진짜 지극히 개인적인 의견이에요. 개발자는 양복입고 일하는 직업이 아니니 그냥 편하게 입고 면접 보세요.     경력직을 뽑아도 자신 있으면 넣어보세요 왠지 이 정도면 나도 하겠는데?  싶으면 넣어보세요. 이건 진짜 보여주고 싶다 하는건 강조하세요 끝으로  그게 뭐야 골치아파 그냥 사진찍어줘 ㄷㄷ 대체 뭔소리야? GLTF? GLB?  Blender glTF Viewer 에서 보시면 됩니다. 그래서 뭘 하려는거야? 여우 glb는  https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/Fox/glTF-Binary  에서 받았습니다.         이런 화면이 나옵니다.  나무? W   A   S   D 아, 말만 들어도 너무 어렵다. 이런거 왜 해요?     그래서 좌표값은 어떻게 구함? 아래 코드를 쓰면 얻을 수 있습니다.   오 쩐다! 그래서 위에 있는 숫자를 집어넣으면 되나요?   맞습니다. 위 숫자를 카메라의 좌표에 입력하면 유저는 화면이 로딩되자마자 해당 좌표에서 여우를 볼 수 있습니다.   근데 왜 wasd랑 lookControls는 막아요?    W   A   S   D  키는 굳이 막을 필요가 없지만,  lookControls  를 막지 않으면 카메라의  rotation lookControls 이 적용된 상태에서  rotation 에 값을 입력해도  x: 0, y: 0, z: 0 그럼 안막고 하려면 어떻게 해야돼요? 그럼 여우에다가  rotation   국비 &gt; 웹 퍼블리셔 &gt; 백엔드 개발자 &gt; 필요하면 뭐든 다 하는 개발자 &gt; 지상 최강의 개발자 이런 루트를 밟아온 사람이라  jQuery 시대 어둠의 시대   jQuery를 까는 사람은 ES6와 SPA가 나타난 이후에 프론트엔드를 시작하셨을겁니다.  응애 거지같고 아름답지 않고 쓰기도 어려웠던 JavaScript였기 때문이거든요.  let ,  const    아, 그런 문법이 있었는데요? 아뇨 없어요. 없었어요? 아니 없어요!  거지같은 jQuery 시대   &quot;jQuery는 쓸 줄 아는데 JavaScript는 쓸 줄 모른다.&quot; 그리피스?! 빛과 소금  querySelector 를 쓰면 되지 않냐?  fetch 를 쓰면 되지 않냐? 라고 하는 사람이 있겠지만, 앞에서 얘기했듯이  &quot;없었어요.&quot; querySelector fetch  는 IE11 까지도 아예 쓸 수 없습니다.  그리고 베헤리트마냥 버전이 안맞으면 다 제물로 바쳐졌... ES6과 SPA의 등장    내가 알던 그 찐따같던 JavaScript 맞냐? TypeScript는 전설이다... 어? 그런  찐따같던  JavaScript도 Node.JS 가 나타나고, 브라우저에서만 돌아가던  찐따같던 프로그래밍 언어 그 전까진 프로그래밍 언어가 아니라 브라우저 언어였달까 Node.JS 시대 가 시작되며  프론트엔드 개발자     이런 식으로 쓰고싶지도 않고 쓰지도 않았으니까요. 어 느새 부터 jQuery 는 안 멋져   오히려 버전 안맞아서 터지는 jQuery보다 낫지 ES6와 SPA가 나오기 전 까지 암흑같던 JavaScript 생태계를 밝혀준 등불 역할을 잘 해주었습니다.    라이브러리 배포도 멋있는데 테스트 케이스 200개 돌파라니 내가 생각해도 &quot;아... 너무 멋지다.&quot;       그리고  codecov 100%  뱃지 이런 짓을 왜 하는거냐?!    그런거 아님 누가 제 라이브러리를 쓰는데 &quot;아, 라이브러리 버그있어서 못쓰겠네. 라이브러리땜에 코드 터지네&quot; 이런 말을 들으면 안되지 않겠습니까? 코드는 언제 터진다고 생각하나?    독버섯이 들어간 수프를 먹었을 때? 테스트 코드가 그리 좋다는데 왜 많이들 안쓰는데? 1. 몰라서   2. 테스트 코드를 작성하는게 낭비라 생각하는 문화가 있어서   3. 외주라서    이 세상의 모든 외주개발자를 응원합니다. ㅠㅠ 테스트 코드는 어떻게 쓰는데? 언어별로 대표적인 라이브러리들이 있어요. JS/TS: jest, mocha, chai Java: JUnit Go: Gomega 깨알 홍보타임 (코드숨) 테스트 코드를 어떻게 쓰는지 배워보고 싶다면  코드숨 기계인간 이종립 님이라던가 @belivvr/aframe-react 홍보타임 어... 먼저  A-Frame three.js  를 기반으로 작성된 3D나 VR개발을 쉽게 할 수 있게 도와주는 라이브러리 입니다. 위 코드를 작성하면   https://aframe.io/examples/showcase/helloworld/ 그래서 만든 것이  @belivvr/aframe-react  https://okky.kr/article/1135478 코드리뷰를 해야 하는 이유   &#39;새 프로젝트를 처음 시작할 때&#39;  는 못느끼는데, 하루가 지나고 이틀이 지나고 점점 시간이 갈 수록 새로 만든 프로젝트임에도 어제 작성한 코드와의 화합과 그에 의한 유지보수가 필요해져요.  빨리 만든다  !=  프로젝트의 진행 속도가 빠르다   코드리뷰를 통해 품질을 높이면 코드리뷰는 시간이 아깝다 생각하며 과연 뭐가 시간낭비일까요? 좀 더 극단적으로 말하자면, 새로 시작하는 프로젝트인데 어제 작성한 코드가 새로운 코드와 충돌해 문제를 일으켜 수정하느라 많은 시간을 보내는 경우도 있을겁니다. 매일매일요. 소프트웨어 장인   팀장놈이 내 코드를 다 지워버렸다 하지만 저는 굉장히 좋아하는 책입니다. 코드리뷰란?   저는 회사의 깃허브 가이드에 코드리뷰에 관한것도 썼는데 아래 내용입니다.   백명석님의 의견과 저의 생각이 일치하는 부분이라 인상깊어서 언급했습니다. 코드리뷰를 잘 하려면/받으려면     &quot;저자가 바쁘다고 커밋 메시지 대충 쓰고 코멘트 대충 쓰면... 리뷰어가...&quot;   (너무 양이 많아서 못보겠으면 LGTM 짤을 쓰는건 안비밀)    이 부분은... &#39;소프트웨어 장인&#39; 서문? 서문: 팀장놈이 내 코드를 다 지웠다 Github를 안쓰던 시절에는...   이 부분이 꽤나 재밌었는데, SVN을 많이 쓰던 시대에는 꼭 금요일 오후에 불러서 비난 대잔치를 열고 퇴근을 못하게 하는 이상한 문화가 여기저기 있었습니다...ㄷㄷ 깃허브의 Pull Request가 생기면서 이런 꼰대문화가 사라졌죠. 깃허브 만세! 효율적인 PR 방법   커밋 메시지를 의미있게 쓰기 PR 올리기. 설명 쓰기. 테스트 자동화 배포 자동화 코드리뷰를 하는 문화가 정착되지 않는건   &quot;자기가 만든것만 일로 보고 코드리뷰같은 남을 돕는 일은 &#39;낭비&#39; 라고 보는 기업 문화가 있으면 시간이 없다고 느낄 수 있어요.&quot; 시늉 만 하게 돼요.   PR이 Approve되지 않는 상황    정합성에 확신이 없는 상태 &quot;작성하신 코드가 문제를 일으키지 않고 잘 동작할거라는 자신이 있으신가요?&quot; 재미있는(?) 코드리뷰 방법   이 부분을 보면서 장난으로 아래 채팅을 올렸는데    장난이 아닐지도 질문 답변 시간           지상 최강의 개발자 쥬니니가 섬기는 코딩의 신 아샬                츄릅 우리 회사를 소개합니다. • 빌리버는 WebXR 기반의 메타버스 플랫폼을 개발하는 회사입니다. • 빌리버 소개 페이지:  https://about.belivvr.com https://developers.belivvr.com • VR 웹툰 서비스 코믹스브이를 운영하고 있습니다:  https://comixv.com/ko https://classv.school/ko • 현대퓨처넷의 글로벌 메타버스 컨퍼런스 &#39;Coming-M&#39; 의 개발을 담당하였습니다:  https://comingm.io https://m.edaily.co.kr/news/Read?newsId=02404246629246376&amp;mediaCodeNo=257 https://m.edaily.co.kr/news/Read?newsId=02801126629278192&amp;mediaCodeNo=257 주요업무 자격요건 • 지상 최강의 개발자 쥬니니와 같이 일할 기회를 잡고싶은 사람 우대사항 근로조건 전형절차 서류전형 ＞ 1차/임원면접 ＞ 최종합격 유의사항 지원은 여기서 해주세요  원티드 채용 링크 혹은  dev_recurit@belivvr.com  으로 자유로운 형식의 이력서를 보내주세요.  지상 최강의 개발자가 되었구나, 쥬니니 그만두겠다고 말하고, 말하고 또 말하고...   2021년이 시작하고, 나는 매 주 금요일마다  &quot;그만둘게요&quot;   그렇지만 개발자를 새로 뽑기가 너무나 어렵다는걸 잘 알기에 나도 사람이 뽑아질 때 까진 나가지 못하고 있었다. 입원 눈이 많이 내렸던 날 이었다.    산재 급여 먹고 기운내 산재  보험의 혜택을 받았다. 산재 TMI 입원 생활    아, 1인실 가고싶어 퇴사    진짜로 팔 다리 멀쩡한데가 없었다. 길고 긴 휴식기    그렇지만 아직 뉴타입의 능력은 남아있어! 큰 수술   밥은 그래도 혼자 먹었어! 우울증   그 중에 하나가 velog 였다.   그리고 샤갈과 고마덕에 힘든 시기를 버틸 수 있었다. 관심병이니라(?)    짐의 관심병으로 자네들이 관심이 있는지를 살펴 볼 것이야 그리고 velog 메인에 내 글이 계속 오르게 되며  관심의 맛 을 알게 되었다.    관심에 진심이다 섹스 신청서   그렇게 관심을 받던 일들 중 하나가 내 사이드 프로젝트였던  섹스 신청서 (연애를 유튜브로 배워서) 시간날 때 버그만 수정하고 Archive 상태로 만들까 고민중이다. 이 프로젝트로 인해서도 많은 관심을 받게 되었다. 섹스 신청서의 부산물들 섹스 신청서는 단지 관심의 수단만은 아니었다. nextjs-starter-kit ,  rust-serverless-lambda-template  를 만들어 공개했다. 그리고 npm에 라이브러리로 배포하기 위해서는 어떻게 해야하는지도 알아보며  npm-library-template (input, button 같은 것들을 라이브러리 형태로 만들어보려고 시도했었다.) 이것들도 꽤나 많은 관심을 받았고,  nextjs-starter-kit 은 star가 30개, fork가 6개나 찍혔다. 지상 최강의 개발자의 탄생 그 즈음,  육화의 용사  라는 애니를 봤는데   주인공이 별로 지상 최강이 아닌 것 같은데 계속 자신을  지상 최강 그래서 나도 그 때 부터  지상 최강의 개발자 를 자칭하게 됐다.    지상 최강의 개발자(물리,샷건) 수 많은 러브콜    스바라시 제안을 하나 하지, 우리 회사에 오지 않겠는가? 그렇게 관심종자의 삶을 열심히 살아가고 있을 무렵,  PO벨로거WER 그리고 지금 다니고 있는  Belivvr 의 양병석 대표님의 연락도 왔다. 거절은 거절한다 예의상 면접이라도 보러 가야지 하고 갔다가 영업당했다.   새로운 시작 그렇게 새로운 시작을 하게 됐다.    내 연봉도 새로운 시작을 하게 됐다 many 개발팀원 여태 개발팀원이 2~3명인 환경에서만 일해오다가 10명인 환경에서 일하게 되니 모든게 새로웠다. 인정받기   전혀 의도한건 아닌데, 마치 도장깨기 하듯이 한명씩 어려운 일을 처리해주며 인정받았다. 그런 식으로 도움을 주다보니 어느 새 모두에게 인정받고 시니어 포지션이 되었다. 고생했던 보람 클라우드 관리도 하고, 비용 관리도 하고, IDC에 가서 서버 장비도 관리하고, 서비스 관리도 하고, 직접 개발도 하고, 문제 생기면 고치고, 재무 심사땜에 데이터 요청 들어오면 쿼리 날려서 데이터 뽑아주고, 사무실 랜선 문제 생기면 직접 &quot;흰주주흰갈흰...&quot; 해가며 랜선 만들어서 새로 연결해서 꼽아주고, ACL 관리도 하고, 방화벽도 만지고, 보안 관리도 하고, ISMS 심사도 받고... 라고 대답하니 &quot;ㅋㅋㅋㅋㅋㅋ 회사라는 타이틀이 붙었는데 신입한테 그렇게 시키는데가 어딨어요? 거짓말 하지 마세요 ㅋㅋㅋㅋㅋㅋ&quot; 라고 다들 웃었는데   &quot;이렇게 고생한건 나중에 언젠가 돌려받을거에요&quot; 라고 위로해주셨었는데 마치 그게 지금인 것 같다.   기회가 된다면 우리 회사의 CTO로 모시고 싶다. 애인 생김    나와 계약해서 VR 개발자가 되어줘!   지상 최강의 개발자 쥬니니와 함께 빌리버에서 함께하실 개발자를 찾습니다. 어떤 개발자를 찾고있나요?  풀스택오버플로우  고양이   카피 닌자    차가운듯 하면서도 따뜻한  성능충    스탠드술사  꿈이 있는 사람   새로운 드래곤의 유희를 만들어 보실 분    아직 푸시 안했는데  코드리뷰를 주고받으실 분   안전수칙(?)을 잘 지키시는 분    나.카.마.가 이따요!   빌리버는 어떤 회사인가요? 💡  빌리버 소개 페이지 빌리버는 WebXR 기반의 메타버스 플랫폼을 개발하는 회사입니다. VR 웹툰 서비스  코믹스브이 를 운영하고 있습니다. 메타버스 교육 플랫폼 서비스  클래스브이 를 운영하고 있습니다. 최근 개최했던 현대퓨처넷의 글로벌 메타버스 컨퍼런스 &#39;Coming-M&#39; 의 개발을 담당하였습니다.  관련기사 어떤 일을 하나요? WebXR 기술을 이용해 PC, 모바일, VR 헤드셋 모두 호환이 되는 메타버스 플랫폼을 개발하고 있습니다.  A-Frame  을 사용한  Mozilla Hubs  기반의 서비스를 오픈했으며, 현재도 개발중입니다. WebXR은 아직 많은 부분이 미개척지입니다. 서비스를 개발하다보면 필요한 라이브러리가 없어 직접 만들어 오픈소스로 배포하기도 합니다. ex)  @belivvr/aframe-react ,  ttf-to-msdf 많은 사람들이 메타버스 서비스를 쾌적하게 즐길 수 있게 하기 위해 WebRTC, WebSocket을 최적화 합니다. 우리 회사의 서비스를 플랫폼화 하여 이용할 수 있도록 개발중입니다. 우대사항 (or 조건) Babylon.JS, A-Frame 등의 라이브러리를 이용해 WebXR 개발 경험이 있으신 분 WebRTC, WebSocket 개발 경험이 있으신 분 Spring Framework 개발 경험이 있으신 분 오픈소스 컨트리뷰트 경험이 있으신 분 이력서에는 어떤 것이 들어가야 하나요? 경력 간단한 자기소개 github 계정 어필하고 싶은 코드가 담긴 repository 주소 이력서는 어디로 보내나요?  dev_recurit@belivvr.com  로 보내주세요.  그런거 없다! 코드여 터져라! 폭발은 예술이다!    코드가 언제 터진다고 생각하나? 원시적인 방법 하나씩 다 눌러본다. 모든 기능을 다 직접 눌러 점검한다.    하루종일 반복 노가다를 할 수 있어 반복 노가다를 대신 해주는 매크로 테스트 해야 하는 지점까지 반복작업을 해주는 매크로를 작성한다. 코드를 변경할 때 마다 매크로를 켜서 확인한다. 조금은 나은 방법이지만 매크로가 노가다를 대신 해줘도 시간은 비슷하게 소모됩니다. 대신 힘은 덜 들겠죠.    크크, 아무리 해도 끝이 없을거다 무한 분열 발생하는 이벤트마다 프로젝트 단위로 분리하여 거기서 실행하여 테스트 합니다. 대신 이벤트마다 프로젝트를 새로 생성해서 해당 코드를 거기로 복사한 뒤 실행 가능한 상태로 가공하여 테스트 하는건 엄청나게 번거롭고 귀찮을겁니다. 그리고 원본 코드를 바꾸고나면 테스트용 프로젝트쪽에도 복사한 코드를 수동으로 변경해줘야겠죠.    침착하자. 「테스트 코드」를 작성하면서 마음을 가다듬자 「테스트 코드」는 대상과 자기 자신밖에 없는 고독한 코드... 내게 용기을 불어넣어 준다... TDD 테스트 코드를 작성해가며 테스트에 만족하는 코드를 완성시킵니다. 코드를 작성/변경 할 때 마다 자동으로 테스트를 돌려 확인합니다. 테스트 코드는  용기를 불어넣어 준다 그리고 테스트 코드를 작성했다면, 코드를 변경했을 때 어떤 문제가 발생하는지 즉각적으로 알 수 있습니다.   깨알 홍보타임   이 글은  @belivvr/aframe-react  A-Frame  의 모든 레퍼런스와 프로퍼티를 제대로 지원하는 유일한 React 라이브러리 입니다. 없어서 답답하니 제가 쓰려고 만든것도 있지만, VR과 메타버스 개발에 유용한 도구로 활용해주시길 바라며 홍보를 마칩니다. 많은 관심 부탁드립니다. 감사합니다.  풀스택은 죠죠데와 나이! 코노디오다! 풀스택의 새로운 정의 흑마술과 백마술 모두를 능통하게 다루는 사람 을 의미합니다.    다 할 줄 알면 풀스택 이라더니... 샤아! 속였구나! 샤아! 그럼 다 할 줄 아는 사람은? 다 할 줄 아는 것  과  흑마술과 백마술 모두 능통한  건 다릅니다.   흑마술? 그게 뭔데 10덕아 Rust로 Lambda 배포의 즐거움 - 도커에 흑마술을 부려봅시다  에 소개된    그런건 저도 자주 합니다만? 나 그런거 자주 하는데? 흑마술에 대해 쉽게 할 수 있는 오해는 불안하게 젠가 쌓듯이 만드는 꼼수나 어쩌다 되는 그런것들 아니냐 할 수 있는데 흑마술은 그런게 아닙니다. 그리고 그런 흑마술은 일정 수준을 넘는 사람이어야 구사할 수 있습니다. 그래서 결론은  다 할 줄 안다 고  흑마술과 백마술에 능통 흑마술과 백마술에 능통 한 사람은  다 할 줄 알  가능성이 높죠. 흑마술과 백마술 모두에 능통한 사람  입니다.    겜...기르...간...고...그훠...위터! 두개의 힘을 하나로! LGTM 코드를 읽을 시간이 없음 사실은 심적 여유가 없음 Approve만 누르거나 LGTM이라고 써주고 Approve를 누르거나... 앞으론 위의 짤을 LGTM 대신 쓰세요.   -꼰- 나 때는 말이야~ 엉? 깃허브가 어딨어 깃허브가? 그 땐 다 SVN썼다~ 이 말이야~ 코드리뷰 같은게 어딨어? 커밋하고 배포했는데 터지면 다 집합하고 퇴근 못했어~ 요즘 시대 참~ 좋아~ 편하게 일 할라 그래~   욕망의 마리오네트 ```suggestion ... ```suggestion ... ```suggestion ... ```suggestion 블록 바깥에는 글자를 쓰지 않음.   극대노 이거 왜 몰라요? 당연히 알아야 되는건데? 내일까지 공부해오세요. 저번에 알려줬잖아요. 근데 왜 몰라요? 휴우...   무관심 Pull Request를 올리고 코드리뷰를 해달라고 요청했으나 아무도 관심을 가지지 않음 개발팀 메신저에 올려도 아무도 관심을 가지지 않음 다들 주니어라서 코드리뷰라는걸 몰?루 제가 실력이 더 낮은데 어떻게 코드리뷰를 해요? ㅠㅠ   덤 요즘 빌리버에서 제가 밀고있는 코드리뷰 문화    gu rou ta go hangul ul ssu ra nun gun are ni yeah yo 1, 2, 3, _, $... 꽃, 별 이름 등등... 집중력 테스트 코딩 테스트 ???? hangul    오픈소스에 어떻게 기여하는지 몰라 내가 오픈소스가 되었다 네...?  https://github.com/belivvr/ttf-to-msdf https://link.medium.com/exsywIa2plb 이렇게 은근슬쩍 우리 회사 홍보를 그리고  무식하게  번역기 돌려서 모질라허브 디스코드 커뮤니티에 공유했습니다.      아주      잘 들어, 난 말이 아니야. 퍼즐 조각이야! 그것도 어려우면 돈으로 기여할 수...  열린결말 런칭 전 날이 아닌 날들엔 니 잘못이다.   런칭 전 날 오전 10시 에~ 내일이 런칭이니까 이거 이거 이거 봅시다.   오후 2시   오후 4시   오후 6시   오후 8시    얍빠리, 하드모드가 오모시로이하단 말이지 아니야 사토상, 이지모드가 좋다구 ㅠㅠ 오후 10시   0시   새벽 2시 많은 이들이 혼돈을 마주하고 무너지지만, 이 자는 아니다... 오늘만큼은. &quot;역병에 걸린 서버를 안정화 시킬 수 있는 방법이 떠올랐어!&quot;   새벽 3시  이범배! 이범배!   새벽 4시 Employees, Assemble!   새벽 5시   아침 7시 우리들의 서비스는 이제부터 시작이다!  열린결말   진짜 몰라요? 어떻게 알려줘요? 알려줄 수 없어요. 알려준다매요? 그럼 안알려주는거에요? 당하기 전에 알려줘야 안당하죠! 몰라요? 그럼 맞아야지!   여러분 안녕하세요 쥬니니입니다. Joy of Coding 에 오신것을 환영합니다. 항상 하던대로, 오늘도 예쁜 코드를 짜보도록 합시다. 처음 오신 분들도 AWS에 있는 낡은 계정을 꺼내서(?) 꼭 저와 함께 배포를 해보세요. 조금 연습하면 정말로 멋진 배포를 할 수 있게 됩니다. 자 그럼 오늘 필요한 것들은 필요한 것들을 비추는 동안 설명을 시작할거에요. AWS 계정 컴퓨터 고양이   그럼 AWS부터 준비해볼까요?  AWS Console IAM   사용자를 누르고,  보안 자격 증명  을 누를거에요.    엑세스 키 만들기  를 눌러서,  Access Key 와  Access Secret Key  를 만들거에요. 다 하셨으면,  AWS Cli aws configure ap-northeast-2 그 다음은 Rust 프로젝트를 만들어볼거에요.  serverless-aws-rust-multi  라는 프로젝트를 보고 할거에요. 개발자가 도망가도록 키보드를 마구마구 치세요 serverless.yml 을 조금 건드려볼게요  serverless-rust  페이지에 가서  x86_64-unknown-linux-musl 자, 도커에 흑마술을 부려봅시다. 이렇게 하고 아까 넣었던  dockerless 이제 rust 코드를 건드려볼거에요.  world  경로에 있는  main.rs  파일을 보면  lambda_http req를 어떻게 다루는지 볼까요?  Body  를 받고싶으면 이렇게 하면 돼요. 그리고 다음은  url query strings 마음껏 코딩하셨으면 이제 배포를 해볼까요? 우선  serverless.yml  의  region  을  ap-northeast-2  로 할거에요.  npx sls deploy 그 뒤에 이렇게 하면 배포가 될거에요. 빌드가 오래걸리시나요? 그럼 그 동안 저번 시간에   안  나왔던 제 고양이를 소개해드릴게요.       가끔 제가 코딩을 너무 못하면 고양이가 훈수를 두어주기도 합니다. 아, 어느새 배포가 다 되었군요. lambda_http  를 사용한 쪽은 응답이 오고, 안 쓴 쪽은 에러가 날거에요.  rust-serverless-lambda-template   이슈가 올라옴   한날 한시에  같이 죽겠소  비슷한 이슈가 둘 올라왔습니다.    버그를 안고친다고? 무슨 개소리야? 왠지 알아들을 수 있을 것 같아 왈왈왈 왈왈 컹컹 멍멍멍!      버그를 안고친다는 개소리가 길다 일이라도 이렇게 할래?! 이건 제 개인프로젝트이고 틈틈히 시간 날 때 마다 하는 것이기 때문에 이렇게 처리하는겁니다. 우리는 사람이니까  태초에 react-checkbox 라는 라이브러리가 없었다. 그래서 만들어서 배포해보게 되는데... 빰 빰  빰 빰빰빰 빰~ 빰~~ 태초에 react-checkbox 라는 라이브러리가 없었다(?)   어어....   그런데 레포지토리는 지워져서 있었는데요, 없었습니다.(?)   삽질들 로컬 테스트 이렇게 하라매요?  yarn add ../react-checkbox  이런식으로 설치하라매요? 왜 아무 반응이 없는데요? 그래서 yarn pack 이란걸 찾았습니다.  yarn pack  하니  package.tgz yarn add ../react-checkbox/package.tgz   /dist/types.d.ts파일은 모듈이 아닙니다. 자꾸  /dist/types.d.ts 는 모듈이 아닙니다.  라고 나오며 사용은 가능한테 타입 에러가 나서 고민하고 있었습니다.  tsconfig.json types.d.ts  대신  index.d.ts  로 바꿔서 내보내보기도 하고 별의 별 짓을 다 해보았으나 안됩니다. 나중에서야 알았는데 캐싱된 데이터가 남아있어서 그렇습니다...    yarn add ../react-checkbox/package.tgz yarn add /Users/juunini/Desktop/react-checkbox/package.tgz  인간이 언제 죽는지 아나? 로컬에서 안된다고 배포를 안해보려 하다니...    고민하고 있으니 마음속의 대죄주교님이... 근면하게  배포부터 하고 생각해보기로 했습니다.  yarn npm publish --access=public 아까 react-checkbox 가 있었다면서요? 그래서  package.json  의 패키지명을  &quot;name&quot;: &quot;@juunini/react-checkbox&quot; 정작 배포해보니 별거 아니었습니다. 처음부터 굉장하게 태어나는게 있는가 하면, 시작은 미약했지만 점점 성장해서 굉장해지는 것도 있으니까요. 다만, npm에 배포한 뒤 레포지토리를 삭제하는건 도리가 아닙니다.   그게  강호의 도리!  입니다 다른 라이브러리는 어떻게 하나 봤는데  react-query npm 라이브러리 템플릿  을 만들어 보았습니다. &quot;internal&quot;: true  internal  이라는걸 처음 봤는데, 굉장히 신기했습니다. import hydration from &#39; react-query/hydration &#39;;    얘! 너 느 계정에 Organizations가 없다지? 느 집엔 이거 없지? 너 봄 Organizations가 맛있단다(?) 자기 프로필에서 보이는 Organizations Github 프로필에 들어가면 하단 Organizations 탭에 아이콘이 뜹니다.   그런데, 많은 사람들이 Oragnizations가 있었는데요, 없었습니다(?). 시크릿 탭에서 보이는 Organizations   시크릿 탭에서 들어가면 Organizations 라는 탭 자체가 없습니다.     뭐야 내 Organizations 돌려줘요 Organization 에 들어간 후  People  탭을 눌러보시면 아래와 같은 화면이 나옵니다.   저기에  Public  이라는게 보이실텐데, 디폴트값은  Private Private 자랑질 하고싶으면   Public 훈장같고 멋있습니다.   타입스크립트 타입스크립트를 처음 사용해봤다. 유튜브에서 타입스크립트 개념 기초 30분 강의를 듣고, 페어와 함께 필요한 부분을 하나 하나 찾아가면서 사용해보았다. 어려울 줄 알았는데, 생각보다 수월했고, 이렇게 이론보다 실행에 바로 옮기는 공부방법도 효과가 좋다는 것을 느꼈다. 하지만, 결과적으로 이론도 제대로 채워야겠다는 생각이 들어서, &#39;타입스크립트 프로그래밍&#39; 책을 사서 읽기 시작했고, 타입스크립트 플레이그라운드 레벨도 끝까지 다 깨볼 예정이다. MVC 벗어나기 이번 자판기 미션에서는 페어와 함께 패턴에 머무르지 말고, 비즈니스로직과 UI로직만 구분하여 최소한의 적절한 설계만 해보기로 했다. MVC 안 쓰니까 더 편하긴 하다. 그러나 어떤 설계가 좋은 것인지는 아직도 잘 모르겠다. &#39;객체지향의 사실과 오해&#39;라는 책을 읽고 있긴 한데, 이를 코드에 적용하여 설계하려면 시간이 조금 더 걸릴 것 같다.  이번 자판기 미션 구현 데모페이지 스터디 독서 스터디에서 프로토타입을 주제로 발표를 했다. 평소에 헷갈리던 부분을 남들에게 설명을 하면서, 오히려 나 스스로의 이해를 더 도운 것 같다.  이외에도 코드리뷰스터디를 할 때마다 참 많은 것을 배운다. 이번 스터디는 게더타운에서 했었는데, 스터디원 외에도 다른 크루원들이 지나가다가 스터디에 참여해주셨다. 여럿이서 다양한 시각에서 스터디에 참여해주셔서 더 유익했고 재밌었다. 개념에 대해 깊게 이해하기 이번에 라우팅을 구현하면서, 처음에 시도한 브라우저 히스토리와 깃허브의 연동이 잘 되지 않았는데, 이유와 해결책을 찾진 못했다. 그래서 브라우저 히스토리 대신에 해시뱅으로 대체하였다. 그런데 구현만을 위해 너무 얕게 공부한 것 같다. 두 가지 방법을 모두 가능하게 해보고, 장단점 등을 찾아서 정리해야겠다.  운동 페어를 하는 도중에도, 짬을 내서 운동을 시도했다. 우려했던 것보다, 운동에 많은 시간이 소요되진 않았다. 역시 시작이 반이다. 운동하러 문 밖을 나가는 게 제일 어렵고 중요하다. 체력을 키우기 위해 달리기를 더 꾸준히 해야겠다. 주 2회 달리기와 주2회 헬스~ 바쁘다. 산책 주말에는 우테코 크루들을 만나서 모각코를 한 후 밥도 먹고 산책을 하고 있다. 특히, 점점 봄이 다가오고 있어 싱그러운 날씨와 자연을 볼 때 기분이 정말 좋다. 이렇게 기분전환이 됨으로써, 다음 한 주를 열심히 공부할 수 있는 에너지를 얻게 된다. 아래의 노래는 그냥  산책 을 말하니까 좋아하는 노래가 생각나서.. :D !youtube[t9aZFgD0mic]  SOF -  __proto__  VS.  prototype    __proto__ 는 메서드 등을 체인을 타고 찾는데 사용되는 실제 객체이다.  prototype 은  new 로 인스턴스를 만들 때  __proto__ 를 생성하는 데 사용하는 객체다.  console.log(new Foo(). proto proto ); // {}, 빈 객체 반환,  함수이므로 root level인 Object.prototype을 가리킨다   빈 새 객체를 만든다. marco에  __proto__  프로퍼티를 만들고, 그   __proto__  프로퍼티가 SetName의  prototype 을 가리키게 한다. 1번에서 만든 새 객체의 context(this)로  SetName.prototype.constructor  (= SetName 함수정의)가 실행(execute)되며, 이러한 해당 함수정의에 따라 &quot;Marco&quot; 문자열을 전달받은 &#39;name&#39; 프로퍼티가 새 객체에 추가된다.  const  marco 에 해당 새 객체(1번에서 만들어진)가 지정되어 반환된다..  결론 : 인스턴스는  __proto__  프로퍼티만을 제대로 갖고, 클래스와 생성자함수는 추가로  prototype  프로퍼티를 갖는다. 인스턴스의  __proto__  프로퍼티는 클래스나 생성자함수의  prototype 을 가리킨다. (사족을 덧붙이자면, 클래스와 생성자함수의  __proto__  프로퍼티는 root level의  Function.prototype  프로퍼티를 가리킨다. 추가로 Function과 Object의 프로토타입 관계를  아담과 이브 에 빗대어 살펴보자.( SOF -  __proto__  VS.  constructor.prototype Object 는 이브이고,  Function 은 아담이다. 아담( Function )은 그의 갈비뼈( Function.prototype )을 사용하여 이브( Object )를 창조하였다. 그러면 아담( Function   예제 콘솔결과   !youtube[F12knyNlrIk] 독백이라 착각하기 쉽다.  윤석철트리오  독백이라 착각하기 쉽다 는 말은, 혼잣말 같지만 사실 누군가와 끊임없는 대화를 하고 있다는 뜻일 수도 있을 것 같다. 이 곡에서는 여러 악기들이 재즈를 통해 재잘재잘대는 독백같은 흥겨운 대화를 리듬감있게 이어나가고 있다. 코딩도 비슷한 것 같다. 코드를 짜는 행위가 독백이라 착각하기 쉽지만, 사실은 코드와 대화를 하고 있는 것이다. 코드들도 마찬가지로 코드들 간에 강한 응집성과 약한 의존성의 대화를 끊임없이 이어 나가고 있다. 개발을 시작한지 얼마 되진 않았지만, 솔직한 느낌으로 개발은 어렵다. 하지만 어렵더라도 그 과정을 이 곡처럼 코드 및 동료들과 흥겹게 대화하며 즐길 수 있다면, 오래 지속할 수 있지 않을까? 독백보다는 흥겨운 대화를 이어나가자. 나만의 유튜브 강의실 미션 끝 이번 주에는 유튜브 미션의 step2의 요구사항을 구현하는 데 중점을 두었다. 기본 요구사항을 구현하고, 사용성을 고민하여 추가로 다음 기능들을 구현하였다.  window의 기본 alert 창을 아래에서 위로 올라오는 toast 창(또는 snackbar)으로 대체하였다. 그리고 영상게시일자를 현재 시간과 비교하여 상대적 시간으로 변환하여 표시하게 했다. 유튜브에서 &#39;1년 전&#39;, &#39;15분 전&#39;과 같은 형식으로 게시일자를 표시하는 것처럼 말이다. 마지막으로 다크모드로 전환하는 토글도 추가하였다.  시간이 더 있었다면, 검색어 히스토리 관련 기능도 구현하고 싶었는데, 느린 구현 속도 때문에 하지 못했다. 다 처음 구현해본 기능들인데, 구글에 검색하면 관련 자료도 많았고 생각보다 어렵지는 않았다.  &#39;나만의 유튜브 강의실&#39; 데모페이지 기능 구현은 다 해서 금요일에 마음을 어느 정도 놓고 토요일에 후이와 준찌를 만나서 편안하게 마무리를 할 계획이었다. 그런데 미루었던 E2E 테스트코드 작성이 생각보다 할 게 많아서 토요일에 여유롭지는 않았고 새벽까지 꽤 무리를 한 후 PR을 제출하였다.  앞으로는 혹여나 밤을 새는 일이 없도록, 생활 패턴과 일정을 잘 조율해야겠다. 잠이 부족하고 체력이 떨어지면, 될 일도 안될 수 있다. 코드리뷰스터디 주간 코리스 - 🎱행운의 로또 1호 주간 코리스 - 🎱행운의 로또 2호 읽고 정리한 내용  타이머 비동기프로그래밍 Ajax 프로미스 제너레이터와 async/await 비동기성 다음 주에 도전할 것들 미션에서  web components ,  custom element 를 활용해보고 싶다.   프레임워크 없는 프론트엔드 개발 이라는 책을 도서관에서 빌려왔는데, 내용이 궁금하다. 다음 미션 기본 요구사항이  타입스크립트 로 작성하는 것이다. 타입스크립트에 대해 전혀 알지 못해서, 이에 대해 공부를 열심히 해야겠다. 그리고  SPA 와  Routing ..! 바쁘다 바빠 달리기를 말할 때 내가 하고 싶은 이야기 이번 주에는 운동을 딱 한 번 했다. 페어프로그래밍 주간에는 도저히 다른 활동에 시간을 내기 어려운 것 같다. 그래도 계속 이럴 수는 없으니까, 페어프로그래밍 주간에도 틈틈히 개념도 탄탄히 다지고 운동도 짬을 내서 조금 더 많이 해야겠다. 무라카미 하루키의 에세이  달리기를 말할 때 내가 하고 싶은 이야기 에서 다음과 같은 구절이 있는데, 소설가든 프로그래머든 같은 맥락에서 공감할 수 있는 내용이라고 생각된다. 프로그래머는 많은 시간을 스스로 생각하고 소설가처럼 구조를 설계해나가는데 시간을 쏟는 것 같은데, 프로그래머도 소설가처럼 불건전한 영혼(?)에 가깝다고 볼 수 있다. 따라서 건전한 육체가 그 누구보다 필요하다.  하루키가 소설 쓰기의 많은 것을 매일 아침 길 위를 달리면서 배운 것처럼, 나도 프로그래밍 혹은 삶의 많은 것을 길 위에서 달리면서 배울 수 있지 않을까 기대한다.   새 미션 시작 이번 주 화요일에 [나만의 유튜브 강의실] 구현 미션이 시작되었다.  위니 와 페어가 되어 화요일부터 금요일까지 페어프로그래밍을 진행하였다. 페어프로그래밍을 할 때마다 느끼는 거지만, 다들 배울 점이 많고 열정적이다! 위니도 나랑 비슷하게 프로그래밍을 배우기 시작한지 6개월 정도 밖에 되지 않았다고 한다. 우리는 이번 미션에서 요구하는 기능인 REST Api, 무한 스크롤, 스켈레톤 UI, 비동기 프로그래밍을 그 전에 해본 적이 없어서 미션에 대한 중압감을 많이 느꼈다. 설계 이번에는 MVC를 탈피해서 새로운 방식의 설계를 도전해보려는 마음도 살짝 먹었으나, 페어와 나는 설계에 힘을 많이 쏟다가는 기한 내 기능 구현도 제대로 못하겠다는 결론에 이르렀고 MVC 패턴 하에 기능 구현 및 에러 핸들링에 초점을 맞추기로 했다. fetch, async/await 미션을 시작하고 youtube API key를 받아서 데이터를 fetch하여 콘솔에 찍었을 때 신기했다. 시작이 반이라고, 일단 데이터를 가져왔으니 데이터를 지지고 볶으면서 화면에 표시하면 되지 않겠는가? 자신감과 안도감이 생겼다. 무한스크롤과 IntersectionObserver 무한 스크롤은  IntersectionObserver 을 사용하여 구현하였다. 처음에는 이를 Controller에 뒀다가 다음날 자고 일어나보니 당연히 View에 들어가야 한다는 생각이 들어서 리팩토링을 하였다. 그리고  IntersectionObserver 가 scroll의 bottom을 감지하는 순간  customEvent를 dispatch하도록 하여 controller에서 해당 customEvent를 수신하여 다음 데이터를 fetch하고 render하는 메소드를 controller가 명령하도록 만들었다.  iframe srcdoc fetch하여 render한 클립 영상은 iframe으로 구현하였는데, 유튜브에서 퍼가기 금지 설정되어 있는 영상은 iframe에 재생도 되지 않고 썸네일도 표시되지 않아 사용성이 떨어져 보였다. 그런데 youtubeAPI를 fetch할 때 퍼가기 가능한 동영상만 필터링하여 가져오는 방법은 아무리 찾아도 나오지 않아서 다른 해결책을 강구해야 했다. 그 결과, 썸네일 url도 데이터로 받고 있으니, iframe의 영상 영역을 각각 해당 썸네일 이미지로 직접 덮고 영상 링크를 걸어두면 어떤가 하는 의견을 주고 받았다. 그리고 우리가 덮은 썸네일 이미지를 유저가 클릭하면 iframe 내부에 영상이 자동재생되도록 하는 것이다. 이러한 아이디어를 해결할 수 있는 방법으로 iframe의 attribue 중  srcdoc 이 있음을 찾게 되었고, 여러 시행착오 끝에 정상적으로 구현하게 되었다. 그런데 아쉬운 점은, 유튜브가 외부에서 자동재생 설정을 하려면 반드시 음소거 설정을 함께 하도록 하는 정책이 있어서, 구현 프로젝트에서 우리가 넣은 썸네일을 클릭하면 영상은 자동재생되나 소리는 나오지 않고 있다. 결국 사용성 개선에 대한 문제로 돌아오는데, 프론트엔드는 이러한 고민이 많이 필요한 것 같다. localStorage 이 외에도 저장 버튼을 눌렀을 때, localStorage에 해당 영상 데이터를 저장하고, 다시 새로고침해서 동일한 영상을 찾게 되었을 때 localStorage에서 데이터를 가져와 해당 영상에 저장 버튼을 &#39;저장됨&#39; 버튼으로 변경하는 것도 쉽지 않았으나, 페어와 함께 결국 다 구현해냈을 때 큰 희열감이 들었다. webpack 다 구현하고 webpack으로 build하고 deploy하는 데도 쉽지 않았다. 이번에는 이전 미션과 달리 프로젝트에 이미지 파일도 추가되었고, 비동기인 async/await도 포함되어 있었기 때문이었다. 이미지 파일을 webpack으로 build하기 위해서는  file-loader  패키지를 설치하고, webpack.config.js의 rules에 다음과 같은 설정을 추가해야 했다. 그리고 비동기 async/await 관련 웹팩 설정은  regeneratorRuntime is not defined  오류가 발생함으로써 인지하게 됐는데, 이를 해결하기 위해서는 코드가 컴파일될 때 async/await 문법을 해석하는데 필요한 regeratorRuntime을 추가해야 함을 알게 됐다. 따라서  @babel/plugin-transform-runtime  패키지를 설치하였고 webpack.config.js의 rules의 babel-loader 부분에 &#39; @babel/plugin-transform-runtime  plugin 설정을 추가함으로써 webpack build 및 deploy에 성공하였다. 마르코의 유튜브 강의실 데모페이지 코드리뷰 피드백 이번 미션에서 배정받은 리뷰어님은  Vallista 님이셨다. 꼼꼼하게 내 코드를 살펴봐주셨고 내가 놓치고 있던 부분들에 대해 잘 짚어주셔서 많은 것을 배우게 되었다. 모든 질문에 대해 상세히 답변해주셨는데, 이를 정리한 내용은 다음과 같다. 테스트코드 로직의 정상 작동 결과는 하나뿐이지만, 오작동하는 케이스는 수십가지가 넘는다. 따라서 유저가 어떤 행동을 했을 때 오작동을 하면 유저에게 그에 대한 피드백이 필요하다. 이러한 오작동 케이스에 대한 수많은 문제를 정상적으로 사용할 수 있도록 유도하는 코드가 필요하다. 테스트코드는 오작동 문제 상황에 대한 코드 보완 여부를 협업하는 사람들과 공유하는 성격도 갖고 있다.  따라서 에러 상황에 대한 테스트코드를 많이 고민하고 작성수록, 이 테스트코드를 코드단위로 이행시켜서 효율성을 증대시킬 수 있다. 결론: 유저 관점에서 유저가 일으킬 수 있는 수많은 오작동 케이스를 커버할 수 있는 테스트코드를 작성하자. 그리고 테스트코드는 에러 상황 커버리지를 코드단위로 이행시키며 다양한 사람들에게 선한 영향력을 줄 수 있음을 염두하고 정성껏 작성하자! 설계 프로젝트에 적합한 설계가 무엇일지 고민하자.  작은 단위의 프로젝트의 경우 MVC는 오버스펙일 수도 있다.  MVC에서 벗어나서 새로운 시도를 해보는 것도 좋다. 함수 분리 기준  로직이 길어지는 경우(코드 10줄 초과)  두 번 이상 재사용될 수 있는 경우  그리고 함수가 길다고 느껴진다면 함수 분리 전에, 함수명이 잘못되었을 수도 있으니 함수명과 그 기능을 다시 잘 살펴보자. (MVC에서 controller는 model과 view가 만나는 전쟁터라서 비대해지기 쉽다 😿 ) 크롬익스텐션 기능 추가 footmarker 검색 기능도 없고  등록 날짜 도 기재되지 않으며 북마크의 이름으로 웹사이트의 타이틀만 가져온다는 것에 대한 아쉬움 때문이었다. 해당 페이지에서 내가 북마크하고 싶은 부분은 특정 섹션이며 섹션을 설명하는 해당 타이틀 태그(h1,h2,h3,h4)의 텍스트를 가져오고, 타이틀 책갈피 링크를 가져왔으면 좋겠다는 생각을 했다.  이러한 아이디어에서 시험 삼아 만들어 본 익스텐션이었고, 몇 개월간 잊고 있었는데, 시지프의 멋진 사이드 프로젝트를 보고 나의 작고 귀여운 프로젝트들도 아껴줘야겠다는 생각을 했다. 그래서 어젯밤에 한 가지 기능을 추가했는데, 그것은 바로 날짜별로 모은 북마크를 앵커 태그와 함께 클립보드에 복사하는 기능이다.  프로그래밍은 어렵지만, 재밌다. 몰입 끝에 내가 만든 것들을 세상에 쉽게 선보일 수 있다는 점이 참 매력적이다.  크롬익스텐션 Footmaker 코드리뷰스터디 기획과 시작 지난 주말에 기획한 코드리뷰 스터디의 첫 시작을 잘 한 것 같다. 레이싱게임 미션 때, 혼자서 다른 37명의 크루들의 리뷰를 모두 살펴봐야해서 힘들었는데, 코드리뷰 스터디를 하면서 분량을 나눠서 하니까 훨씬 수월했다. 뿐만 아니라, 담당한 코드들을 더 자세히 분석하고, 다른 스터디원들과 분석 결과를 공유하니까 새롭게 알게 되는 부분들이 많아서 좋았다.  코드리뷰 스터디 그리고 코드리뷰 스터디 모집글을 우테코 슬랙에 올렸을 때, 생각보다 많은 분들이 하고 싶다고 하셨다. 하지만 인원은 4명 정도의 소규모로만 진행하고 싶어서, 아쉽게도 다 같이 함께 할 수는 없었다. 그런데 이후 해당 스터디의 템플릿을 본따서 별도로 스터디를 하고 싶다는 여러 크루의 연락이 왔고, 그 결과 프론트엔드 및 백엔드에서 동일한 스터디가 2개 더 생겼다. 조금이라도 다른 크루들에게 도움이 된 것 같아 뿌듯했다. 로또 미션 구현 완료 생활 학습 다음 주부터  나만의 유튜브 강의실 AJAX &amp; JSON ,  RESTful API ,  Promise &amp; async/await ,  loading &amp; skeleton ,  lazy loading ,  debounce &amp; throttle  를 중심으로 공부하고, 블로그 포스팅도 이를 중심으로 해야겠다.  그리고 자바스크립트 문법을 탄탄히 해야겠다. 잡다한 거 이것저것 손대지 말고 기본부터 잘하는 게 우선인 것 같다.   첫 회고 우아한테크코스를 시작한지 3주가 지났다. 우테코 총 10개월의 과정을 알차게 보내어 실력 있는 개발자가 되고 싶다는 생각에 시지프, 호프, 우디와 함께 주간회고스터디를 참여하게 됐다. ‘내가 성장하고 있는지’ 또는 ‘너무 무리하고 있진 않는지’ 등을 매주 일요일에 시간을 들여 회고를 하는 스터디이다.  성장의 요소 우테코는 남들과 경쟁하는 곳은 아니다. 대신 지난 자신보다 성장하는 것에 초점을 두고 있다. 하지만 지난 자신과 비교하여 성장하는 것도 쉬운 일이 아니다. 이를 위해서는 명확한 목표 의식과 체계적인 세부계획, 그리고 이를 수행할 성실함과 체력이 기본으로 요구될 것이다. 그러나 이것만으로는 오래 유지하기 어려울 수 있다. 장기간 지속가능하려면 회고를 통하여 달성목록을 정리 및 학습 방향 조정의 과정이 반드시 있어야한다. 내가 지난 한 주간 어떻게 공부하고 생활했는지 정리하며 “잘 하고 있구나”라는 생각을 가지어 자아의 긴장을 풀도록 하는 것은 아주 중요하다. 이렇게 주기적으로 내가 무엇을 잘 했는지 스스로 칭찬해주지 않고 막연하게 지나간다면, 잠재되어 있는 불안감이 언젠가 크게 드러나고 번아웃으로 이어질 수 있으니 주의해야 한다. 또한, 방향성은 속도보다 중요하기 때문에, 주기적으로 방향을 조정하고 작은 단위의 목표를 재설계하는 것은 필수적이다. 방향 페어프로그래밍 이번 주에는 로또 구현 미션 1단계를 진행했다. 무비와 함께 페어프로그래밍을 하여 1단계를 구현하였는데, 페어프로그래밍을 통해 얻는 것이 많다는 생각이 들었다. 설계나 개별 코드들을 말로 설명하며 하나의 결과물로 만드는 작업을 하면서, 추상화 능력이 더 길러지는 것 같다. 또한, 내가 모르던 기술이나 나와 다른 사고방식의 구현 과정을 페어프로그래밍을 통해 살펴보며 동시에 학습되는 부분도 많다.  유닛테스트 또한, 해당 미션을 유닛테스트 TDD 방식으로 처음 시도하였다. 기능 요구사항을 정리하고 구조도로 설계를 간단히 그려보았다. 그리고 단위 테스트를 작성하며 테스트 실패를 확인한 다음 성공하도록 하는 과정을 반복했다. 핵심 기능에 대한 유닛테스트를 다 만든 다음, 구현에 들어가게 되니 생각했던 것보다 무엇을 해야할지 더 명확해졌다는 느낌이 들었고, 리팩토링 후에도 테스트를 돌림으로써 코드에 대한 신뢰성도 높아져서 능률이 올랐다. 커스텀 이벤트를 이용한 설계 View의 역할을 명확히 하기 위해 노력했다. View에서 값을 가져오고, 이벤트도 수신하도록 하고 싶었다. 그러면서 View가 직접 Controller에게 명령은 하지 않도록 만들기 위해, 커스텀 이벤트를 활용했다. Controller와 View 모두 해당 요소에서 이벤트를 수신하게 하는데 수신하는 이벤트가 다르게 만들었다. View는 내장된 실제 이벤트를 감지하여 입력된 데이터와 함께 커스텀 이벤트로 만들어서 이벤트를 발신한다(dispatch). Controller는 View가 발신한 해당 커스텀 이벤트를 관찰하고 있다가 발생하면 감지하고 로직을 실행한다.  뻔한 MVC 패턴을 다시 쓰긴 했지만, 그래도 전보다 더 개선된 설계를 할 수 있어서 만족스러웠다. CommitLint 사소한 거지만, 커밋 메시지에 이모지 등 컨벤션을 통일하면 좋겠다는 생각이 들어 커밋린트도 적용해보았다. 나중에 쌓인 커밋 메시지를 보니까 이모지들로 반짝반짝하고 규칙적인 게 보기 좋았고 귀여웠다. JSDoc 다른 크루의 코드를 보다가 주석에 무언가를 규칙적으로 써진 코드를 보았고, 그것이 JSDoc이라는 문서 작성 기능임을 알게 됐다. 그래서 궁금한 것은 또 참을 수 없어서  내 코드에도 JSDoc을 적용하고 주석을 달아보았다. 로컬에서는 해당 문서를 확인할 수 있는데, 깃허브에 deploy를 어떻게 하는 건지는 모르겠어서 아직 해결하지 못했다.  읽은 책 ‘DOM을 깨우치다’와 ‘모던자바스크립트’의 ‘브라우저렌더링, DOM, 이벤트타겟’ 부분을 읽었다. node, element가 무엇인지 그리고 그 메서드들을 살펴보면서 DOM의 모습과 작동방식에 대해 조금 더 이해를 하게 됐다.  공부하면서 포스팅을 하며 기록을 남겼던 게 의미가 있는 것 같다. 다시 생각하려고 하니 벌써 그 내용들이 정확하게 떠오르지 않는데, 포스팅을 해두어서 복습하는 데 도움이 된다. 읽을 책 오늘 도서관에 다녀오며, 보이는 책들을 여러 권 집어왔다. 이번 주는 설계와 객체지향에 대해 고민이 많았던 터라, 그런 내용의 책들이 많다. 객체 지향과 디자인 패턴 오브젝트: 코드로 이해하는 객체지향 설계 객체지향적으로 생각하라 테스트 주도 개발로 배우는 객체 지향 설계와 실천 그런데 객체 지향 관련 책들은 다 자바로 설명되어 있어서 이해하기 쉬울지 모르겠다. 그래도 일단 최소한 텍스트라도 읽으면서 도대체 무엇을 객체지향이라고 하는지, 그리고 좋은 설계는 무엇인지 얻고 싶다. 그리고 CSS도 나에겐 어렵기 때문에, CSS 책도 빌려왔다. 에릭 마이어의 CSS 노하우 호프가 최근에 읽었다는 심리학 책도 재밌어 보여서 읽기 시작했다. 나는 왜 나에게만 가혹할까 건강 이번 주는 잘 자고 잘 일어났다. 커피를 끊고 헬스장도 잘 다닌 덕분인 것 같다.  다음 주에도 헬스장을 3번 이상 가야겠다. 그리고 아침 기상 시간을 조금 더 앞당겨서 7시에 일어나도록 노력해야겠다. 몇 주전부터 직접 요거트를 만들어 먹고 있는데, 건강에도 좋고 맛도 좋아서 만족스럽다. 다음주 목표 정리 객체지향이 무엇인지 이해하고 글로 정리하기 좋은 설계가 무엇인지 학습하기 함수와 클로저 학습 후 정리하기 Css grid 정리하기 코드리뷰 스터디 조직하고 시작하기 로또 미션 step2 구현하기 헬스장 3회 이상 출석하기 7시에 일어나기. 수업 전 9시부터 자습하기 우아한테크코스 레벨1  자동차경주  미션을 수행하며 코드리뷰를 받았다. 내 코드에 대한 리뷰 및 다른 크루들이 받은 리뷰들을 살펴보다가, 나중에 리마인드하면 좋을 내용들이 많아 보여서 메모한 내용을 포스팅한다.    컨벤션  isCarNameBlank 와 같이  is  라는 prefix가 붙은 네이밍은 car name이 비어있는지 여부에 따라서 true나 false를 반환한다고 예상된다. 선택자 중 id명과 class명을 서로 다르게 주는 것이 헷갈리지 않는다. 보통 id와 class의 네이밍 컨벤션을 다르게 가져간다. 함수는 한 가지 일만 공통 메서드는 의도가 드러난 한 가지 일만 수행하도록 하는 게 유리하다. 한 함수에서 여러 일을 동시에 하지 않도록 분리한다. 자료구조를 활용하여 중복 제거 Set 자료구조를 통해 중복을 제거하고, 원본의 길이와 비교하면 해당 배열에 중복값이 있는지 쉽게 확인할 수 있다. DOM 요소 삽입 방법 innerHTML을 사용하면 기존에 매핑된 이벤트가 전부 소멸된다. 매핑된 이벤트를 소멸하지 않고 유지하면서 DOM에 추가하기 위해 insertAdjacentHTML 메서드를 사용해볼 수 있다. insertAdjacentHTML 추천 https://kit-developer.tistory.com/27 단축평가 or로 이어진 조건들을 some 메서드로 리팩토링 and로 이어진 조건들을 every 메서드로 리팩토링 테스트코드 본질적인 방어는 본진에서 해두고, 테스트는 ‘예방차원&#39;에서 안전장치를 마련하는 것이다. 테스트코드에서도 자주 쓰이는 string은 상수로 관리하면 휴먼에러를 방지할 수 있다. 전역에서 사용하는  custom commands  의 경우 문서에서  support  폴더에 정의하길 권장한다.  support/commands.js  파일에 정의하면 좋다. {enter} 하면 enter키가 눌리는 테스트코드(cypress) 설계 model과 controller를 분리했음에도 controller가 model에 직접 개입하는 것은 바람직하지 않다. model에 값을 던져주고, model이 해당 동작을 수행하게끔 하는 편이 좋다. 그렇지 않으면, 역할 개입에 의해 예상치 못한 문제가 발생하기도 하기 때문이다. 이 때문에 이런 사례가 발생하지 않게 하기 위해 미리부터 model을 캡슐화하는 것도 좋은 전략이다. model의 상태를 다른 곳에서 변경하기 보다는 해당 model에게 메세지를 보내서(model의 메서드 호출) model이 직접 스스로 자신의 상태를 변경하는 방식(model의 메서드 내부에 상태 변경 코드)을 추천한다. 상태를 외부에서 직접 변경하는 방식보다는 객체가 스스로 상태를 책임지는 방식이 캡슐화가 더 잘됐다고 할 수 있고, 코드의 의도를 파악하기도 더 좋다. 헐리우드 원칙  https://johngrib.github.io/wiki/hollywood-principle/ controller가 다른 객체인 view의 멤버변수(element)에 직접 접근해서 eventListener를 달으는 것이 올바를까? 객체 지향 프로그래밍에서 객체의 데이터는 객체의 외부에서 직접적으로 접근하는 것을 막는다. 객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨질 수 있기 때문이다 . 객체의 프로퍼티를 객체 바깥에서 직접 조작하는 행위는 데이터의 유지 보수성을 해치는 주요 원인이다. 따라서 view의 멤버변수에 접근하여 eventListener를 다는 메서드는 view 내부에서 해주는 것이 적절하다고 보인다. 또한, 다른 객체의 멤버변수에 접근해야할 경우, getter나 setter 등을 사용하는 것이 적절하다. MVC에 얽매일 것이 아니라, 도메인 단위로 분리할 수도 있다. 이 프로그램은 크게 봤을 때 입력, 경주, 우승자 표시 이렇게 3개의 도메인으로 구성되어 있는 것 같다. 그런 관점에서 봤을 때 RacingCarGame이 다루고 있는 도메인은 입력 form과 경주화면 2가지를 모두 담고 있는데 이 2개는 분리가 가능할 것 같다. 그리고 View는 화면단의 모든 영역을 핸들링 하고 있는데 이 부분도 도메인 단위로 분리가 가능한 영역으로 보인다. model은 순수하게 &#39;데이터&#39; 및 &#39;데이터를 변경하는 메서드&#39;만 들고 있으면 되고, controller는 그와 정 반대로 &#39;데이터&#39;를 아예 들고 있지 않아야 맞다. controller가 들고 있어야 하는 정보란, 프로젝트 전반을 진두지휘하기 위한 접근자(각 인스턴스에 대한 정보)들로 충분하다. html 태그에 event를 등록하는 메서드는, &#39;컨트롤러&#39;가 제어하는 메서드가 아니라, View에서 사용자 이벤트가 발생했을 때 컨트롤러에게 이를 &#39;전달&#39;해주는 목적을 띕니다. 즉, &#39;컨트롤러&#39;가 아닌 &#39;VIew&#39;에 더 어울리는 메서드이다. view를 하나로만 작성하지 말고, 값 입력 폼 view, 레이싱 경기진행 view, 결과를 보여주는 view 등 대략 더 나눠볼 수 있을 것이다. 그러면 컨트롤러도 view에게 지시할 때 특정 view를 가리켜 지시할 수 있다. 컨트롤러가 view의 일까지 너무 많이 가지고 있지 않은지 고민하자. 예를 들어, 아래 코드처럼 어디에, 어떤 위치에, 어떤 템플릿으로 그릴지를 컨트롤러에서 다 정하지 말고, 이러한 구체적인 렌더링은 view가 알아서 하게 하자. 컨트롤러는 단지  view에게 실행해! 라고만 알려주는 편이 역할 분리가 된 것이다.  this.view.render(selector, position, template); 바로 return하는 함수 관련 바로 return을 하는 함수라면 () 안에 return을 내포하고 있어 다음과 같이 리팩토링이 가능하다. DOM selector 탐색을 root에서부터 시작하는 경우가 많은데, 이럴 경우 탐색하면서 매칭되는 첫 번째 element를 반환한다. 이런 방식으로는 프로젝트 덩치가 커질수록 다음과 같은 두 가지 이슈가 예상된다. 모든 element를 root에서부터 탐색하기 때무에 element 깊이가 깊어질수록 탐색 속도 저하 특정 element  부터 탐색하는 방법을 고민해보자.  element = baseElement.querySelector(selector); forEach를 map으로 리팩토링 DOM에 렌더링을 하기 위한 HTML String을 준비할 때, 데이터 배열을 돌면서 HTML string을 만드는 경우 forEach를 쓰기도 하는데, forEach 대신 map 메서드를 쓸 수 있다. class 객체를 생성할 때, class와 생성자 함수 중 어떤 것을 사용하는 것이 더 좋을까? class는 결국 syntatic sugar이긴 하다. 팀 내에서는 섞어서 쓰고 있다. 요즘에는 class가  private  이나  상속  등 사용 측면에서 유리한(편한) 면이 더 있다고 생각해서, 팀내에서 class를 더 선호하기도 하다. 파일 분리 파일을 분리하되 응집력있게 모아두면 괜찮다. 함수가 쪼개지고 파일까지 쪼개지다 보면 오히려 역할이나 배경, 의도를 파악하기가 어려울 때가 종종 있다. (파일도, 함수도, 모두 마찬가지이다.) 유효성 검사 데이터에 대한 유효성 검증방법은 데이터 관련  Model  에서 제공하고, 검증은  Controller  에서 하는 방법도 있을 것 같다. 고민  개발이란 게 정답이 없다.  교육기간에 너무 베스트 프랙티스나 정답을 따라서 하기보다는, 이것저것 삽질하면서 베스트 프랙티스로 향하거나 본인만의 답을 찾는 게 가장 중요하다. 고민하는 근력이야말로 현업에서 가장 중요하다. sort 메서드와 immutable 복사본 없이 sort 메서드로 모델의 데이터를 직접적으로 정렬시키는 것은 주의해야 한다. immutable하게 모델을 유지하는 것을 추천한다. 프로그램의 복잡도가 올라갈수록  직접적으로 객체를 변경하는 것 은 의도치 않은 사이드이펙트를 가져올 수 있기 때문이다. 올바른 변수 이름 짓는 법  https://youtu.be/ZtkIwGZZAq8 간결하면서도 의미가 전달되는 것이 중요하다. 변수 이름에는 동사를 넣지 않는다. 단수형, 복수형을 구분한다. 변수의 단수형에는 관사(a, the)를 넣지 않는다. 복수형은 ‘s’를 뒤에 붙인다(또는 list로 하는 경우도 있다). 전치사는 최대한 생략한다.  nubmerOfUsers  같은 변수명보다는 더 간결히  userCount 가 더 낫다. 또는  number 를 앞에 쓰고 싶다 한다면, 약간 문법 파괴를 하더라도  numUsers  같이 짧게 쓰는 경우도 있다. 아무튼  numberOfUsers  처럼 전치사를 넣는 네이밍은 피하는 것이 좋다. 좋은 오픈소스의 코드들을 보면서 변수명이 어떻게 지어졌는지 보고 익혀보자. 명령형과 선언형 명령형(imperative, HOW) : “어떻게 구현하는가&quot;를 설명한다. 어떤 방법으로 해야 하는지를 나타낸다. 어떤 동작을 할 것인지, 수행할 명령을 순서대로 써놓은 것. 선언형(declarative, WHAT) : “무엇&quot;이 일어나는지, 무엇과 같은지를 설명한다. 상수화 어디까지 상수화하는 것이 좋은지에 대해 여러 사람들의 생각을 묻고 고민해보자. 상수화하면 어떤 이점이 있을까? 상수화 시, ID의  # , class의  .  를 이런 함수를 만들어서 편하게 사용할 수도 있다(전역 프로토타입 객체를 건드리는 것은 권장하는 방법까진 아니나, 이 정도 미션에서는 가능할 수도 있 다.). prettier 환경 설정 trailingComma의 값에 ‘all’ 설정을 하게 되면, 코드리뷰 시 실제로 코드가 변경된 부분만 표시가 될 수 있으므로, 코드리뷰할 때 편하다는 장점이 있다. 은닉화 class의 속성이나 메서드에 해쉬 # prefix를 추가하여 private class fields를 선언할 수 있다. 다른 클래스에게 노출하지 않아야 하는 것임을 알 수 있게 한다. #으로 private 메서드를 만들었는데, 순서상 constructor 아래에 넣은 이유는? 관련된 메소드를 모아서 클래스를 읽는 사람이 위에서 아래로 일어나는 일을 로직의 흐름대로 알 수 있게 해야 한다.private은 내부에서만 일어나는 일이니 외형적인 요소에 포함되지 않는다. 그렇기에 public만 보고도 어떤 행동을 하는 객체인지 협업하는 사람이 잘 알 수 있어야 캡슐화가 잘 된 것이다. public을 private보다 위에 선언함으로써, 외부에서 해당 코드를 볼 때 위에서부터 빠르게 찾도록 할 수 있다. jsDoc  JSDoc을 사용하여 자바스크립트에 타입 힌트 제공하기  https://velog.io/@yijaee/JSDoc을-사용해-JavaScript-파일-문서화하기  https://jsdoc.app/ class static 메서드만 존재하는 class가 class로서 의미가 있을까? 객체로 만들어도 충분할 수 있다. class는 어디까지나 “인스턴스를 생성하기 위한 틀 또는 추상적 객체&quot;라는 원래의 목적에 맞게 쓰는 것이 좋다. 왜냐하면, static 멤버로만 구성된 클래스는 실제로 new 연산자와 함께 호출하여 인스턴스를 생성할 일이 없으니, ‘공통 속성을 뽑아낸 추상적 범주&#39;라기보다는 그 자체로 특정 역할을 부여한 “구체적 객체&quot;와 다름없다고 볼 수 있다. 유틸 함수 범용성이 있는 함수는 유틸 폴더로 옮기는 것이 낫다. 유틸에는 보통 도메인에 대한 정보가 없다. 드모르간 법칙으로 if문 없애기 조건 충족시 false, 불충족시 true를 반환하는 함수라면 이런 식으로 if문을 없앨 수 있다. 입력된 값들에 빈 값이 있는지 체크 시맨틱 태그 웹접근성을 위해 div 대신에 section이나 article을 사용하여 시맨틱하게 구현도 고려하기 section 안에 타이틀 태그를 넣어서 스크린리더기가 해당 섹션의 설명을 읽을 수 있도록 도와줄 수 있다. 타이틀 태그를 화면에 표시하고 싶지 않다면 hidden 어트리뷰트를 사용한다. null, “”(empty), undefined null, “”(empty), undefined는 구분된다.  null object타입 변수의 선언과 데이터가 없는 상태로서 메모리의 변수의 위치가 정해지고 공간은 텅 빈 상태 null은 원시값(Primitive Type) 중 하나로, 어떤 값이 의도적으로 비어있음을 표현한다. undefined는 값이 지정되지 않은 경우를 의미하지만, null의 경우에는 해당 변수가 어떤 객체도 가리키고 있지 않다는 것을 의미  &quot;&quot;  (empty) string 타입 메모리의 변수의 위치가 정해지고 공간에 빈 문자열 하나만 있는 상태  undefined undefined 타입 선언한 후에 값을 할당하지 않은 변수나 값이 주어지지 않은 인수에 자동으로 할당됨 max 값 구하는 경우 for문 대체하는 리팩토링 이벤트리스너 달 때 자동화된 타겟 처리 label, button label에는 for 어트리뷰트가 있다. 그걸 사용해서 input과 매칭해주면 좋다. button은  type=&quot;submit&quot; 으로 하거나, 전체를 form으로 감싸서 input에서 enter키를 입력해도 확인 버튼을 누른 것과 동일하게끔 구성하는 것이 좋다. rAF   rAF 를 왜 사용할까?  게임을 할때  FPS (Frame Per Second)라는 단어를 많이 사용하는데 1초동안 몇번의 화면을 보여주는지를 알려주는 단어인데 이  FPS 가 낮아지게 되면 사용자 입장에서 부드러워야 할 화면이 뚝 끊기게 되어 사용자 입장에서 불편하게 느껴진다. 이런 부분을 해소하기위해  rAF 가 나왔다.  rAF 는 사용자가 이러한 끊김을 느끼지 않도록 1프레임마다 호출을 보장해주는  web api 이다. 디스플레이의 환경에 맞게 최적의 빈도로 실행을 해줘서 사용자 경험을 챙겨줄 수 있다   setTimeout ,  setInterval 로 구현해도 되는거 아니냐! 라고 할수도 있겠지만  rAF 는 앞의  set~ api 와는 동작하는 방식이 다르기 때문에 이러한 차이가 있다. 자바스크립트는 기본적으로 싱글스레드로 동작하는데  setTimeout ,  setInterval api 는 지정해준 시간이 지나면 해당 콜백함수들을  task queue 에 넣어주는데, 이전에 큐에 쌓여있던 함수에서 지연될 가능성을 배제하지 못하기 때문에 지정해준 타이머에 명확히 실행해준다는 보증이 없다. 그에 비해  rAF 는  Animation frames 라는 브라우저 렌더링과 관련된 task를 별도로 처리하는  queue 를 통해 실행시점을 보증할 수 있다.   rAF 와 묶여 있는 내용들은 브라우저의 렌더링 과정(+  reflow ,  repaint ), 자바스크립트의 동작방식(이벤트 루프), 큐의 우선순위( Micro Task Queue ,  Animation Frames ,  Task Queue ) 등으로 참고하면 좋다. HTMLCollection vs NodeList querySelectorAll 과  getElementsByClassName HTMLCollection, NodeList 두 객체의 공통점 둘 다 DOM API가 여러 개의 결과값을 반환하기 위한 DOM 컬렉션 객체이다. 또한, 둘 다 유사 배열 객체이면서 이터러블이다. 따라서 둘 다  for ...of  문으로 순회할 수 있다.  Array.from  메서드나  스프레드 연산자 를 사용하여 배열로 만들 수 있다.  item()  메서드는 두 객체에 모두 있는 메서드다. 첫 번째 인자로 받는 index 값에 해당하는 아이템을 반환한다. HTMLCollection  getElementsByTagName ,  getElementsByClassName  메서드를 통해 반환된다.  children  프로퍼티를 통해 반환된다. children 프로퍼티가 반환하는 HTMLCollection 에는 텍스트 노드가 포함되지 않는다. Live 객체이다.(객체가 스스로 실시간 노드 객체의 상태 변경을 반영한다) Live 객체라는 특성 때문에, 반복문을 순회하다가 부작용이 발생할 수 있다. 이에 대한 해결책은  for 문을 역방향으로 순회  하거나  while 문을 사용하여 객체에 노드 객체가 남아 있지 않을 때까지 무한 반복하는 방법등으로 회피 할 수도 있다. 더 간단한 해결책은 부작용의 원인인  HTMLCollection  객체를 사용하지 않고, 배열로 변환하는 것이다. 그러면 유용한 배열의 고차함수(forEach, map, filter, reduce 등)을 사용할 수 있다. 또는  querySelectorAll  메서드를 사용하여  NodeList  객체를 반환받아 사용할 수도 있다. forEach() 메서드를 갖고 있지 않다.(배열로 만들어야 사용 가능) 객체의 각 요소에는 배열의 인덱스로 접근하거나, 객체의 속성에 접근하듯이  .[속성명] 의 방식으로 접근할 수도 있다. HTMLCollection 객체에만 있는 메서드로는  namedItem() 가 있다. 요소의  name  어트리뷰트의 값이 있는 경우에 이 메서드를 이용하여,  namedItem() 의 첫 번째 인자가  name  어트리뷰트의 값과 일치하는 요소를 반환한다. NodeList  querySelectorAll  메서드를 통해 반환된다.  childNodes  프로퍼티를 통해 반환된다. childNodes 프로퍼티가 반환한 NodeList에는 요소 노드뿐만 아니라 텍스트 노드도 포함되어 있을 수 있다. 대부분 Non-live 객체이다(노드가 변경되어도 그 상태를 반영하지 않는다). 다만,  childNodes  프로퍼티는 live 객체이므로 주의가 필요하다. forEach(), entries(), keys(), values() 메서드를 갖고 있다.(이외에 배열의 고차함수는 배열로 변환해야 사용 가능) 결론 이처럼 HTMLCollection이나 NodeList 객체는 예상과 다르게 동작할 때가 있어 다루기 까다롭고 실수할 수 있다. 또한, 각 객체마다 메서드를 어느 정도 제공하기는 하지만,  배열 의 고차함수(forEach, map, filter, reduce 등)만큼 다양한 기능을 제공하진 않는다. 그러므로 노드 객체의 상태 변경과 상관없이 안전하게 DOM 컬렉션을 사용하고 유용한 고차함수를 사용하려면, HTMLCollection이나 NodeList 객체를  배열 로 변환하여 사용하는 것이 좋다.  Array.from 메서드 나  스프레드 연산자 를 사용하여 간단히 배열로 변환할 수 있다. DOM 이벤트 이벤트를 설정하는 것은  인라인 attribute 이벤트 핸들러 ,  속성 이벤트 핸들러 ,  addEventListener()  메서드를 사용하여 수행될 수 있다. 이 중에서 addEventListener() 사용이 권장된다. addEventListener()에서 세 번째 매개변수는 이벤트가 이벤트 흐름의 캡처 단계(true)에서 발생될지, 버블링 단계(false)에서 발생될지를 가리키는 Boolean 값이다. 요즘 브라우저에서는 해당 매개변수가 생략될 경우 기본 값이 false이다. 이벤트 흐름   이벤트가 발생되면 DOM을 따라 흘러가거나 전파되면서 다른 노드와 개체들에서 동일한 이벤트를 발생시킨다. 이벤트 흐름은 캡처 단계나 버블링 단계, 혹은 양쪽 모두로 발생되도록 프로그래밍할 수 있다.  이벤트 수신기 제거 수신기가 익명 함수로 추가되지 않았다면,  removeEventListener() https://developer.mozilla.org/ko/docs/Web/API/EventTarget/removeEventListener 이벤트 개체에서 이벤트 속성 얻기 기본적으로 이벤트에서 호출되는 핸들러나 콜백 함수에는 이벤트와 관련된 모든 정보를 갖고 있는 매개변수가 전송된다.  addEventListener() 사용 시 this 값 addEventListener() 메서드에 전달되는 이벤트 수신기 함수 내부에서 this 값은 이벤트가 연결된 노드나 개체에 대한 참조가 된다.   event.currentTarget  속성을 사용해도 this 속성이 제공하는 것과 동일하게 참조를 얻을 수 있다.  이벤트가 호출된 노드나 개체가 아닌 이벤트의 대상을 참조  event.target  속성은 이벤트가 발생된 노드나 개체(즉, 대상)에 대한 참조를 제공한다. 이벤트 흐름에서 이벤트의 진원지를 파악할 때 유용하다.  preventDefault()를 사용하여 기본 브라우저 이벤트 취소 브라우저는 HTML 페이지를 사용자에게 보여줄 때 사전에 구성된 여러 이벤트를 제공한다. 이러한 브라우저 이벤트는 이벤트 핸들러 함수 내부에서  preventDefault()  메서드를 호출해서 막을 수 있다.  그러나 preventDefault() 메서드는 이벤트가 전파(버블링, 캡처)되는 것을 중지시키지는 않는다.  이벤트 수신기의 끝 부분에서 false를 반환해도 preventDefault() 메서드를 호출하는 것과 같은 결과를 갖는다.  stopPropgation()을 사용하여 이벤트 흐름을 중지 이벤트 핸들러/수신기 내에서 stopPropagation()을 호출하면 캡처/버블링 이벤트 흐름 단계가 중지된다.  그러나 노드나 개체에 직접 연결된 이벤트는 여전히 호출된다. stopImmediatePropagation()을 사용하여 동일한 대상의 이벤트 흐름뿐만 아니라 다른 유사 이벤트도 중지  stopImmediatePropagation()  메서드를 호출하면, 이벤트 흐름 단계를 중지시키는 것뿐만 아니라, 이 메서드를 호출한 이벤트 수신기 이후에 연결되어 호출되는 이벤트 대상의 다른 유사 이벤트도 중지시킨다. 그러나  stopImmediatePropagation() 을 사용하더라도 기본 이벤트는 막지 않으므로,  preventDefault() 를 추가로 호출해야만 브라우저 기본 이벤트를 막을 수 있다. 사용자 정의 이벤트  document.createEvent() ,  initCustomEvent() ,  dispatchEvent() 를 조합해서 사용하면 사용자 정의 이벤트를 addEventListener에 연결해서 호출할 수 있다. 이벤트 위임(delegate) 이벤트 위임은 이벤트 흐름을 활용하여 단일 이벤트 수신기가 여러 개의 이벤트 대상을 처리할 수 있게 하는 프로그래밍 행위를 말한다.  이벤트 위임의 부수 작용은 이벤트가 생성될 때 이벤트에 응답하기 위해 이벤트 대상이 DOM 내에 있을 필요가 없다는 것이다.  이것이 가능한 이유는 이벤트 흐름 때문이며, 특히 그 중에서도 버블링 단계 때문이다. Reference DOM을 깨우치다(코디 린들리 / O&#39;REILLY) Document 노드 HTMLDocument 생성자(document로부터 상속됨)는 DOM 내에 DOCUMENT_NODE(ex, window.document)를 생성한다.  Document 및 HTMLDocument 생성자는 보통 HTML 문서를 로드 시 브라우저에 의해 인스턴스가 만들어진다.  document 속성  document.doctype 은 &lt;!DOCTYPE&gt;을 참조한다.  document.documentElement 는  &lt;html&gt; 을 참조한다.  document.activeElement 를 사용하면, 문서 내에서 포커스되어 있거나 활성 상태인 노드에 대한 참조를 얻을 수 있다.  document.hasFocus()  메서드를 사용하면, 사용자가 현재 해당 HTML 문서가 로드된 창에 포커스를 두고 있는지 여부를 알 수 있다(return boolean).  document.defaultView  속성은 최상위/전역 객체(브라우저에서 window 개체)를 가리킨다. Element 노드 HTML*Element HTML 문서 내의 각 element들은 고유한 성질을 가진다.  DOM에서 각 element가 고유한 Javascript 인터페이스/생성자를 통해 만들어진다. 예를 들어,  &lt;a&gt;  element는 HTMLAnchorElement() 생성자를 통해 DOM 노드로 만들어진다.  HTML*Element는 HTMLElement, Element, Node, Object로부터 속성 및 메서드를 상속받았다. https://html.spec.whatwg.org/multipage/indices.html#elements-1 Element의 속성과 메서드 Element 노드는 브라우저가 HTML 문서를 해석해서 문서 콘텐츠를 기반으로 대응되는 DOM을 만들 때 인스턴스화된다.   attributes  속성을 통해 Element의 Attribute 노드의 유사 배열 컬렉션을 얻을 수 있다. Attribute의 값을 획득,설정,제거하려면  getAttribute(), setAttribute(), removeAttribute()  메서드를 사용할 수 있다.   hasAttribute() 메서드를 사용하여 Element가 특정 attribute를 가지고 있는지 확인할 수 있다. Class Attribute 값 리스트를 얻기 위해  classList 속성을 사용할 수 있고, 이는 유사 배열 컬렉션이다. 읽기 전용이지만 add(), remove(), contains(), toggle() 메서드를 사용해서 변경할 수 있다. 참고로  className  속성은 공백으로 구분된 문자열 값을 반환한다. dataset 속성은 element에서 data- 로 시작하는 모든 attribute를 가진 개체를 제공해준다. dataset은 data attribute들의 camelCase 버전을 갖는다. 예를 들어  data-hello-marco 에서 하이픈(-)은 cameCasing으로 대체되어  element.dataset.helloMarco 가 된다. DOM에서 data-  attribute를 제거하려면, dataset 속성에 대해 delete 연산자를 사용하면된다( delete element.dataset.helloMarco ). Element 노드 선택 특정 Element 노드 참조 얻기  querySelector() 나  getElementById()  메서드를 사용할 수 있다.  querySelector()  메서드는 CSS Selector 문법 형식의 매개변수를 받는다. 예를 들어,  #score&gt;tbody&gt;tr&gt;td:nth-of-type(2) 를 전달하면 해당 단일 element의 참조를 얻는다. 그리고 selector를 기반으로 문서 내에서 발견되는 첫 번째 노드 element를 반환한다.  Element 노드 리스트를 선택하고 생성  querySelectorAll() ,  getElementsByTagName ,  getElementsByClassName()  메서드를 사용하여 NodeList를 생성한다( childNodes  속성도 이들처럼 NodeList를 반환한다). element 노드에서  children  속성을 사용하면, element 노드의 직계 자식 노드 전체 리스트(HTMLCollection)을 얻는다. children은 element가 아닌 노드(ex, text노드, comment노드)는 제외된다.  사전에 구성되어 있는 Element 노드 선택하는 유사 배열 리스트가 다음과 같이 존재한다.  document.all ,  document.forms ,  document.images ,  document.links ,  document.scripts ,  document.styleSheets 인라인 CSS 스타일은 element 노드 개체에 존재하는  style  개체의 속성으로 각자 표현될 수 있다.  style 개체에 포함된 속성명에는 CSS 속성명에서 일반적으로 사용되는 하이픈(-)이 포함되지 않고, camelCase로 변환되어 있다. (ex, backgorund-color는 backgroundColor이다.) 또한 측정 단위가 있는 CSS 속성은 적절한 단위를 포함해야 한다(ex, style.width = &#39;300px&#39;;) NODE    DOM(Document Object Model, 문서 개체 모델)은 자바스크립트 NODE 개체의 계층화된 트리다.  Node는 자바스크립트 생성자 함수에 불과하다. 따라서 Node는 자바스크립트의 다른 개체들처럼 Object.prototype으로부터 상속받는다. 노드 개체 유형  노드 유형 형식은 모두 대문자이며 _로 단어를 구분한다. 이는 브라우저 환경에서 Node 개체의 속성으로 기록되며, 상수로 표현된다.  이러한 nodeType 상수는 단지 특정한 자바스크립트 인터페이스/생성자로부터 생성되는 노드가 유형을 기술하는 데 사용되는 숫자 분류에 불과하다.  해당 노드 개체의 루프를 돌면서 모든 속성 및 메서드(상속받은 것 포함) 이름를 확인 노드의 유형과 이름 식별 console.log(document.nodeName, document.nodeType) // #document 9 console.log(document.createDocumentFragment().nodeName, document.createDocumentFragment().nodeType) // #document-fragment 11 console.log(document.querySelector(&#39;body&#39;).nodeName, document.querySelector(&#39;body&#39;).nodeType) // BODY 1 console.log(document.querySelector(&#39;body&#39;).firstChild.nodeName, document.querySelector(&#39;body&#39;).firstChild.nodeType) // #text 3   call(), apply() 또는 Array.from()을 사용하여 유사 배열 리스트인 노드 컬렉션을 배열로 변환할 수 있고, 이를 통해 노드 컬렉션도 Array 개체가 제공하는 메서드들을 접근할 수 있게 된다.  DOM 내의 노드 탐색 다음 속성을 통해 DOM을 탐색하여 다른 노드에 대한 참조를 얻을 수 있다. parentNode, firstChild, lastChild, nextSibling, previousSibling, childNodes 위 속성은 element 노드뿐만 아니라 text나 comment 노드도 탐색하는데, 이를 원치 않는다면 다음 속성을 사용하여 text와 comment 노드를 무시하고 DOM을 탐색할 수 있다. parentElement, firstElementChild, lastElementChild, nextElementChild, previousElementSibling, children,  Node 위치 및 동일 여부 확인  contains()나 compareDocumentPosition()으로 DOM 트리 내의 Node 위치를 확인할 수 있다.  isEqualNode() 메서드를 호출하면 매개변수로 전달하는 노드와 동일한지 확인할 수 있다. 두 노드가 동일하려면 여러 조건(형식, nodeName, localName, namespaceURI, prefix, nodeValue, NameNodeMaps, childNodes NodeLists 등 동일)이 만족되어야 한다. Reference DOM을 깨우치다(코디 린들리 / O&#39;REILLY) 위키백과 JavaScript로 DOM을 렌더링하기 Javascript로 DOM 화면을 렌더링하기 위해 관련 메서드를 찾다가 유사하면서도 다른 여러 메서드들을 알게 됐다. Element.innerHTML, Element.insertAdjacentHTML, Node.appendChild 등 관련 메서드가 있는데, 메서드를 살펴보기 전에 Element와 Node가 무엇인지부터 체크하자. EventTarget vs Element vs Node   EventTarget EventTarget 인터페이스는 이벤트를 수신할 수 있고, 수신한 이벤트에 대한 수신기(listener)를 가질 수 있는 객체가 구현하는 인터페이스이다. EventTarget의 자식으로 Node나 Window가 있다. 주요 메서드로는  EventTarget.addEventListener() ,  EventTarget.removeEventListener() ,  EventTarget.dispatchEvent()  등이 있다. Node Node는 부모인 EventTarget으로부터 속성을 상속받았다. Node는 여러 가지 DOM 타입들(Document, Element, CharacterData, DocumentFragment, DocumentType)의 부모로서, 여러 DOM 타입들은 Node로부터 속성을 상속받아 비슷하게 처리될 수 있다. Node는 속성이나 메소드가 적합하지 않은 경우에 null을 반환할 수 있다. 주요 속성으로는  Node.childNodes ,  Node.parentNode ,  Node.firstChild ,  Node.lastChild ,  Node.nextSibling ,  Node.previousSibling ,  Node.textContent 이 있다. 주요 메소드로는  Node.appendChild() ,  Node.cloneNode() ,  Node.hasChildNodes() ,  Node.insertBefore() ,  Node.removeChild() ,  Node.replaceChild() 참고로 DOM(문서 개체 모델, Document Object Model)은 자바스크립트 Node 개체의 계층화된 트리다. Element Element 예시 :  &lt;body&gt; ,  &lt;a&gt; ,  &lt;p&gt;  등과 같은 노드  참고로 Element 노드는 아니지만 Node 중에  window.document  등과 같은 Document 노드, 줄바꿈과 공백을 포함한 텍스트인 Text 노드,  class=&quot;cool&quot; 과 같은 Attribute 노드 등도 있다) Node와 EventTarget은 Element의 부모이므로, Element는 Node와 EventTarget의 속성을 상속한다.   Element는 Document 안의 모든 객체가 상속하는 제일 범용적인 클래스로서 공통 메서드와 속성만 갖고 있다. Element의 속성을 상속받은  HTMLElement 나  SVGElement 도 있다.  주요 속성으로는  Element.classList ,  Element.id   Element.innerHTML ,  Element.outerHTML  등이 있다. 주요 메서드로는  EventTarget.addEventListener() ,  Element.insertAdjacentElement() ,  Element.insertAdjacentHTML() ,  Element.querySelector() ,  Element.remove()  등이 있다. Element.innerHTML innerHTML은 Element의  속성 이며, Element 내에 포함된 HTML(또는 XML) 마크업을 가져오거나 설정한다. 구문 element.innerHTML = htmlString;     Node.appendChild()  appendChild() 메서드는 한 노드 개체를 DOM 트리인 특정 부모 노드의 자식 노드 리스트 중 마지막 자식으로 붙인다.  만약 인자로 주어진 노드가 이미 문서에 존재하는 노드를 참조하고 있다면 appendChild() 메소드는 해당 노드를 현재 위치에서 새로운 위치로 이동시킨다.(만약 인자로 주어진 노드가 이미 부모를 가지고 있다면 우선 그곳에서 삭제되고 새로운 위치로 이동된다. 따라서 문서에 존재하는 노드를 다른 곳으로 붙이기 전에 부모 노드로부터 지워버릴 필요가 없다.)  [참고] 즉, 한 노드는 문서상의 두 지점에 동시에 존재할 수 없다.   appendChild()와 비슷한 메서드로서 Node.insertBefore()가 있다. Node.insertBefore(삽입될 노드, 삽입될 노드가 앞으로 올 참조 노드) 메서드는 두 번째 매개변수가 전달되지 않을 경우, appendChild()처럼 동작한다.  구문 innerHTML, innerAdjacentHTML, appendChild 성능 비교 innerHTML이 비교적 느리고, insertAdjacentHTML이 비교적 빠른 편이다. innerHTML은 무겁고 비싼 대가를 치르는 HTML 파서를 호출하기 때문에, 만약 텍스트 노드 정도 삽입하는 경우에는 textContent를 사용하는 것이 낫다.   Reference  https://developer.mozilla.org/ https://www.measurethat.net/Benchmarks/Show/16493/1/innerhtml-vs-insertadjacenthtml-vs-appendchild-vs-inser 문제 일단 EOL이 뭐야? 파일마다 EOL을 넣어야 하는 이유 [해결방법] 파일마다 EOL을 자동으로 넣도록 설정 파일마다 직접 매번 개행을 꼼꼼히 해주거나... .prettierrc (또는 .prettierrc.json) 파일(객체 내부)의 &quot;endOfLine&quot;프로퍼티를 &quot;auto&quot;로 설정한다.   OS마다 다른 EOL 방법 기종이나 운영 체제에 따라 EOL을 나타내는 코드가 다를 수도 있다.  윈도우 : CRLF(\r\n) 유닉스 : LF(\n) 맥OS : LF(\n) 버전 9까지는 CR, 이후부터는 LF CR, LF, CRLF ?   LF는 프린터에서 종이가 한 줄씩 인쇄되며 나오는 것을 뜻한다. 커서는 그 자리에 그대로 둔 상황에서 종이만 한 줄 올려 줄을 바꾸는 동작이다. CR은 프린터에서 실제 인쇄를 수행하는 장치가 한 줄의 끝에서 시작 위치로 돌아가는 것을 뜻한다. 현재 커서를 한 줄 올림 없이 가장 앞으로 옮기는 동작이다. CRLF(\r\n)는 CR(\r)과 LF(\n)를 합친 조합이다. 타자기 이후 컴퓨터에서 줄바꿈을 할 때 CRLF를 사용하기도 했으나, 메모리 절약 등을 이유로 CR 혹은 LF를 사용하게 되었고, 위에서 살펴본 것처럼 운영체제별 사용하는 EOL이 다르다. 운영체제마다 다른 EOL로 인한 문제 위에서 살펴본 것처럼 윈도우에서는 EOL을 전통적인 방식의 CRLF를 사용하는 반면, 유닉스나 맥에서는 LF를 사용한다는 차이가 있다는 점이다. 이 때문에 EOL을 CRLF로만 인식하는 에디터(메모장)의 경우 유닉스 계열 운영체제에서 작성한 문서를 열면 모두 한 줄로 나오고 깨지게 된다. [해결방법] git에서 CRLF 관련 문제 해결 autocrlf 설정 사용 윈도우로 개발하는 분과 협업하면 EOL이 다른 문제가 생긴다. 위에서 살펴본 것처럼 윈도우는 EOl로 CR과 LF를 다 사용하지만, 맥과 유닉스는 LF만 사용하기 때문이다.  Git은 Checkout(저장소에서 가져올 때)할 때 LF를 CRLF로 변환해주고,  Commit(저장소로 보낼 때) 시 자동으로 CRLF를 LF로 변환해주는 autocrlf 기능이 있다. git config --global core.autocrlf true git config --global core.autocrlf input git global config 구성 후에는 코드를 다시 pull해와야 한다. 파일 끝에 개행을 추가해야 하는 이유 파일마다 EOL(End Of Line)을 왜 넣어야 할까 Formatting and Whitespace git 에서 CRLF 개행 문자 차이로 인한 문제 해결하기 새줄문자 class-based components   React.16.8 이전에는 &#39;state&#39;와 &#39;side effect&#39;를 관리하려면 클래스형 컴포넌트를 사용했어야 했다. 하지만 React 16.8에서 함수형 컴포넌트를 위한 &#39;React Hooks&#39;가 도입되어 클래스형 컴포넌트를 사용할 이유가 없어졌고 이제는 함수형 컴포넌트만 거의 사용한다. 클래스형 컴포넌트는 React Hooks을 사용할 수 없다. 클래스형 컴포넌트는 render() 메서드(예약어)를 사용하여 렌더링할 수 있다. 클래스형 컴포넌트로 작성된 기존의 리액트 레거시 코드 등에 대한 이해를 위해 클래스형 컴포넌트에 대하여 알아두는 것도 좋다. 클래스 기반 컴포넌트 추가하기 props -&gt; this.props State 및 이벤트 작업하기 render 메서드 내부에는 함수를 추가하지 않는다. 기술적으로는 가능하나, 제대로 작동하지 않을 수 있다. 클래스형 컴포넌트에서는 컴포넌트를 구성하는 모든 state를 하나의 객체로 그룹화해야 한다. constructor에서 this.state에 그 객체를 할당한다. this.state에서 이름 state는 정해진 것이다. 그리고 state를 변경할 때는, this.setState() 메서드를 사용하여 변경한다. 컴포넌트 수명 주기(클래스 컴포넌트에만 해당!) componentDidMount() react에서 import한 &#39;component&#39;를 extends를 하자마자 이 메서드를 사용할 수 있다. 컴포넌트가 마운트되면, 이 메서드가 호출된다. useEffect(..., []) componentDidUpdate() 컴포넌트가 업데이트되면 호출된다. useEffect(..., [someValue]) 의존성 배열이 변경될때마다 useEffect 함수가 재실행되는 것과 유사하다. 위와 같은 useEffect 훅을 클래스형 컴포넌트에서는 아래와 같이 componentDidUpdate를 사용하여 동일한 효과를 낼 수 있다. componentWillUnmount()  이 메서드는 DOM에서 컴포넌트가 제거되기 직전에 호출된다.  useEffect(() =&gt; {return () =&gt; {...}}, []) useEffect의 cleanup함수와 비슷하다. cleanup함수는 effect 함수가 다시 실행되기 직전이나, 컴포넌트가 DOM에서 제거되려고 할 때 다시 호출된다.  state가 모든 컴포넌트 인스턴스에 대해 독립적으로 작동하는 것처럼, 이 메서드는 모든 컴포넌트 인스턴스에 대해 실행된다. 클래스 컴포넌트에서 context 연결하기 users-context.js App.js static contextType = UsersContext; this.context.users 컴포넌트에 대한 불필요한 재평가 방지를 위한 최적화 방법(React.memo())  export default React.memo(DemoOutput);  그렇다면 모든 컴포넌트를 최적화하면 되지 않을까? 하지만 최적화를 하는 데에는 조건이 있다. 자식 컴포넌트가 많아서 컴포넌트 트리가 크면 React.memo가 유용하다. 컴포넌트 트리의 상위에서 컴포넌트 트리의 불필요한 가지를 재실행하는 걸 방지한다. 대규모 앱은 불필요한 재평가 방지를 위해 컴포넌트 트리 가지를 잘라내는 것이 좋다. 반면, 부모 컴포넌트를 재평가할 때마다 컴포넌트나 컴포넌트의 props가 계속 변하는 경우라면, React.memo는 효율적인 선택이 아니다. 왜냐하면 컴포넌트가 다시 실행될 때마다 props 값을 비교한 데이터가 저장되는데, 비효율적이기 때문이다. 물론 앱 규모에 달렸다. 모든 컴포넌트에 React.memo를 쓰기보다 컴포넌트 트리의 뿌리를 골라서 자식 컴포넌트의 가지를 잘라 내는 것이 자식 컴포넌트를 다 실행하는 것보다 더 효율적이다.  props 값에 변하지 않은 함수만 들어있음에도 불구하고 리액트에서 props 값이 변경되었다고 보고 컴포넌트가 재실행 및 재평가되는 이유는 객체인 함수는 매번 실행할때마다 재생성되어 이전과 다르다고 판단되기 때문이다. useCallback()으로 함수 재생성 방지하기 useCallback()을 사용함으로써 객체인 prop 값에 대해서도 React Memo가 작동하도록 만들 수 있다. 객체들을 만들고 저장하는 방식을 useCallback 후크로 조금 수정하면 된다. useCallback은 기본적으로 컴포넌트 실행 전반에 걸친 함수를 저장하는 후크이다. 즉 React에 함수를 저장하여 이 함수를 매 실행마다 재생성하지 말라고 알리는 것이다. 그러면 동일한 함수 객체 중 하나가 메모리 내의 동일한 위치 중 하나에 저장되고, 그렇게 항상 동일한 함수 객체를 재사용할 수 있다. 사용 방법은 저장하고 싶은 함수를 useCallback()의 첫 번째 인수에 넣어주고, 두 번째 인수에는 의존성 배열을 주입하며 함수에서 사용하는 모든 state, props, context를 배열에 넣어준다. 이 상황에서는 해당 함수가 절대 변경되지 않는 것임을 전제하였으므로, 의존성에 빈 배열만 넣어줘도 된다. 그래서 앱 컴포넌트가 리렌더링될 때 동일한 함수 객체가 재사용된다. 리액트가 실제로 어떻게 작동하는가 React React는 유저 인터페이스를 만드는 자바스크립트 라이브러리다. React는 컴포넌트를 활용하여 효율적으로 유저 인터페이스를 만들고 업데이트한다. React는 컴포넌트와 state를 관리하는 라이브러리일뿐이다. React는 컴포넌트의 현 state와 전 state의 차이점을 찾아낸다. React는 데이터에서 변경된 내용을 바탕으로 화면에 뭘 나타낼지 정한다. 그렇게 정한 내용을 인터페이스(ReactDOM에게)에 보낸다. React는 props를 다루며, props는 부모 컴포넌트에서 전달된 데이터로서 부모와 자식 컴포넌트를 연결한다. React는 컴포넌트 내부 데이터인 state와 컴포넌트 전반에 영향을 미치는 context 데이터를 다룬다. props, state, context가 변할 때마다 React가 그것들을 쓰는 컴포넌트를 업데이트하고, 컴포넌트가 화면에 새로운 내용을 띄우려는지 확인한다. 만약 새 내용이 있다면, React가 ReactDOM에 전달하여 새 화면(컴포넌트)를 화면에 띄우도록 요청한다. React는 컴포넌트 트리가 현재 어떻게 생겼고 어떻게 보일지 결정한다. React는 props,sate,context가 변할 때마다 컴포넌트 함수를 재실행하며, 컴포넌트를 재평가한다. 하지만 컴포넌트에 대한 재평가와 DOM에 대한 리렌더링은 서로 같지 않다. React가 컴포넌트를 재평가하더라도, Real DOM의 모든 부분이 리렌더링되고 재평가되진 않으며, 변화된 부분만 효율적으로 리렌더링된다. ReactDOM ReactDOM은 웹의 인터페이스다. 실제 HTML요소를 화면에 불러오는 역할을 한다. ReactDOM은 브라우저의 일부인 Real DOM을 다룬다. 그래서 ReactDOM은 유저가 보는 화면에 무슨 내용을 띄울지 정한다. ReactDOM은 차이점을 받고, Real DOM을 조정한다.     컴포넌트와 Real DOM의 차이점을 구분해야 한다.  컴포넌트 컴포넌트는 props, state, context가 바뀔 때마다 재평가된다. 그다음 리액트가 컴포너트 함수를 실행한다.  Real DOM Real DOM은 리액트가 컴포넌트의 이전 state와 현재 state를 비교한 뒤 차이점(state, prop, context)이 있을 때만 업데이트된다. 즉, Real DOM은 필요할 때만 가끔 바뀌는데, 이는 효율 면에서 중요한 개념이다. 전 state와 현 state를 가상으로 비교하는 것은 메모리에서만 처리할 수 있어서 비용이 저렴하지만, Real DOM의 내용을 브라우저에 나타내는 것은 복잡하기 때문에 비용이 더 비싸다. 브라우저에 작은 변화라도 여러 번 일어나면 Real DOM을 너무 많이 써서 페이지가 느려질 것이기 때문에, Real DOM은 필요할 때만 가끔 바뀐다.   Real DOM 렌더링 예시 이전 평가 결과 현재 평가 결과 (&lt;p&gt;This is new!&lt;/p&gt;) 만을 삽입한다. DOM 전체를 리렌더링하진 않는다. 1. 함수형 프로그래밍 개요 함수형 프로그래밍 기법은 리액트 뿐 아니라 리액트 생태계를 이루는 여러 라이브러리의 근간이다. 함수가 1급 시민이 되면 변수에 함수를 대입할 수 있고, 함수를 다른 함수에 인자로 넘길 수 있으며, 함수에서 함수를 만들어서 반환할 수 있어야 한다. 자바스크립트에서는 함수가 1급 시민이기 때문에, 자바스크립트가 함수형 프로그래밍을 지원한다고 말할 수 있다. 1급 시민이라는 말은 정수나 문자열 같은 다른 일반적인 값과 마찬가지로 함수를 취급할 수 있다는 뜻이다. 함수를 객체, 배열, 다른 함수의 인자에 넣을 수 있다. 또한, 함수가 함수를 반환할 수 있다. 특히, 함수가 함수를 인자로 받는 경우와 함수가 함수를 반환하는 경우를  고차함수  라고 부른다. 이처럼 함수에 2개 이상의 화살표가 있다면 고차 함수를 사용하고 있다는 뜻이다. 2 명령형 프로그래밍과 선언적 프로그래밍 비교 프로그래밍 패러다임을 크게  선언적 프로그래밍 과  명령형 프로그래밍 으로 나눌 수 있다. 함수형 프로그래밍은  선언적 프로그래밍  의 방법 중 하나이다.  선언적(declarative) 프로그래밍 은  필요한 것을 달성하는 과정을 하나하나 기술하는 것 보다 필요한 것이 어떤 것인지를 기술하는 것에 더 방점을 두고 애플리케이션 구조를 세워나가는 프로그래밍 스타일이다. 선언적 프로그래밍의 코드 구문은 어떤 일이 발생해야 하는지에 대해 기술하고, 실제로 그 작업을 처리하는 방법은 추상화를 통해 아랫단에 감춰진다. 선언적 접근 방식이 더 읽기 쉽고, 그렇기 때문에 더 추론하기 쉽고, 그 애플리케이션의 규모를 확장하는 것도 더 쉽다.  명령형(imperative) 프로그래밍  은 코드로 원하는 결과를 달성해 나가는 과정에만 관심을 두는 프로그래밍 스타일이다. 3 함수형 프로그래밍의 개념 함수형 프로그래밍의 핵심 개념으로 불변성(immutability), 순수성(purity), 데이터 변환(transformation), 고차 함수, 재귀(recursion) 등이 있다. 3.1 불변성 함수형 프로그래밍에서는 데이터가 변할 수 없다. 그래서 원본 데이터 구조를 변경하는 대신 그 데이터 구조의 복사본을 만들되 그중 일부를 변경한다.  그리고 원본 대신 변경한 복사본을 사용해 필요한 작업을 진행한다. [객체] [배열]  const addColor = (title, list) =&gt; [...list, {title}]; 3.2 순수 함수 순수 함수(Pure Functions)는 파라미터에 의해서만 반환값이 결정되는 함수를 뜻한다. 이는 함수형 프로그램의 핵심 개념 중 하나이다.  순수함수에는 부수 효과(side effect)가 없다. 부수 효과란 전역 변수를 설정하거나, 함수 내부나 애플리케이션에 있는 다른 상태를 변경하는 것을 말한다. 순수 함수는 인수를 변경 불가능한 데이터로 취급한다.  순수함수 규칙 순수 함수는 파라미터를 최소한 하나 이상 받아야 한다. 순수 함수는 값이나 다른 함수를 반환해야 한다. 순수 함수는 인자나 밖에 있는 다른 변수를 변경하거나, 입출력을 수행해서는 안된다.  리액트에서는 UI를 순수 함수로 표현한다.  순수 함수를 사용하면 애플리케이션의 상태에 영향을 미치지 않기 때문에 코딩이 편해진다. 다음은 DOM을 변경하는 순수하지 않는 함수의 예시이다. 이 함수는 함수나 값을 반환하지 않으며(규칙2 위반), DOM을 변경하는 부수 효과를 발생시키기(규칙3 위반) 때문에, 순수하지 않은 함수이다. 리액트 등에서 UI로 사용할 순수함수의 예시는 다음과 같다. 부수 효과를 발생시키지 않고 엘리먼트를 반환한다. 이 함수는 엘리먼트를 만드는 일만 책임지며, DOM을 변경하는 책임은 애플리케이션의 다른 부분이 담당해야 한다.  const Header = (props) =&gt; &lt;h1&gt;{props.title}&lt;/h1&gt; 3.3 데이터 변환 함수형 프로그래밍은 한 데이터를 다른 데이터로 변환하는 것이 전부다. 함수형 프로그래밍은 함수를 사용해 원본을 변경한 복사본을 만들어낸다. 그런 식으로 순수 함수를 사용해 데이터를 변경하면, 코드가 덜 명령형이 되고 그에 따라 복잡도도 감소한다. 자바스크립트 내장 함수를 사용하여 데이터 변환하여 다른 데이터를 만들어낼 수 있다. 새 값을 반환하는 Array.join, Array.filter, Array.map, Array.reduce, Array.reduceRight 3.4 고차 함수 고차 함수는 다른 함수를 조작할 수 있는 함수다.  고차함수는 다른 함수를 인자로 받을 수 있거나 함수를 반환할 수 있고, 때로는 그 2가지를 모두 수행한다. 예를 들어, Array.map, Array.filter, Array.reduce는 다른 함수를 인자로 받기 때문에, 모두 고차 함수다. 다른 함수를 반환하는 고차 함수는 자바스크립트에서 비동기적인 실행 맥락을 처리할 때 유용하다. 함수를 반환하는 고차 함수를 쓰면 필요할 대 재활용할 수 있는 함수를 만들 수 있다. 커링  커링(Currying)  은 고차 함수 사용법과 관련한 함수형 프로그래밍 기법이다. 커링은 어떤 연산을 수행할 때 필요한 값 중 일부를 저장하고, 나중에 나머지 값을 전달받는 기법이다. 이를 위해 다른 함수를 반환하는 함수를 사용하며, 이를 커링된 함수(Curried fucntion) 라고 부른다. 3.5 재귀 재귀는 비동기 프로세스에서도 잘 작동하는 또 다른 함수형 기법이다. 함수는 필요할 때 자기 자신을 다시 호출할 수 있다.  3.6 합성 함수형 프로그램은 로직을 구체적인 작업을 담당하는 여러 작은 순수 함수로 나눈다. 그 과정에서 언젠가는 모든 작은 함수를 한데 합칠 필요가 있다.  합성 방법으로 체이닝 등이 있으나, 함수를 더 큰 함수로 조합해주는 compose와 같은 커스텀 함수를 사용할 수 있다. compose는 여러 함수를 인자로 받아서 한 함수를 결과로 내놓는다.  compose 함수 예시 책 [러닝 리액트]에서 발췌 요약한 내용입니다.   다익스트라(Dijkstra) 알고리즘 이번에 만드는 다익스트라 알고리즘은 ‘그래프’와 ‘우선순위 큐(이진 힙 버전)’ 개념을 이해하고 있어야 한다. 다익스트라 알고리즘은 그래프의 두 개의 정점 간에 최단 경로를 찾는 알고리즘이다.  기본 논리 루프를 돌면서, 새로운 노드를 방문할 때마다 기록된 거리가 가장 짧은 노드부터 먼저 확인한다. 방문할 노드로 이동한 후 각 노드에 인접한 이웃 노드들을 차례로 확인한다. 각 이웃 노드에 대해 시작 노드에서부터 현재 보고 있는 노드까지 이어지는 전체 거리를 합산한다. 현재 보고 있는 노드까지의 새로운 거리가 기존에 최단거리로 기록된 값보다 작으면, 새로운 더 짧은 거리를 저장한다. 가중 그래프(Weighted Graph) 다익스트라 알고리즘는 가중 그래프를 기반으로 한다. 예를 들어, A 장소(vertex1)와 B 장소(vertex2) 사이의 ‘거리’를 weight로서 간선에 추가해줘야 한다. 우선순위 큐(PriorityQueue) 단순히 배열로 우선순위 큐를 구현한 코드다. 성능이 더 좋은 이진 힙으로 구현한 우선순위 큐는  이진 힙 포스팅 에서 확인할 수 있고, 그 PriorityQueue 클래스를 아래 코드와 교체하기만 하면 된다. 일단, 다익스트라에 집중하기 위해 우선순위 큐는 다음과 같이 간단히 구현하고 넘어간다. 다익스트라 알고리즘 코드   코드 실행 결과   그래프 순회(Graph Traversal) 그래프에서 순회하는 코드를 짤 때, 루트가 있는 트리와는 달리 시작점을 정해줘야 한다. 그래프의 한 노드에서 다른 노드로 갈 때 유일한 하나의 길만이 있다는 보장은 없다. 이미 방문한 노드를 다시 방문해야 할 수도 있다. 그래프 순회 사용 예시 P2P 네트워킹 웹 크롤러 최단 거리 찾기   DFS(깊이우선탐색) Explore as far as possible down one branch before &quot;backtracking” DFS(깊이우선탐색)은 다른 형제를 방문( backtracking)하기 전에 한 브랜치에서 가능한 가장 아래까지 깊이 탐색한다. DFS와 BFS 모두, 매개변수로 시작점을 받고 순회하면서 방문한 정점을 추적한다는 점들은 같다. 아래와 같은 그래프에서 A부터 순회를 시작하는 과정을 살펴보자. 방문한 곳들의 노드를 인접리스트에서 지워나가야 한다.  아래 이미지는 A와 B 노드를 방문하고 이제 B에서 다음으로 방문할 노드를 결정해야 하는 상황이다. 인접리스트에는 A와 B가 삭제되어 있다. B에서 다음으로 방문할 노드는 인접리스트[B]에 남아 있는 ‘D’ 가 된다. 이러한 로직을 인접 리스트의 배열(각 정점의 간선)들에서 값이 남지 않을 때까지 반복한다.   DFS - 재귀형 코드 depthFirstRecursive 메서드 코드 메서드 실행 결과 확인 DFS - 순환형 코드 depthFirstIterative 메서드 코드 코드 실행 결과 코드의 작동 방식 때문에, 재귀형 코드와 달리 순회 순서가 달라지긴 했으나, 두 방법 모두 DFS 방식인 것은 동일하다.   BFS(너비우선탐색) BFS(너비우선탐색)은 현재 같은 높이(height)의 이웃 정점들을 먼저 방문하는 알고리즘이다. 아래 코드에 주석을 달긴 했지만, BFS 순환형 코드는 DFS 순환형 코드와 거의 비슷한다. 다른 점은 while 조건문에서 순회하는 개념으로 stack 대신 queue를 사용하고 이를 위해 pop 메서드 대신 shift 메서드를 쓴다는 것이다. 코드 실행 결과 메서드 내부에서 실행된 콘솔로그까지 포함한 코드 실행 결과는 아래 이미지와 같다. queue에서 제일 앞 정점부터 초록선으로 shift하며 순회하는 모습이다. 지금 방문한 정점과 간선으로 이어진 정점들을 돌리는 forEach문에서 queue에 push되는 정점들이 neighbor 옆에 찍혔다.   그래프(Graph) 자료구조 이전에 살펴본 트리는 그래프의 일종이다. 그래프는 트리를 포괄하는 개념이다. 그래프를 코딩하는 방법은 여러 가지가 있으나,  인접 리스트(Adjacency List)  를 사용하여 그래프를 만들어본다. 그래프는 유한한(가변적인) 꼭지점(노드)들의 집합으로 구성된 데이터 구조다. 이 꼭지점들의 집합에 순서가 없는 경우에는  무방향 그래프(Undirected graph)  이고, 순서가 있는 경우에는  방향 그래프(Directed graph) 라고 한다. 즉, 그래프는 노드와 노드들의 연결을 모은 것이다. 아래와 같은 이미지도 유효한 그래프다. 트리와 달리 부모 노드 같은 것은 없다. 그래프에서 노드는 모두 똑같이 취급되며, 단지 서로 다른 방식으로 연결될 뿐이다.   그래프 활용 사례 소셜 네트워크 지도 길 찾기 라우팅 알고리즘 추천 알고리즘  그래프 구조로 장르들의 관계를 모형화하여 시각화한 웹 사이트 그래프 관련 용어  Vertex(정점)  : 노드, 위 그림에서 동그라미  Edge(간선)  : 노드 사이의 연결, 위 그림에서 노드를 잇는 줄  Undirected/Directed(무방향, 방향) 무방향 그래프는 양방향 연결이다. 간선에 방향이 없다. 방향 그래프는 간선에 정해진 방향(화살표)이 있다.    Weighted/Unweightet(가중, 비가중) 가중 그래프는 간선에 값이 부여된 그래프다.   인접 리스트(Adjanceny List) 그래프의 노드와 간선 관계를 아래 이미지처럼 해시 테이블을 이용한 인접 리스트로 저장할 수 있다. 만약 아래 예시에서 C노드와 다른 노드들 간 간선을 확인하려면, 인접리스트의 ‘C’ 키에 있는  [&#39;B&#39;, &#39;D&#39;]  밸류를 통해  C 노드는 B노드 및 D노드와 연결되어 있다.   그래프의 기본 구조(Constructor) 이번엔 무방향 그래프를 만든다. 정점 추가 메서드(addVertex) 정점 추가 메서드는, 입력 받은 정점이 인접리스트에 없으면 인접리스트에 정점 key에 빈 배열을 value로 지정해준다.   간선 추가 메서드(addEdge) 간선 추가 메서드는, 추가하려는 간선으로 이어진 두 개의 정점을 입력받고, 이들을 인접리스트에서 서로의 정점의 배열에 push하도록다.   간선 제거 메서드(removeEdge) 간선 제거 메서드는, 제거하려는 간선으로 이어진 두 개의 정점을 입력받고, 인접리스트의 각각 정점들의 value에서 상대 정점만 제외하여 반환(filter 메서드 사용)된 배열을 재할당한다.   정점 제거 메서드(removeVertex) 정점을 제거하려면, 정점과 연결된 모든 간선들을 제거하고 그 정점도 삭제해야 한다.   코드 실행 결과 해당 클래스의 인스턴스 메서드들을 아래와 같이 실행하면, 주석과 같은 그래프 자료구조가 만들어진다. Prologue Velog 글 작성법 (마크다운 문법) 1. Headings(제목,주제) #을 사용하여 제목의 크기를 정합니다. 1~6개의 #으로 제목 텍스트를 설정할 수 있습니다.  2개 이상의 headings를 사용할 경우, 자동으로 contents table을 생성해 줍니다. Contents table 각각의 headings 를 클릭하면 해당 section으로 이동합니다. ⌨️ 입력   🖥 출력 The largest heading The second largest heading 3333333333333333333 444444444444444444444 555555555555555555555 The smallest heading6  ***  으로 글에서 회색 구분선을,  &lt;br&gt; 로 줄바꿈 을 할 수 있습니다.  2. Styling text(글꼴 스타일) 글꼴 스타일 지정하여 텍스트를 강조할 수있습니다.  bold(굵게), italic(이탈릭체), strikethrough(취소선) Style Syntax Keyboard shortcut Example Output Bold ** ** or __ __ Command + B (MAC) or  Ctrl+B (Windows/Linux)  **This is bold text**  This is bold text Italic * * or _ _ Comand + I (MAC) or  Ctrl+I (Windows/Linux)  *This text is italicized*  This text is italicized Strikethrough  ~ ~  ~~This was mistaken text~~  This was mistaken text Bold and nested italic ** ** and _ _  **This text is _extremely_ important**  This text is  extremely  important All bold and italic  *** ***  ***All this text is important***   All this text is important       3. Quoting text(인용문) 텍스트를  &gt; Text that is not a quote &gt; Thext that is a quote   Text that is quote 추가적으로 중복하여 사용할 수 있습니다.  ⌨️ 입력    🖥 출력 Text that is quote Quote that is in quote 4. Quoting code(코드 인용) 하나의 backticks  `  으로 문장내 코드 또는 명령을 작성할 수 있습니다. backticks 내의 텍스트들은 포맷되지않고 그대로 출력됩니다. `  git status   `  to list all new or modified files that haven&#39;t yet been committed.  🖥 출력 Use  git status  to list all new or modified files that haven&#39;t yet been committed. 코드나 텍스트를 독립적인 블록에 작성하고 싶다면 3개의 backticks  ` 를 사용해 보세요! ⌨️ 입력   🖥 출력   4.1 Syntax highlighting(문법 강조)  추가적인 언어 구별자를 사용해 코드 블럭 에서 syntax 강조를 할 수 있습니다.  ⌨️ 입력       🖥 출력 5. Links(링크) 인라인 링크를 작성하려면 대괄호  []  로 묶은후 URL을 ()로 묶은후 입력하면 됩니다. I like [Github Pages](https://pages.github.com/). I like [Velog](https:https://velog.io/). Github Pages Velog . 6. Images(이미지)  ! 입력후  [ ]  를 입력하고 이미지 링크를 입력하면 이미지를 띄울 수 있습니다. 컴퓨터에 있는 파일을 올리면 자동으로 링크를 생성해줍니다. ⌨️ 입력  ![](https://images.velog.io/images/jay_/post/dcf7c78c-a924-4aa2-8e47-c23fc426a668/velog_logo.png)   6.1 Images 크기 조절 html 을 활용하여 작성하면 width, height를 px,%등으로 입력하여 사이즈를 조절할 수 있습니다. &lt;img src=&quot;https://images.velog.io/images/jay_/post/dcf7c78c-a924-4aa2-8e47-c23fc426a668/velog_logo.png&quot; height=&quot;20%&quot; width=&quot;20%&quot;&gt;  🖥 출력 💡 height, width 뿐만 아니라 align값을 right, left를 입력하면 오른쪽, 왼쪽정렬이 가능합니다!  7. Lists(목록)  -  또는  *  사용하여 순서없는 목록을 만들 수 있습니다.  George Washington  John Adams  Thomas Jefferson      🖥 출력  George Washington  John Adams  Thomas Jefferson 순서가 있는 목록은 각 행 앞에 숫자를 붙이면 됩니다. James Madison James Monroe 🖥 출력 James Madison James Monroe John Quincy Adams First list item First nested list item Second nested list item     🖥 출력 First list item First nested list item Second nested list item 8. 이모티콘 .   9. Tables(표) 파이프  |  와 하이픈  - 을 사용하여 table을 만들 수 있습니다.  - 은 각 열의 헤더를 만들때,  | 는 각 열을 구분하는데 사용합니다. (테이블윗줄이 비어있어야 합니다.) ⌨️ 입력   🖥 출력 Command Description  git status List all  new or modified  files  git diff Show file differences that  haven&#39;t been  staged 다음과 같이 오른쪽, 왼쪽 중앙 정렬도 가능합니다. ⌨️ 입력   🖥 출력 Left-aligned Center-aligned Right-aligned git status git status git status git diff git diff git diff 10. 수식 수식은 보통 논문에서 많이 보게되고 이에 작성의 필요성을 느껴 추가합니다. velog 에서 수식 작성은 KaTex 라이브러리를 이용하여 작성할 수 있습니다. 일반적으로  $$  태그를 사이에 두고 작성합니다. (관련 내용 업데이트는 velog 공식 블로그에 간략하게 나와있습니다.)   예시1  ⌨️ 입력    예시2     https://katex.org/docs/supported.html 참고자료 https://velog.io/@kim-mg/velog-%EA%B8%80%EC%93%B0%EA%B8%B0-markdown-%EC%9E%91%EC%84%B1%EB%B2%95 https://velog.io/@baekmoon1230/Markdown-%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%81%AC%EA%B8%B0-%EC%A1%B0%EC%A0%88-%EC%A0%95%EB%A0%AC https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code https://velog.io/@velog/v2-update#10-%EC%82%AC%EB%9D%BC%EC%A7%84-%EA%B8%B0%EB%8A%A5%EB%93%A4 좀더 읽어볼만한 자료 https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting https://velog.io/@wonhs717/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4Markdown-%EB%AC%B8%EB%B2%95-ytk5zemk0x     Epilogue  Velog ..  그리고 블로그 첫 글을 작성해 보았습니다. 글재주가 없고, 마크다운 작성법을 공부해 가면서 작성하느라 시간이 조금 걸렸습니다. 부족하거나 틀린부분있으면 편하게 말씀해주시면 감사드리겠습니다! 현재 이미지 크기조절이 잘 안되네요.. 참고하시길 바랍니다.  그런 개발자로 괜찮은가 - &#39;이력서&#39; 편 이 글은 작년에 포트폴리오를 만들었지만 내용이 부실함을 깨닫고 열심히 리모델링한 내용입니다.   바뀐 포트폴리오   반응은 좋았지만 내용은 좋지 않았다. 💡 빛 좋은 개살구 같은 나의 포트폴리오 작년 여름에 4학년 1학기가 끝나고 그래도 포트폴리오 하나는 가지고 있어야 되지 않겠어? 하는 마음에 포트폴리오의 핵심도 알지 못한 채 그냥 만들었습니다. 그렇게 두 달 동안 열심히 만든 포트폴리오는 반응이 정말 좋았습니다.  반응이 좋았던 포트폴리오 회고록  예전 포트폴리오   그 중에서도 제일 와닿았던 댓글입니다. decody:  모션이나 애니메이션도 UX를 풍부하게 해주지만, 모션이나 인터렉션에 대한 가이드(어포던스)를 제공해주는 게 중요하다고 생각합니다. 보통 주니어 분이 기술스택 표현할 때 템플릿 등에 있는 퍼센트바를 사용하는데, 저런거 의미없어요. 시니어급들이 평가할 때 차라리 strong, knowledgeable, experienced 이런 식으로 구분해서 하는 훨씬 효과적일 겁니다. 그냥 프로젝트에서의 사용경험, 해당 프레임워크나 라이브러리에 대한 지식, 그런 것들로 구분하는게 낫습니다. 결국 포트폴리오 사이트의 목적은 job을 얻거나 프로젝트를 잡으려고 하는 것이므로, 그 목적성에 부합하게 설계하고 텍스트를 작성하면 되는 것입니다. 많은 생각을 하게되었습니다. 그냥 내가 스타일링일 좀 한다는 걸 보여주고 싶어서 만들었구나 하는 생각이 들면서 포트폴리오의 본질에 대해서 조금 더 깊게 생각했습니다. 그리고 저 때 당시로 포트폴리오를 만들었는데, 내가 이걸 입사 지원할 때 제출해도 괜찮을까? 하는 의문이 들었습니다. 그만큼 제 스스로도 내용이 부실하다는 걸 알고 있었던 것 같습니다. 좋은 포트폴리오는 무엇일까? “개발자 포트폴리오&quot; 라고 구글에 검색하면 많은 글들을 볼 수 있습니다.   그 중에서 정말 좋았던 글 몇 개만 올려보겠습니다.  개발자 이력서 작성하기 (feat. 이력서 공개) | Wonny(워니님)  그런 개발자로 괜찮은가 - &#39;이력서&#39; 편 | 태태태님  이직초보 어느 개발자의 이력서 만들기 | 구인본  이력서 관련 포스팅 | Outsider님 여러 글들에는 “좋은 포트폴리오&quot;에 대해서 얘기하지만 읽다보면 정답은 없는 것 같았습니다. 하지만 다들 추구하는 방향은 같았습니다. 1. 나를 가장 잘 아는 거울  필자가 생각하는 이력서의 정의는 ‘나를 알리는 수단’ 보다 ‘나를 가장 잘 아는 거울’이라 생각한다. 특히 개발자에게는 더욱더. 무엇을 개발해왔고 어떤 기술을 써 왔으며 어떤 경험이 있는지 어느 곳에 작성을 하지 않으면 더듬더듬 기억으로 나 자신을 알기엔 요즘은 봐야 할 정보가 많은 세상이 되어버렸기 때문이다.  태태태님의 그런 개발자로 괜찮은가 - &#39;이력서&#39; 편의 개발자에게 이력서란?에서 포트폴리오는 &quot;내가 스타일링을 정말 잘 해!&quot;(저는 그렇게 만들었습니다.)를 알리는 수단이 아니라, 무엇을 개발해왔고, 어떤 기술을 사용했으며, 어떤 경험을 했는지 알리는 수단입니다. 2. 인상적인 첫 페이지 우선 자신을 알리는 즉, 이 이력서를 보게 되는 사람에게 가벼운 인사말과 나 자신을 소개하는 몇 가지 포인트로 서두를 구성한다. 3. 필수적인 것들만, 심플해야 한다.   가능한 짧게  쓴다. 불필요한 내용을 다 쳐낸다. 정보를 추가할 때마다 이 정보가 목적(인터뷰/과제 기회를 얻는 것)에 도움이 되는지를 자문해본다. 이 목적에 부합하지 않는 내용은 과감히 지운다.  필자는 이력서를 잘 쓰는 방법 중에 가장 중요한 건  ‘심플’ 해야 한다고 생각한다. 나 이것도 했고 저것도 했고 주절주절 일기를 쓰는 게 아니라 정말 중요한 꼭지(Point)를 찾고 간결하고 명료한 문장으로 한눈에 들어올 수 있도록 구성이 필요하다.  태태태님의 그런 개발자로 괜찮은가 - &#39;이력서&#39; 편 어떻게 써야 할까?에서 4. 읽는 사람이 잘 읽히도록 만들기.  생각해보았습니다. 만약 첫 페이지에서 관심을 가지고 다음 페이지를 넘길 때 독자가 기대하는 것이 무엇일까? 어렸을 때부터… 이런 건 아닐 테고, 내 사생활, 구체적인 인적사항도 아니라고 생각했습니다. 최근에 했던 프로젝트부터 보여주고 점점 거슬러 올라가면서 개발이력들을 펼치기로 했습니다.  구인본님의 이직초보 어느 개발자의 이력서 만들기, 독자가 관심 있어 할 내용 순으로에서 좋은 포트폴리오 와는 정반대였거든요. 그래서 아예 싹 갈아엎기로 했다. 인상적인 첫 페이지 BEFORE   AFTER   연락처들 첫 페이지로 이동 저의 연락처와 블로그 주소같은 것들을 맨 첫 페이지로 올렸습니다. 문구 변경 그리고 문구를 바꿨습니다. 조금 더 저의 정체성이 들어나고, 제 가치관을 느낄 수 있는 문구 로 바꿨습니다. 최근 업데이트 날짜 표시 계속해서 업데이트가 되고 있다는 것을 어필하기 위해서 넣었습니다. 사진 사실 사진같은 경우는 여러 글들에서도 의견이 나뉘었는데, 넣어도 된다는 의견과 굳이 넣을 필요가 없다는 의견이었는데 저는 넣었습니다. 제주도를 갔다온 사진인데, 제 좋은 추억을 조금이나마  공유 읽는 사람이 잘 읽히도록 만들기 사실 이 부분을 제일 신경을 많이 썼습니다. 스킬 progress bar 삭제   그 대신에 프로젝트에서 사용한 스킬들을 왜 넣었는지 간략하게 설명을 적었습니다.   구조 변경 전 포트폴리오에서는  Introduction  -  skill  -  project  -  contact 그래서 결과적으로는  Work(경력)  -  Project(프로젝트들)  -  Share(블로그, 유튜브)  -  Education(교육)  -  OpenSource(오픈소스) 순으로 작성을 했습니다. Table of Contents   각각 섹션의 목록을 한 눈에 볼 수 있게끔해서 현재 어디 위치에 있는지 쉽게 알 수 있도록 했습니다. 모바일 반응형 디자인 적용 모바일에서도 볼 수 있도록 반응형 디자인을 적용했습니다. 피드백을 받았다.  이력서를 작성했다면 반드시 다른 사람에게 피드백 받기를 추천한다. 이력서는 온전히 다른 사람이 읽을 문서이기 때문에 다른 사람의 의견이 큰 도움이 된다. 내 이력서도 피드백을 통해 정말 많이 개선됐다. 피드백이 없었다면 절대 지금과 같은 결과가 없었을 것이라 확신할 정도로 피드백을 통해 좋아졌다.  워니님의 개발자 이력서 작성하기 (feat. 이력서 공개), 이력서를 다 쓰고 나면: 반드시 피드백 받기에서   인프런 멘토링에서 포코님과 캡틴 판교님에게 포트폴리오가 어떤 부분이 부족하고, 어떤 부분이 괜찮은지 피드백을 받았습니다. 소개 섹션에서 아래로 향하는 화살표가 있어야 할 것 같다. “나&quot;에 대한 얘기를 조금 더 했으면 좋겠다. 몇몇 스타일 오류 수정하기. 멋진 포트폴리오만큼 훌륭한 실력을 갖추도록 노력하자. 이건 나의 스토리, 여러분의 스토리를 만드세요. 좋은 이력서보다 더 중요한 것. 💡 좋은 이력서와 그에 맞는 실력이 중요하다. 실력을 키우면 된다. 저도 이렇게 포트폴리오를 만들었지만 프로젝트 부분에서 많이 부족한 것 같습니다. 예를들면 개선했던 부분들, 어떤 문제가 있었고 문제를 어떻게 해결했나? 이런 부분들이 있으면 좋은데, 아직 사례가 없어서 못 적고 있네요... 그래서 어떻게 하냐구요? 좋은 포트폴리오를 작성하는 것도 중요하지만 그냥 우리의 실력을 계속해서 키워나가면 됩니다. 📌 테오 구글 스프린트 4기   구글 스프린트 과정을 수요일부터 일요일까지, 하나의 간단한 프로젝트를 도출해내는 과정을 겪어봤습니다.  테오의 엄청난 진행력 주말이 사라지는  좋은 경험을 했고, 좋은 사람들을 알 수 있고, 결과적으로 우리가 처음에 계획했던 NPM 배포도 성공적으로 해보았으니 대만족하고 있습니다.  우리가 만든 라이브러리: react-season-component 우리가 만든 공식문서: react-season-component-web 우리가 어떤 것을 했는지는  테오가 정말 설명을 잘 해놨으니 , 이 글에서는 스프린트 회고에 집중하지 않고 NPM 배포는 어떤 식으로 이루어지는지, 어떤 것을 해야하는지에 그리고 각각의 과정에서 우리는 어떤 실수를 했는지에 대해서 집중을 해서 글을 써보겠습니다. 개발 환경 바로 시작해보겠습니다. 📌 npm    NPM 은 무엇일까요? npm은 Node Package Module (Node Package Manager)의 줄임말로 우리가 사용하는 라이브러리들이 이 곳에 배포가 되어있습니다. 리액트  또한 이 곳에 배포되어 있고, 하나의 명령어로 React 개발 환경설정을 다 해주는  create-react-app  또한 npm에 배포가 되어있습니다. 우리도 npm에 배포를 해서 다른 사람들이  npm install 라이브러리 명  명령어를 통해서 내 라이브러리를 설치해서 사용하게 할 수 있습니다. 📌 npm 계정 생성 NPM에 계정을 만들어봅시다. NPM 공식 홈페이지에 접속 해서  회원가입  버튼을 클릭해서 회원가입을 진행합니다.   📌 npm 로그인 우리가 만든 계정으로 로그인 해봅시다. npm 계정을 생성하고, npm 웹 페이지에서 로그인을 하는 것이 아니라 로컬 터미널에 로그인을 해야합니다.  $ npm login 위 명령어를 터미널에 입력을 하게 되면 각종 정보들을 입력하게 됩니다.     📌 프로젝트 설정 npm을 배포하기 위한 프로젝트를 생성해봅시다. create-react-app 을 통해서 만들어보겠습니다. TypeScript 요즘 프로젝트들은  TypeScript TypeScript 를 지원해주지 않는다면 많은 프로젝트에서 우리의 라이브러리를 사용할 수 없습니다. 그래서 언어는  JavaScript 가 아닌  TypeScript 를 통해서 라이브러리를 만들어보죠.  $ npx create-react-app [프로젝트 명] --template typescript tsconfig.json  다양한 tsconfig 컴파일러 옵션 Npm을 타입스크립트로 배포하기 위해서 몇 가지 타입스크립트 설정을 해야합니다.  1.  &quot;noEmit&quot;: false    noEmit * 2.  &quot;declaration&quot;: true  *  .d.ts true 로 주어야 합니다.  3.  &quot;outDir&quot;: &quot;./dist&quot;    tsc dist  폴더에 두기 위해서 위와 같이 작성합니다. * 4.  &quot;include&quot; 속성  *  tsc src  폴더에서  lib  폴더를 생성해서 그 안에서 개발을 할 겁니다. 그래서 아래와 같이 작성을 합니다.  &quot;include&quot;: [&quot;./src/lib/**/*.tsx&quot;, &quot;./src/lib/**/*.ts&quot;] 완성된 모습은 다음과 같습니다. (create-react-app typescript version 기준) package.json  package.json docs package.json의 여러가지 옵션들 프로젝트가 생성되었다면  package.json package.json  1.  &quot;name&quot;    &quot;name&quot;: &quot;react-hyeonsu-component&quot;   react-hyeonsu-component 라고 작명 해보았습니다. 라이브러리 이름은 꼭 npm에 먼저 쳐보세요.    2.  &quot;version&quot;    &quot;version&quot;: &quot;0.0.1&quot;   major | minor | patch  순으로 적습니다.  주의할 점:  3.  &quot;private&quot;    &quot;private&quot;: false   우리는 중앙 저장소인 npm에 배포하기 위해  private  옵션을  false 로 변경해주세요.  4.  &quot;main&quot;    &quot;main&quot;: &quot;dist/index.js&quot;   dist dist  폴더에 있는  index.js  5.  &quot;types&quot;    &quot;types&quot;: &quot;dist/index.d.ts&quot;   우리는 타입스크립트를 지원하기 위해서 타입 추론을 도와주는 진입점 파일을 명시해줍니다.  주의할 점:  package.json이 &quot;files&quot; 프로퍼티를 포함하고 있으면 &quot;types&quot; 프로퍼티는 무시됩니다. 이 경우 메인 선언 파일을 &quot;files&quot; 프로퍼티에 전달해야 합니다.  6.  &quot;browser&quot;    &quot;browser&quot;: &quot;./browser/specific/main.js&quot;   우리는 브라우저에서 구동되는 라이브러리를 제공해야 하기 때문에  browser  필드도 설정해야 합니다.  참고  제가 main 필드도 없애보고, browser 필드도 없애보고, 둘 다 없애보고, 둘 다 넣어보고 했는데 둘 다 있어야 잘 작동합니다.  7.  &quot;scripts&quot;      prepare  스크립트를 추가해놓아야 합니다.  rm -rf dist  명령어로  dist 폴더를 삭제하고  mkdir dist  명령어로 다시  dist  폴더를 만들고 다시 만들어진 폴더에  tsc  명령어로 컴파일을 진행해서 나온 파일들을  dist 에 넣는 과정입니다. npm 배포를 하기전에 실행하는 명령어 입니다. 정말 별 것 없지 않나요? 추가적으로  package.json 에 넣으면 좋을 내용을 적어보았습니다.  1.  description      2.  keywords    &quot;keywords&quot; : [&quot;react&quot;, &quot;component, &quot;background&quot;, &quot;animation&quot;]      3.  author   프로젝트 작성자 정보로, 한 사람만을 지정합니다. JSON 형식으로 name, email, url 옵션을 포함합니다.  4.  repository        5.  contributors   프로젝트에 참여한 공헌자 정보로, 여러 사람을 배열로 지정할 수 있습니다.   .npmignore npm에 배포하지 않을 파일을 명시해줍니다. 우리는  dist  폴더를 제외하고 나머지  src  폴더,  public  폴더,  tsconfig 과 같은 것들은 우리 라이브러리에 포함시켜 라이브러리 크기를 키울 필요가 없습니다. 라이브러리에서 사용되지 않는 폴더나 파일은 이 곳에서 명시합시다.   📌 개발 진행 설정은 끝났으니 라이브러리로 내보낼 컴포넌트를 개발해봅시다. 우리는 CSS-in-JS 라이브러리인  emotion 을 설치해줍니다.  $ npm install @emotion/react @emotion/styled   라이브러리 개발 폴더는  lib 으로 아까  tsconfig.json lib  폴더를 생성하고, 거기에  index.tsx  파일에 우리가 최종적으로 보내고자 하는 컴포넌트를 내보내면 됩니다. 우리는 간단하게 제 이름으로 된  Hyeonsu  컴포넌트를 만들어보겠습니다. src/lib/Hyeonsu/index.tsx   간단히 컴포넌트를 만들었고, 내보내고 있습니다. src/lib/Hyeonsu/styled.tsx   저는 스타일 코드 파일을 따로 분리하는 것을 좋아하기 때문에 다음과 같이 분리했습니다. src/lib/index.tsx   그리고 여러 컴포넌트를 내보낼 가능성을 생각해,  index.tsx  파일을 두고 최종적으로 컴포넌트를 내보내고 있습니다. 폴더 구조는 간단히 이렇게 생겼습니다.   이렇게 하면 우리는 npm에 라이브러리를 내보낼 준비가 되었습니다. 📌 빌드 및 npm 배포 우리가 만든 라이브러리를 빌드하고, 배포를 진행해봅시다.  npm publish  명령어를 입력해서 배포를 하면 됩니다. 그럼  dist  폴더를 생성하고, 빌드해서 알아서 배포를 진행할거에요   그럼 정말 끝났습니다! 📌 사용해보기 잘 만들어졌나 확인해볼까요?   저는 새롭게 프로젝트를 파서  npm install react-hyeonsu-component  명령어를 통해서 설치를 해보았습니다. 잘 설치가 되네요!   컴포넌트를  export default 가 아닌  export   우리가 원하는대로 잘 만들어진 것을 볼 수 있습니다. 📌 오픈소스에서 중요한 것    The State of JS 2021 | Other Tools 섹션 이번  State of JS 2021  에서  Library Evaluation Rankings , 라이브러리를 평가하는데 중요한 요소가 무엇인지에 대한 설문이 있었습니다. 공식문서 컴포넌트 라이브러리를 만들었다면 컴포넌트의 속성을 변경시키며 사용해볼 수 있는 공식문서를 만들어보세요. 그리고 사용방법과 종류에 대해서도 설명을 잘 해놓는다면 유저가 쉽게 접근 할 수 있을거에요. README.md README 파일은 라이브러리의 얼굴입니다. 깃허브에서 사용자들이 라이브러리를 찾고, 맨 처음 보게되는 것이 README 파일이기 때문에 각별히 신경을 써야합니다. 우리 라이브러리의 정체성을 잘 표현하고, 사용법과 설명을 적어보세요. 유명 라이브러리들의 README를 참고해서 작성을 해보세요. 라이센스 라이센스는  ‘해야할 것’과 ‘하지 말아야할 것’에 대한 약속 Github 문서에 의하면, 라이센서가 없으면 기본 저작권법이 적용되지만, 라이센스를 선택하게 됨으로써 코드의 모든 권리는 내가 가지고 다른 사람이 내 코드를 복제, 배포, 재생산을 할 수 없으니 오픈소스 프로젝트는 오픈소스 라이센스를 선택하라고 권장하고 있습니다.  참고: Github license의 종류와 나에게 맞는 라이선스 선택하기 Contribute 오픈소스는 혼자 만들 때 보다, 같이 만들 때 그 가치가 더욱 빛납니다. 혼자해서 키워나가는 것 보다는, 나는 그런 구조를 만들어놓고 사람들이 자발적으로 도와주도록 만들어 놓으면 내가 들이는 시간은 줄이면서 더욱 라이브러리를 단단하게 만들 수 있습니다. 📌 Boiler Plate  Boiler Plate Repository fork  후에,  clone package.json 의 라이브러리 이름과 버전들을 바꾸어 가면서  npm publish 아,  npm login  잊지 마시구요! 📌 우리가 겪었던 문제 라이브러리를 테스트할 땐 dist 폴더를 확인하면 됩니다. 만든 라이브러리를 테스트 하기 위해선 우선 생성된 dist 폴더를 테스트 해보면 됩니다. 굳이 npm에 배포하고 난 다음에 다른 프로젝트에서 라이브러리를 설치해서 테스트해보지 않아도 됩니다. dist파일이 그대로 npm에 배포되기 때문이죠.  하지만 예외는 있습니다.    수 많은 배포 이력들... TypeScript 지원하기 많은 사람들이 타입스크립트를 공부할 예정 이거든요. 전처리가 필요한 SCSS, SASS와 같은 파일들은 Webpack 설정이 필요합니다. 📌 마무리 위의 과정들이 모든 프로젝트에 적용되지는 않습니다. 위의 과정들은  create-react-app  +  TypeScript  +  emotion 를 통해 간단한 컴포넌트를 배포해보고 사용해보는 과정입니다. 위의 과정에서 CSS-in-JS가 아닌 CSS, SASS, SCSS를 사용한다면 여러가지 전처리를 해주어야 하고,  create-react-app이 아닌 vite를 통해 프로젝트를 생성해주었다면 그에 맞는 설정 을 해주어야 합니다. 또한 라이브러리 안에서 사용하는 다른 라이브러리들과의 의존성도 생각해야 합니다. 그리고 컴포넌트 라이브러리가 아닌 다른 편의성을 위한 라이브러리라면 여러 설정도 바꿔주어야 합니다. (node환경인지 browser인지에 따라 설정 값도 바뀌겠죠?) 누구나 할 수 있어요! 이 글의 취지는 npm 배포라는 &quot;큰 벽&quot; 처럼 느껴지는 과정들이 해보면 별 것 아니다 라는 것을 느끼고 여러분들께 소개해주고 싶었습니다. 하고나면 정말 아무것도 아니란 걸 알게될 거에요 여러분들이 자주 사용하는 함수나 컴포넌트와 같은 것들을 라이브러리로 배포해놓고 사용하는 건 어떨까요? 자신이 프로젝트를 진행할 때 가져와서 사용해도 되고, 문서만 작성 잘해놓는다면  ⭐star⭐ 가 올라가는 경험을 할 수도 있습니다. (가슴이 웅장해지지 않나요?) 참고  타입스크립트 핸드북 - Publishing  내 NPM 패키지(모듈) 배포하기  한 눈에 끝내는 Node.js | 07 확장모듈 - npm 활용하기  The State of JS 2021  Github license의 종류와 나에게 맞는 라이선스 선택하기  defunctzombie / package-browser-field-spec Public  npm docs 한 친구의 DM으로 시작된 여정 인프런에 관심이 많은 친구 한명이  동욱(향로) 님을 뵙고 여러가지 질문을 하고, 인프런 방문을 하고 싶어서 별 기대없이 DM을 날렸던 것이 동욱님께서 답장을 주시면서 관심있는 친구들 3명이 더 모여 총 4명이서 대전에서 서울에 가게 되었습니다. 평소에 유튜브 개발바닥, EO 같은 채널을 관심있게 보는 우리에게는 동욱님은 거의 연예인과 같은 존재였는데요, 그냥 저희가 동욱님과 만나서 얘기를 나누고싶다고 무작정 들이밀었는데, 동욱님께서 너무 흔쾌히 받아주시고 따뜻하게 정말 성실히 대답을 해주신 것이 너무나도 감동적이었습니다.  원래는 한시간 계획되어있던 약속이 얘기를 나누다보니 두시간이 넘게 되어서 근무시간인데 동욱님께 방해가 되지 않았을까 걱정했지만 오히려 저희에게 감사하다고 말씀하시는 동욱님을 보면서 한번 더 감탄을 하지 않을 수 없었습니다. 정말로 실제로 봤을 때는 저희가 맨날 유튜브로 인터넷으로만 보던 분이 눈앞에서 움직이니까 정말 연예인을 본 듯한 느낌이었습니다.  이 여운이 가시기 전에 우리가 나눴던 대화들을 조금 공유해보려고 합니다. 해당 글은 인터뷰 내용을 기억나는 대로 재구성한 것이라 일부 틀리거나 다른 내용이 들어있을 수 있습니다! 1. 인프런 사내의 일과는 어떻게 진행되나요?  동욱:  일반 팀원들과 다를 수 있는데 보편적으로 말하면 9시부터 10시 30분까지 출근하고, 7.5시간 (+1.5시간: 점심시간)을 일하게 됩니다. 10시에 출근하면 7시에 퇴근합니다. 10시 출근 기준으로 출근하고 같이 업무 오늘 해야할 것의 리스트를 적고 이거는 필수는 아니에요. 그리고 10씨 30분까지 개인일을 하고, 인프런 개발파트에 20명인데 평일 오후 1시에서 2시에는 자유 질문 시간 자리에 앉아서 질문만 받는 시간을 따로 가져요. 2시부터 6시까지는 면접, 회의, 계속 잡혀있어요 아니면 외부 개발자 미팅을 많이 합니다. 중간중간에 백엔드 개발자 코드를 계속 봐주고있고 프론트 리뷰는 아키텍쳐 설계만 참여해요. 상세하게는 참여하지 않습니다. 그리고 인프런에서는 일주일에 하나씩 주제를 하나 가지고 여러가지 개발 방식으로 개발을 해보고 다 같이 모여서 어떤 방식이 더 나은지 비교를 해보는 시간도 가집니다. 예를 들어 대량의 Input을  React  상태로 받는 예시에서는 상태 관리 도구로  MobX ,  recoil ,  redux ,  context API 로 각각 따로 개발을 똑같이 해보고 어느것이 성능이 좋은지 얘기를 해본다고 합니다. 매일매일 하루일과는 다릅니다. 개발, 코드 리뷰, 회의, 면접 이렇게 하루가 지나갑니다.  서경:  그러면 정해진 퇴근시간은 딱히 정해져 있진 않은 거네요? 예전에 듣기로 인프런 최대 장점 중 하나가 일할 수 있을 때 언제든지 일할 수 있는 문화라고 들었는데요 (웃음)  동욱:  없어요. 대표님이나 저는 보통 퇴근시간이 정해져 있지 않습니다. 세콤으로 관리를 하고 있어서 자기 출근 찍고 일하고, 퇴근할 때도 그냥 하고 싶을 때 일 합니다. 주말에 개인 공부하고 싶을 때 회사에 와서 공부하는 사람들도 있습니다. 2. 결제/스트리밍/쿠폰/회원 관리 등에서 서드파티 서비스를 사용하나요? 만약 그렇지 않다면 부서 관계 없이 모두 다뤄볼 기회가 있을까요?  동욱:  동영상 재생은  video.js 와  player.js 를 쓰고있습니다. 다른 경우에도 대부분 오픈소스 같은 것을 사용합니다.  DRM  기술로는  PallyCon 을 사용합니다. 인프런 사이트 자체는 순수  Vanilla JS 로 되어있어서 쓸수있는 라이브러리는 많이 없습니다.  JavaScript 의 경우에 사용할 수 있는 라이브러리는 대부분  React 나 ,  TypeScript 에 맞춰져 있기 때문에 이 부분은 인프런이 개선해 나갈점입니다. 모든 팀이 파트별로 나뉘어 있지 않습니다. 즉 블로그, 강의 이런 식으로 분야가 나뉘어 있지 않고 전부 개발 팀, 한 팀에 모여있습니다. 현재는 전체적으로 다뤄볼 수 있고 만약에 파트별로 나뉘면 자신의 파트를 6개월에서 1년에 한번씩은 바꾸어서 진행을 할 예정입니다. 3. 신입 개발자에 대한 수습기간이 있는 걸로 아는데, 수습 기간에는 어떤 걸 하게 될까요? 또 어떤 것을 공부 하라고 조언 해주시나요?  동욱:  신입의 교육에 대한건 계속해서 바뀌고 있는 중이며 신입을 어떻게 관리해야 하는지 계속 고민중입니다. 인프런은  Node 를 사용하는 회사이지만, 서경님 같이 신입분이라면  JVM 언어와  Spring 을 공부하는 것을 추천드립니다.  Node  쪽은 컨텐츠가 상당히 부족합니다. 예를 들어  JDBC Internal-타임아웃의 이해 (Naver D2)   이 글이 2011년도 글인데 자바의 경우 이런 자료들이 굉장히 많고, 지금도 계속 생성중입니다. 그러나  Node  입장에서는 이정도 수준의 칼럼 혹은 정보량은 부족할 뿐더러 한글로 된 것은 거의 없다고 봅니다. 관련한 참고 글 :   자바 공화국 이와 같이 커뮤니티적으로  Java 와  Node 가 많이 차이가 납니다. 또 다른 예시로 김영한님의 강의를 보면, 게시물 만들어 보기와 같은 수준이 아니라, 원리와 과정에 대해 깊숙히 다루면서 핵심 구조를 파악할 수 있게 됩니다. 그러나 Node 진영의 경우 ORM이 약하기도 하고, 자세한 수준의 강의는 거의 없다시피 한 것도 큰 이유입니다. 인프런에서는 새로오신 분들 께 과제를 냈을 때  데이터베이스 관련 설정을 해온 사람이 한명도 없었습니다. 그러나  Java 를 사용하던 이전 직장에 있을 때는 여러  timeout 을 비롯한 커넥션 설정들을 해오신 분들이 일부 있으셨습니다. 그런 부분에서도 배우는 지식 또한 차이가 날 수 밖에 없다고 느껴졌습니다. 브라우저에게 있어 상대하는 클라이언트는 단 한 명입니다. 그러나 서버가 감당해야 할 요청은 수천이 될 수도 있고 수만이 될 수도 있습니다.  따라서 그러한 걸 고려한 설계를 해야합니다. 같은 예로  redux 를 활용한  React  상태관리도 클라이언트 하나를 위한 것입니다. 상태를 변경하는 주체도 클라이언트 한명이죠. 그러나 백엔드의 경우 사용자가 수백, 수만명일 수 있기 때문에 상태 관리를 해선 안됩니다. 통신, 타임아웃, 인코딩 등 설정할 게 많은데  Node 가  JavaScript 를 사용하기 때문에 프론트엔드와 백엔드에서 같은 방식을 사용하는 것은 좋은 설계라고 할 수 없습니다.  서경:  그렇다면  JavaScript 를 활용하면 프론트엔드와 백엔드를 모두 사용할 수 있다는 점이 오히려 약점으로 작용할 수도 있다는 말씀이시군요?  동욱:  맞습니다. 프론트엔드와 백엔드가 수행하는 역할은 다르기 때문에 명확히 구분해야 합니다. react에서는 16.8버전 이후로는 함수형 컴포넌트를 권장합니다. 따라서 class를 사용하지 않는 경우가 많은데, 백엔드에서는 OOP가 굉장히 중요한 요소입니다. 이 외에도 프론트엔드에서는 사용자 인터렉션으로 이루어지기 때문에 json 리터럴로 사용하는 경우가 많은데, 백엔드를 하시는 분들이 프론트에서 처럼 모든 값을 json 리터럴로 다룬다면 좋지 않은 방식일 수 있습니다. 참고:  React Hook 개요 (함수형 컴포넌트) 서경님께서 인프런에 희망해서  Node 를 공부한다고 하셨지만 당장 떨어지신다면 갈 곳이 없는 것이 사실입니다. 앞서 말했듯이  Java 에는 좋은 자료들이 매우 많이 있으므로 자주 참고해보시면 좋습니다. 꼭  Java 가 아니더라도  JVM  환경에 대해 공부하는 걸 추천합니다.  TypeScript 를 공부하셨다면  Kotlin 도 접근하기 좋을 수 있습니다 4. 백엔드 신입 개발자에게 요구하는 역량에 대해서  충환:  스프링 관련 영한님 강의를 들으면서 공부하고 있는데 신입에게 어느 정도의 깊이를 요구하는 지를 잘 모르겠습니다.  동욱:  신입 기대치를 생각해서 어느 정도의 실력을 쌓고 신입 공채에 지원하는 것보다는 인턴, 공채 등에 다 지원하면서 그 과정에서 배우는 것이 더 낫습니다. 영한님 강의를 들으신다고 해도 개인 프로젝트를 진행할 때는 이때 배운 내용들이 어느 정도 필요한지 잘 모를 수 있습니다. 실제 개발을 해보면 다양한 요구사항이 있고 여러 상황을 마주치게 됩니다. 실무 개발을 해본 사람은 알겠지만 많은 경험을 쌓아야 할 수 있는 게 많아지기 때문에 스스로 어느 정도는 돼야 어디에 지원한다는 커트라인을 정하게 되면 그 시기가 점점 늦어지므로 항상 지원하며 도전하는 것이 좋습니다. 5. 위의 질문과 연관해서 스프링의 핵심 원리는 이해했는데 코드레벨까지 알아야하나요?  동욱:  코드 레벨까지 알 필요는 없는데 어떤 흐름으로 동작하는지는 확실하게 알아야 합니다. 또한 프레임워크의 핵심 원리를 아는 것도 중요하지만 좋은 코드를 작성하는게 더욱 중요합니다. 개인적으로는 자바지기 박재성님이 운영하시는 넥스트 스텝의   클린코드를 위한 TDD, 리팩토링 with Java  를 추천합니다. 좋은 코드를 작성하는 법, 테스트 하기 좋은 코드를 짜는 법 등을 배울 수 있고 현업에서 일하고 있는 실무진들의 코드 리뷰를 받을 수 있기 때문입니다. 개인 프로젝트를 진행하는 것보다 리뷰를 받는 코스에 참여하는게 실력을 늘리기에 좋습니다. (+우아한 테크 코스도 추천합니다.) 6. NEXTSTEP에 대해서  충환:  작년에는 이것 저것 하느라 경황이 없어서 지원을 못했습니다. 올해 4월에 모집이 또 있는데 동욱님은 어떻게 생각하세요?  동욱:  우아한테크코스와 넥스트스텝이 코치분들은 같고 리뷰어분들이 다릅니다. 운영진이 같기 때문에 우아한테크코스 운영진의 양질의 교육을 받을 수 있습니다. 몇몇 스타트업 또는 빅테크 기업(카카오페이, 11번가)에서 신입개발자 교육을 넥스트 스텝에 맡겼었다고 할 정도로 좋은 교육임을 알 수 있습니다. 7. 백엔드 공부 방향에 대한 추천  충환:  자바를 더 깊게 공부할지, 객체지향 및 테스트 주도 개발을 공부할지 고민입니다.  동욱:  충환님의 수준을 정확히 몰라서 답변하기 애매합니다. NEXT STEP의 교육 과정이 위에서 설명한 것 처럼 정말 구성이 좋기 때문에 진행하면서 어떤 부분이 본인에게 더 필요한지 생각해서 공부하면 좋을 것 같습니다. 8. 트래킹 관련 경험에 대해서  서경:  인프런 채용 공고에 있는 백엔드 개발자의 주요 업무를 보면 모니터링 + 쿼리 관련 성능 개선이 주 업무가 될 것 같은데, 현재 제가 인턴을 하고 있는 스타트업 회사의 경우에는 고객층 자체가 특정 전문 직업군에 한정되어 있어 트래픽 자체가 많지 않아 부하에 대한 모니터링 및 성능에 큰 투자를 하지는 않고, 기능 추가 위주로 task를 받습니다. 따라서 모니터링/로그를 추적해서 성능을 개선하는 task 자체는 받지 않고 있는데 이런 경우에는 어떻게 tracking 관련 실무 경험을 쌓아볼 수 있을까요?  동욱:   모니터링을 하지는 않더라고 로그관리는 무조건 할 겁니다. 그것이 파일로 관리되든, aws cloudwatch로 되던간에. 실제 테스트, 배포환경은 파일이나 실시간 스트리밍으로 로그를 수집하는 형태, 플랫폼에 던지는 것을 선택해야 실제 발생하는 에러를 확인할 수 있습니다. try catch문들을 확인하며 예외처리를 하는 코드를 뜯어보는 것도 좋은 방법입니다. 어떤 곳에서 에러가 생기며 그 에러를 어떻게 처리하는지 확인하면서 실력을 키우는 겁니다. 인턴 과정에서 중요한 것은 업무를 경험해볼 수 있다는 게 아니고, 실력이 뛰어난 다른 누군가의 코드를 많이 볼수있는게 좋은 겁니다. 인턴 경험에서 최대한 다른 사람의 코드를 보면서 배우고, 개인 프로젝트에 적용해 본다면 가장 좋을 것입니다. 예전에 합격했던분들 중 스프링 레거시로 개발하시던 분이 있습니다. 그 분이 하셨던 일들 중 인상 깊었던 건 그 분이 프로젝트를 진행하면서 서버비용을 줄이기 위해 어떤 걸 했었는지 부터 시작해서, 오류가 발생하면 알람을 보내기 위해 어떻게 구축했고, 작은 서비스라도 24시간 동안 무중단 배포하기 위해 어떻게 설계 했는지 등 세세한 히스토리를 모두 개인 블로그에 적어놓으셨는데 이러한 점이 좋은 요소가 되었습니다. 결국 서비스는 실 사용자들에게 어떤 가치를 줄수 있느냐가 중요합니다. 어떤 프레임워크나 라이브러리를 쓰는게 중요한 것은 중요한 것이 아닐지 모릅니다. 따라서 아주 작은 서비스라 할지라도 실제 사용자를 받아보며 좋은 서비스를 제공하기 위해 고민하는 것이 중요하며 좋은 경험이 될 것입니다. 9. RDBMS 인덱스 튜닝 / 쿼리 튜닝 관련 질문  충환:  RDBMS 실행계획을 통한 인덱스 튜닝/쿼리 튜닝 관련해 공부에 도움 될만한 혹은 되셨던 자료를 추천해주실 수 있으신가요?  동욱:  Real MySQL을 추천합니다. 아키텍쳐, 인덱스, 실행계획, 쿼리최적화 부분이 잘 되어 있습니다. 10. 개인적인 공부 방향에 대해서  서경:  제 공부 방향에 대해서도 피드백을 받고 싶은데요, 현재 제 기술 스택을 간략히 말씀드리자면, ts-express, sequelize, java-spring, docker, aws 정도입니다. 여기에 더해 제가 지금 사적으로 따로 하고 있는 프로젝트에서 devops 포지션을 맡게 되어서 k8s + aws에 관해 추가적으로 공부할 계획이고, 이왕이면 시작한 김에 SAA와 CKA까지 따보고 싶습니다. 회사 업무 관련해서는 회사 안에 레거시 코드가 꽤 많은데, 특히 ts 관련해 문제가 있어 보이는 코드들이 많아(ex: 너무 많은 any) ts를 집중적으로 공부하고 있습니다. 또한 ts를 공부하다 보니 OOP관련해서도 공부할 게 많아 OOP도 추가적으로 공부할 계획인데 이 이후에 무엇을 하면 좋을지, 혹은 이 계획에 대해 피드백 해주실 사항이 있으실까요?  동욱:  지금도 이미 너무 많은거같은데요? (웃음) 사람들이 DevOps 직무에 대해 오해하는 게 많습니다. k8s를 하는것도 나쁘지 않지만, 특정 기술에 매몰되는건 좋지 않습니다. 실무에서는 k8s 없이 배포환경을 구축하는 경우도 많습니다. Docker가 대세이긴 하지만, 여전히 Docker 없이 EC2에 직접 배포를 하고 실행하는 환경도 실무에서는 쉽게 볼 수 있습니다. 현재 상황에서 가장 효율적으로 구축할 수 있는 배포환경이 어떤 것인지가 중요합니다. AWS 자격증을 따는 건 괜찮습니다. 다만 탈락률이 꽤 되고 돈이 많이 든다는 것은 감안해야 합니다. 서경님이 백엔드를 지향한다고 말씀하셨기 때문에 우선순위는 좋은 백엔드 개발자되는것이 우선순위입니다. OOP, 계층형 아키텍쳐 구축, 좋은 테스트코드, ORM 등의 역량이 우선시 될 것입니다. 타입스크립트 같은 경우에도 TS eslint, prettier를 활용해 여러 값을 계속 넣어 보면서 강제화 하면서 경험을 쌓을 수 있을 겁니다. OOP에 관한 건 책  오브젝트 를 정말 추천합니다. 이 책은 다른 외국의 원서들보다도 좋은 내용을 포함하고 있어요. 이 책을 보면서 내 코드에 넘겨보는 경험이 필요할 것 같습니다. 테스트코드를 어떻게 하면 잘 짤지에 대해 고민하고 공부해 보는 걸 추천합니다. 예를 들면 Mocking test는 거의 의미가 없고 저장소를 이용한 테스트가 중요한데 왜 그런지 알아야 하는 등이 있을 겁니다. 모킹 vs 저장소를 이용한 테스트 :  https://github.com/woowacourse/jwp-refactoring/pull/12?fbclid=IwAR22hXT931hlXcIuUwTQ2uo536SIU5NWRyfYAzOvhOcs_FUcrkRA_iZfACw#discussion_r503260073 좋은 테스트 코드를 짜려는 생각이 중요하며 코드 자체를 테스트하기 쉬운 코드로 작성하는 것이 중요합니다. 최근에는 신입 개발자라 하더라도 테스트 코드를 작성할 줄 모른다고 하면 붙기가 쉽지 않습니다. 테스트 코드도 Java의 경우가 좋은 자료들이 많기 때문에 다른 커뮤니티의 것들로 공부하는 걸 추천합니다. 영한님 강의를 예시로 들면 영한님 강의같은 경우는 테이블을 기준으로 설계를 시작하는 게 아닌 도메인부터 설계를 시작합니다. 말씀하신 Sequelize의 경우 테이블에 직접적인 영향이 가기 때문에 직접적인 영향이 가는데, 저장소가 Mongo로 바뀌어도 영향이 가지 않을 정도로 객체 설계부터 시작합니다. 테스트 코드에 대해선 .net 공식 문서 같은 것들을 찾아봐도 좋습니다. 공식 문서에 테스트 코드를 어떻게 짜야 하는지 같은 내용들이 잘 나와있습니다. 좋은 코드를 작성한 후에 말씀하신 DevOps 적인 역량을 키우는 것이 낫습니다. 만약 백엔드적인 역량이 부족한데 k8s를 쓴다고 말하면 ‘어림도 없지’라고 생각할 수밖에 없습니다. 사실 질문을 듣고 조금 놀랐습니다. 앞서 충환님이 질문해주신 건 하나를 얼만큼 공부해야 할지 물어보셨는데, 서경님 같은 경우에는 여러 가지를 어떻게 공부해야 할지 물어 보시더라구요. 같은 학교 같은 학과 같은 학번인데 이렇게 상반되는 질문을 하셨는데, 그 이유에 대해서도 한번 고민해보시면 좋을 것 같습니다. 추가) 영한님의 HTTP 강의는 모든 개발자에게 추천합니다.  https://www.inflearn.com/course/http-웹-네트워크 프론트엔드 개발자, 백엔드 개발자 모두 HTTP에 관한 지식은 필수적입니다. 김영한님 강의에서 개발자에게 필요한 내용을 정말 잘 정리되어 있습니다. 꼭 듣길 추천합니다! 11. Rust와 Web Assembly에 대해서 어떻게 생각하시나요?  동욱:   Node 가 나온지는 10년이 넘었습니다. 국내에는 2015년에서 2016년까지  Node 가 핫하게 언급이 되었고 많은 백엔드 개발자들이 뛰어들었고 본인도 역시 그 중 하나였습니다. 하지만 결국 대세가 되진 못했습니다. 지금  Rust 와  Web Assembly 가  Node 가 2015,16년도에 한창 뜨거웠을 때 받았던 그 느낌과 비슷합니다. 대세가 될지 제가 예측할수는 없을것 같습니다. 동욱님의 경험에서 우러나오는 답변을 들을 수 있었습니다. 12. 학생 스타트업에 대해서 질문  유성:  실제 배포하여 서비스중인 스타트업에서 PM을 맡고있습니다. 아키텍쳐, 기술스택 선정과 CI/CD, 모니터링등 부수적인 것들을 적용하며 과연 올바른 방향으로 가고 있는것인지 , 코드리뷰를 진행하면서도 제대로 되고 있는 것인지 생각이 많이 듭니다. 스타트업은 지속적으로 하고 싶으나 위 고민들 때문에 부스트캠프나 취업도 고려하게 됩니다. 선배 개발자로써의 조언을 듣고 싶습니다.  동욱:  가보진 않은 길이지만 성공한 케이스가 많아 개인적인 의견을 드리겠습니다. 저는 개인적으로 리스크 관리를 하는편입니다. 스타트업에 뜻이 있는 경우 경험이 많은 시니어 개발자는 크게 상관이 없지만 사회초년생일때는 시행착오가 많기 때문에 웬만하면 시리즈 C, B 규모의 회사에 가서 회사가 커지는 걸 보고 창업을 하는 걸 추천합니다. 본인이 창업 후 회사가 엔젤투자 받고 시드받고 A, B를 거치며 투자금 300억 정도를 받으면 시리즈 B급이라 하는데 이는 축구로 치면 2부리그라고 할 수 있습니다. 그 이상인 천억 부터는 1부리그 취급을하는데 이 단계에서 필요한 경험치는 정말 다릅니다. 사용자 트래픽이 늘면 경험이 없어 대응을 못하게 될텐데 이렇게 되면 서비스 매니징으로 배치 될 것이고, 결국 커리어가 생각했던 것과 조금 달라질 수 있습니다. 다만 피엠이나 대표는  본인의 경험치가 되고 커리어가 되기 때문에 괜찮은 편입니다. 또 주니어일수록 좋은 시니어에 경험치를 받아먹는게 정말 중요합니다. 단적으로 1년에게 삽질해서 얻은 경험치를 좋은 시니어 밑에서 두세달만에 배울 수 있기 때문입니다.  유성:  1년 정도는 이대로 진행해 보아도 괜찮을까요?  동욱: 13. Github Action에 대해서 어떻게 생각하시나요?  유성:  프로젝트 규모가 아무래도 작다보니  Github Action 으로 시작했습니다. 사용하다보니 굉장히 좋다고 느꼈는데 현재 시니어 또는 개발자들 사이에선 어떤가요?? 또  Github Action 을 한 번 깊에 파보는 것은 어떤가요?  동욱:   Github Action 은 좋습니다. 실제로 일부 빅테크 기업에서는 CI/CD 모두  Github Action 을 사용하기도 합니다. 적은 번거로움과 마켓플레이스에 존재하는 다양한 action들은 강점입니다. 하지만  Github Action 으로 jenkins나 다른 기존 CI/CD툴로 가능한 모든 일들을 처리할 수 없기에 사용한다면 Build까지  Github action 으로 진행하는 것을 추천드립니다. 또한 당연한 말이지만 깊게 커스텀 하기 위해서는 문법을 공부해야하는 수고로움 역시 존재할 것입니다. 물론  Github Action  자체를 깊게 파보는 것은 좋다고 생각합니다. 14. 개발바닥을 시작한 계기에 대해서  동욱:  그냥 재미있을 것 같아서 시작했습니다. 호돌님과 예전 회사에서 계속 둘이서 얘기를 많이 했었는데 주변에서도 재미있다고 했습니다. 그런데 이런 얘기들을 유튜브로 남겨서 사람들에게 공유를 하면 어떨까 하는 생각을 했습니다.  그리고 우형을 나오게 된다면 커뮤니티적인 장점을 더 이상 누리기 힘드니, 그 전에 마케팅이나 커뮤니티적인 효과를 유튜브에서 이끌어 낼 수 있을까 해서 시작한 계기도 있지만, 제일 큰 계기는 그냥 재미있을 것 같아서 였습니다.  15. 첫 직장에 대한 조언  현수:  저는 프론트엔드 개발자를 희망하고 있는데 제가 인턴을 8개월 정도하면서 느낀건데 엄청나게 제가 맡고있는 프로덕트에 흥미가 없으면 일이 정말 일처럼 느껴지고 그래서 하루가 끝나면 너무너무 힘들더라구요 제가 지금 취준생인데 제가 일단 첫 직장으로 원하는 곳은 흔히 말하는 유니콘기업들입니다. 근데 만약 원하는 유니콘 기업에 입사를 했을 때 제가 원하는 일을 한다는 보장이 없잖아요. 그랬을 때 또 똑같은 피곤함과 보람을 잘 못 느낄 것 같습니다. 그런데 우선은 또 대기업의 복지나 또 돈을 무시못하기 때문에 월급같은 것들도 한번 느껴보고 싶고, 요즘 카카오 개발자다, 배민 개발자다 이런 타이틀도 한번 달아보고 싶기도하지만, 다른 면에선 제가 원하는 가치관을 가지고 프로젝트를 개발하는 곳도 들어가서 집중해서 개발도 한번 해보고 싶기도 한 마음들이 여기저기 떠다닙니다.  동욱님은 유니콘 기업도 가보셨고, 지금은 그거 보다 조금 작은 인프런에서 일도 해보고 계신데 저에게 조언같은 걸 주실 수 있으실까요?  동욱:  첫 직장으로서의 조언을 원하시는 건가요? 앞으로의 커리어에 대한 조언을 원하시는 건가요?  현수:  지금 당장은 첫 직장의 조언을 얻고 싶습니다.  동욱:   커리어가 결국 한 회사에서 멈추는 것은 아니고, 보통 2~3년 사이에 개발자들이 많이 이직합니다. 이직사유는 연봉, 권한 변경, 성장 등의 사유는 많습니다. 공통적으로 하는 이유는 보편적으로 팀으로서의 지식을 떼고, 자신 스스로가 잘하는 사람인지를 확인하고 싶은 이유도 있습니다. 내가 잘하는 것인지 아니면 내가 이 팀에서 같은 일을 많이 해봤기 때문에 잘하는 것처럼 보일 수 있는지 궁금해서 초기화하기 위해서 옮기는 이유가 있습니다. 너무 편안하면 불안한 사람들도 있기 때문입니다. 첫 직장은 당연히 빅 테크가 좋습니다. 당연히 첫 직장은 급여보다는 성장에 초점을 맞추는 것이 중요합니다. 빅테크 기업의 경우는 신입 개발자를 성장시킬 여유가 있을 확률이 높고, 빅 테크 기업에서는 대량의 트래픽을 받기 때문에 그걸 고려한 코드를 본 것 자체가 신입 개발자에게 좋은 경험이 됩니다. 그리고 장애 히스토리, 테스트 코드 등을 보는 것도 도움이 많이 될 것입니다. 자신의 팀이 아니여도 다른 팀에라도 좋은 끌어줄 사람이 있기 때문에 확실히 배울 수 있는 시니어가 존재하기 때문에 배울 기회 자체가 훨씬 많습니다. 그에 비해 스타트업의 경우에는 좋은 시니어를 만나지 못할 확률이 더 높습니다. 현수님이 원하는 프로젝트를 진행하는 곳에 들어가도 좋은 시니어를 만날 수 있다는 확률이 대기업보다는 확실히 적습니다. 반대로 대기업은 기술을 도입하는 데 훨씬 힘들거나 할 수도 있습니다. 새로운 기술을 도입하고 싶어도 해당 팀의 모든 사람을 설득해야 하기 때문에 가능성이 스타트업보다 적습니다. 예를 들어 이걸 안 쓰면 안 되는 경우에도 반대 때문에 도입할 수가 없습니다. 그런 경우 모든 시니어를 설득해야 하기 때문에 그 과정이 어렵습니다. 스타트업과 대기업은 스톡옵션 차이도 있습니다. 대부분의 대기업들은 이미 상장을 했기 때문에 스톡옵션을 받을 수 있는 가능성이 희박하지만, 스타트업의 경우에는 스톡옵션의 기회가 남아 있을 확률이 높습니다. 그러나 모든 스타트업이 이 모든 조건(좋은 시니어, 스톡옵션, 기술을 도입할 수 있는 가능성)을 만족할 확률은 낮다고 했습니다. 그런 조건들이 가질 확률이 미지수이기 때문입니다. 그러나 빅테크 기업의 경우 확실하게 이점을 취할 수 있기 때문에 빅테크 기업이 신입 개발자의 첫 직장으로서는 나은 것 같습니다. 자금적인 문제도 당연히 있습니다. 어쨌든 한 번 대기업의 맛을 보는 것이 좋습니다. 일단 지금 스타트업에 가게 된다면, 아쉬움이 너무 클 것입니다. 스타트업에서 빅테크로 가는 것은 어렵지만, 빅테크에서 스타트업으로 이동하는 것은 반대보단 쉬울 것 입니다. 따라서 빅테크에서 커리어를 쌓고, 그동안 거기서 공부했던 것을 바탕으로 시리즈 A 정도 급으로 이동해서 쌓아둔 내공을 사용할 수 있다면 훨씬 많은 선택권과 기회가 있을 것입니다. 16. 실무에서의 장애 대응 예시에 대해서  충환:  스프링 핵심 원리를 알면 장애를 대응할 때 도움이 된다고 하셨는데 실무에서 발생하는 예시를 들어주실 수 있으신가요?  동욱:  스프링의 핵심 원리를 잘 알면 기능 개발이나 확장에는 확실히 도움이 되겠지만 장애에 잘 대응할 수 있는 것은 아닙니다. 실제 서비스에서 장애는 굉장히 많기 때문에 직접 경험해보며 배워야 합니다. 실제 장애 경험을 예로 들자면, 이번 인프런 문제는 데이터베이스 문제였습니다. 이 뿐만 아니라 장애 요인에는 로드밸런서, 쿼리 문제 등 수 많은 요인이 있습니다. 스프링을 잘 아는 것이 애플리케이션 레벨의 기능 확장이나 코드 분석에 도움이 되겠지만, 장애에는 연관되어 있는 서비스가 너무 많아 전반적인 지식이 필요합니다.  추가로 백엔드 개발자 업무의 30% 이상이 데이터베이스와 관련돼있습니다. 어플리케이션 서버는 데이터베이스와 밀접하므로 관련 쿼리를 잘못 짜면 좋은 성능을 기대할 수 없습니다. JPA를 사용한다고 쿼리를 공부하지 않는 것은 옳지 못한 태도입니다.  SQL 첫걸음  →  SQL 레벨업  →  Real MySQL 1편  추천합니다. SQL 첫걸음:  http://www.yes24.com/Product/Goods/22744867 SQL 레벨업:  http://www.yes24.com/Product/Goods/24089836 Real MySQL 1편:  http://www.yes24.com/Product/Goods/103415627 마무리  (방역수칙을 지키면서 서울의 한 스타벅스 카페에서 동욱님을 만났습니다.) 정말 말씀을 정성스럽게 잘해주셔서 생각없이 질문을 하다보니 두 시간이 그냥 지나가버렸습니다... 동욱님께서 유튜브에서 말씀하시거나 다른 개발 유튜버들이 말씀하신 부분들 말고 질문을 최대한 하려했지만, 결국 비슷하게 간 느낌도 있습니다. 그리고 저희가 주변에서 들을 수 없는 시니어 개발자를 통해서 들을 수 있는 내용들을 생각하다보니 조금 딥해진 부분도 있는 것 같습니다.  하지만 동욱님을 직접 만나서 직접 들은 피드백은 무엇보다도 값지고, 실시간으로 들으면서도 동욱님이 말씀을 너무 잘해주셨습니다. 그리고 동욱님과 얘기를 나누는 것도 중요하지만 존경하는 분을 뵙게 된 것 자체만으로도 너무나도 감격이었습니다. 그리고 동욱님께서 계속 저희에게 오히려 고맙다고 그러셨는데 그런 모습들을 보면서 많은 것을 느꼈습니다. 저희들도 저희가 시니어가 됐을 때 주니어들에게 선한 영향력을 줄 수 있는 개발자가 되겠다고 다짐하는 계기가 됐습니다. 정말 바쁜 업무 시간에도 시간을 내어서 만나주신 동욱님 다시 한번 정말 정말 감사합니다! 다음에 꼭 서울 판교에서 뵐 수 있었으면 좋겠습니다! 구현 결과  게임하러가기:  https://find-different-color.vercel.app/ https://github.com/junghyeonsu/find-different-color (⭐ 2022/02/14 랭크기능 추가 ⭐)   메인 페이지에  랭크 보기  버튼을 추가해서 랭크 페이지를 추가했습니다.   처음에  게임 시작 빈 공백 만 아니면 되고, 닉네임은  세션 (Session storage 사용)에서 유지됩니다.   firestore 를 사용했습니다. 랭킹 기준은  단계(stage) 점수(Point) 를 내림차순으로 랭킹이 매겨집니다. 다른분들과 경쟁해보세요! 🕹️ Numble Challenge    챌린지 내용 링크 기간: 2/4 - 2/13 이 챌린지는  React 를 더  React 스럽게 사용하고 싶은  0~1년차 React 기반 프론트엔드 개발자 에게 적합해요. 이 챌린지에서 우리는  Context ,  Redux ,  Recoil  등 상태관리 라이브러리를 사용하지 않고 다른 색깔 찾기 게임을 제작할 거예요. 이 챌린지를 통해 우리는 이 챌린지를 통해 우리는 요구사항에 따라 적절한 단위로  component 를 나눠볼 수 있고, 어느  component 가 어느  state 를 가지고 있어야하는가에 대해 실전적으로 익힐 수 있으며, 적절한  prop 을 사용해 탄력적인  component  작성에 대해서도 연습할 수 있어요. 요구 사항   📌 참가 동기 4학년이 끝나고 취준을 하느라 개발에 많은 시간을 쓰지 못하고, CS공부나 알고리즘을 푸는데에 시간을 보내고 있었다. 그러다가 친구의 추천으로  Numble Challenge 에 대해서 알게되었고, 너무 재미있어 보여서 그냥 생각도 안하고 바로 신청했다. 📌 사용한 기술 TypeScript (language) create-react-app (react) react-router-dom (router) styled-components (CSS in JS) react-animated-numbers (number animation) react-responsive-modal (Modal component) Eslint &amp; Prettier (linter &amp; formatter) Vercel (deploy) 📌 프로토타입 디자인을 좀 예쁘게 하고 싶었기에  Pigma   📌 폴더 구조   📌 주요 로직 타이머 useTimer  훅을 생성해서 timer와 관련된 함수들을 관리했다. 타이머를  useRef 를 사용해서 구현하는 것이 제일 성능상, 그리고 사이드이펙트를 제거할 수 있는 좋은 방법 같았다.  타이머 구현 관련 자료 를 참고해서 개발하였다. 그리고  animationActive  상태 값은 타이머 Bar가 5초 이하로 떨어지면 Bar가 흔들리는 애니메이션을 추가했는데, 해당 애니메이션을 넣기 위해서 다음과 같이 작성했다. 위의 코드는  styled-components animation  속성에  infinite animationActive  상태 값이 true이거나, 5초 이하일 때만 애니메이션이 작동하도록 한다. 애니메이션은  keyframes 를 사용했고, 아래와 같이 작성했다. 이렇게 작성하면 이 애니메이션을 동작시키고 싶을 때만  animationActive  상태 값을 잠시  true 로 바꿨다가,  setTimeout 을 이용해서 다시  false 로 바꾸면 된다. 정답이 아닌 색깔 카드를 클릭했을 때, 한번 흔들리는 애니메이션이 아래와 같이 작성되었다.   색깔 뽑기 로직 해당 프로젝트에서 제일 시간이 많이 걸렸던 부분이다. 우선 두 가지가 관건이었다. 어떻게 색깔을 랜덤으로 뽑을 건지? 어떻게 랜덤으로 뽑힌 색과 다른 색을 뽑을 건지?    const pickRandomColor = useCallback(() =&gt; Math.floor(Math.random() * 256), []);  Math.random() Math.floor 로 내림 연산을 해주면 0에서 255까지의 정수를 잘 뽑는다. difference difference 의 값이 작아진다. 그리고 뽑아진 랜덤 색상에  difference   📌 어려웠던 점  Card color 는 위에서 설명했고, size와 Card의 개수, 정답 Card의 Index는 요구사항에 맞게 프로그래밍했다. 그리고 각각의  Card 에  border 를 줬는데, Card의 개수가 늘어날수록 게임보드의 총 크기가 변했다.  box-sizing: border-box; 그래서  Card  컴포넌트에  box-sizing: border-box 를 주어서 border가 생겨도  Card  컴포넌트의 전체 width, height는 변경되지 않도록 하였다. 추후 개선점 파이어베이스로 간단히 데이터베이스를 연결해서 유저 이름을 받게하고 유저들끼리 랭킹시스템을 구현하고 싶다. 위의 랭킹시스템을 구현해서 여러 게임을 만들어서 플랫폼을 만들고 싶다는 생각을 했다.. 너무 재미있을 것 같다.  storybook ,  jest 를 이용해서 테스트 파이프라인을 구축하고 싶다. 마무리 💪 강점 찾기 [Strengths finder]   해당 책을 받으면 맨 앞장에 테스트를 볼 수 있는 코드가 있고  스트렝스 파인더 5가지 강점 아래는 그렇게 해서 나온 결과이다.   해당 책에는 각각의  강점을 가지고 있는 사람의 특징 과  해당 강점을 가지고 있는 사람과 어떻게 일을 하면 좋은지 에 대한 설명이 나와있다. 아래는 홈페이지에 나와있는 내가 가지고 있는 강점에 대한 간단한 설명들이다. 1. 성취 (Achiever) 성취자는 성취에 대한 끊임없는 욕구가 있습니다. 그들은 내부에 불타는 내부 불이 있습니다. 그것은 그들이 더 많은 일을 하고 성취하도록 부추깁니다. 강한 성취자 재능을 가진 사람들은 매일이 0에서 시작하는 것처럼 느낍니다. 하루가 끝날 때까지 그들은 스스로에 대해 기분 좋게 느끼기 위해 의미 있는 일을 성취해야 합니다. 그리고 &quot;매일&quot;은 근무일, 주말, 휴일 및 휴가까지 매일을 의미합니다. 어떤 형태의 성취도 없이 하루가 지나면 아무리 작더라도 성취자는 불만을 느낀다. 도전적인 프로젝트를 마치고 나면 휴식이나 쉬운 과제에 대한 보상을 구하는 경우는 거의 없습니다. 그들은 과거의 성취에 대한 인정을 높이 평가하지만, 그들의 동기는 지평선에 있는 다음 목표를 향해 노력하는 데 있습니다. 2. 승부 (Competition) 경쟁은 비교에 뿌리를 두고 있습니다. 강력한 경쟁 재능을 가진 사람들에게 그들의 성과는 그들의 궁극적인 척도입니다. 그들은 세상을 볼 때 본능적으로 다른 사람들의 성과를 인식합니다. 그들은 최고를 갈망하고 탁월하기 위해 열심히 노력할 것입니다. 특히 다른 사람들과 비교할 때 그렇습니다. 노력에 관한 것이 아닙니다. 그것은 승리에 관한 것입니다. 노력이나 의도와 상관없이 목표를 달성하더라도 동료를 능가하지 못하면 성취가 공허하게 느껴질 것입니다. 그들은 비교할 필요가 있습니다. 비교할 수 있으면 경쟁할 수 있고, 경쟁할 수 있으면 이길 수 있습니다. 3. 배움 (Learner) 강한 학습자 재능을 가진 사람들은 끊임없이 배우고 개선하기 위해 노력합니다. 학습 과정은 그들이 얻는 지식만큼 중요합니다. 무지에서 유능함으로의 꾸준하고 신중한 여정은 학습자에게 활력을 불어넣습니다. 새로운 사실을 배우고, 새로운 주제를 시작하고, 중요한 기술을 마스터하는 스릴은 지배적인 학습자 재능을 가진 사람들을 흥분시킵니다. 학습은 이러한 사람들의 자신감을 키워줍니다. 학습자를 지배적인 주제로 삼는다고 해서 누군가가 주제 전문가가 되도록 동기를 부여하거나 전문적 또는 학문적 자격을 취득하는 데 수반되는 존경을 받기 위해 노력하는 것은 아닙니다. 학습의 결과는 &quot;거기에 도달하는 것&quot;보다 덜 중요합니다. 4. 최상화 (Maximizer) 극대화자는 일반적으로 다른 사람보다 먼저 다른 사람의 재능과 강점을 봅니다. 자신의 것이든 다른 사람의 것이든 강점은 그들을 매료시킵니다. 극대화자는 다른 사람들이 자신의 잠재력에 대해 흥분하도록 돕는 것을 좋아합니다. 그들은 사람들이 가장 잘하는 것과 그들이 잘할 수 있는 직업을 봅니다. 그들은 사람들의 재능이 그들이 완료해야 하는 작업과 어떻게 일치하는지 볼 수 있습니다. 평균이 아닌 탁월함이 그들의 척도이자 추구입니다. 그들은 자신과 다른 사람들의 강점 영역에 집중하고 약점을 관리하도록 이끄는 질적 지향성을 가지고 있습니다. 5. 존재감 (Significance) 강한 의미의 재능을 가진 사람들은 다른 사람들이 자신의 가치를 알아주기를 원합니다. 그들은 사람들이 자신을 인식하고 듣고 가치를 부여하기를 원합니다. 특히 그들은 다른 사람들이 자신의 독특한 장점을 알고 감사하기를 원합니다. 그들은 사람들이 자신의 기여를 중요하고 강력하며 중요한 것으로 보기를 바랍니다. 다른 사람들이 자신을 인정해 주기를 간절히 바라는 열망은 평범한 것에서 벗어나 특별한 것을 향한 동기를 부여합니다. 결론적으로 나는  내면의 끊임없이 불타는 열정 을 가지고 끊임없이  배움 을 추구하고  경쟁 을 하며 항상  최상 을 노리고 다른 사람들에게 나의 가치를  계속해서 증명 하길 원하고, 그렇게 하는 사람... 인가보다. 나랑 너무 잘 맞는 것 같아서 놀랍기도하면서 내가 테스트에서 답변한 것을 기준으로 짜집기하면 충분히 만들어낼 수 있는 얘기같아서 조금 의심이 들기도 하면서, 34가지나 되는 강점들 중에서 뽑힌 5가지라고 생각하면 또 놀랍기도하다. 이 중에  성취 에 되게 많은 공감이 갔는데,  성취  강점을 가진 사람들은 꾸준히  자신의 성과를 평가하고 판단 현재 진행하고 있는 프로젝트. 📌 GIBLIB 해외 인턴십 학교에서 MI333이라는 해외 인턴십에 합격을 해서 학기동안 일주일 10시간 정도 투자해서 프로젝트를 진행하게 될 것 같다. 📌 하얀마인드 파트타임 인턴십 일주일에 20시간으로 인턴을 진행하고 있고, 현재는 웹 사이트를 만드는 프로젝트에 참여하고 있다.  📌 졸업프로젝트 11월 말 정도까지 MVP를 완성하고 논문을 써야하기 때문에 개발이 빨리 진행이 되어야 할 것 같다. 현재 관심있는. 🍃 Flutter [Udemy] Flutter &amp; Dart - The Complete Guide [2021 Edition] 예전에  flutter 에 관심이 있어서  Udemy  사이트를 통해서 강의를 들었었는데, 1년이 지나고 많이 까먹은 것 같아서 다시 강의를 듣고있다. 강의 수가 총  377  flutter 남은 77일은. 졸업프로젝트를 잘 끝내자. 인턴 프로젝트에 최선을 다하자. 현재 진행하는 프로젝트가 순탄하게 개발이 되어서 MVP를 완성시키고 사용자들에게 배포를 해서 피드백을 받고싶다. 학기를 잘 끝내자. 성적 잘 받게 해주세요 flutter 공부를 꾸준히 하자. 하고있는 일들에 영향이 가지 않는 선에서 꾸준히 공부를 할 것이다. 🤔 확실하게 하자 이번에 졸업프로젝트를 개발하다가  로그인 ID / Password JWT(Json Web Token) JWT 📌 HTTP 통신 서버와 클라이언트가 데이터를 주고 받는 통신 방법 connectionless HTTP는   연결을 유지하지 않는다. stateless HTTP는 *  상태를 유지하지 않는다.  * 자신이 누구인지 계속해서 인증 웹페이지가 느려지는 원인 이 된다. 아래 방법들은  로그인을 유지 시킬 방법 이라고 생각해도 무방하다. 📌 로그인을 처리하는 법 Not good 👎 위에서 얘기한대로 유저에게  ID  /  Password  를 받아서, 서버의 데이터베이스와 그냥 비교하는 방법이 있다. 무언가 다른, 로그인을 유지할 수 있고 안전한 방법이 필요했다. Good 👍 Session (세션) vs Token (토큰) 토큰 방식 말고도  세션 방식 이 있었다. 사용자의 로그인 정보에 대한 것을 어디다가  유지, 저장 을 하느냐에 따라 두 방식으로 나뉜다. 세션 방식 (서버 유지)    이미지 출처-JWT(Json Web Token)은 왜 사용될까 이러한 이유 때문에 아래와 같은 토큰 방식을 사용한다. 토큰 방식 (클라이언트 유지) 서버에 저장하지 않아서  서버에 확장성 해당 토큰이 유효한지만 체크 상관이 없다 는 뜻이다. 🪙 JWT JWT는 두 개체 사이에서 안정성있게 정보를 교환하기 좋은 방법  JWT 는 우리가 위에서 계속 말한  웹 토큰 ,  JSON Web Token 웹표준 (RFC 7519) 전자 서명  된 URL-safe (URL로 이용할 수있는 문자 만 구성된)의 JSON이다.    JWT 는  . 을 기준으로 세 파트로 나뉜다. Header payload 클레임(claim)  이라고 하고,  key - value payload 에는 여러 개의 클레임을 담을 수 있고, 클레임을 공개(public) 혹은 비공개(private) 할 것인지 등록(registered)할 것인지 결정할 수 있다. signature 시그니처(signature)에는 위의 헤더(header)와 페이로드(Paylaod)를 합친 문자열을 서명한 값이다. 서명은 헤더의  alg 에 정의된 알고리즘과  secret key 를 이용해 생성하고  Base64 URL-Safe 로  인코딩 secret key 를 포함해서 암호화가 되어있다.   생성된 JWT는 왼쪽의  Encoded 된 값처럼 점(.)을 구분자로 헤더, 페이로드, 시그니쳐로 나눠서 서로 전달하게 되고, 서버는 헤더의  alg ,  kid 잠깐, 공개 키(public key)와 비밀 키(secret key) 서명은 비밀 키가 있는 곳에서만 할 수 있고 공개 키를 가진 어느 곳에서나 이 데이터의 서명을 검증할 수 있다. 📌 JWT의 장단점 장점 세션 방식과 다르게 별도의 인증 저장소가 필요 없어서 서버와의 커뮤니케이션을 최소한으로 할 수 있다. 트래픽에 대한 부담이 적다. 세션과 다르게 독립적인 느낌의 JWT를 활용한다는 것. 단점 JWT의 크기가 커질수록 거의 모든 요청에 대해 전송되므로 데이터 트래픽 크기에 영향을 미칠 수 있다. 토큰은 클라이언트에 저장되기 때문에 DB에서 사용자 정보를 수정하더라도 토큰에 직접 적용할 수 없다. 📌 JWT 프로세스 Only &quot;Access Token&quot;   사용자가 id와 password를 입력하고 서버로 로그인 요청을 보낸다. 서버는 비밀 키(secret key) 를 통해서 서명을 하고 공개 키(public key)로 암호화 시킨  Access Token 을 발급한다.   Access Token 을 사용자(클라이언트)에게 보낸다.  요기까지하면 사용자는 로그인이 된 것이다. 로그인 정보가 필요한 API Call마다 토큰을 실어서 보낸다. 사용자(클라이언트)는 API를 요청할 떄  Authorization Header 에  Access Token 을 담아서 보낸다. 서버에서는 사용자가 보낸 토큰을 공개 키(public key)로 서명을 체크하고, 안에 담긴 정보를 확인한다.  서버는  secret key 로 사용자가 보낸 토큰의 서명을 복호화하여서 유효한 토큰인지 확인한다. 서버가 요청에 대한 응답을 사용자(클라이언트)에게 전달한다. With &quot;Refresh Token&quot;  Access Token  만을 사용했을 때 보안 문제를 해결하기 위해 나온  Refresh Token 위와 같은 방식으로 진행했을 때의 문제점은  Access Token Refresh Token  Refresh Token  또한  Access Token Access Token ,  Refresh Token  Refresh Token 을 한 달,  Access Token Access Token 의 기간이 다 되어도  Refresh Token Access Token 을 발급 받을 수 있다. (로그인 유지)  Refresh Token 는  Access Token 를 다시 발급받기 위한 JWT. 📌 토큰을 유지하는 위치 secure httpOnly  🍪 프론트에서 안전하게 로그인 처리하기 (ft. React) 간략하게 정리하면  localStorage XSS(Cross-site scripting) 에 취약하고,  쿠키 XSS(Cross-site scripting)  &amp;  CSRF(Cross-site request forgery): 다른 도메인에서 우리 도메인으로 API Call을 날리는 공격  둘 다에 취약해질 수 있다.  secure httpOnly  역시  CSRF  공격에 취약하다. 📌 결론   HTTP 의  connectionless ,  stateless   JWT 는 암호화, 복호화를 통해 두 개체 사이에서 정보를 안전하게 주고 받을 수 있는 좋은 수단이다.   필요한  API   Refresh API 새로고침,  AccessToken  만료시에 호출 (setTimeout으로 자동 호출 설정 가능)  RefreshToken 을 쿠키에서 읽어와서 서버로 보냄  RefreshToken , AccessToken 을 다 받아올지  AccessToken 만 받아올지는 선택   Login API 로그인 시 호출  RefreshToken , AccessToken  을 받아옴  API 호출 후  AccessToken 는 header에 default로 설정하여 API마다 보내도록 설정  AccessToken 의 유효기간이 끝나기 전 자동으로  Refresh API 가 호출되도록 설정 가능 (선택적)  RefreshToken 는 쿠키에 저장  RefreshToken  또한 기간이 만료되면 재로그인이 필요! 📌 10/3일 추가   제가 좋아하는 유튜버인 니콜라스의  노마드 코더  채널에서 올라온 영상도 참고해보세요!  영상 링크 참고  JWT를 통한 회원 인증 시스템 구현 :: 뇽뇽냥냥늉늉    리액트 Life cycle 과 Redux &amp; JWT 기반의 사용자 인증에 대한 고찰 :: nomadhash  쿠키(Cookie), 세션(Session) 특징 및 차이 :: 99C0RN  로그인은 어떻게 이루어질까❓(Cookie, Session) :: junhok82  [JWT] JSON Web Token 소개 및 구조 :: velopert  서버 인증(JWT) :: 불곰  JWT를 소개합니다. :: NHN Cloud 📌 Review 포트폴리오 개발 방학의 주 사업이었다. 원래는 한 달을 잡고 개발을 하려고 했는데 누군가 개발은 예상되는 시간의 2배 정도를 잡으면 적당하다고 했던 것 같은데 정확히 떨어졌다. 프로젝트 초기 설정부터, 디자인, 개발을 전부 해야 하니까 시간이 많이 들었던 것 같다. 특히 디자인을 자세한 설계가 없이 개발하려니 그냥 개발을 하면서 생각나는 디자인을 바로 적용시키는 방식으로 되었다. Experience section 은 뭔가가 조금 부실해보여서 다시 개발을 해야할지도..  후기 포트폴리오 알고리즘 문제 풀기 처음엔  프로그래머스 로 시작해서 프로그래머스 2단계까지 다 풀고나서  백준  으로 넘어가서 단계별로 풀어보기를 풀었다.     방학동안 100문제는 넘게 푼 것 같은데, 뭔가 체계적으로 푼 것 같진 않고 그냥 보이는 문제들 다 풀었다. 그래서 그런지 실력이 늘었다는 느낌이 안든다. 그래도 자바스크립트 기본적인 문법들은 꽤나 많이 익숙해진 것 같다. 꾸준히 풀어야 하는데 방학이 끝나고도 계속해서 풀 수 있을지 모르겠다. 티스토리 방문자 10000명   작년 세트렉아이 인턴에서부터 시작한 티스토리 블로그, 약 1년정도?가 지난 지금 전체 방문자가 10000명을 넘었다. 티스토리는 그냥 알고리즘이나 일상같은 것들을 올리고 있고, 전문적인 지식이나 후기글은 벨로그에 올리려고 하고있다. 블로그를 통합해야 하는 생각이 들 때도 있는데 벨로그에 종합 통계라던지 댓글 알림 시스템 (이메일 등록이 왜 안될까요) 같은 것들이 잘 안되어 있어서 벨로그로 통합하기가 조금 꺼려졌다. 그리고 또 10000명을 넘기고 일일 평균이 50~100명 정도가 되니까 티스토리도 욕심이나고 벨로그도 욕심이 나는데 눈치를 보다가 업데이트가 잘 되는 플랫폼에 통합을 해야할 것 같다.  티스토리 📌 Fail 운동 다시 개강했으니 또 운동을 열심히 해야겠다. 책 읽기 그래도 계속해서 책을 읽으려고 시도를 해야 할 것 같다. 📌 Plan 하얀마인드 우선 정해진 것은 3개월동안이고 그 다음은 그 때 정할 것 같다. MI333 학기 졸업프로젝트 CS공부, 알고리즘 공부, (plz 영어) 요기서는 희망사항인데, 진행하는 프로젝트들이 적지 않아서 병행이 가능할까 의문이 든다. 위에 것들은 취직을 위해서 준비해야 하는데 내가 특히 CS와 알고리즘에 많이 약해서 그래도 꾸준히 공부를 해야할 것 같다.  📌 개요  완성한 포트폴리오 첫번째 포트폴리오 페이지   그렇게  완성한 포트폴리오 의 후기를 적어본다. 📌 사용 기술 Language &amp; Framework:  TypeScript ,  NextJS Libarary:  material-ui icon  (아이콘),  gsap  (애니메이션 및 스크롤 트리거),  styled-components  (style-in-JS),  react-parallax-tilt  (Contact card hover effect) Deployment:  vercel  NextJS 는 SSR을 위하여 적용한 것은 아니고, 다른 프로젝트에서 NextJS 를 사용하기 위해 폴더 구조에 적응하기 위해 사용하였다.  NextJS 를 만든 회사에서 같이 운영하는  Vercel 는 배포에 신경을 쓰지 않고 개발에 집중할 수 있도록 잘 되어있었다. 📌 구성 👋 Introduction section   나에 대한 소개를 간략적으로 하는 섹션 PPT로 나에 대한 발표를 하는 , . unDraw 💪 Skill section   내가 사용할 수 있는 기술을 설명하는 섹션 👍 Experience section   내 경험들을 소개하는 섹션 📞 Contact section   내 연락처들을 명함 형식으로 표현한 섹션 📌 기능 1. Adapt GSAP   GSAP 를 적용하였다. 각각의 섹션에 애니메이션 트리거를 적용하기 위해서 각 섹션의 위치파악이 필요했다.   각 섹션의 최상단 컴포넌트에  useEffect hook  으로 해당 컴포넌트의 위치를 파악하고  useRef  에 담겨있는 각 섹션의 위치를 위의 변수들에 할당해주었다. 그리고 해당 섹션에 도착하면 트리거가 실행이 되는 방식으로 애니메이션을 재생시켰다.   그리고 글씨와 그림이 순차적으로 보여지는 애니메이션을 적용하기 위해  delay props 를 할당해서 실행되는 시간을 달리하였다. 2. Custom scroll event   PPT는 한장씩 보여지는 것이 이쁜데, 가운데에 걸쳐서 두 섹션이 한꺼번에 보이는 것을 원하지 않았다. delta  값이 들어온다.   해당 값에 따라  power 를 측정하는 함수를 만들어 스크롤 게이지가 늘어나도록 하였다.   그리고 스크롤 게이지가 20 혹은 -20에 충족하면 다음 섹션으로 이동하는 함수를 구현하여 사용자의 화면을 완벽히 조종할 수 있게 하였다. 3. Page progress bar   사용자에게 현재 섹션의 위치를 알게하기 위해  progress bar 를 직접 만들었다. 해당 컴포넌트는 뒤에 있는  progress bar  와 앞에있는  active progress bar  컴포넌트가 겹쳐있는 형태이다. activate progress bar 의  height 를 늘려주는 식으로 개발하였다. 4. Animate skill bar   노란색 게이지가 차는 애니메이션을 내기 위해서  width 에 애니메이션을 주었다. 그리고 오른쪽의  count  숫자를 구현하기 위해서  counter  컴포넌트를 직접 구현하였다.   number 는 목표로 하는 숫자,  delay 는 count를 세기 시작하기 전 딜레이를 의미하고,  trigger 는 GSAP의 trigger와 동일하다. 5. Slide carousel   Experience 탭에서 슬라이드 형식으로 보여주고 싶었다. 6. Color pallette    contact section  에서 약간 허전한 느낌이 들고 재미있는 요소를 주기 위해서 여러  color 들의 조합으로 볼 수 있게  color pallette 를 구현하였다. 카드의 색만 변하는 것이 아닌  Contact section 의 모든 요소가 영향이 가도록 하였다.  context API 를 통해서 해당 섹션의 색을 변화시킬 수 있도록 개발하였다.  pallette   확장하기 쉽도록 상수로 따로 색을 관리하였다. 7. Rotate card    transform-style: preserve-3d; rotate-y  값이  180deg  만큼 회전되어서 시작하게 하였다. 그리고 아래의 회전 버튼을 클릭하게 되면 card 최상단 컴포넌트가  rotate-y  값이  180deg  만큼 회전되어서 앞면과 뒷면이 번갈아가면서 보이도록 하였다.   backface-visibility 는 해당 컴포넌트의 뒤의 요소를 보이게 할 것이냐, 혹은 안보이게 할 것이냐에 대한 속성인데  hidden 8. Responsive design styled-component 에서 제공해주는  theme 를 통해서  medio query  브레이크 포인트를 생성해서 전역으로 사용할 수 있게 하였다.             📌 어려웠던 점 반응형 &amp; 적응형 적용하기 사용자 브라우저의  width vw ,  vh 와 같은 단위로 스타일링을 진행했다. 하지면 어느  width 에서도 똑같은 뷰를 보여주고 싶었지만, 원하는대로 되지 않아서 어려웠다. 아직  CSS 에 대한 확고한 개념, 개발 체계가 잡혀있지 않아서 조금 어려웠던 것 같다. 반응형과 적응형 스타일 개발을 잘 하기위해서 해당 개념들을 확실히 하고 나만의 가치관을 만들어야 겠다고 생각했다. GSAP 조작 애니메이션이 내가 원하는대로 잘 되지 않아서 어렵고, 애니메이션이라는 것이 디버그 하기가 정말 어려워서 삽질을 많이 했던 것 같다. 그리고 GSAP 라이브러리가 리액트에 완벽한 지원을 해주지 않기 때문에 구글링에 많이 의지했다. 📌 아쉬운 점 📌 To do list 아이폰 사파리에서 스크롤 애니메이션이 적용이 안됨. (scroll-behavior가 safari에 지원이 안됨) 갤럭시에서 가끔 100vw가 안될 때가 있음 (안드로이드 자체 헤더 문제인 듯) Experience section 개선 (readablity, content, ...etc) 📌 hoist의 사전적 의미  hoist hoisting 정확히는 자바스크립트가 실행될 때 자바스크립트  Parser 가 어떻게 자바스크립트 코드를 처리하는지에 대한 내용이다. 📌 그래서 어떻게 처리하는데? 코드에서 변수, 함수의  &quot;선언&quot; 들을 위로 올려서 처리한다. 중요 변수, 함수의  선언 위에서 계속 강조하고 있지만 변수, 함수의  할당 이 아닌  선언 을 올려서 처리하는 것이다. 변수 예시 위의 예시에는  two  가 선언되어 있지 않으므로 당연히 에러가 뜬다. 위의 예시에서도 코드 순서대로라면  two  를 선언하기 이전에 호출했으므로 에러가 나야하지만,  Javscript hoisting 이 작동해  two  의 선언을 우선적으로 실행했다. 그렇기 때문에 에러가 아닌  undefined 가 뜨는 것을 볼 수 있다.  위의  hoisting one ,  two 를 띄우는데  아!  JavaScript hoisting 으로  two 를 먼저 선언하니까  1 2  라고 나오지 않을까? 라고 생각할 수 있지만, 그건 변수의 할당과 선언을 헷갈린 것이다.  hoisting 은 변수의 선언만을 책임지기 때문에 위의 예시에서 볼 수 있듯  1 undefined 가 뜬다. 함수 예시 함수중에서도  함수 표현식 은  hoisting 이 안되고,  함수 선언문 은  hoisting 이 일어난다. 함수 선언문 우리가 자주보는 함수 선언과 동일한 방법 함수 선언문은 어디에 선언이 되었든  hoisting 이 일어난다. 함수 표현식 📌 hoisting 우선 순위 📌 var, let, const var 위에서 계속  var let, const  let  과  const  는 es6에 나온 새로운 문법이다. 차이점 이렇게  var 는 변수가 초기화 되기 전에 호출이 되면  undefined let  과  const 는 레퍼런스 오류가 뜨기 때문에 오류를 예측할 수 있게 된다. 이것이 장점이다. 위의 예시만 보면  let  과  const  는  hoisting 이 일어나지 않는 것 처럼 보인다.  let / const  선언 변수는 호이스팅되지 않는 것이 아니다. 스코프에 진입할 때 변수가 만들어지고  TDZ(Temporal Dead Zone) 가 생성되지만, 코드 실행이 변수가 실제 있는 위치에 도달할 때까지 액세스할 수 없는 것이다.   let / const 변수가 선언된 시점에서 제어흐름은  TDZ 를 떠난 상태가 되며, 변수를 사용할 수 있게 된다. 일시적 사각 지대 (Temporal Dead Zone; TDZ)  var  변수의 경우 선언 단계 - 초기화 가 동시에 이루어지는 반면,  let / const  변수의 경우 선언 단계와 초기화 단계가 나누어서 이루어진다.  let / const  변수의 선언 단계와 초기화 단계 사이를 일시적 사각 지대  (Temporal Dead Zone; TDZ) 라고 부른다. 실제 코드에서  let  변수의 선언 또는  const  변수의 선언 및 할당 (const 의 경우 선언과 동시에 값 할당이 되어야 한다.)이 나오기 전까지는 해당 변수는 TDZ에서 관리 한다고 생각하면 된다.  해당 코드가 나오기 전에 미리 사용을 하려고 할 경우 TDZ에서  ReferenceError 를 발생 시킨다. 참고  https://gmlwjd9405.github.io/2019/04/22/javascript-hoisting.html  https://medium.com/korbit-engineering/let%EA%B3%BC-const%EB%8A%94-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EB%90%A0%EA%B9%8C-72fcf2fac365 내가 다 안다고 생각했던 것들을 실전에서 안다고 증명을 해야할 때 머뭇거리는 나를 위해 던지는 질문 리스트 📌 (프론트) 개발자 상식 ✅   CORS 에 대해서 정확히 알고 있나?  HTTP ,  HTTPS 에 대해서 알고 있나? (책 읽자.)  ✅ 웹 서버와 WAS의 차이점에 대해서 알고 있나?  Ngnix 가 무엇이고 언제 사용하는지 잘 알고 있나? UI와 UX의 차이점에 대해서 알고 있나?  OAuth 의 동작 방식에 대해서 알고 있나?  ✅   브라우저의 동작 방식에 대해서 알고 있나?  ✅    CSR ,  SSR 의 차이점과 각각의 특징에 대해서 알고 있나?  ✅   브라우저 저장소의 각각의 차이점에 대해서 잘 알고 있나?  PWA 가 무엇인지 정확히 알고 있나? 프론트엔드 ESLint, Prettier 에 대해서 알고 있나?  ✅   프론트엔드 모듈 번들러, Webpack에 대해서 알고 있나? &amp; 트랜스컴파일러 Babel에 대해서 알고 있나? 웹 접근성과 시멘틱 마크업에 대해서 잘 알고 있나?  SEO 와 적용 사례에 대해서 잘 알고 있나?  REST API 에 대해서 잘 알고 있나? 번들과 번들 최적화에 대해서 잘 알고 있나? 브라우저 주소창에 주소를 입력하고 엔터를 치면 어떤 일이 일어나는지 정확하게 알고 있나? ✅  로그인 방식, 토큰 관리는 어떻게 하는지 정확히 알고 있나? 디자인 패턴이란 무엇인가? 서버와 클라이언트의 차이에 대해서? ✅  NPM 배포 방법을 알고 계신가요? 📌 JavaScript  ✅   hoisting 에 대해서 알고 있나?  this 에 대해서 알고 있나?  closure 에 대해서 알고 있나?  prototype 에 대해서 알고 있나?  context 에 대해서 알고 있나?  JavaScript 의 동작 방식에 대해서 알고 있나?  let ,  const ,  var  의 차이점에 대해서 알고 있나? 이벤트 버블링, 이벤트 캡처, 이벤트 위임에 대해서 알고 있나?  JavaScript 의 비동기, 비동기 처리에 대해서 알고 있나?  TypeScript 와  JavaScript 의 차이점에 대해서 잘 알고 있나? 그냥 함수와 화살표 함수의 차이점에 대해서 정확히 알고 있나?  JavaScript 에서 이벤트루프가 무엇인지 알고있고 사용 경험이 있나? 애니메이션 구현은 어떤 방식으로 하는지 알고 있나? 📌 React  React 는 왜 쓰는 거고, 다른 프레임워크와의 차이점을 알고 있나? ✅   React 의  virtualDOM 에 대해서 알고 있나?  React 에서  Flux  패턴을 알고 있나? 좋은 컴포넌트 설계란 무엇인지에 대해 알고 있나?  React 의 상태 관리에 대해서 잘 알고 있나?  React key property 에 대해서 정확히 알고 사용용도를 알고 있나?  React 의 좋은 스타일링 방법에 대해서 잘 알고 있나?  React 의 컴포넌트 메모이제이션에 대해서 잘 알고 있나?  React  테스트에 대해서 잘 알고 있나?  Next.JS 는 왜 사용하는거고 잘 알고 있나?  React hooks 에 대해서 정확히 알고 있나? 📌 Computer Science 모든 자료구조에 대해서 알고 있나? 자료구조의 적용 사례와 각각의 장단점을 알고 있나? 🥇 한 발짝 더 웹 설계 패턴 및 자신이 추구하는 방식이 있나? 자신의 꾸준한 성장을 위해 노력하는 것이 있나? 웹 서비스의 사용성을 개선하기 위해 고민해 봤던 부분이 있는지? 구체적인 사례와 나의 확고한 의견이 있나? 자신의 코딩 컨벤션이 있나? 자신의 라이브러리 선택에 대한 확고한 가치관이 있나? 잘하는 개발자가 무엇이라고 생각하는지 의견이 있나? 나의 질문 출처들  1. 캡틴 판교님   2. alskt0419.log   3. holim0.log   4. tech-interview-for-developer repository   5. 소인성님의 IT-Note 레포 순열? 이름 그대로  순서대로 뽑아서 줄을 세우는 걸 순열 이라고 하지요. 순열을 기호로 나타낼 때는 순열을 뜻하는 영어  Permutation의  첫 글자  P 를 이용해요. n개 중에서 r개를 뽑아서 줄을 세우는 걸 n P r이라고 합니다. 위는  순열 🥝 🍓 🍋 요기  키위 ,  딸기 ,  레몬 이 있습니다. 세 가지 과일을  장바구니에 넣는 순서 단, 과일은 하나씩 존재합니다. 이 경우에는  순열 을 묻는 것입니다.   키위가 첫 번째에 키위가 두 번째에  장바구니에 들어갔으니 당연히 다른  경우 입니다. 이렇게  순서에 따라 다른 경우 가 되는 상황에는  순열 을 떠올리면 됩니다. 중복 순열? 그럼  중복 순열 중복을 허용 한다는 것입니다. 위의 과일을 예로 들자면 아까전의 예시는  과일들이 하나 씩 넉넉하게 3개씩 있다 고 생각하면 됩니다. 🥝🥝🥝 🍓🍓🍓 🍋🍋🍋 그러면 요기서  3개만 장바구니에 넣는다  라고 생각하면 그 경우에는  중복 순열 입니다.   이렇게  과일이 하나가 아니라 여러 개 가 있고,  장바구니에 들어간 순서에 따라 다른 경우 가 된다면  중복 순열 을 말하는 겁니다. 조합? 조합은 순열과 다른 개념으로  순서 차이가 중요하지 않습니다.  순열을 기호로 나타낼 때는 순열을 뜻하는 영어  Combination  첫 글자  C 를 이용해요. n개 중에서 r개를 뽑아서 줄을 세우는 걸 n C r이라고 합니다. 순서 차이가 중요하지 않다. 라는 말은  순서가 달라도 똑같이 보겠다 . 라는 말과 같은 말입니다. 🥝 🍓 🍋 3개의 과일을 장바구니에 들어간 결과 에 집중해봅시다. 이런 문제는  조합 을 생각하시면 됩니다. 🥝 🍓 🍋 🍋 🥝 🍓   이런 경우에는  1번 장바구니 와  2번 장바구니 키위🥝, 딸기🍓, 레몬🍋 이  똑같이 하나 씩 들어있는 같은 장바구니 입니다. 장바구니에 들어간  순서 넣은 결과 만 따지자면(조합) 같은 경우입니다. 중복 조합? 중복 조합은 역시 중복을 허용한 조합이라는 얘기입니다. 🥝🥝🥝 🍓🍓🍓 🍋🍋🍋   같은 장바구니 코드로 짜봅시다. Javascript 순열과 조합에 대한 코드는 DFS를 이용했습니다. 순열 to Code 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 N = 3, M = 3일 때    위와 같이 순열을 뽑고자 할 때는 아래와 같이 작성하면 됩니다. 해당 코드에 대한 자세한 설명은  링크 에서 확인 할 수 있습니다.  직접 풀어보기 : 백준 15649 N과 M (1) 중복 순열 to Code N = 3, M = 3일 때   위와 같이 중복 순열을 뽑고자 할 때는 아래와 같이 작성하면 됩니다.  직접 풀어보기 : 백준 15649 N과 M (3) 조합 to Code 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 N = 3, M = 3일 때  1 2 3   위와 같이 조합을 뽑고자 할 때는 아래와 같이 작성하면 됩니다. start  라는 매개 변수의 역할은 for문이 어디서부터 시작되냐를 결정합니다. 해당 매개 변수가 필요한 이유는 조합은 순서를 따지는 게 아니기 때문에 이미 거쳐 온 수에 대해서는 다시 돌아갈 필요가 없습니다. 해당 코드에 대한 자세한 설명은  링크 를 참고해주세요  직접 풀어보기 : 백준 15649 N과 M (2) 중복 조합 to Code N = 3, M = 3일 때   위와 같이 중복 조합을 뽑고자 할 때는 아래와 같이 작성하면 됩니다.  직접 풀어보기 : 백준 15649 N과 M (4) https://mathbang.net/545  (순열과 조합) ⭐세 가지의 자바스크립트 자바스크립트 종류에는 세 가지가 존재합니다.  ES5  : 표준 자바스크립트   ESNext  : ES6 이후 버전을 통틀어 가리킴  typescript  : 마이크로소프트가 개발하고 유지하고 있는 오픈소스 프로그래밍 언어 ⭐타입스크립트를 사용하는 이유 자바스크립트는 코드에 명시적으로 타입을 정의할 수 없어서  다른 사람이 작성한 코드를 어떻게 사용해야 하는지, 파악하기도 쉽지 않습니다. 요즘 소프트웨어는 대부분 많은 사람들이 투입되어서 개발이 됩니다. 이런 경우에는 개발자들 사이에 소통이 정말 중요합니다.  function makePerson(name, age) {} 위와 같은 코드를 작성이 되어있고,  makePerson(32, hyeonsu); 위와 같이 실행했을 때 오류가 발생한다면 원인을 찾기가 어렵습니다.  function makePerson(name: string, age: number) {} 하지만 위와 같이 타입이 명시가 되어있다면 쉽게 오류를 발견할 수 있고, 쉽게 추적이 가능합니다. 대규모의 개발이 진행되고 있고 많은 사람이 개발에 참여하고 있다면 더욱더 이런 문제는 많아질 것입니다. 협업과 소통의 효율을 높여주는 이러한 언어를 사용하지 않을 이유가 없죠. 트랜스파일러, 컴파일러  ESNext  자바스크립트 소스코드는  Babel  이라는  transpiler  (트랜스파일러) 를 통해서  ES5  자바스크립트 코드로 변환됩니다. 트랜스파일러는 어떤 프로그래밍 언어로 작성된 소스코드를 다른 소스코드로 변환시켜주는 프로그램을 의미합니다. 소스코드를 바이너리코드로 변환시켜주는  compiler (컴파일러)와는 다른 느낌이지만, &quot;무언가를 또 다른 무엇으로 바꿔준다&quot;는 관점에서는 비슷하므로, 둘을 구분하지 않는 경향이 있다고 합니다. ⭐ESNext 주요 문법 타입스크립는 대부분 ES6 이후의 문법을 지원하기 때문에  타입스크립트를 잘 다루려면 우선 ES6 이후의 문법을 잘 알아야 하고, 타입스크립트만 사용할 수 있는 고유의 문법이 있습니다. 우선은 ESNext(ES6 이후)의 문법부터 봅시다. 비구조화 할당 화살표 함수 클래스 생성기 Promise &amp; async / await ⭐타입스크립트 고유의 주요 문법 타입 주석과 타입 추론 인터페이스 튜플 제네릭 대수 타입 (추상 데이터 타입) ⭐타입스크립트 개발 환경 만들기 (Mac 0S 기준) ✅ 비쥬얼 스튜디오 코드 (VSCode) 설치  https://code.visualstudio.com/ ✅ Node.js 설치  https://nodejs.org/en/ ✅ 구글 크롬 브라우저 설치  https://www.google.com/intl/ko/chrome/ ✅ 타입스크립트 컴파일러 설치 터미널에서 아래 명령어를 입력해서  npm i -g typescript typescript를 global하게 설치합니다.  tsc -v 출력 예시 :   Version 4.1.2  (타입스크립트의 버전이 떴다면 정상적으로 설치완료) ✅ 타입스크립트 파일 생성 리눅스 계열 OS에서는  touch  프로그램이 기본적으로 설치가 되어있습니다. 맥OS도 리눅스 계열이므로  touch  명령어를 사용할 수 있습니다.  touch hello.ts  hello.ts  파일을 만드는 명령어 입니다. 타입스크립트 파일의 확장자는  .ts  입니다. 간단한 로그를 찍어주는 코드를 작성해 봅시다. ✅ 타입스크립트 컴파일  tsc hello.ts 위의 명령을 입력하고 나면 해당 폴더에  hello.js  라는 이름으로 자바스크립트 파일이 생성됩니다. 트랜스파일러에 의해서 타입스크립트 → 자바스크립트 코드로 변환이 되는 것입니다. ✅ 컴파일 된 자바스크립트 파일 실행  node hello.js 자바스크립트로 변환된 파일을 실행시켜 봅시다.   위의 사진과 동일하게 실행됐다면 성공적으로 실행이 된 것입니다. ✅  ts-node  설치  tsc  명령어는 타입스크립트 코드를  ES5 tsc ts-node  프로그램을 이용하면 변환과 실행을 동시에 시켜줍니다. 그리고  위와 같이 문구를 바꾸고,  ts-node 정상적으로 작동합니다! 📌 인턴 📍 3월 2일 ~ 6월 11일 제가 인턴을 진행한 기간입니다. 3개월 약간 넘는 기간동안 학교에서 진행하는 인턴십을 진행했습니다. 한 학기에 해당하는 기간이라 마냥 짧은 시간은 아니었고 실제로도 진행하는데 꽤나 긴 시간처럼 느껴졌습니다. 이 기간동안 많은 것을 배웠고 많은 것을 했습니다. 인턴이 끝난 기념으로 제가 했던 것들과 느낀점들을 기록으로 남기려고합니다! 📍 웹 프론트엔드 개발 우선 제가 들어간 곳은 직원수가 30명정도 되는 이제 막 시작하는 스타트업이었고, 저는 이곳에 프론트엔드 개발자로 들어가게 되었습니다. 이 회사의 주요 프로덕트는 영어 쉐도잉 어플리케이션이었고, 저는 앱 개발보다는 웹 개발을 하고 싶다고 맨 처음에 말을 했는데 다행히 웹 개발을 하는 프로젝트가 있어서 해당 프로젝트에 배정이 되었습니다. 아래는 제가 진행한 프로젝트들입니다. B2B 사이트 개발 (약 두 달 정도) 개요 B2B? 처음에 B2B 웹 사이트를 담당하게 될 것이라고 들었을 때는 처음듣는 단어라서 많이 당황했습니다. B2B는 Business-to-Business service의 약자로 보통 영어 어플리케이션 같은 경우는 B2C(Business-to-Customer)로 주요 타겟층이 고객 이라는 뜻입니다. 영어 어플리케이션의 주요 기능들은 전부 고객들을 위한 것입니다. 하지만 제가 맡은 B2B 웹 사이트는 주요 타겟층이 회사나 학원같은 대규모 인원들을 대상으로 진행하는 비지니스 모델입니다. 그래서 회사에서 단체로 구매를 했을 경우, 회사에게 여러 통계 지표를 보여준다던지, 관리자들이 할 수 있는 기능들을 수행할 수 있는 웹 사이트를 만드는 것이 B2B 웹 사이트입니다. 딱 들었을 때 와닿지 않아서 추후에는 LMS(Learning management system)으로 이름을 동시에 사용했습니다. B2B 프로젝트? 제가 3월달에 B2B 프로젝트에 투입이 되었을 때는 개발이 많이 진행이 되지않은 상태였습니다. 1월달부터 한 분의 개발자가 개발을 해오고 계셨는데, 제가 들어감으로써 2명이서 개발을 진행하게 된 것입니다. B2B 사이트는 일반 사용자들에게는 비공개라서 스크린샷을 첨부할 수 없어 많이 아쉽습니다... 내가 맡은 것 로그인 페이지 로그인 페이지가 기본적으로  react-admin  프레임워크에서 제공되는 로그인 페이지를 사용하고 있었는데, 제가 디자인적으로 욕심이 생겨서 해당 로그인 페이지를 커스터마이징 하여 저희 회사의 분위기에 맞도록 개발을 하였습니다.  생성, 삭제, 수정과 같은 함수 추가 제가 프로젝트에 막 투입됐을 때는 생성 기능밖에 없었는데 나머지 기능들을 추가하는게 저의 임무였습니다. 그래서 기존에 구현이 되어있던  dataProvider  를 사용해서 삭제와 생성, 수정과 같은 기능들을 추가했습니다.  여러가지 편의기능 추가 (이메일로 ID 찾기, 비밀번호 찾기, CSV로 파일 불러오기) 회사에서 단체로 구매를하고, 관리자가 멤버를 추가할 때 ID값을 알아야 추가를 할 수 있었는데, ID값이 해쉬값으로 구성이 되어있어서 직접 일일이 쳐서 추가를 한다는 것은 거의 불가능했습니다. 그래서 멤버들의 정보를 입력해서 버튼을 클릭하면 그 정보를 바탕으로 ID값을 가져오는 기능을 구현했고, 추가로 비밀번호를 찾는 기능이라던지, CSV 파일을 읽어서 멤버들을 한꺼번에 불러오는 기능과 같은 것들을 개발했습니다. 한/영 언어 선택 기능 원래는 한글만 지원을 하려다가 나중에  globalization 을 생각해서 영어까지 지원을 하게 되었습니다. 그래서 I18N(언어 선택) 기능을 추가를 했습니다. 추후에 B2B 홈페이지를 개발하는 사람에게 다른 언어를 쉽게 추가할 수 있도록 하였습니다. 번역과 같은 작업은 어떻게 이루어지는지 알 수 있어서 좋았습니다. 전체적인 디자인 전체적인 UI가 파랑색으로 이루어져 있었는데, 인턴 회사는 시그니처 컬러가 빨강색 이었습니다. 그래서 전체적인 UI 색을 빨강색으로 입히는 개발도 진행을 했습니다. 사용 기술  react-admin B2B 사이트를 구현하는데 사용되는 프레임워크입니다. 기본적인 UI와 여러가지 기능들을 제공을 하고있습니다.  react-admin 은 라이브러리가 아닌 프레임워크라서 처음에 프로젝트에 도입됐을 때 적응을 잘 못했습니다. 동작방식은 어떻게 되는지, 어떤 컴포넌트를 제공하는지, 사용법은 무엇인지 등등 프레임워크에 익숙해지는 시간이 필요했었습니다. throttle &amp; debounce 여러 Input에 값에 대해서 검증을 진행한다던지, API를 호출을 해야하는 경우가 있었는데 보통 onChange 이벤트에 검증이나 API 호출을 넣는 경우가 많습니다. 그럴 때 value가 변할 때마다 onChange 함수가 실행이 되기 때문에 성능면에서 좋지 않습니다. 그래서 여러 번 반복되는 함수 실행에 제약을 걸어주는  throttle  과  debounce 에 대해서도 자세히 알게 되었고, 실제로도 적용시켜봄으로써 확실히 알 수 있었습니다. I18N I18Next  였습니다. 하지만  react-admin  자체적으로 제공하는  I18N  이 있어서 그거를 사용하게 되었습니다.  어려웠던 점 react-admin 맨 처음 이 프로젝트에 도입되었을 때 어느정도 틀이 구축이 되어있어서 거기에 익숙해지는데 조금 시간이 걸렸습니다. 더구나 그냥  react  코드 였으면 조금 쉽게 익숙해질 수 있었는데  react-admin  프레임워크 공식문서를 읽고 코드를 이해하느라 처음 3일 정도는 코드를 이해하는데에 집중을 했던 것 같습니다.  graphQL 회사에서는  REST API 를 사용하다가  GraphQL 로 넘어가는 중이었는데  GraphQL 이 무엇인지는 알고 있었지만 사용법을 몰라서 조금 많이 헤맸습니다. CTO분이 가이드 해주신 걸 토대로 제가 원하는 함수를 만들어보았습니다. 하지만 다른 사람의 코드를 참고하여서 만들었고, 제가  GraphQL  을 정확히 이해를 한 것이 아니라서 나중에 따로 공부를 해야할 것 같습니다.   B2B 소개 페이지 개발 (한 달 정도) 개요 소개 페이지?  결과물     B2B 웹 페이지를 개발하고 사용자들에게 제공하기 전에 회사의 B2B 프로그램에 대해서 설명을 하는 페이지를 개발했습니다. 기존에 회사 어플리케이션 홈페이지가 있었는데 거기에 버튼을 추가해서 제가 만든 사이트로 이동을 하는 방식으로 기획이 되었습니다. 내가 맡은 것 전체 디자이너분께서  zeplin  을 통해서 공유해주신 디자인을 통해서 개발을 진행하게 되었습니다. 큼지막하게 6개의 섹션으로 나누어서 진행을 했습니다. 우선 공통적인 부분인 헤더(로고)와 푸터를 먼저 넣었고 (헤더와 푸터는 개발이 되어있어서 컴포넌트 그대로 가져다 사용했습니다.) 그리고 맨 위의 섹션부터 하나하나씩 개발을 진행했습니다. 섹션 개발은 데스크탑 뷰 먼저, 그 다음엔 모바일 뷰 개발을 하였습니다.   위 사진은 제가 브랜치를 나누면서 같이 프로젝트를 진행하는 사람들에게 공유를 하기 위해서 만든 PPT입니다.  shape-up  과  betting  은 회사의 process가 진행되는 방식을 의미합니다. 원래  betting  기간에는 다음  shape-up  을 위한 기획에 집중이 되어야 하는데 저는 전  shape-up  에 마무리를 전부 하지 못해서 열심히 베팅 기간에도 개발을 진행했습니다... 사용 기술 nextJS, semantic Tag 우선 회사 제품 웹 사이트는 nextJS로 개발되었습니다. 그래서 제가 추가하는 B2B 소개 페이지 역시 nextJS를 신경써서 제작을 해야했습니다. 제가 만든 페이지가 데이터를 받아온다던가 하는 부분들이 없어서 크게 신경 쓸 부분은 많이 없었지만, 제가 놓치고 있던 부분은  semantic tag  에 대한 부분들이었습니다.   시멘틱 태그를 알기전에는 모든 컴포넌트를  div  로 감싸서 코딩했습니다. 하지만 논리적으로 정해진 HTML 태그들을 사용해야 SEO(검색 엔진 최적화)에 좋다는 것을 알았고,  div 로 했던 모든 것들을 논리적인 태그로 전부 바꿨습니다.  header  와  section ,  article  같은 태그들은  div  와 똑같은 역할을 하지만 구글 검색 엔진에서 크롤러가 열심히 웹 사이트들의 구조를 파악하고, 크롤러에게 좋은 웹 사이트라고 인식이 되기 위해서는 그냥  div  가 아닌 논리적인 태그로 이루어져야 한다는 것을 새롭게 알게되었습니다. useForm 마지막 섹션에  form  을 구현해야 해서 그냥 생각없이 구현을 하다가 코드리뷰를 받고 정말 많은 것을 느꼈습니다. 개발자는 항상 좋은 코드를 작성하려고 노력해야 한다는 것을 알고 있지만 그냥 제가 아는 그대로만 작성을 하고 있었습니다. 그래서 피드백을 받고 작성한 것이  hooks  를 이용한  form  입니다. 공통적으로 사용하는 함수 같은 경우에는 모듈화를 해서 사용하는 방식으로 코딩을 했습니다. 그래서 제가 코딩했던 것을 기록하기 위해서  벨로그에도  올렸습니다. 어려웠던 점 CSS 반응형 디자인 브라우저  width  에 따라 다른 크기를 보여주기 위해서  vw  단위를 사용했습니다. 그리고 모바일과 데스크탑을 나누는 브레이크 포인트를 하나로 기준을 두고 (600px) 기준보다 아래면 모바일로 인식, 위면 데스크탑으로 인식하게 하여서 따로따로 디자인을 했습니다. CSS가 생각보다 정말 신경쓸 부분이 너무 많았고, CSS 요소들마다 브라우저에서 지원을 하는지 안하는지도 정말 중요했기 때문에... 예를 들어  display: flex  에서  rowGap  특성을 사용하면  safari  와  ios  에서 지원을 안합니다. ( 최근 사파리 업데이트에서 추가가 되었다고 합니다. )   이제는 디자인을 보면 어떤식으로 디자인을 해야겠다. 어떤 요소를 사용해야겠다 라는 건 금방 눈에 들어오지만, 막상 다 하고나면 짜잘한 오류(사파리에서 작동을 안한다던지, 익스플로러에서 작동을 안한다던지)들과 같은 신경 쓸 것들이 너무 많다는 것 또한 깨달았습니다.  📍 저번 인턴과 비교한다면? 작년에 진행했던 여름방학 인턴십과 비교를 해본다면? 코드 리뷰 제일 큰 차이점은 코드 리뷰를 받고, 안 받고의 차이였습니다. 저번 인턴 때는 중견기업이라서 인턴에게 많은 리소스를 부여하지 않아서 사수 한 분이 배정이 되고, 과제를 해결해나가는 느낌이었다면 이번 인턴은 스타트업의 느낌이 정말 강했고 정말 프로덕트를 개발한다는 느낌이 있어서 저의 코드 하나하나가 실제 프로덕트에 들어가기 때문에 리뷰를 꼼꼼히 받았습니다. 코드 리뷰를 받음으로써 정말 내가 아직 코드적으로 많이 부족하구나를 느꼈고 열심히 해야겠다고 생각했습니다. 이슈를 쪼개는 기준,  string 을 그대로 넣지 않고 상수화 시켜서 넣는 것, 변수 네이밍, 중복된 코드를 다루는 법, 메모이제이션 등등과 같은 코드 퀄리티를 높이는 것에 대해서 정말 많이 배웠습니다. 회사 규모 저번 인턴 때는 300명의 사원이 있는 중견기업이었고, 이번에는 30명정도의 멤버가 있는 스타트업이었습니다. 저번 인턴 때는 사수님과 그리고 팀장님까지밖에 못만나봤지만, 이번 인턴때는 직접 운영하고 계시는 CEO, CTO 분들과 1:1 미팅을 할 수 있고 그 분들의 생각을 들을 수 있어서 정말 좋았습니다. 📍 마지막으로 대학교를 다니면서 두 번의 인턴밖에 안해봤지만 중견기업, 스타트업을 경험해보았으니까 정말 큰 대기업이나 유니콘 기업도 경험을 해보고 싶습니다. 이번 인턴이 정말 좋았던 것은 실제로 창업을 한 CEO들이 어떻게 일하고, 스타트업은 어떻게 돌아가는지 정말 눈 앞에서 경험할 수 있어서 너무너무 좋았습니다. 📌 자전거 구매   예전부터 자전거를 사고 싶다는 생각을 계쏙 가지고 있었는데 이번에 기회가 돼서 그냥 구매를 해버렸습니다. 이것보다 한 단계 낮은 기종을 사려고했는데 사고자 하는 기종이 매물이 정말 없어서 조금 높은 가격이지만 열심히 타고다니자는 마음으로 큰 돈 주고 구매하게 됐습니다. React hooks를 사용한 useForm 만들기 를 하면서 했던 내용들을 공유하려고 합니다. 📌 섹시하지 못한 Form   우선 Form을 만들 때 고려해야 하는 것들이 있습니다. Input handler (onChange 함수) Error text (validation 함수) 위 사진처럼  이름 ☑️ State 우선  Input 의 값을 담아줄 state가 필요합니다. 그리고  Error Text 를 띄울 state와 제출 버튼을 클릭했을 때 로딩중인지 나타낼 state 이렇게 생성했습니다. ☑️ onChange Handler  Input  값이 변경될 때마다 값을 갱신시켜 줄 핸들러를 생성합니다. ☑️ validation function 제출 버튼을 클릭했을 때  Input  값을 판별할 validation function 또한 선언해주었습니다. ☑️ Submit function useEffect  안에는  async - await isLoading  값이 변경되면 제출된 값에 대해서 Alert(toast)를 띄우는 간단한 함수입니다.  이렇게 작성하면 문제점이 뭘까요? 우선 Form에 필요한 데이터는  name id ,  password ,  email  등등 많은 값들이 필요하게 됩니다.  onChange validation state 하지 못합니다. 이렇게 만드는 사람이 있냐구요?    그럼 섹시하게 Form을 만드는 방법은 무엇일까요? 📌 섹시한 Form 섹시한  Form  을 작성하기 위한 아이디어로는 중복된 코드를 줄이는 것입니다. 우선  섹시하지 못한 Form  의 중복되는 코드들은 각종  state  들 (input value, error text)  onChange Handler  함수들  validation  함수들 정도로 나눌 수 있습니다. 그래서 우리는  React Hooks  를 이용해서  useForm  을 제작할 겁니다! ✅ Hooks? useForm? 그럼  Hooks  는 무엇일까요? 잠깐 짚고 넘어가면 *  React Hooks 은 리액트의 새로운 기능으로 React 16.8버전에 새로 추가된 기능으로  state ,  component 에 대한 것들을 바꿔놓았습니다. * React Hooks 예를 들면  function component 에서  state react hook 을 사용하여 만든다면  class component ,  render function 이 되는 것 함수형 프로그래밍이 가능해지는 것입니다. 보통 Hooks 들의 이름 앞에는  use 그래서 요약을 하자면 우리는  form render  함수 또는 생명주기 함수들을 사용하지 않는  hook  을 사용하니, 이름은  useForm  짓자. * ✅ useForm 제작 우선 useForm의 전체 코드를 살펴보고 하나하나씩 뜯어보겠습니다. useForm의 매개변수들  function useForm({ initialValues, onSubmit, validate }: useFormProps) { 우선  useForm  을 사용하는 곳에서 받아올 매개변수들입니다.  initialValues state 로 관리를 합니다. 이런식으로  useForm  을 사용하는 곳에서  state  들을 정의할 수 있습니다.  onSubmit  와  validate  도 같은 맥락으로 제출 함수와 검증 함수를  useForm  을 사용하는 곳에서 선언에서 사용할 수 있도록 하는 것입니다. state, onChange handler 위에서 받은  initialValues  는  useForm  안에서  values  라는  state state  들은 어떻게 할까요?  useForm  안에서의  onChange  는 어떻게 작성될까요?  섹시하지 못한 Form  에서 각각의  state  들마다 handler를 하나씩 생성해주었는데,  useForm  에서는 하나로 통일했습니다. 들어오는  event.target  객체의  name  과  value Input  컴포넌트의  name  속성으로  state 와 같은 이름을 지정해줘야 합니다.  &lt;Input name=&quot;id&quot; /&gt; 이런식으로 말이죠. 이렇게 코딩을하면  Input  컴포넌트가 많아진다해도,  name  만 변경해주고, 그에 맞는  initialValues  만 선언해주면  handleChange  함수를 또 만들지 않아도 됩니다. Validation   그럼 입력 검증은 어떤식으로 진행될까요? 우선 저는 validation을 코드를 적을 파일을 새로 작성해주었습니다. 그리고  useForm  을 사용하고자 하는 컴포넌트에서 아까  useForm.ts  파일에서  validation validate: SignUpValidation  이런식으로 validation 함수를 넘겨줍니다. 그러면  useForm  에서는 제출 함수인  handleSubmit  이 실행될 때, errors state의 setter인  setErrors  를 통해서 저희가 넘겨준 validate 함수  SignUpValidation  함수를 실행해서  errors  객체를  state 로 변경시켜줍니다. 그럼  errors  state가 변경되었으니, 아래  useEffect errors  의  key  의 개수를 파악하는 식으로 에러가 났는지 안났는지 확인할 수 있습니다. 다음과 같이 말이죠. 그럼  validation  진행은 알았고,  error text  는 어떻게 나타낼까요?  useForm  을 사용하는 컴포넌트에서  errors  state를 사용하면 됩니다. 이런식으로요 📌 마무리  useForm  을 사용해서  form form  을 작성하면서 이렇게도 짤 수 있구나를 알게되어서 되게 좋았습니다. 참고  [React Hook] 양식(form)에 적용하기 React Hooks 공식문서   📌 인턴 두 달 후기 프론트엔드 개발자로 두 달이라는 시간이 흘렀다. 두 달이라는 시간이 어떻게 보면 길게 느껴질수도 있는데, 막상 돌이켜보면 무언가를 하기엔 너무 짧은 시간이었던 것 같기도하고, 내가 조금 게을렀던 것 같기도하고... 원래 우리 회사가  sprint  라는 개발 방법론으로 1주일 단위로 나누어서 진행을 하고 있었다. 이번 4월부터 다른 방법론을 적용해서 3주단위로 진행을 하게 되었는데, 조금 더 체계적으로 기획과 개발을 나누어서 할 수 있어서 좋았다. 이번 주가 개발 마지막 주였는데, 내가 맡았던 부분을 전부 해결하지 못해 조금 많이 아쉽다. 예전에 개발기간은 자기가 생각하는 기간의 두배로 잡으면 적당할 거라고 했던 어떤 글이 생각이 났었다. 이번 달까지 인턴을 진행하면서 느낀 것은 혼자 개발하면 절대 실력이 빨리 늘 수 없다는 것을 느꼈다. 코드 리뷰를 받으면서 정말 내가 많이 부족하구나 라는 걸 계속해서 느끼고있다. 나의 코드를 리뷰해주는 분과 나와의 다른 점이라고 하면 어떤 무언가를 사용하면 그것을 왜 사용하는지, 사용하면 장점이 무엇인지, 어떻게 하면 더 나은 사용자 경험을 줄 수 있는지 계속해서 생각하고 피드백을 주는 것 같았다. (왜 나는 그렇게 깊게 생각하지 못하는가) 아직 많이 부족함을 느끼고 나도 그렇게 생각하려고 계속 생각하는걸 보면 긍정적인 영향을 코드 리뷰를 하면서 많이 받는 것 같다. 가끔 죄책감도 조금 들고... 덕분에 코멘트를 고치려고  Self-review 를 많이 작성하다보니 Github Activity의 비율이 56%까지 치솟았다.   어느새 인턴 기간이 한달 가량 남았는데 많은 것을 배우고 느끼고 가고 싶다. 너무 조급해하지 않으려고 한다. 인턴으로써 할 일을 다 하면서 내가 얻어갈 수 있는 것들을 모두 얻어가자. 📌 퀸스 갬빗 (The Queen&#39;s Gambit) 넷플릭스라는 새로운 취미가 생겨 넷플릭스를 챙겨보다가 눈에 계속 들어오던  퀸스 겜빗 을 3일정도에 걸쳐서 정주행을 했던 것 같다. 예전에 유튜브에서 넷플릭스나 다른 영화를 요약해서 보여주는 채널에서 보았었는데 되게 흥미롭게 봐서 처음부터 끝까지 다 봤다. 유튜브로 요약본을 봤을 때는  체스 천재 소녀 이야기  라는 주제로 체스에 관한 얘기를 많이 풀어내고 체스에 관한 내용이 많이 나올 줄 알았다. 막상 정주행을 하고나서 느낀 것은 당연히 체스에 관한 얘기도 많이 나오지만, 체스에 관해서만 나오고 거기에 몰두하는 것이 아닌 다른 세부적인 이야기들도 풀어내고 있었다. 특히 마지막쯤에 풀어내는 이야기는 주변 사람들의 소중함에 관한 이야기를 하는 것 같았다. 함께 하는 사람들의 소중함에 대해 다시 생각할 수 있었고, 소소함 감동과 체스를 몰라도 재미있게 볼 수 있었던 것 보면 잘 만든 드라마인 것 같다. 📌 운동 운동을 시작한건 예전 군대때부터 조금씩 흥미가 생겨서 꾸준히 헬스를 다닌지 약 1년정도 된 것 같다. 하루하루 그냥 운동을 할 때는 몸의 변화를 잘 못느낀다. 그냥 하니까 하는 느낌. 그러다가 인바디를 며칠전에 쟀었는데, 작년에 비해서 몸이 많이 변한 것 같아서(골격근량 늘고, 체지방량이 줄음) 기분이 좋았고, 재고 나니 내 몸이 조금 변했나? 하는 생각이 들었다. 코딩은 꾸준히 못하더라도 운동은 꾸준히 했었는데 확실히 몸의 변화가 이루어졌다는 것을 느끼니 조금 더 열심히 하고싶고, 이번 여름은 힘들지라도 내년 여름정도에는 몸을 만들어서 바디프로필 같은 것도 찍어보고싶다. 인생에 있어서 한번쯤은 몸이 좋았던 시절이 있어야 하지 않을까?.. 하는 생각 📌 4월과 그 이후 벌써 5월이라니 2021년을 맞이한 지 얼마 됐다고 5월인지 점점 대학생 생활이 끝나감에 너무 슬프고 두렵다. 하루에 인턴 일이 끝나고 맨날 더 공부를 해야지, 프로젝트를 해야지, 하는 생각만 들고 막상 한 날은 별로 없었던 것 같다. 정말 정말로 회사 일을 하면서 사이드 프로젝트를 하는 분들에 대한 존경심이 느껴졌다. 인턴에서 하루하루 무사히 지나가는 것만으로 조금 나에겐 벅찬 것 같았다.  리액트의 장점에는  Virtual DOM  이 있어 근데... Virtual DOM이 정확히 뭔데? Virtual 이라고 하면 가상? 뭔가를  가상으로  돌리는 것 같다라는 것은 누구나 알 수 있다. 근데 중요한 것은 그것을 왜 쓰는지에 대한 이유를 알 필요가 있다. 브라우저의 동작 방식  Virtual DOM 을 사용하는 이유를 알기 위해서는 우리가 사용하는  Chrome ,  Firefox 와 같은 브라우저의 동작 방식을 알아야한다. 사용자 인터페이스: 브라우저의 뒤로가기, 새로고침 버튼과 같은 것들이다. 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이에서 연결다리 역할을 한다. 렌더링 엔진: 요청한 콘텐츠를 표시한다. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다. 통신: HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행됨. UI 백엔드: 콤보 박스와 창 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용한다. 자바스크립트 해석기: 자바스크립트 코드를 해석하고 실행한다. 자료 저장소: 이 부분은 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 &#39;웹 데이터 베이스&#39;가 정의되어 있다. 우리가 집중할 곳은  렌더링 엔진 의 동작방식이다.   DOM Tree 브라우저가 HTML을 받으면 렌더링 엔진이 HTML을 파싱하고 DOM의 Node로 이루어진 트리를 만든다. Render Tree 그 다음으로 외부 CSS 파일을 파싱한다. 그리고는 스타일 정보와 DOM Node 트리를 가지고  Render Tree 라는 새로운 트리를 생성한다. Layout 이  Render Tree 를 만들 때는 각 Node들의 요소들의 스타일이 계산되고, 각 노드가 화면의 정확한 위치에 표시되는 것을 의미한다. Painting 화면의 정확한 위치에 표시된 노드들을 그리는 과정이다. 이 과정들이 점진적으로 진행된다. 우리가 DOM을 임의적으로 조작을 하면 위의 과정들이 다시 반복이 되는 것이다. 노드를 하나 바꿀 때 마다 위의 과정들이 반복되기 때문에 전체적인 성능이 떨어지고 속도가 느려진다. Virtual DOM 리액트는 SPA(Single Page Application)이다. SPA는 DOM에 조작이 많이 발생한다. 그래서 리액트는 이를 해결하기 위해서 Virtual DOM을 사용한다. Virtual DOM은 Real DOM으로 변화가 적용되기 전에 앞단에서 변화들을 다 수용하고 난 다음에 최종적인 결과를 Real DOM에 전달을 해주는 역할을 한다. 가상 DOM을 조작하는 것은 실제 집에서 방을 움직이는 것이 아니라 청사진을 편집하는 것으로 생각하면 된다. Virtual DOM은 Real DOM과 동일한 속성을 갖고 Real DOM의 가벼운 복사본이다. JSX 요소를 렌더링 할 때 모든 Virtual DOM이 업데이트된다. 이건 엄청나게 비효율적으로 들리지만 Virtual DOM이 빠르게 업데이트 될 수 있기 때문에 비용은 미미하다. Virtual DOM이 업데이트되면 React는 Virtual DOM을 업데이트 직전에 찍은 Virtual DOM 스냅 샷과 비교한다. 핵심적인 차이는 Virtual DOM이 없다면, Real DOM이 받을 연산들을 Virtual DOM에서 진행이 되고, Real DOM에는  딱 한번 의 전달만 이루어져서 Real DOM에는 딱 한번의 리렌더링이 일어나도록 하는 것이다. Virtual DOM에서 받은 변화나 계산들은 쪼개서 받을 때 보다 많겠지만, 요기서 중요한 것은  딱 한번 이라는 점이다. 연산의 횟수를 줄이는 것이 Virtual DOM의 목적이다. 요약 모든 Virtual DOM이 최신 정보들을 받는다. Virtual DOM은 업데이트되기 전과 비교를 한다. 그리고 React는 어떤 객체가 바꼈는지 알아낸다. 변한 객체들만 Real DOM에 업데이트 된다. Real Dom의 변화들이 화면의 변화를 일으킨다. 참고 브라우저 렌더링  https://d2.naver.com/helloworld/59361 VirtualDOM  https://velopert.com/3236 https://velog.io/@sbinha/React%EC%97%90%EC%84%9C-Virtual-DOM https://www.codecademy.com/articles/react-virtual-dom 📌 인턴 한달 후기 다행히 인턴에 합격을 하고 한달동안 인턴을 다녔다. 학교에서 원칙적으로는 아침 9시부터 저녁 6시까지의 근무를 원하지만, 나는 8시부터 5시까지 근무를하고 저녁시간을 조금 더 가지는 것을 선택했다. 나와 같이 프론트엔드 개발자로 하고 계시는 분도 엄청나게 경험이 많지 않아서 우리 프로젝트에서 필요한 기능들을 우리 스스로 생각하고 기획도 진행해야 될 때도 있다. 확실히 스타트업이라 개개인의 능력에 따라 프로젝트가 잘 진행이 되고, 안 될수도 있다는 것을 뼈저리게 느끼고있다. 내가 특출나게 잘하는 사람이어서 이 프로젝트를 성공적으로 신속하게 처리를 하고싶지만... 몸과 마음은 언제나 맞는 적이 잘 없는 것 같다. 회사의 복지나 분위기를 말하자면 저번 인턴때는 중견기업의 기업이었는데 확실히 그 때 보다는 좀 더 자유로운 분위기와 편하게 개발을 할 수 있는 분위기다. 그리고 회사라는 느낌보다는 &quot; 하나의 프로젝트를 같이 진행하는 팀 &quot; 이라는 느낌이 완전 강하게 든다. 그리고 회사의 시설도 리모델링을 몇 주전에 하고나서 카페같은 분위기라서 재미있게 개발을 할 수 있어서 좋다. 사람들도 너무 좋은 사람들밖에 없어서 이렇게 좋아도 되나 싶을 정도로 좋다. 나만 잘하면 될 것 같다. 📌 구글 폼 설문 인턴을 다니면서 학교 과목을 하나 더 수강을하고 있다. 종합설계라는 과목인데, 졸업프로젝트를 진행하면서 기획(문제정의서, 요구사항명세서, 브레인스토밍과정)등등의 보고서들을 매 주마다 내야하는데 2주차때는  문제점 목록 이라는 보고서를 내야했는데, 우리가 하고자 하는 주제의 문제점을 파악하는것이 목적이었다. 보통 다른 사람들에게 물어보거나 자신 프로젝트의 담당 교수님께 면담을 신청하는게 보통이었는데 우리는  구글 폼 을 사용해서 설문을 진행을 했다. 결과는 대성공적이었다. 우리가 이왕하는거 제대로 해보자고 해서 설문을 하는 사람들에게 추첨을 통해서 우리들의 사비를 털어서 기프티콘까지 제공해주기로 했다. 질문 또한 정말 우리가 원하는 것이 무엇인지 생각을 해서 작성을 했고 이렇게 많은 사람이 참여할 줄 몰랐다.   총 154개의 응답을 받았고, 보고서를 제출할 당시에는 142명의 응답을 기준으로 보고서를 작성해서 과제를 제출했던 걸로 기억이 난다. 보고서는 아래에서 볼 수 있다.  설문조사 결과 📌 넷플릭스 미생 넷플릭스를 원래는 안보다가 친구의 권유로 같이 결제를 하게 되어서 숙제처럼 보게 되었는데 (지금은 빠져있음) 처음으로 본 드라마가 미생이었다. 나는 아름다운 여자와 잘생긴 남자가 알콩달콩하는 드라마는 뭔가 끌리지 않았고, 넷플릭스에 딱 처음들어갔는데 추천해주는 작품들중에 내 눈에  미생 이 띄었나보다. 그래서 보기 시작했다. 나는 글을 잘 쓰는 능력은 없는 것 같아서 드라마에 대해서 크게 얘기를 하지 않겠다. 그냥 재밌었다. 나는 여러 회사를 다녀본 것도 아니고 아직 학생이라서 정말로 회사가, 사회가 저런가 하는 의문점이 들었다. 미생이라는 드라마는 드라마이므로 조금의 각색과 과장되게 하는 요소들이 당연히 있었지만 이 사회에서 어디선가 일어날 수도 있는 일이라고 생각이 들었다. 그리고 그 드라마적인 요소가 나한테는 크게 나쁘지 않았는지 계속 보게 되더라. 원래는 드라마나 영화같은 것을 챙겨보지 않았다. 귀찮았는지 다른 할 일이 많았는지 모르겠는데 지금느끼는 것은 경험해보지 않아서 몰랐던 것 같다. 미생을 이후로 지금은 다른 애니메이션을 보고있고, 넷플릭스라는 새로운 취미가 점점 자리잡는 것 같다. 📌 3월 그리고 4월 3월은 그냥 빠르게 지나갔다. 그리고 공부를 많이 못했다. 인턴 일이 끝나고나면 집에와서 헬스장에 갔다가 그냥 뻗어버리거나 놀러나갔다. 회사 일이 끝났는데 더 공부를 해야 돼? 라는 마음이 한 켠에 잡혀있어서 공부 의욕이 나지 않았던 것 같다. 지금도 그렇고.. 회사에서도 물론 배우는 것들이 많다. 하지만 나는 스스로에게 스트레스를 조금 줘야 편안함을 느끼는 성격이라 무언가를 더 해야될 것 같지만, 할 힘이 없고 또 거기에 대한 죄책감으로 조금 보냈던 것 같다. 4월에는 3월보다는 만족스러운 한 달을 보내고싶다. 우선 졸업프로젝트도 슬슬 개발을 시작해야하고, 내 개인적인 공부도 멈추고 싶지 않다. 이제 4학년이라 여러가지 생각이 드는 것도 그렇고 조금 더 힘을 내야 할 것 같다. 아직 출발지점에서 많이 오진 않았지만... 도착지점이 어디인지도 잘 모르겠다 사실 여튼 4월에는 3월보단 조금 더 의욕적이고 계획적이고 구체적인 한 달이 되기를   📌SW 중심대학 공동 해커톤 참가  2월 4일 부터  2월 6일 까지 2박 3일동안 하나의 소프트웨어를 만드는 해커톤에 참여를 했다. 주제는  코로나 언택트 시대에 맞춘 소프트웨어  였는데 그냥 저거는 형식상의 주제였고, 아무런 주제도 상관없다고 했다. 하나의 팀에 5명이 들어가고, 개발자 4명에 디자이너 1명으로 구성이 되었다. 해커톤에 참여하는 모든 사람들이 아이디어를 제안할 수 있었고,그리고 제안한 사람은 자동적으로 팀장이 되었다. 모든 참가자들이 해당 아이디어가 마음에 들면 함께 작업하고 싶다고 신청을 넣을 수 있었다.  나도 아이디어를 제안하고 싶었는데 도저히 생각이 나지 않더라,,, 그래서 내가 신청한 아이디어는 두 개 였는데 아쉽게도 첫번째는 이미 프론트엔드 개발자를 구한 것 같아서 들어가지 못했다. 그리고 들어간 두번째 팀의 주제는  코로나 시대에 맞춘 예술 문화 공유 웹 사이트 였다. 엄청나게 대단한 아이디어는 아니었지만, 취지가 굉장히 마음에 들어서 신청을 하게 되었다. 그러고는 2월 4일부터 2박 3일동안 팀원들과 계속 카카오톡, 줌을 통해서 소통을 하면서 개발을 시작했다. 맨날 혼자 개발하다가 다른 분들과 소통하면서 개발을 하는게 마냥 쉽지 않았고, 디자이너분이 정말 대단하고 멋있다는 것도 느꼈다. 아무래도 밤을 새우면서 진행하다보니 정신적으로 많이 힘들었다. 그럴 때마다 팀원들과 서로서로 으쌰으쌰하며 버텨내면서 할 수 있는 최선을 다했다. 그렇게 만들어진 결과물은 정말 완벽히 만족할 만한 건 아니었지만 최선을 다했기에 후회는 없었다. 그리고 API 통신을 위해서 스프링과 리액트 연동을 하는데에 꽤나 많이 시간이 지체되어서 아쉬웠다. 그리고 프론트분야를 맡으면서 단기간에 디자인과 기능을 전부 잡기란 정말 정말 힘들었다. 아쉽게도 수상은 하지 못했다. 결과물  깃허브 배포 사이트 그리고 여담이지만 같은 팀원분중에 백엔드를 맡으셨던 팀장님이 며칠전에 연락이와서 같이 다른 프로젝트를 진행할 생각이 없냐고 물어보셨다. 아쉽게도 나는 거절을 했다. 다가오는 학기에 아래에서 얘기할 인턴도 합격을 했고, 졸업프로젝트도 병행을 해야되어서 다른 프로젝트를 진행할 여력이 없을 것 같았다. 그렇게되면 내가 팀원분들에게 민폐를 끼칠 것 같아서 차마 내 의지만 충만하다고 받을 수는 없었다. 그래도 정말 기분이 좋았던 것은 내가 다른 사람에게 함께 같이 프로젝트를 하고 싶은 사람을 보여졌다는 것이 정말 행복했다. 해커톤을 성공적으로 경험했다고 이 때 생각했다. 📌하얀 마인드 인턴 합격 결국  하얀마인드 하얀마인드 는 영어 공부를 도와주는 어플리케이션  레드 키위 를 만든 회사이다. 내가 지금 거주하고 있는  대전 봉명동 에 사옥이 하나가 있고, 서울에 하나가 있는 걸로 알고있다. 해커톤을 시작하는 날에 면접을 봤어서 기억이 아직 생생하게 난다. 약 30-40분 정도 면접을 봤었는데 자기소개서에 썼던 내용들 위주로 질문을 받았다. 그 때의 기억을 되살려서 받았던 질문들을 떠올려보면.. 저번 인턴 때 쿠버네티스와 관련해서 일을 했는데, 쿠버네티스가 어떤 것을 하는 것인가? 내가 했던 프로젝트가 뭐고, 거기서 무슨 역할을 맡아서 진행했고 어려운 점은 무엇이었나? 내 성격이 남에게 싫은 소리를 못하는 성격이라고 했는데, 어떻게 해결했나? (지금은 괜찮다고 적었음) 코딩테스트때 풀었던 문제 하나를 설명해달라. 리액트 클래스 컴포넌트와 함수 컴포넌트의 차이점은 무엇인가? 리액트 기술중에서 우리에게 설명을 해주고 싶은 기술은? 면접을 받으면서도 기분이 되게 좋았다. 왜냐하면 정말 편한 분위기로 대해주셨고, 항상 웃고 계셨다. 나도 기분 좋게 말을 할 수 있었고 그냥 마냥 기술적인 내용들만 물어보는게 아니라, 나라는 사람이 어떤 사람인지 정말 궁금해서 나오는 질문들이 있었기에 기분이 좋았다. 면접 마지막에 영어를 혹시 할 줄 아냐고 물어서 엄청 못하는건 아닌 것 같다고 대답했다가 영어로 질문 받고 영어로 대답을 부탁한다는 것을 듣고 살짝 멘붕이 왔다. 그리고는 애기 옹알이 하듯이 대답을 해드렸더니 웃음을 참는 듯한 느낌이 들었다. 내가 들어도 웃길 것 같다.ㅋㅋㅋ.ㅋ... 그래도 다행히 합격 소식을 듣고 정말 기뻤다. 무언가를 간절히 원하고 이루기 위해 노력하고 난 다음에 얻는 성취는 정말 짜릿했다.  3월 2일 부터  6월 11일 까지 3개월 조금 넘는 시간이 어떻게보면 짧게 느껴질수도 길게 느껴질수도 있는데 작년 2개월동안 진행했던 인턴도 마냥 짧게 느껴지진 않았고, 얻은 것도 정말 많았기 때문에 이번에는 정말 좋은 경험이 될 것 같다. 영어 공부를 하자. 📌졸업 프로젝트 주제 제안 이제 나도 4학년이라서 졸업을 하기 위해서는  졸업 프로젝트 를 진행하고  논문 도 제출해야 졸업 요건을 만족해서, 졸업을 할 수 있다. 보통 교수님들이 제안하는 주제들중에서 학생들이 선택을 해서 신청을 하는 방식으로 진행이 된다. 혹은 우리가 교수님들께 주제를 제안하는 방식이 있다. 주제를 제안하는 방식은  졸업 프로젝트 에 걸맞는 주제를 고안해내고, 교수님을 지정해서 그 교수님을 만족을 시켜야 통과가 되기 때문에 쉬운 길은 절대 아니었다. 근데 우리 팀원들이 모두 만족하는 주제는 없었고, 정말 신중히 선택을 해야된다고 생각을 했다. 왜냐하면  졸업 프로젝트 는 1년동안 진행하는 프로젝트이기 때문에 누구하나 마음에 들지 않으면 안됐다. 회의를 통해서 결론이 난 것은 교수님들의 주제에 신청을 하지말고, 우리가  주제를 제안하는 방향으로 가보자 였다. 그렇게 우리가 생각해낸 주제를 가지고 해당 분야에 관심이 많으신 교수님께 제안을 했다. 다행히 교수님께 허락을 받고 우리 팀원들이 모두 원하는 방향으로  졸업 프로젝트 를 진행할 수 있게 되었다.  📌읽은 블로그 글들 이번 달에 읽은 기술 블로그 포스트들이다.  타입스크립트로 context API 사용하기  타입스크립트로 redux 프로처럼 사용하기  redux-middleware  NextJS-그게-뭔데  리액트-그게-뭔데  Javascript-ES6-Module   등등등... 이번달에는 타입스크립트로  context API 와  Redux 를 사용하는 것에 대해서 공부를 했고, 계속 이해가 안될 때는 토이 프로젝트를 진행하면서 익숙해질 때까지 반복을 했다.  https://github.com/junghyeonsu/practice-context-api  https://github.com/junghyeonsu/perfect-experience-of-flex 두 개의 간단한 예시를 직접 만들어보면서  context api 와  redux 에 대해서 공부를 했다. 벨로그를 시작하고나서 벨로그를 자주 들어오는데 개발자들을 위한 블로그이라서 그런지 정말 좋은 글들이 너무 많다. 최대한 유튜브 보는거를 줄이고 벨로그에서 글을 읽는 습관을 들이려고 한다. 📌HTTP책 빌려서 읽기   프론트엔드 개발자라면 무조건 읽어야 하는 필독서라고 하길래 2년만에 학교 도서관을 들렀다. 지금까지 1,2,3장을 읽었는데 작년 학교에서 배웠던  컴퓨터 네트워크 ,  데이터 통신  수업에서 들었던 내용들이 그대로 있었다.  HTTP이 무엇인지   HTTP 메세지 포맷   HTTP 메소드 종류   HTTP 요청과 응답   HTTP 헤더   HTTP 상태 코드  등등.. 여러가지 내용이 있었는데 지금 한꺼번에 적으려니 막상 생각이 안난다. 궁금하면 읽어보자. 책 대출기간이 30일인데 그 안에 다 읽을 수 있겠지?.. 📌리액트 기초 정리 리액트의 개념을 내가 제대로 알고있나 정리도 하고, 한번쯤은 정리를 해두고 싶어서 하루에 하나의 개념을 정리를 했다. 그렇게  notion 에 정리해놓은 것들을  velog 로 다시 옮겨서 올려놓았다.  👊리액트 부시기 : 리액트 초보 탈출하기 나는 누군가에게 무언가를 가르칠 때 내가 아는 지식을 공유한다는 것이 재미있고, 내가 모르는 것을 알 수 있어서 정말 좋다고 느꼈다. 📌2월 1월 회고록을 쓴지 얼마 됐다고 벌써 2월 회고록을 쓰고있다.  사실 그냥 개발을 안한 것을 변명하기 위한 말들일 뿐이다. 2월은 정말 너무 빠르게 지나갔다. 실제로도 짧은 것도 있고 휴학을 하지 않겠다고 마음먹고 나서 이번 2월달이면 방학이 끝난다는 생각에 싱숭생숭한 마음도 한 몫을 한 것 같다. 2월이 끝나면서 내 3학년 겨울방학도 끝나게 되었다. 방학 때 무엇을 했나 돌아보면 꾸준히 이룬 것은  운동 은 정말 열심히 했던 것 같다. 그리고 매일  카페 에 와서 노트북을 펴서 무언가를 하려고 했던 의지만큼은 성공했던 것 같다.  3월부터는 개강을하고 인턴을 시작하고 졸업프로젝트도 시작을하면 쉬고 싶다 해도 쉬지 못할 것 같다. 사실 나는 쉴 때도 공부를 해야된다는 강박에 빠져 무언가를 하지 않으면 뭔가 실패한 것 같고 그런 느낌을 자주 받는데, 휴식을 즐길 줄 아는 것도 중요하다는 것을 가족들과  포항 을 가서 느꼈다.  다음달 회고록은 아마 정신없던 한 달을 돌아보지 않을까 예상하며 2월 회고록 요기서 끝-⭐  리액트  를 친구랑 후배에게 가르쳐주면서 나도 되돌아 볼 겸 정리를 했씁니다. 정말 처음 접하는 사람에게 최대한 이해하기 쉽게 정리 하려고했고, 친구와 후배가 보기 쉽게  notion 에 정리를 해서 말투가 조금... 이상할 수 있습니다. 고수 입장 금지라고 해놨는데 다들 읽으시고 이상한 부분이 있다면 말씀해주시면 수정하겠습니다~! ✅리액트는 왜 쓰는걸까요  리액트 공식문서 https://velog.io/@skypedanny/리액트-그게-뭔데 ✅CRA 시작하기  create-react-app 시작하기 create-react-app 은 저 위에 것들을 설정할 필요없이 그냥 설치만 하면 바로 리액트를 사용할 수 있게 해주는  아주 좋은 라이브러리   ✅리액트 컴포넌트에 대해서 컴포넌트는  리액트 를 이루는,  뷰  를 구성하는 주요 요소라고 생각하면 될 듯? 최상단 컴포넌트에서 정말 작은 (예를들면 하나의 버튼을 보여주는 컴포넌트)까지 전부 컴포넌트로 이루어져있어영 그래서 리액트를 사용할 때는 컴포넌트를 어떻게 나누고, 어떻게 짤 것인지에 대해서 고민을 많이 하게됨 (왜? 하나의 컴포넌트안에 너무 많은 기능을 넣으면 가독성이 떨어지고 재사용성이 떨어짐) 컴포넌트를 나누는 건 대부분 기능별로? 재사용가능한 단위별로? 나누는게 대부분인듯!   컴포넌트를 어떻게 나눌 것인가 생각을 해보면  화면 전체를 나타내는 컴포넌트 (가독성이 뛰어남)  로고 컴포넌트  검색창 컴포넌트  동그라미 컴포넌트 (재사용성이 뛰어남) 로 나눌 수 있겠지? 그 안에 세부적으로 들어가면 뭐 할 게 많겠지만, 전체적으로 보면 이렇게 나눌 수 있다~ 이런말 컴포넌트의 종류 그러면 컴포넌트가 어떤건지 대충 추상적으로 알았으니까 이제 구체적으로 알 시간이야^^ 리액트 컴포넌트는 두 가지 형태를 제공하고있어.  클래스형 컴포넌트 class component  함수형 컴포넌트 function component  클래스형 컴포넌트    함수형 컴포넌트   클래스형 컴포넌트는 기계적이고, 함수형 컴포넌트는 인간 친화적으로 다가갈 수 있다. 그러니까, 클래스형은 조금 기계적으로, 우리 마음에 잘 와닿지 않는 구조이고 함수형이 우리가 조금 더 친숙하게 다가갈 수 있는 구조라는 얘기임  클래스형 컴포넌트 는 옛날에 사용됐고,  함수형 컴포넌트 는 최근에 이제 뜨기 시작했어 왜? 그 전에는   함수형 컴포넌트 에서  state 랑  life cycle 이라는 것을 못했거든. 근데 최근 리액트 업데이트에서  함수형 컴포넌트 에서도  state 랑  life cycle 을 조절할 수 있는 것을 업데이트해줌ㅎ^^ 그게 무엇이냐 바로바로  React Hooks React Hooks 를 사용하면  함수형 컴포넌트 에서도  state 랑  life cycle 을 조절할 수 있는데 그건 나중에 알게되겠지 뭐ㅎㅎㅎ ^^ 결론 : 최신 문법은 Function Component와 React Hooks를 이용한 구조를 많이 사용한다 Class Component 에서는  state 를 변경할 때  this.setState  라는 함수를 불러서 스테이트를 변경해야됨. 근데 이게 단점이 뭐냐면, 만약 하나의 state만 변경하고 싶은데  this.setstate  함수를 매번 불러야한다~ 하지만  React Hooks 를 사용하면   요기 보이는 것 처럼 각각  State 를 선언할 때  setter 도 같이 선언해줌. 그래서 저 함수를 사용해서 각각의  State 들을 바꿀 수 있따.  this.setState  를 선언 안해줘도 됨 그리고  function component 는 그냥 return 문으로 작성하면 되는데,  class component 는 render함수 안에서 return문을 작성하는 방식으로 진행이 된다. 엄청나게 귀찮고 그런건 아닌데, 그냥 개발자들은 이게 귀찮나봄. 그래서 나도  Function Component  와  React Hooks  를 사용하는 조합으로 바꿨음. 근데 편한거 같음^ ( 예전에는 나도  Class Component  사용했음. ) ✅리액트 State와 Props에 대해서 두 개의 개념은 정말 중요하지, 리액트를 한다고하면 어떤 state에 따라서 view를 결정하고(조건부 렌더링) , props를 전달하고, state를 변경하고, 관리하고 등등 리액트에선 정말 중요한 개념들이야 두 개의 공통점은 둘 다  렌더링 에 영향을 주는 데이터들 이라는 점! 그럼  state 와  props 는 무슨 차이가 있을까?  state 는 컴포넌트안에서 사용이 되는  데이터 이다!  props 는 컴포넌트로 전달되어서(마치 함수의 매개변수처럼)사용되는  데이터  이다. 이렇게 설명하면 잘 모르겠지? ㅇㅇ 그럴거같았어 그래서 준비했지 이제는  함수형 컴포넌트 로 기준을 잡아서 진행을 하겠습니다. 왜냐하면  클래스형 컴포넌트 는 더 이상 잘 안쓰이고, 공식문서에서도  함수형 컴포넌트 를 밀어주거든. 아직 잘모르더라도  함수형 컴포넌트  와  React Hooks  를 계속 사용하려고 노력을 해야 익숙해짐! State 사용하는 대표적인 Counter 예제  TestComponent.jsx   위의 예제를 보면  count state  를 선언해서 사용하는 것을 볼 수 있음! 보통  state 로 정하는 것들은  변하는 값 을  state 로 많이 설정함! 위 예제에서는  count 값 이 변하는 값이니까  state 로 지정을 해준 것임. 그리고  state 로 지정해준 값이 변할 때마다 그 값을 사용하는 부분이 다시 렌더링됨! 페이지가 전체가 다시 리로드 되는 것이 아니라, 해당 상태값을 사용하는 부분만 다시 렌더링이 된다~ 이 말씀 그리고  state 는 배열, 숫자, 문자, 객체 모든 형태로 존재할 수 있어. 그리고 이렇게 컴포넌트안에서 정의된  state 는 이 컴포넌트에서 사용되는 값이기 때문에 만약에 다른 컴포넌트로  state 를 넘겨서 사용하고 싶다면? 전달을 하고 싶다면 어떻게 해야될까? 그 때 우리의  props 의 개념이 들어가는거지  TestComponent.jsx    TestChildComponent.jsx        TestComponent  에서  TestChildComponent 로  count state 를 넘기려면  props  개념을 도입해서 전달을 해야 돼!   위와 같은 방식으로  props 를 넘기게 되어있어. 내가 예제에서는 둘 다  count 로 이름을 지정해놔서 헷갈릴수도 있는데, 너가 만약에 다른 이름으로 넘기고 싶으면  다른이름 = { count }  이런식으로 다른이름으로 props를 넘길 수 있어.  그럼 넘기는거까지는 성공했는데 받는쪽에서 사용은 어떻게 할까?   받은쪽 컴포넌트에서는 위에서 밑 줄 친 것처럼 위에서  넘길 props 이름 으로 지정해놓은 걸로 받을 수 있어 만약에  count 가 아니라 다른이름으로 지정해놨으면 해당 이름으로 받아야 돼! 저렇게  count  데이터를 부모로 받겠다고 정해놓고, 아래  View 를 책임지는  return 문에서 사용을 하면 되는거임! 정말 쉽죠~? 그럼 저  count 는 부모 컴포넌트로부터 받은  props  가 되는거지. props children에 대해서 이제  props 에 대해서 알았다 이거야. 근데  children 은 뭐냐고? 우리가  props 로 넘기고 싶은 데이터가 저런 상태값이나 특정값말고 , HTML요소 를 넘기고싶으면? 그럴때 사용할 수 있는 것이  children  이라는  props  입니더.   우리는 저렇게  TestChildComponent  에서 HTML 요소를 출력하고 싶다면?    children 을 받겠다고 명시를 해준 다음  return  문에서  {children}  을 고대로 출력해주면  &lt;p&gt;요기는 children 이름으로 전달될거야!&lt;/p&gt; 이 부분이 전달이 되는거지! 이게  props   children  의 개념이야. 다른  props 들은 너가 이름을 정하는대로 전달이 되겠지만, 이렇게  children  처럼 정해진 요소가 있다는 것!   쉽죠?  state 랑  props 의 개념 기본적인 것들은 다 가르쳐준듯 그럼 생각할 수 있는게, 만약 프로젝트의 크기가 정말 정말 커져서  고조 할아버지 컴포넌트  →  증조 할아버지 컴포넌트  →  할아버지 컴포넌트  →  아버지 컴포넌트  →  자식 컴포넌트  이렇게 계층구조가 이루어져서 맨 위의 컴포넌트에서 맨 아래에 컴포넌트에 상태값을 넘기고싶어. 그러면 일일이  props 로 넘겨야할까? No. 절대 그렇게 일일이 다 할 수없어.  가독성도 정말 떨어지고 코드의 퀄리티도 정말 떨어질거야. 이제 그럴 때 필요한 개념이 바로바로 그 무시무시한  전역 스테이트 관리  가 되는거지. 대표적인 것들로는  Redux   mobX   Context API  , 그리고 새롭게 뜨고있는  Recoil  등등... 거의 리액트의 끝판왕👿이지. 각각 사용하는 방식도 다르고, 사용하는 상황도 조끔씩 달라. 일단 이런것들이 있다는 걸 알고있는 것 만으로도 너희는 최고야.  전역 스테이트 관리  단어만 들어도 유추할 수 있듯이 전체적으로 스테이트를 관리해주는 어떠한 것이 있고, 거기만 참조를 하면 바로 사용할 수 있는 그런 느낌적인 느낌. 여튼 고생-✌️뿅 ✅React 이벤트 및 이벤트 전달 클릭했을 때, 마우스 올렸을 때, 마우스 나갔을 때 등등 여러가지 이벤트 전달하는 방법은 HTML 이랑 JS랑 똑같음!   너가 이벤트를 넣고 싶은 요소에  on  만 써도 여러가지 이벤트들이 나옴. 제일 많이 쓰는건  click  이나  change  임   컴포넌트안에 함수 객체를 생성해서 (const) onClick 특성에 넣어주면 되는거임   이정도면 이벤트 쓰는건 다 알았다 보면 됨ㅎㅎ  이벤트도 props로 넘길 수 있다고? ㅇㅇ 가끔 부모 컴포넌트에서 생성한 함수를 자식 컴포넌트에 실행시키고 싶은 욕구가 들 때가 있어 그럴 때 함수를 props로 넘길 수 있음! 그냥 state넘기는 것 처럼 똑같이 넘기면 됨 부모 컴포넌트   자식 컴포넌트   결과   어우썸하져? 요기까지 다 이해했으면 state, props에 대한 기본적인 내용들은 다 안다고 봐도 됨 이제 점점 리액트를 하다가 props로 일일이 넘기는 작업들이 귀찮아질때쯤 되면 전역 스테이트 관리툴들에 눈을 뜨면서 그쪽 공부를 시작하는거지.,  지금 시작하기엔 조금 러닝커브가 많이 높기때문에 기본적인 것들을 익혀두고 하는걸 추천할게 ✅리액트 스타일링 하는 법 리액트에서 스타일링을 하는 방법은 세 가지가 있습니다. css파일을 따로 만들고 import 해서 사용하는 방법 inline styling으로 조져버리는 방법 styled-components 라이브러리를 사용해서 스타일링 하는 방법 나도 맨 처음에는 1번을 사용해서 했었음. 근데 저 방식은 HTML 요소마다 ClassName을 지정을 해줘야함 (리액트는 Class가 아니라 ClassName으로 이름을 지어줘야함) 그래서 class명을 계속 생각해줘야 하고 이름이 겹치면 안되기때문에 잘 생각을 해야됨. 그게 은근 귀찮음! 그리고 CSS 파일을 생성해야 하기 때문에 파일 개수가 늘어남 이게 또 파일구조가 보기 안좋음!  그리고 2번은  &lt;div style={{color:&#39;red&#39;}}&gt;빨강쓰&lt;/div&gt; 이런식으로 스타일링을 하는건데 그냥 한 줄 넣을때는 유용하지만 CSS를 많이 적용을 해야된다면 메인 코드가 정말 더러워짐 그래서 비추! 대망의 3번 styled-components 라이브러리 이 방식은  styled-components  라는 라이브러리를 사용해서 스타일링을 하는 방식임 CSS파일을 따로 만들필요도 없고 ClassName을 붙여줄 필요도 없음! 그리고 스타일링 코드가 딱딱 분리가 되기 때문에 코드도 깔끔해지고 그리고  SCSS  라는 CSS를 도와주는 스크립팅 도구 언어도 지원을 해주기 때문에 좋음! 메인 폴더에서  $ npm install styled-components 를 입력해서 라이브러리를 우선 다운받아야 사용이 가능함! 그리고 코드를 살펴보면    `  이 모양은 ~ (물결모양)을 쉬프트 안누르고 누르면 나오는 기호임! 따옴표나 쌍따옴표가아님! 이러면 CSS 파일도 안만들어도되고 ClassName도 부여안해도 되고, 스타일링을 변경하고 싶으면 CSS파일을 찾는게 아니라 그냥 바로 컴포넌트 파일로가서 찾으면 금방이니까 가독성도 좋아지고 장점이 많은 것 같음! 이거는 정답이 없고 자기가 편한 방식대로 하면 됨!  styled-components  라이브러리도 단점이 있다면, 일단 문법 자동 완성 기능을 지원을 안해줌. 근데 나는 코드 퀄리티가 떨어지는 것 보다는 내가 조금 불편한게 조금 더 낫다고 생각함 모르면 구글링하면 바로나옴^^ ✅리액트에서 필요한 라이브러리 찾기 이 주제는 리액트에 가까운 내용이라기 보다는  오픈소스 에 대해 익숙해지자 라는 취지의 내용이야 리액트 프로젝트를 진행할 때 필요한 기능들은 많고, 시간이 부족할수도 있는데 기능하나에 엄청난 시간을 투자할 수 없을 때  오픈소스 를 적극 활용하면 얻을 수 있는 이득이 많아.  내가 라이브러리랑 오픈소스를 혼용해서 단어를 사용할 수도 있는데 둘 다 똑같은 의미이니까 그렇게 아세요 예를들어 달력 기능을 추가하고 싶다. 예쁜 버튼이나 아이콘을 추가하고 싶다. 사진을 한장 한장 자동으로 넘겨주는 슬라이드가 필요하다. 와 같은 기능들을 일일이 구현할 시간이 없다면, 오픈소스를 적극 활용하면 정말 시간을 많이 단축시킬 수 있지. 근데 어떻게 찾아야할지 모르겠다고? 그냥  깃허브 에 검색하면 바로 나와 달력 기능을 제공해주는  오픈소스 를 찾겠다 그러면 깃허브에 핵심 단어만 검색하면 돼  react  +  calendar  만 검색하면 바로 나옴     그러면 이런식으로 리액트 캘린더 오픈소스들이 쭈욱 나오는데  star 수가 많은 것에 들어가도 상관없고 너가 마음에 드는 곳에 들어가서  npm install 로 다운받고, 사용법도 대부분  README.MD 에 다 적혀있으니까 차근차근 읽어보고 사용하면 돼 보통  star 수가 많은 오픈소스가 많은 사람들에게 입증이 됐다는 소리니까 믿고 써도 좋아. 그리고 사용하다가 오류같은 것을 너가 발견하면 컨트리뷰터도 될 수 있고 오픈소스 경험도 할 수 있으니 정말 좋겠지? 대표적인 라이브러리들 그리고 대표적인 라이브러리들은 몇 개 외워두는게 프로젝트 진행하는데에 시간절약을 많이 할 수 있어. 우선 기억나는 대표 라이브러리들을 나열해볼게 페이지 이동 구현을 도와주는  react-router, react-router-dom   link 비동기 HTTP 통신을 도와주는  axios   link 스타일링을 도와주는  styled-components   link 전역 state 관리 도구  redux, react-redux   link 버튼, 리스트, 아이콘 등등 홈페이지 구성의 기본적인 것들을 제공해주고 디자인도 깔끔한  material-ui   link 테스팅을 도와주는  jest   link 코드를 깔끔하게 정리해주는  prettier   link 코드의 퀄리티를 높여주는 정적 분석 도구  eslint   link 등등등 이정도만 잘 알아둬도 홈페이지 구성하는데는 문제없고, 그때 그때 자신이 필요한 것을 파악하고 검색해서 사용하는 결단을 내리는 것도 프로젝트 속도를 높이고 퀄리티를 높이는 것에 중요한 것 같음! 쪼우아요~ 오늘은 요기까지 - 뿅✌️ ✅리액트 조건부 렌더링 우선 조건부 렌더링이 뭘까부터 알아야겠지옹 크게 대단한건 아니고, 만약 너가 어떠한 조건이 만족될 때만 어떤 컴포넌트를 보여주고 싶다. 예를들어 보통 회원가입 기능을 만들 때 비밀번호를 입력하고, 확인 차 비밀번호를 한번 더 입력하게 만드는데, 1차와 2차 비밀번호가 같을 때만  통과  라는 메세지를 띄우고 싶다던가, 너가 미니 유튜브를 만드는데 화면이 1000px 이상일 때는 한 줄에 4개의 영상을 보여주지만, 그것보다 작아지면 2개의 영상만 띄운다던가와 같이 어떤 조건에 따라서 다른 화면을 보여주기를 원할 때 사용하는 스킬이지. 리액트의 수많은 패턴중에 많이 쓰이는 패턴이라 이렇게 들고왔음! 리액트에서 조건부 렌더링을 구현할 때 나는  삼항 연산자 를 정말 많이 사용해  삼항 연산자 는 자바스크립트 문법중에 하나인데,  ?  기호를 사용하는 문법이지.  condition ? &quot;condition이 true입니다.&quot; : &quot;condition이 false입니다.&quot; 위에 예시가  삼항 연산자  간단한 예시인데, condition 이라는 조건을 기준으로  :  기호를 사이에두고 왼쪽은 true일 때, 오른쪽은 false일 때 표시되는 것을 의미해 간단히  삼항 연산자 에 대해서 알았으니까, 리액트에서 어떻게 적용되는지 확인해보자구  Counter.jsx   간단한 카운터 예제로 조건부 렌더링을 보여줄게 어려운 건 없어  count state 를 생성하고 버튼을 클릭하면 1증가 하거나, 1감소 하거나 하는 기능이지 그리고  return 부분에서  {count &gt; 5 ? &lt;div&gt;5가 넘었다!&lt;/div&gt; : &lt;div&gt;5를 못넘었어...&lt;/div&gt;} 이 부분이 조건부 렌더링을 보여주는 부분이야.  count &gt; 5  에서 조건을 확인하고 조건이 맞다면  &lt;div&gt;5가 넘었다!&lt;/div&gt; 를 표시해주고, 아니라면  &lt;div&gt;5를 못넘었어...&lt;/div&gt;  을 보여주는 정말 간단한 예제이지   HTML 태그가 들어갈 수 있다는 건 조건에 따라 다른 컴포넌트를 보여줄 수도 있다는 얘기야 정말 자주 사용되니까 알아두면 좋아! ✅리액트에서 리스트 출력 및 key 특성 리액트에서 프로젝트를 진행을 하다보면  리스트 로 state를 만들거나,  리스트 를 출력해야 하는 경우가 정말 많은데 그럴때는 어떤식으로 코드를 짜는지, 주의할 점은 무엇이 있는지 확인해보자구   위 예제에서  initialList  배열을 만들어서 출력을 하는 모습이야. 위 처럼 출력을 해도 크게 상관이 없지만, 나중에 배열이 엄청 커진다면 일일이 저렇게 해 줄 수없지.   자바스크립트의  map  함수를 이용해서 리스트를 빠르게 출력할 수 있지.  map 함수는 배열을 돌면서 하고싶은 동작을 할 수가 있어 위 코드는  item  이라는 변수가 배열의 인덱스 하나하나씩 돌 때 리스트 아이템을 담아줄 변수야 이름은 자기가 짓고 싶은대로 지으면 돼.   정상적으로 출력이 잘 되는것을 볼 수 있지. 그런데 하나 문제가 있어 저렇게만 코딩을 했다면 무조건 뜨게되는 경고 메세지가 있어   위 경고 메세지는  오류 메세지  가 아니야. 경고 메세지이지. 무시를 해도 동작은 한다는거야 그래서 무시해도 된다? 무시해도 상관은 없어. 그럼 어떤 페널티가 주어지니까 저렇게 경고를 해주는 거겠지? 해결하는 방법은  map 함수안에 반복되는 요소에  key props 를 주면 돼 우리는  div  가 반복이 되니까  div  에  key props  를 부여한 것을 볼 수 있어.  key 는 고유값을 부여를 해주어야 해. 그래서 우리는  id 값을 준 것을 볼 수 있지. 그럼  key 는 왜줘야 하는걸까? https://ko.reactjs.org/docs/lists-and-keys.html 공식문서에 나와있는  key  에 대한 글이야. 효율적으로 렌더링을 해주기 위해서 존재한다고 생각하면 될 것 같아. 그러면  key  값을 어떤 값으로 줘야할지 감이 안잡힐 경우가 있는데 위에 예시처럼  id  값을 부여해서 주는 방법도 있고, 최후의 수단으로 배열의  index  를 주는 방법도 있다고 해. 근데 요기에 대해선 공식문서에는 부정적인 의견이야.  최후의 수단으로 배열의 인덱스를 key로 사용할 수 있습니다. 만약 항목들이 재배열되지 않는다면 이 방법도 잘 동작할 것이지만, 재배열되는 경우 비효율적으로 동작할 것입니다. https://ko.reactjs.org/docs/reconciliation.html#recursing-on-children 그렇다고하네.. 자세한 내용들은 공식문서를 살펴보는 것도 좋은 방법! 아, 요기서  index  랑  id  랑 무슨 차이냐고 할 수도 있는데 둘은 달라.  index 는 배열이 만약에 변한다면, 요소들마다  index  값이 변할테지만,  id 값은 처음부터 주어진 값이기 때문에 배열이 변한다 하더라도,  id 값은 그대로이기 때문에 렌더링 성능에 문제가 없다고 생각하면 될 것 같아.  요기까지 읽었다면, 리액트 조금 다룰 줄 안다 정도? 아직 말할 것이 많지만 더 이상 얘기를 한다면 정말정말 길어질 것 같고 나 또한 모르는 것이 많기 때문에 공부를 하는 겸 정리를 해봤씁니더 도움이 되었으면 좋겠군요 다들다들 화이팅~ ✅리액트에서 기초적으로 알아야 하는 지식들   create-react-app으로 React 프로젝트를 생성할 수 있나? (Hello World)   리액트 컴포넌트를 생성하고 import 및 export를 할 줄 아나?   react hooks를 주로 사용할건데, 그럼 react hooks는 뭐고, class컴포넌트랑 function컴포넌트의 차이를 아나?   react hooks로 state를 생성하고 바꿀 줄 아나?   컴포넌트에서 이벤트를 어떻게 처리하는지 아나?   react hooks로 props를 전달하고 사용할 줄 아나?   react에서 스타일링을 어떻게 하는지 아나?   각종 react 라이브러리들을 다운받고 사용할 줄 아나?   조건부 렌더링를 할 줄 아나?   리스트와 key를 다룰 줄 아나? 😀회고록 벨로그에서 첫 회고록이자, 2021년 나의 첫 출발을 기록하기 위한 글이다. 한 달 동안 내가 했던 것을 되돌아보고, 다음을 기약하기 위해 매 달 쓸 예정이다. 📌블로그 포스트 두 개 아직 기술 블로그를 올릴 만큼의 실력은 아니라고 생각하지만, 내가 겪었던 시행착오를 다른 분들은 겪지않게 하고 싶은 마음이 있었기 때문에 내가 새롭게 알게 된 내용들을 잘 정리해서 올렸다.  [React] create-react-app &amp; Typescript 초기 세팅 완벽 정리  [React] Github Pages를 이용해 나만의 이력서 페이지 만들기 📌알고리즘 공부 나도 이제 4학년이라서 나도 취직 생각을 해야하기 때문에 알고리즘 공부를 시작했다. 알고리즘에 대해서는 문외한이기 때문에 1부터 시작을 했다. 언어는  python 을 사용하기로 마음 먹었다.  python 을 제대로 처음부터 공부하기 위해서  갓 동빈나 파이썬 유튜브 강좌 를 전부 들었다. 그리고 문제 은행 사이트는  프로그래머스 와  백준 사이트를 병행하기로 하였다.     그 전에 꾸준히 풀 수 있을까 📌사이드 프로젝트 위에 적었던  Typescript 와  React ,  Eslint ,  Prettier 를 사용하는 포스트를 올렸던건, 해당 툴들을 사용해서 프로젝트를 진행하고 있기 때문이다.    프론트 단은 순조롭게 진행이 되었던 것 같은데, 백엔드 아키텍처를 구성하고 생각하는 것이 처음이라서 많이 어려운 것 같다. 사용하고 있는 기술 스택은 데이터베이스는  firebase 를 사용하려고 하고, 데이터 수집은  python selenium 을 사용해서 크롤링으로 데이터 수집을 하고 있다. 또 크롤링에 대해서 알아보려고  robots.txt 도 알아보고 새로운 것을 많이 알았다. 2월말까지 배포를 목표를 했었는데.. 할 수 있겠지? 📌인턴 지원 우리 학교에서 지원해주는 인턴쉽 기업들 중에서 유일하게 마음에 드는  스타트업 이 있어서 지원을 하게 되었다. 1학기를 학교에서 수업을 듣는 것 보다 실무 경험을 더 쌓고 싶어서 지원을 하게 되었다. 면접을 제발 잘 봐서 꼭 합격해서 1학기를 해당 스타트업에서 많은 것을 배우고 싶다.  2월달 회고록에 아무런 얘기도 없으면 떨어졌다는 얘기.. 📌들었던 강좌  니꼴라스 쌤의 타입스크립트 강좌 를 다 들었다. 타입스크립트를 프로젝트에 적용을 해보고 싶어서 들었던 강좌이다. 맛보기로는 최고인데, 타입스크립트를 자세하게 배우고싶으면 다른 강좌가 더 나은 것 같다. 그리고  React Native  유데미 강좌, 어플 출시 및 수익 창출에 대한 강좌도 구매했는데 아직 전부 듣지 못했다. 애플리케이션을 만드는 것에 대한 흥미가 지금은 약간 식어서 다른 것들에 집중을 하고 있다.  📌1일 1커밋   깃허브 주소 2021년을 시작하면서 제일 신경쓰고 있는 사업중에 하나이다. 처음에는 개인 프로젝트에 신경을 많이 쓰느라 커밋을 신경쓰지 않아도 됐었는데, 요즘은 졸업 프로젝트, 자소서 등등 다른 것들에 신경 쓸 일이 많아서 커밋을 잘 못했던 것 같다. 반성하자.. 📌1월 벌써 1월이 지나갔다. 그 말은 즉슨 방학이 반도 안남았다는 얘기.. 이렇게 회고록을 쓰니까 한 달을 돌아볼 수 있고 좋은 것 같다. 반성도 하고 뭔가 많이 한 것 같으면서도 아닌 것 같은..   다가오는 2월은 지나간 1월 보다는 더 나은 한 달이 됐으면 좋겠다. 뭔가 잘 되길 빌어야 하는게 많은 것 같은 2월..  졸업 프로젝트 ,  인턴 ,  해커톤 ,  내 무릎 (다침) 등등 전부 잘 됐으면 좋겠다.  화이팅 정현수 repost from  hashnode FastAPI는 파이썬 웹 프레임워크의 새로운 트렌드로 자리잡고 있다. Flask를 사용하던 조직은 FastAPI로 옮겨가고 있고, 새 프로젝트들은 Flask를 후보에도 올리지 않는 경우도 생기고 있다. 파이썬 생태계에서 Flask의 숨은 꺼지고, FastAPI를 쓰는 것이 당연해지게 될 것이라고 단언한다. 어떤 Flask 튜토리얼의 마지막 글은  Why I&#39;m Leaving Flask  이기까지 하다.   전반적으로 &#39;현대적인 프레임워크&#39;라는 평가로, 2019년부터는 production에서 운영을 시작한 조직들이 많이 등장했다. Uber의 딥러닝 Toolbox인  Ludwig에서 사용된 사례 , MS에서는  내부 ML 서비스들을 시작으로 Windows와 Office 제품들에 관련된 부분들도 옮겨볼 예정이라는 코멘트 도 있었다. 국내에서는 매드업의 사례( Flask에서 FastAPI로 간 이유 - 매드업 블로그 )가 대표적이다. 필자가 다니고 있는 AB180에서도  abit.ly  라는 숏링크 서비스의 백엔드 전체를 FastAPI로 개발했다. 숙련도가 높지 않음에도, 꽤 괜찮은 수준의 생산성과 사용 경험을 얻을 수 있었다. 해당 서비스를 개발하던 동료가 매일마다 ‘와 대박.. 이게 된다고?’ 라며 연호했던 기억이 난다. 필자는 Flask를 약 5년 가까이 써왔는데, 앞으로는 FastAPI를 애용하려고 하고 있다. 이 글에서는 FastAPI가 어떤 장점을 가지고 있는지, FastAPI를 쓰고 돌아보니 Flask에는 어떤 단점이 있었는지 등을 이야기한다. 일러두기 주요 요소들의 버전 이 글은  Python 3.9.0 ,  Flask 2.0.3 ,  FastAPI 0.75.0  버전을 기준으로 작성되었다. 문자열의  removeprefix  메소드를 호출하는 코드가 포함된 예제를 제외하고는 모두  Python 3.7+ 에서도 동작하는 것을 확인했다.  (깨알 파이썬 지식) PEP 616 - String methods to remove prefixes and suffixes Python 3.9에서 문자열에 추가된  removeprefix 와  removesuffix  메소드는, 각각 인자로 전달된 문자열을 앞에서/뒤에서 제거한 결과를 반환한다.  lstrip ,  rstrip 과 다른 점은 다음 예제를 통해 알 수 있다.  lstrip 과  rstrip 은  기준이 되는 각 문자 가  인자로 전달된 iterable 내에 포함 되어 있는 경우 제거하는 반면,  removeprefix 와  removesuffix 는 각각  prefix와 suffix 전체가   인자로 전달된 것과 완전히 일치 하는 경우에만 제거하는 것이다. 예제에 지면 아끼기 코드 예제가 길어지면 읽기 힘들기 때문에, 코드의 라인 수를 줄이기 위해 대부분의 예제에서  import  문을 아예 제거했다. 직접 실행해보고 싶다면 PyCharm의  context actions  기능을 통해 import문을 채워주기만 하면 된다.  context actions 기능 사용법 참조가 깨진 부분에 커서를 두고 Windows에서  Ctrl + Enter , Mac에서  Option + Enter 를 누르면 된다.   Flask 2 이 글은 Flask 2번대 버전에서 새롭게 릴리즈된 기능을 사용한다. 바로  @get ,  @post  데코레이터를 사용하는 것이다.  Example (Flask) Ellipsis 이 글은 두 가지 목적에서 Ellipsis가 등장한다. 생략 표현 생략을 표현하기 위해  pass  statement 대신 다음과 같이  ... (Ellipsis)를 사용한다. Ellipsis는 원래 numpy에서 다차원 배열을 쉽게 다룰 수 있도록 만들어진 값인데, 의미 그대로  생략  을 표현하기에 자연스러우므로  pass  대신 자주 사용된다.  pass  가 statement인 것에 비해 Ellipsis는 expression이므로 더 많은 범위에서 사용할 수 있기도 하다. FastAPI와 Pydantic에서의 표현 FastAPI와 Pydantic에서, 기본값을 명시하는 부분에 Ellipsis를 사용해  기본값 없음  을 표현한다.  Example (FastAPI) Glossary 이 글은 Flask와 FastAPI에 대해 다룬다. HTTP, 웹 서버, Python, Flask에 대한 배경지식이 있어야 한다. Flask를 통해 DB를 사용하는 WAS(web application server)를 간단하게나마 개발해본 적 있다면 읽어볼만 할 것이다. 추가적으로, 몇 가지 프로그래밍적인 이론 지식이 준비되어 있으면 좋다. 이미 자연스럽게 사용하고 있으나, 용어가 익숙하지 않아 이해하기 어려운 것이 있을 수 있으므로 여기서 자주 등장하는 몇 가지 요소들만 간단하게 요약했다. view function Flask에서, HTTP request가 들어왔을 때 실행되는 함수를 의미한다. 가령 다음 예제의  get_posts  와  create_post  함수는 view function이다.  Example (Flask) FastAPI에서는 조금 더 general한 용어로  router  라고 부른다. DI 코드에서 필요한 의존성(dependency)을, 외부에서 주입하는 것을 의미한다. 어렵게 생각할 것 없다.  &quot;Dependency Injection is a 25-dollar term for a 5-cent concept&quot;  라는 말도 있다. 코드에서 dependency를 찾고, 이것을 DI에 맞추어 변경하는 과정을 따라가 보자.  before  after DI와 관련된 강결합(tight coupling), 약결합(loose coupling), IoC와 같은 개념들과 장점에 대한 부분들은 분명히 어렵겠지만, DI 자체는 쉬운 개념이다. 물론 DI가 어떤 장점이 있는지 이해하는 것은 좋다.   Dependency Injection Demystified   라는 글로 출발해   파이썬 애플리케이션 의존성 주입 - dependency injector   를 거쳐 Martin Fowler의   Inversion of Control Containers and the Dependency Injection pattern   까지다. FastAPI는 어떤 점이 더 나은가? DI 중심 설계 Flask의 global variable vs FastAPI의 DI Flask에는 application context라는 것이 있다. API 요청마다 생성되는 thread같은 개념이고, 이 context에 따라  request  라는 전역변수에 담기는 값이 달라진다. 요청마다 생성되는 thread에 각자 할당해주는 객체인 것이다. 이를 Flask에서는  thread-local object 라고 부른다.  Example (Flask) FastAPI에도 분명 request들을 관리하는 context 개념이 있겠지만, 개발자가 신경쓸 필요가 없다. contextual한 데이터들은 모두 DI되기 때문이다.  Example (FastAPI) Flask의  request ,  current_app 과 같은 전역변수들은 일관적이지 않은 요소이기 때문에, 함수의 행동과 결과가 전역변수의 상태에 따라 달라지므로 예측 가능성이 떨어진다. 반면에 FastAPI와 같이, contextual한 데이터들이 DI되게 되면  pure function을 중심으로 코드베이스를 구성 할 수 있게 된다. 덕분에 testability를 높이며, input을 가지고 output을 쉽게 예측할 수 있게 되는 것이다. 이는 깔끔한 모양의 Domain Service의 역할을 하므로, 다른 endpoint의 controller가 호출하기도 좋다. 가령  POST /posts 라는 게시글 추가 API가 있는 상황에서,  POST /posts_v2  라는 새로운 버전의 API를 개발한다고 하자. 만약  POST /posts_v2  가  POST /posts  API의 내용을 확장한 것이라면, 함수 호출로 로직을 쉽게 재사용할 수 있다.  Example (FastAPI) FastAPI에서는 request와 관련된 모든 데이터를 DI받을 수 있다. FastAPI는 인자의 타입, 기본값에 따라 요청에서 어떤 데이터를 어떤 방식으로 inject해줄지 정한다. 몇 가지 상황(요청의 Content-Type 헤더 등)에 따라 조금씩 달라지기도 하지만, 기본적인 구조는 다음과 같다. type hint가 primitive type(int, str, ...)인 인자에는 동일한 이름의 path parameter나 query parameter를 전달한다. (1)에 더해 기본값이  fastapi.Header  객체인 인자가 있다면, 그 이름에 해당하는 header의 값을 전달한다. type hint가  Type[pydantic.BaseModel] (BaseModel을 상속한 클래스)인 인자가 있다면, body를 전달한다. 이렇게 글로 보면 복잡한데, 코드로 표현된 것을 보면 초면이라도 꽤 자연스럽게 이해되는 것을 느낄 수 있다.  Example (FastAPI) 이는 어떤 request data를 사용할지 function signature 수준에서 모두 명시하게 만들어, Flask에서처럼 request 데이터 접근이 로직 어딘가에 숨겨져 찾기 어려운 문제를 겪지 않을 수 있다.  (여담)  Header  는 왜 타입이 아니라 기본값으로 명시하게 했을까?  Header 라는 type hint가 있다면 그것은 조금 이상하다. FastAPI에서 type hint는 말 그대로 타입을, 기본값은 data source(어디서 가져올지)를 나타내는 것이 기본적인 컨셉이다. type hint를 모조리 primitive type과  Type[pydantic.BaseModel]  선에서 정리하는 것이 보기에도, 프레임워크를 구현하기에도 좋다. Python에서 기본값이 정의된 인자( default value parameter )는 기본값이 정의되지 않은 인자( non-default value parameter ) 앞 순서에 위치할 수 없다. HTTP request에서 header는 부재료인 경우가 많으므로, 가장 나중 순서에 정의하게 만들어 사고 흐름을 자연스럽게 하기 위함이다. Flask의 context manager vs FastAPI의 Depends DB와 관련된 작업을 하려면 connector가 필요하다. 보통은 connector만 사용하지 않고,  SQLAlchemy 라는 라이브러리를 사용한다. DB 작업에 관한 많은 번거로운 일들을 대신 처리해주고, ORM 및 여러 편의 기능들을 지원하기 때문이다. DB에 대한 작업들은 transaction 단위로 처리하는 것이 일반적이다. SQLAlchemy에서 추천하는 방식은 context manager를 사용해  with  문으로 transaction을 처리하는 것이다.  session  이라는 개념이 사용된다.  Context Manager  Example (Flask) with 블럭 시작과 함께 transaction도 시작하고, 블럭 종료와 함께 transaction도 종료된다. 이는 with문이라는 도구를 통해 직관적으로 transaction을 사용할 수 있다는 장점이 있다. 하지만 일반적으로 트랜잭션을 여러 번 생성하는 경우는 잘 없다. 요청 당 한 번의 트랜잭션이 사용되는 것이 일반적이라는 것이다. 그러므로 controller가 실행되기 전 transaction이 시작되고, controller와 함께 transaction도 종료되도록 만들면 조금 더 편할 것이다. 이렇게 탄생한 것이  flask-sqlalchemy 이며, 실제로 많이 사용되고 있다. 이는 다음과 같은 일을 가능하게 만든다.  Example (Flask) FastAPI에서도 이러한 context manager 컨셉을 이용해 with  문을 열어 transaction을 사용할 수 있으나, 더 좋은 방법이 있다. 이러한 session을 dependency로 만드는 것이다.  Depends  라는 클래스를 이용하면 쉽게 DI를 받도록 만들 수 있다. 참고로 다음 예제의  session_scope 에 해당되는 코드는 앞에서의 것과 동일하다.  Example (FastAPI) HTTP request가 들어와 함수 실행을 준비하는 과정에서, FastAPI는  Depends  에 명시된 callable을 호출한다. callable이 일반 함수라면 그 리턴을 DI해주고, context manager라면 함수 실행의 전과 후에 enter/exit을 처리하며 yield받은 것을 잘 DI해준다. Flask의 view decorator vs FastAPI의 Depends Flask에는 view decorator라는 것이 있다. view function에 붙여주는 decorator인 것이다. 이는  request  와 같은 전역 객체들이 유효한 상태로 실행된다. 덕분에 다음처럼 Authorization 헤더를 검증하는 로직을 decorator로 만들어 두고, view function에서 가져다 사용할 수 있게 된다.  Example (Flask) 이러한 decorator의 작업 결과를 controller가 사용해야 하는 일이 생길 수 있다. 예를 들어 JWT를 통해 얻어낸 user id와, 그 user id를 통해 DB에 쿼리한 user 객체가 있을 수 있다. Flask에서는 이런 상황에서  g  라는 전역 객체를 사용한다.  request 처럼 요청마다 만들어지는 객체다. 다음은 앞의 예제를 조금 수정한 것이다.  Example (Flask) FastAPI는 이런 것들도 DI 컨셉을 기반으로 만들 수 있다.  Example (FastAPI) FastAPI는 router 함수들에게 해주는 것과 같이, dependency 함수들에도 request 데이터를 DI해 준다. 덕분에 앞의 예제처럼 dependency에서도 header를 받아서 처리하는 것이 가능한 것이다. Flask의  g  객체는 파이썬의 dynamic attribute 특성을 이용해 만들어진 것인데, 참조하고자 하는 속성의 존재 여부를 확신할 수 없다는 것이 가장 큰 단점이다. 데코레이팅 구문이 지워지거나, view decorator가  g  객체에 속성을 바인딩하지 않기라도 하면  g.user  구문에서 바로  AttributeError 가 발생하는 것이다. FastAPI의  Depends 를 사용하게 되면, 먼저 type hint가 되어 자동완성이 되므로 심리적으로 안정적이다. 실제로 버그가 발생할 가능성도 비교적 적을 수밖에 없다. 어떤 함수가 router의 dependency에서 지워지면, 애초에 router의 인자에서 빠지게 되는 것이므로 warning을 받을 수 있다. 그리고 Dependency가 데이터를 제대로 리턴하는지는 mypy와 같은 type checker를 이용해 검증할 수 있다.  (깨알 파이썬 지식) dynamic attribute 파이썬의 모든 객체에는 속성을 마음대로 추가할 수 있다. Flask의  g  객체도 이러한 특성이 반영된 것이다. thread-local로 동작하는, 텅 빈 객체인 것이다. 속성을 제한하고 싶다면, 클래스에  __slots__  를 정의하면 된다. 그러면  __slots__ 에 정의되지 않은 이름의 속성을 설정하는 구문에서 에러가 발생한다. list-like 객체나 tuple-like 객체를 사용할 수 있다. 쓸만한 것들 중 가장 빠른 속도 벤치마크 async/await을 기반한 비동기 프로그래밍 지원, 퍼포먼스가 가장 좋다고 잘 알려진 ASGI인 Uvicorn을 사용하고 있어 준수한 성능을 보인다.  링크 는 Java, Go, Node.js, Python에서 잘 사용되는 프레임워크들과의 Multiple queries(DB query를 여러 번 수행하는 워크로드) 상황에서의 벤치마크 점수 비교다. Flask, Django가 1,000점대의 점수를 갖는 것에 비해, FastAPI는 Go의 echo, gin, martini나 node.js의 express, koa 등보다 높은 14,000점대의 점수를 기록했다. 이러한 벤치마크 점수는 쿼리 횟수별 rps(response per second), latency, overhead 정보를 기반으로 계산된다. 필요하다면 세부적인 데이터를 더 살펴보도록 하자. 물론 FastAPI 벤치마크의 경우 PostgreSQL을 대상으로 ORM을 사용하지 않은(raw SQL을 사용한) 테스트 결과밖에 없어 현실적인 워크로드와 벗어나 있을 수는 있다. MySQL + SQLAlchemy와 같은 기반 환경에서는 상상했던 것만큼 그렇게 좋은 성능을 내지 못할 수도 있다 (그러나 큰 차이는 없을 것이라고 생각한다). 무엇이 이러한 차이를 만드는가? FastAPI가 여타 다른 프레임워크에 비해 이만큼 높은 퍼포먼스를 뽑아낼 수 있는 이유는, 비동기 프로그래밍에 기반한 동시성 제어 모델 덕분이다. 예를 들어 220ms의 총 처리 시간을 가진 API에서, DB query가 200ms를 소요한다고 하자. Flask 환경에서는 이 200ms를 thread가 온전히 대기한다. 그러나 FastAPI 환경에서는, DB query 부분에 await 처리가 되어 있다면, thread가 그 대기 시간동안 다른 일을 처리하기 위해 움직일 수 있으므로 자원을 효율적으로 사용할 수 있는 것이다.  (여담) 프레임워크 수준의 latency 최적화는 큰 차이를 주지 못한다 파이썬에는  japronto 라는 프레임워크가 있다. 첨부되어 있는 rps 측정 통계를 보면 알 수 있듯, 말도 안 되는 수준이다.   여기서 중요하게 생각해야 하는 부분은, 이것이 자체적인 벤치마크 결과라는 점이다. 값에 거짓을 섞지는 않았겠지만, 극적인 차이를 연출했을 가능성이 높다. japronto를 테스트할 때는 심혈을 기울이고, 다른 환경에서는 적극적으로 튜닝을 시도하지 않았을 가능성 현실적이지 않은 상황을 테스트했을 가능성  (*정말 중요한 부분) 조금 파헤쳐본 결과, Go 환경 테스트에는 멀티코어를 활용하는  GOMAXPROCS  를 설정하지 않았고, 높은 퍼포먼스를 가진  fasthttp  라이브러리를 서버 구현에 사용하지 않았다. 이 둘을 잘 조율하면 japronto와 큰 차이가 나지 않는다는 점을 발견했다. 다른 환경의 벤치마크 과정까지는 알아보지 않았으나, (1)의 가설이 일부 맞다고 볼 수 있다. 그리고 벤치마크는  &quot;Hello world&quot;  를 리턴하는 HTTP 서버를 통해 테스트했다고 한다. 그러나 현실 세계의 API는 복잡한 도메인을 처리하기 위해 DB query를 수행하며, 이것이 처리 시간에 큰 비중을 차지한다. 때문에 이러한 DB query 상황을 연출해 테스트했다면 이 정도의 극적인 차이가 나지 않을 수 있다. HTTP message나 JSON string을 아무리 빠르게 parse/build한다고 하더라도, 결국 DB query가 발생하는 상황에서는 latency에 큰 차이를 만들어내지 못한다. 예를 들어 HTTP Message와 JSON을 처리하는 것에 Flask는 20ms, japronto는 1ms를 소요한다고 하자. 이는 20배 차이지만, DB query를 하는 부분이 들어가 200ms씩 더 점유하게 됐다면 각각 220ms, 201ms로 비교적 큰 차이라고 보기 어렵다. 프레임워크 수준의 latency 최적화는 결국 유의미한 수준의 차이를 만들지 않으며, 트래픽을 감당하는 것에 실질적으로 중요한 것은 동시성 제어 모델이라는 점을 인지해야 한다. 주:  비동기적으로 Python 다루기 속도보다 더 중요한 것 현재 섹션의 제목은 &lt;쓸만한 것들 중 가장 빠른 속도&gt; 다. 사실 속도만큼이나 중요한 것이, 프레임워크가 정말로 ‘쓸만하냐’는 것이다. 파이썬은 언어 차원에서 비동기 프로그래밍을 잘 지원하고 있으므로, 고성능의 프레임워크를 만드는 것 자체는 크게 어렵지 않다. 그러므로 쓰기 좋은 프레임워크를 찾는 것이 매우 중요하다. 결국 이러한 프레임워크는 개발자들에 의해 사용되는 도구에 불과하기 때문이다. 웹 프레임워크를 평가할 수 있는 지표를 대충 다음과 같이 정리할 수 있을 것 같다. 충분한 기능을 빌트인하고 있거나, 부가적인 기능이 필요할 때 믿을만 한 라이브러리가 있는지 WebSocket, Streaming Response, CORS와 같은 HTTP 기능이나 Middleware, 테스팅 모듈 등 이들이 제대로 공급되고 있는지 얼마나 개발자에게 친숙한 인터페이스로 제공되고 있는지 얼마나 버그 없이 stable한지 문서를 통해 가이드를 잘 주고 있는지 생산성이 괜찮은지 IDE와 잘 어울려 동작하는지 등 러닝커브를 줄이기 위한 튜토리얼이 제공되고 있다면 가산점! maintain이 잘 되고 있는지 production ready인지 배포 난이도 등, ops 관점에서 편하게 건드릴 수 있는지 조직이나 엔지니어들의 성격에 따라 더 중요하게 생각하는 부분이 있겠지만, 내 기준으로는 이 만큼이다. 웹 프레임워크는 굉장히 많지만, 이 기준에 모두 부합하는 프레임워크는 많지 않다. 이만큼 완전한 프레임워크를 준비하는 것은 큰 비용이 들어가기 때문이다. FastAPI는 이런 부분들이 잘 준비되어 있다고 생각했다. 이 뒤로도 FastAPI의 장점을 구구절절 설명할 것이기 때문에 특별한 언급은 넘어가도록 하자. validation과 문서화 FastAPI에서, router 함수들의 signature는 다음 두 용도로 사용된다. validation 문서화 그리고 type hint에 pydantic model을 사용할 수 있게 만들어, 복잡한 데이터 모델과 validation을 충분히 수행할 수 있다. 이러한 특징은 FastAPI를 굉장히 특별한 프레임워크로 만들어 준다. validation 함수에 정의되어 있는 매개변수와 타입 정보는, 매 request마다 들어오는 데이터들을 validation하는 데에 사용된다. 여기에는 pydantic의 컨셉이 녹아들어 있다. validation에 걸리는 경우 message도 programmability와 human readability를 함께 챙기는 방향으로 잘 정리해 준다.  Example (FastAPI) 다음은 해당 FastAPI 앱이   localhost:5000   에서 실행되고 있다고 가정한 curl 결과다. response json은 임의로 prettify했다. Flask의 경우에는 validation 기능이 내장되어 있지 않으므로, 별도로 만들어진 extension 라이브러리를 사용해야만 한다.  Flask-WTF 는 사용 사례가 많으나 form data를 위한 validation 라이브러리로 SSR(server side rendering) 상황이 아니라면 그렇게 어울리지 않는다. type hint가 비약적으로 발전하던 시기 이전에 만들어졌기 때문에, 인터페이스도 조금 ‘옛날 것’ 느낌이 들기도 한다.  Flask-Validator 는 인터페이스가 그렇게 친숙하지 않으며 star 수도 많지 않고, 마지막 커밋이 2년을 넘으므로 조금 불안한 부분이 있다.  Flask-Pydantic 은 전반적으로 FastAPI의 스타일이 반영된 라이브러리다. pydantic을 사용하며, view function에 DI도 해 주고, 에러 처리도 신경썼다. FastAPI가 취향에 맞는다면, Flask에선 이 라이브러리를 사용했을 때 만족스러울 것이다. 필자도 나중에 Flask 환경에서 개발할 상황이 생긴다면 이 라이브러리를 사용할 것 같다. Flask-Pydantic은 2020년 중반부터 인기를 얻기 시작했다. 그 전부터 Flask를 사용해왔던 사람들은 불편함을 감수하고 기존 라이브러리들을 사용하거나, 직접 만들어서 사용하곤 했다. 필자의 경우에도 과거에 Flask를 쓰면서, validation은 해야겠는데 마땅한 라이브러리가 없어 직접 만든 적이 있었다. 다음처럼 데코레이터의 인자로 pydantic model을 받고,  g  객체에 바인딩해주는 형태였다.   JoMingyu/Flask-Large-Application-Example 내용을 각색   문서화 파이썬에서 함수의 signature는  inspect.signuatre 와 같은 것으로 매우 쉽게 뽑아낼 수 있다. 때문에 FastAPI는 router 함수의 signutare를 API 문서화에도 이용한다. FastAPI 어플리케이션은 현재의 라우팅 정보들을 수집해, 자체적으로 API 문서를 serving한다. 예로 다음과 같은 FastAPI 어플리케이션이 있다고 하자.  Example (FastAPI) 이는 다음처럼 API 문서를  /docs  라는 URL에 Swagger 형태로 서빙한다.   ReDoc으로 visualize된 결과도  /redoc  에서 제공해준다.   title이나 description같은 부분은 직접 설정 가능하며,  pydantic.constr ,  pydantic.conint 와 같은 타입을 이용해 만든 구체적인 validation rule들도 문서에 반영되어 굉장히 편하다. Swagger, ReDoc과 같은 visualizer를 사용하려면 당연한 것이긴 하지만, FastAPI는 OpenAPI specification을 만들어내기 때문에 다른 visualizer를 사용하기에도 좋다. 보통은 이렇게 API 문서가 코드와 결합되지 않고 따로따로 관리되는 경우가 많다. 따라서 직접 문서화를 해줘야 하고, 이 과정에서 문서화를 하지 않고 넘어가거나, 실수가 발생해 문서와 실제 API 간 mismatch가 발생해 불편함이 생기곤 한다. FastAPI를 사용하면, 이런 문제를 쉽게 해결할 수 있게 된다. 개인적으로 API와 API 문서는 강결합되어야 한다는 입장이라, 이 기능은 정말 만족스럽다. 풍부한 빌트인 기능 지원 FastAPI는 Starlette을 기반으로 하고 있다. 그러므로 Starlette에 있는 기능을 빌트인 단위에서 모두 사용할 수 있어 이득이 크다. Flask에 있는 기능은 모두 FastAPI에 있다고 보면 되고, 추가적으로 다음과 같은 기능들을 사용할 수 있다. WebSocket 지원 GraphQL 지원 백그라운드 task startup/shutdown 이벤트 handler CORS 지원 GZip 압축 지원 Streaming response 지원 이들을 당장 쓸 일이 없어 특별한 감흥이 없을 수 있으나, 이러한 빌트인 지원은 이 기능들이  필요해졌을 때  매우 소중하게 작용한다. 예를 들어 Flask의 경우 CORS, GZip, websocket 기능을 지원하지 않는다. 각각  Flask-CORS ,  Flask-gzip 이나  Flask-Compress ,  Flask-SocketIO 를 사용해야 한다. 이러한 라이브러리를 찾는 과정도 쉽지 않고, 제대로 된 라이브러리가 없거나, maintain이 제대로 되지 않거나 하면 좀 힘들어진다. 이러한 기능들이 프레임워크 단위에서 지원된다는 것은, maintain의 범위에 들어있어 시간이 지나도 안정성을 보장받을 수 있다는 장점이 있으니 아무래도 좋게 바라볼 수밖에 없다. 디테일한 문서  FastAPI의 문서 는 개인적으로 파이썬 웹 프레임워크들 중 가장 잘 만들어져있다고 생각한다. 단순히 디자인이 예쁜 것을 넘어서, 지원되는 기능들이 모두 양질의 내용으로 문서화되어 있으며  튜토리얼 도 제공하고,  배포에 대한 가이드 나  HTTPS 에 대한 부분처럼 Ops에 대한 것들도 신경쓰는 것을 볼 수 있다. 그 과정에서 배경지식이 필요한 부분이 있다면  Python Types Intro 와 같이 직접 설명해주기도 하고, 공부할 수 있는 웹사이트의 링크를 제공해주기도 한다. 마케팅적인 측면도 조금 있겠지만, 뉴스레터를 통해 소식을 공유하거나, 본인들 로드맵에 대한 이야기도 적극적으로 내세우는 것을 보았을 때 이 부분도 좋게 바라볼 수밖에 없다. Flask는 왜 이렇게 하지 못했는가 비동기 프로그래밍은 Python 3.5에서, Type Hint는 Python 3.6에서 정립되어 지금까지 발전하고 있다. Flask는 그 전에 만들어졌기 때문에, FastAPI에서  좋은 기능 으로 보이는 것들을 구현하고 있지 않다. 또한 Python 3.5의  EOL 이 한참 지난 뒤 릴리즈된 Flask 2.0에서도 큼지막한 기능을 추가하지 않은 것을 보았을 때, Flask는 마이크로 프레임워크의 정신을 계속 이어가고 싶은 것으로 보인다. Flask 생태계는 extension 문화가 많이 발전해 있기 때문에, Flask 입장에서도 빌트인 기능을 적극적으로 추가하는 것은 괜한 모험이 될 수 있는 것이다. 필자의 생각 Flask는 이제 그만 써야겠다 FastAPI는 성능과 생산성이 높고, 버그 발생 가능성은 낮다. 새 프로젝트에서 Flask를 선택할 이유는 전혀 없다고 생각한다. 과거에 Java를 사용하던 조직이 Kotlin으로 이동했듯, Flask를 사용하던 조직이 FastAPI로 이동하는 흐름이 앞으로 있을 것이라고 생각한다. 그 이유는 성능 때문일 수도, 자동 문서화와 같은 강력한 편의 기능 때문일 수도 있다. 내가 학생이라면 어떻게 할 것인가 기존 Flask 프로젝트 몇 개는 FastAPI로 옮겨보고, 새 프로젝트는 Python 3.10, SQLAlchemy 2.0+ 환경에서 FastAPI를 사용해 진행할 것 같다. Flask, FastAPI를 어느 정도 알면서, Flask 어플리케이션을 FastAPI로 옮겨본 경험이 있는 정도가 된다면 파이썬 계열에서는 꽤 경쟁력 있는 개발자가 될 것이라고 본다. 물론 백엔드는 언어, 프레임워크 말고도 알아야 할 것이 많지만. Flask와 FastAPI 어플리케이션을 벤치마크해 보고, 어느 정도 워크로드에서 얼마나 비용 최적화가 되는지도 알아보려고 할 것 같다. DB query의 비중이 높지 않은 어플리케이션은 생각보다 지표 변화가 극적이지 않다거나, 하는 것을 실험해보는 과정을 거쳐보면 재밌을 듯. 예전에 Sanic이라는 게 있었는데.. 파이썬에서 비동기 프로그래밍은 생각보다 오래 존재해왔던 기능이다. 빌트인에서 비동기 프로그래밍이 제대로 지원되기 시작한 Python 3.7이 2018년 6월에 릴리즈된 것으로 알 수 있다. 그러나 비동기 웹 프레임워크가 생태계의 중심이 되는 것은 또 다른 이야기다. 당연히 프레임워크가 개발되는 기간도 있겠지만, DB Query가 동기적으로 실행된다면 결국 가장 시간이 많이 들어가는 부분에서 Blocking이 발생하는 것이기 때문이다. 이것은 비동기 트랜잭션을 지원하는 DB 라이브러리가 있어야 해결할 수 있다.  aiomysql ,  psycopg2 같은 라이브러리를 예로 들 수 있다. 이들은 Python 3.7 이전부터 개발되어왔기 때문에 사실 특별한 걸림돌은 아니다(Python 3.3에서도 비동기 프로그래밍은 할 수 있었기 때문이다.  yield from  문법이 존재하고  asyncio  라이브러리가 있던 시기였으므로). 문제는 ORM 라이브러리를 사용할 때 발생한다. ORM 라이브러리가 비동기 DB 라이브러리를 connector로서 지원하지 않으면 사실상 ORM을 사용할 수 없는 것이다. SQLAlchemy의 경우  databases 와 같은 어댑터를 끼우고, 조금 더 low-level의 인터페이스를 쓰는 것으로 우회할 수는 있으나, SQLAlchemy라는 핵심적인 라이브러리를 완전히 사용하지 못 한다는 것은 큰 문제다. 이는 2021년 3월에 SQLAlchemy 1.4가 만들어지며 aiomysql, aiopg, psycopg, aiosqlite를 지원하게 되며 해결되었다. 주:  [FastAPI] 9. Persistence Layer 구간을 비동기 처리 하는 방법 파이썬 비동기 웹 프레임워크의 시초 격인  Sanic 은 불행하게도 그 전에 소문이 나 버렸다. 실질적으로 제대로 된 비동기 웹 어플리케이션을 개발할 수 없었던 시기였다. 그나마  peewee-async 라는 또 다른 ORM 라이브러리를 사용해볼 수 있었으나, 둘이 썩 잘 어울린다는 느낌은 아니었다. 예를 들어, Sanic 테스트 클라이언트에서 request를 보낸 뒤에 event loop를 닫아버려 peewee에서 에러가 난다거나 하는 일이 있었다. 애초에 peewee 자체가 썩 인기 있는 ORM 라이브러리도 아니었고 말이다. 그래서 비동기 트랜잭션은 포기하는 방향으로 개발하는 케이스도 꽤 있었다. 그런데 다들 Sanic을 성능 때문에 쓰려고 했던지라 모순되는 일이다. 다음의 관심도 변화 차트를 보면 알 수 있는데, Sanic은 잠깐 반짝였을 뿐이고, Flask의 인기를 실질적으로 뺏은 것은 FastAPI라고 볼 수 있다.   FastAPI는 파이썬 비동기 프로그래밍에 관심이 많아지던 시기에 이목을 끌었고, 얼마 안 지나 SQLAlchemy 1.4가 릴리즈되었으며, 애초에 성능 말고도 많은 장점들이 있으므로 계속해서 관심을 얻는 것으로 보인다. 필자는 FastAPI를 모두에게 강력 추천하고 싶다. Flask를 배우고 있는 학교 후배들에게는 앞으로 FastAPI를 써 보라고 했다. FastAPI가 파이썬 웹 프로그래밍 세상에 많은 기여를 해주길 기대한다. 파이썬에서  반올림 의 결과를 리턴하는  round  함수는 수학에서 배웠던 것과 조금 다르게 동작한다.    1.5 ,  2.5  모두 반올림의 결과로  2 를 리턴했다. 초등 수학에서 배웠던 개념으로 생각하면, 둘 다 올림 처리가 되어야 하는 것이 맞다.  round(1.5) 는  2 ,  round(2.5) 는  3 의 결과를 가져야 타당하다. 어림(근사) 어림(근사)은 근사 처리되어야 할 대상, 예를 들어  1.15 를 정수로 근사할 때  0.15 를 처리하는 방법에 대한 개념이다. 그 방법에는 올림, 버림, 반올림이 있다. 올림과 버림은 자리 올림이 진행될 때 변위가 모두 동일한 방향을 갖는  Directed Rounding 에 속한다. 예로 올림은 변위가 +∞를 향하고, 버림은 변위가 -∞을 향한다. 파이썬의  round  함수는 변위의 방향이 하나로 정해지지 않으므로(e.g.  0.5 -&gt; 0(변위 -0.5) ,  1.5 -&gt; 2(변위 +0.5) ) 여기에 해당되지 않는다. 반올림 반올림은 근사의 과정에서 올림을 하기도 하고, 버림을 하기도 하는 방식이다. 반올림의 예로 대표적인 사사오입 방식을 예로 들면, 근사 처리되어야 할 대상이  0.5 ,  0.6 처럼 절반 이상일 때 올리고,  0.3 ,  0.4 처럼 절반 미만일 때 버리게 된다. 그러나, 프로그래밍에서 사사오입과 같은 맹목적인 올림 처리는 적절하지 않은 것으로 간주한다. 예로 소수부가 0.5인 숫자들로 이루어진 데이터셋을 처리한다고 가정하자. 사사오입 방식을 사용하는 경우, 반올림 처리되기 전과 후의 집계 결과에 오차가 커질 수 있다.  [0.5, 1.5, 2.5, 3.5] 라는 List의 요소를 모두 더한 결과는  8 이다. 모든 요소를 사사오입 방식으로 반올림 처리한 뒤 모두 더하면  1 + 2 + 3 + 4 로  10 이 된다. 4개의 요소들이 모두  0.5 만큼 고평가되어, 결과적으로  2 의 오차가 생겼다. 이런 문제로, 공학에서는 통계학적으로 더 합리적인 반올림 방법들을 사용하곤 한다. 사사오입은 반올림의 방식 중 하나라는 것을 인지하자. 반올림의 모든 방식들은, 근사로 처리될 대상이 정확히 절반에 해당하는 경우를 어떻게 처리할지에 대한 고민에서 출발한다.  0.5 를 반올림했을 때  1 이 된다는 것이 너무 당연하다고 생각할 수 있지만,  0.5 가 만약  0 으로 버림 처리되더라도 참값과의 오차는 올림 처리된  1   0.5 로 동일하다. 부동 소수점의 연산에 관한 표준을 다루는  IEEE 754 에서는, 이런 오차를 보정해주기 위한 반올림 방법으로  Round half to even 을 제시한다. Round half to even 반올림 대상이 절반에 걸리는 경우 가까운 짝수로 맞춰준다.  0.5 는  0 ,  1.5 와  2.5 는  2 가 되는 식이다. IEEE 754가 기본값으로 추천하는 방식으로, 파이썬의  round  함수도 이 방식을 사용하고 있다.  Bankers&#39; rounding ,  Gaussian rounding 이라 부르기도 한다.   여담 AppleScript에는  rounding as tought in school 이라는 커맨드가 있다.   썸네일의 주인공 : 이러고 있어도 우리 동아리 운영에 큰 공헌을 한, 요즘 진짜 개발 잘 하는 iOS 엔지니어  이병찬 이 글 왜 썼니? 2기 졸업생으로 고등학교를 떠나온 지 1년이 훌쩍 넘었다. 빠른년생이라 몇 개월 전에 졸업한 후배들이랑 친구 먹고 다니다 보니, 졸업 언제 했는지를 직접 세보고 나서야 내가 사회에 나온 지 얼마나 됐는지 실감이 난다. 이제 학교 일에 관심 그만 가져야 하는 꼰대가 돼버렸다. 다들 경험해 봤다면 알텐데, 잘 따라와주는 학생 가르치는 게 세상에서 제일 재밌다. 내가 운영했던 전공동아리에선 청출어람이라는 말이 어울리는 정말 멋진 후배들이 많았고, 같은 업계에서 정말 나보다 나은 사람들이 되었다. 그래서 ‘고등학생 시절 가장 재밌었던 추억’으로 확실히 기억나는 게 바로 이 전공동아리 이야기다. 기술적인 우여곡절이 많았던  DMS 라는 프로젝트도 기억에 남는데, 이건 나중에 쓸 지 말 지 고민해 봐야겠다. 이 글은 신생 학교의 덜 만들어진 체계 속에서 그 많은 동아리들이 &#39;실패했다&#39;고 생각한 이유가 무엇인지, 그리고 왜 실패할 수밖에 없었는지를 다룬다. 그리고 소위 ‘잘 나가는’ 동아리를 만들어내기 위해 무엇을 관찰했고, 어떤 고민을 했고, 어떻게 해결했는지, 어떤 성공과 실패가 있었는지 등등을 이야기한다. 대마고의 전공동아리 내가 졸업한 고등학교는 대덕소프트웨어마이스터고등학교다. 이름이 너무 길어서 대마고라는 별명도 있다. 하여튼 이 대마고에 입학하는 대부분의 학생들은, 졸업한 뒤에 소프트웨어 업계에서 바로 일하고자 한다. 이 쪽이 안 맞다고 생각하는 일부는 자퇴하거나 학교에 남아서 다른 공부를 하곤 했는데, 이들은 그리 많지 않았다. 따라서 3학년이 될 때까지 대부분의 학생들은 전공 실력을 늘리는 데에 대부분의 시간을 투자하는 편이다. 게다가 마이스터 고등학교 특성 상 모의고사나 수능같은 것들을 다 피해갈 수 있고, 성적을 이유로 취업하지 못하는 경우는 잘 없기 때문에, 시험 점수를 목적으로 하는 학교 공부를 그렇게 높은 우선순위에 두지 않는 경우가 많다. 전공 공부와 일반교과 공부를 병행하고 둘 모두에서 평균 이상의 결과물을 내는 게, 보통의 재능과 노력으로는 어렵기 때문에 하게 된 대표적인 우선순위 조절 사례다. 이런 분위기를 기반으로 하다 보니, 학교에서도 학생들의 전공 실력 향상을 위한 여러 컨텐츠들을 설계했었다. 방학에 소프트웨어 마이스터 고등학교끼리 모여서 캠프를 열거나, 특강을 준비하거나, 기말고사가 끝나고 겨울방학 전까지 며칠 간 온종일 프로젝트를 하게 하는 &#39;점프업 캠프&#39;라는 것도 있었다. 이런 단발성 이벤트들과 함께, 주기적으로 진행됐던 것중에 하나가 전공동아리였다. 특정 주제(해킹, 임베디드, 앱개발 등등)로 뭉친 10명 남짓의 그룹이 금요일 7~10교시에 모여서 시간을 보내는 것이었다. 내가 1학년일 때, 동아리들 각자는 튼튼하지 못하다고 느꼈다. 한 학기라도 순탄히 넘기면 다행인 분위기에, 학교가 생긴 초창기부터 유지되고 있는 동아리도 한두개 뿐이었던 것으로 기억한다. 당시 학교는 만들어진 지 2년째였고, 따라서 대마고 이름으로 재학 중인 3학년이 없었던 것이 동아리가 튼튼해지기 어려운 이유였다고 생각한다. 1학년 시절 느꼈던 당시의 문제점을 풀어 보겠다. 1학년 : 그 때 동아리는 무슨 문제가 있었나? 선배 부족 아직 머리가 다 안 만들어진 고등학생이 소프트웨어를 공부하게 되면, 웬만큼 똑똑하지 않고서야 공부 방향을 잡아줄 선배의 유무가 큰 차이를 만든다. 1학년이었던 나한테는 선배가 있었지만, 2학년이었던 그 선배들에겐 선배가 없었다. 학교의 신입생 기수가 올라감과 함께 경쟁률은 떨어지지만, 그와 반대로 전체적인 실력은 상향평준화되는 이유가 이것이다. 똑같은 고등학교 2학년이더라도, 그 위에 선배가 몇 기수나 있느냐에 따라서 성장 속도의 차이가 있었던 것 같다. 졸업한 1, 2, 3기 사람들이 후배들 신경 하나도 안 쓰고 살면 이런 이야기가 성립 안하겠지만, 내 친구들만 봐도 다들 최대한 후배들 챙겨주려고 하는 걸 보니 이게 좀 되는 것 같다. 아무튼 1학년이었던 내게 2학년 선배들은 엄청난 사람들이었지만, 상대적인 느낌이었을 뿐이었다. 객관적인 입장에서 대부분이 높은 수준을 가지고 있다고 말하기 어려웠다. 높은 경쟁률 뚫고 들어온 똑똑한 사람들이었는데, 학교가 잘 안 갖춰졌을 때 선배 없이 이리 치이고 저리 치이느라 성장의 전성기가 어쩔 수 없이 늦게 시작되는 현상이었다. 선배는 시행착오를 대신 해주고 알려주는 역할이 중요하다고 생각하는데, 그 선배들은 그런 역할을 해줄 선배가 없었으므로 자신들이 그런 것들을 다 겪었어야 했다. 이런 와중에 정말 실력 좋은 outlier들이 있었지만, 말 그대로 수준 높은 사람이 ‘몇몇’만 있었다는게 문제였다. 전체적으로 상향평준화된 게 아니라, 똑같은 학년이더라도 실력의 편차가 심했다. 그래서 말 그대로 ‘잘하는 선배’가 있는 동아리에 따라가서 배워보려는 식으로 동아리가 구성됐다. 이런 것 때문에, 당시 동아리들은 ‘실력 좋은 사람이 있어야만 인기있어 지는 구조’로 발전했다. 따라서 이런 슈퍼스타들 한두명의 움직임이 동아리의 이미지를 결정하고, 동아리를 흔들리게 만들었다. 무언가 시너지를 내는 팀 게임을 하지 못하고 &#39;임시로 만들어진 그룹&#39;의 느낌이 강했다. 시행착오하는 동아리는 인기가 없다 도전적인 동아리의 축소 마음 맞는 사람들끼리 모여 봐야, 아무 컨텐츠 없이 자습만 하면 상승효과가 없다. 만약 그 조직의 성격에 맞게 시너지를 낼 수 있는 컨텐츠를 구현하고, 실행에 잘 옮길 수 있다면 자습과는 비교할 수 없을 정도로 큰 시너지 효과가 나온다. 그러나 당시에는 대부분 그게 잘 되지 못했다. 동아리들은 &#39;나름 사람을 뽑았으니 뭐라도 해보자&#39;는 생각으로 이것저것 시도했지만, 결과적으로 대부분 시행착오였기 때문에 동아리 활동을 지치게 만들었다. 예를 들어 당시 내가 속했던 Oreo라는 앱 개발 동아리에서는, 선배들이 동아리 활동 시간마다 후배들한테 뭔가 가르쳐 보려고 항상 자료를 만들어 왔었다. 당시 안드로이드 SDK의  ImageButton 과  TextView  몇 개를 가지고 아주 간단한 클리커 게임을 만들었던 것이 기억난다. 그런 수업 자체는 매우 유의미했지만, 코딩 잘 모르는 애들 가르치겠다고 매 주마다 한두 시간 분량의 자료를 만들어온다는 게 정말 힘든 일이다. 이런 강의식 컨텐츠는 분명 효과가 있었지만, 강의를 담당하는 선배에게 과하게 의존한다는 단점이 있었다. 어느 날 우리들을 가르쳐주기로 한 선배가 너무 바빠서 자료를 준비해오지 못한다면, 그 날은 사실상 자습에 가깝게 활동이 이루어졌다. 동아리가 처음부터 완벽할 수는 없다. 당시의 Oreo도 그랬다. 그런 상황에서 동아리가 성장하기 위해서는, 좋은 사례를 베끼는 것으로 시작하는 것이 좋다. 하지만 그게 쉽지 않았다. 첫째로 학교에 있었던 동아리들 중 ‘여기 진짜 잘한다’는 생각이 드는 곳이 없었다. 둘째로 소프트웨어 분야에서 꽤 오래 된 고등학교들은, 대학을 준비하는 학생의 비율이 높아 우리 학교에 그대로 적용할 수가 없었다. 그럼 Oreo의 이야기처럼, 동아리의 성장을 위해 시행착오를 함께 버티면서 성장통을 한동안 겪는 것은 어쩔 수 없었다. 그러나 대부분의 동아리는 이런 시행착오를 굳이 겪으려고 하지 않는 방향으로 나아갔다. 보수적이고 안정적인 운영의 전성기 동아리에 속한 동아리원의 가장 우선된 목표는 개인의 성장이다. 이기적인 생각이라고 느낄 수도 있겠지만, 구성원의 입장에선 이게 당연하다. 동아리원 각자는 자습보다 더 높은 질의 성장을 위해 동아리에 들어온 것이고, 동아리는 그들이 잘 성장할 수 있는 체계를 만들어줄 의무가 있다고 생각한다. 이런 이유로, 동아리원은 자신이 속한 동아리가 시행착오를 겪고 있을 때 속이 답답할 수밖에 없다. &#39;이럴 바에 자습을 하겠다&#39;는 생각을 갖게 된다. 그러면서, 이런 일이 발생한다. &#39;다른 종류의 시행착오를 겪을 예정&#39;을 잘 포장해서 홍보하는 신생 동아리가 나타난다. 지금 속해 있는 동아리에 답답함을 느낀 구성원들은 &#39;저긴 좀 다르지 않을까?&#39; 싶어 동아리를 옮긴다. 사실 그 동아리도 비슷한 수준의 고통을 겪고 있고, 옮겨간 동아리원은 &#39;여기도 다르지 않네&#39;라고 생각하지만 어차피 다시 돌아갈 수도 없다. 이 과정에서, 기존 동아리가 앞으로의 몇 년을 설계하고 컨텐츠 구현에 도전하고 있었다면 큰 일이다. 한두 명의 이동으로 동아리가 해체될 위기에 놓일 수 있게 되고, 실제로 나도 겪었다. 이런 문제로 적극적인 시행착오를 겪으려 하는 동아리가 매우 적었고, 시행착오를 도전하는 동아리는 위와 같은 이유로 빠르게 망했다. 결국 theme만 다른 수많은 자습 동아리들이 대부분을 차지했다. 앱개발 동아리도, 웹개발 동아리도 결국 동아리 활동 시간의 모습은 이어폰 꽂고 자기 할 거 하는 것으로 똑같았다. 결국 많은 사람들이 신생 동아리로 이리저리 옮겨다니고, 그렇게 사람 빠진 동아리는 망하는 악순환이 반복됐다. 2학년 : 이게 왜 아쉬웠나 솔직히 말하면, 동아리 아무 데나 들어가서 대충 다녀도 된다. 소속에 상관 없이 본인이 열심히 하면 평균 이상 갈 수 있다. 심지어 그냥 자습 하면서 공부하고 살아도 상관 없다. 하지만 내가 여기서 아쉬웠던 건 시너지다. 4명으로 구성된 잘 갖춰진 팀은, 독립적인 개인 4명보다 더 나은 무언가를 만들어낼 수 있을 거라고 생각했다. 만약 그런 시너지 효과를 동아리가 만들어줄 수 있다면, 그 소문을 듣고 좋은 사람이 모이고, 재밌는 역사를 써나갈 수 있을 것 같았다. 학교가 만들어졌던 초창기에 &#39;마이스터 부장&#39;이라는 직책을 가진 선생님 한 분이 계셨다. 그 선생님이 하셨던 말씀 중에 &#39;나중에 사회에서 같은 학교 출신이 아니라 같은 동아리 출신으로 즐거워하고 뭉쳐 다녔으면 좋겠다&#39;는 것이 있었다. 나는 그 말에 강하게 공감했다. 색깔이 확실한 동아리 출신들끼리 모이면 강한 조직력을 가지며, 즐거울 수밖에 없다. 이런 생각에 &#39;튼튼한 동아리&#39;가 없다는 것을 아쉬워했다. 큰 그림을 그리고, 폐교되기 전까지 해체되지 않을 명확한 색깔을 가진 동아리를 만들고 싶었다. 만약 해체되더라도, ‘그 때 그 동아리 진짜 괜찮았는데 아쉽다’는 식으로, 모두의 기억에 남았으면 했다. 그래서, 일단 신규 동아리 신청을 했다. 일단 동아리를 만들자 당시 소프트웨어 개발과 3학년이었던 선배 한 명, 그리고 같은 과 2학년이었던 친구 세 명을 모아 동아리를 만들기로 했다. 이 과정에서, 세 가지의 가설을 세웠다. &#39;잘 하는 선배&#39;들이 동아리에서 버티고 있으면, 동아리가 겪는 시행착오는 후배들도 어느 정도 버텨줄 것이다. 어찌 되었든 실력 좋은 선배들은 ‘든든한 지원군’인 셈이니까. 내가 동아리장 잡고, 실력 좋은 친구들 데려다가 시간 쓰면 동아리에 어느 정도 색깔을 낼 수 있을 것이다. 동아리의 성장통에 답답함을 느낄 때쯤, 어느 정도 동아리의 모양이 완성되어 있을 것이다. 그렇게, 2017년에 모바일 앱 개발 동아리  GRAM 이 탄생하게 됐다. 뉴 메타를 만들기 위해 머리 맞대고, 어수선할 정도로 많은 것들을 도전하고 빠르게 실패해서, 적극적으로 피드백하는 성격의 동아리였다. 그리고 졸업 전까지 : 나는 무슨 노력을 했나 사람 잘 뽑기 우리 학교에서 전공 동아리가 사람을 뽑을 때는, 2, 3학년은 미리 갖춰진 경우가 많았기에 보통 1학년을 타겟으로 한다. 신입생 상태인 1학년들 사이에 전공 실력의 편차는 그리 크지 않으므로, 우리는 지원자를 평가하기 위한 지표에서 전공 실력을 모두 배제했다. 그 이유는, 신입생에게 전공 실력이 그렇게 중요하지 않기도 하고, 우리 동아리의 컨셉 상 1학년 지원자가 가진 전공 실력이 동아리 활동에 어떤 영향도 주지 않을 것이라고 봤기 때문이다. 우리 동아리는 생기있고 선후배 안 가리는 곳을 원했다. 따라서 조용한 한두 명의 인재를 중심으로 조직이 구성되는 것을 원치 않았다. 그렇게 ‘생기있는 동아리’에 맞게 평가 지표를 &#39;같은 동아리에서 활동하고 싶은지&#39; 위주로 설정했고, 여기에 맞춰 질문을 구성했다. 동아리 구성원과 지원자들을 반씩 묶어서 두 면접 그룹을 만들고, 면접에 참가한 구성원들이 점수를 매기도록 했다. 중간에 2, 3학년 인원을 보충해야 할 필요가 있었다. 동아리 컨텐츠 상, 이들은 배우는 입장보다 코칭을 하는 경우가 많았기 때문에 전공 실력을 점검할 필요가 있었다. 이런 점검을 위한 여러 기술적인 질문들을 100문항 가까이 내부에서 먼저 정리하고, 면접에 들어올 지원자들에게 이 내용을 미리 전해줬다. GRAM은 지원만으로도 성장에 도움이 된다는 이미지를 주기 위함이었다. 면접의 방식, 또는 사람을 뽑기 위해 면접이라는 절차를 사용했던 것이 좋았는지는 잘 모르겠다. 대신, 사람을 뽑는 시점부터 우리 동아리의 색깔을 반영하고자 노력했다는 점은 좋게 평가할 수 있을 것 같다. 물론 면접을 통한 지원자 검증은 생각해봐야 할 주제다. 예를 들어 2, 3학년 지원자의 전공 실력을 점검하기 위해 과제를 내주는 방법이 더 정확했을 수 있다. 그러나 과제를 내주는 것은 책임감 있게 생각해야 한다고 본다. 지원자들은 그 과제를 위해 열심히 시간을 투자할텐데, 그에 합당한 보상을 주지 못한다면 과제를 내주는 건 무리다. 사람 잘 뽑으라는 말은 아무리 강조해도 지나치지 않다. 동아리에 아무리 체계가 잘 잡혀있어 봐야, 마이너스 시너지를 내는 인원이 있으면 성장이 질질 끌릴 수밖에 없다. 후배들을 환영하고, 응원하기 우리는 동아리 신입생을 뽑고 난 뒤 첫 동아리 시간에, 1학년들이 오기 전에 일찍 동아리실에 가서 후배들을 환영해주기로 했다. 특별한 건 없었고, 그냥 예쁘게 움직이는 GIF 위에 동아리 이름 띄워놓고 모니터에 연결한 다음, 불 꺼놓고 기다리는 것이었다. 이처럼 우리는 신규 인원을 환영하기 위한 고민을 자주 했다. 이건 소속감을 위한 설계라던가 하는 게 아니라, 그냥 ‘우리 서로 친하고 재밌게 지내보자~’같은 소소한 목적이었다. 우리는 우리 동아리에 있는 후배들이, 우리보다 훨씬 더 빠르게 성장할 수 있을 것이라는 믿음을 가지고 있었다. 그래서 &#39;어차피 선배들이 더 잘하니까&#39;같은 생각 없이, 이것저것 도전하고 얼른 우리들을 가르치려 들길 바랬다. 그리고, 애초에 후배의 가파른 성장에 시기질투하지 않을 사람들로 동아리의 2, 3학년 인원을 구성했다. 후배들에게 ‘벌써 그런 것도 하고 대단하다&#39;는 이야기를 자주 했다. 이건 사실 응원을 해야겠다는 의도보단, 정말로 후배들이 대단하다고 느꼈던 적이 많아서 감정 그대로 한 이야기기도 하다. 실제로 내 2학년 1학기보다 후배들의 2학년 1학기가 더 나았다. 물론 절대적인 실력 수준에 대한 현실자각도 있어야 하지만, 어차피 이런저런 프로젝트 하면서 자기 알아서 느끼기 때문에 우리가 관여할 일은 아니었다. 하여튼 우리는 후배들을 향한 응원에 많은 자원을 투자했다. 물론 ‘너 이미 잘하고 있으니까 쉬어도 돼’같은, 사람을 덜 열심히 살게 만드는 무책임한 격려는 하지 않도록 했다. 응원들은 모두 ‘너 잘한다’고 박수 쳐주는 일이었다. 자신의 든든한 지원군인 선배들이 완전히 ‘자기 편’이라고 느끼게 하기 위함이었다. 그래야 두려움 없이 이것저것 도전할 수 있는 감정적인 여유가 생기고, 그런 자신감을 가진 만큼 덜 실패하기도 한다. 시간 들여서, 문화 가꾸자 동아리를 운영하며 가장 많은 시간을 투자했던 건, 우리의 색깔이 반영된 문화를 만드는 것이었다. 효율이 극대화된 스케줄로 동아리 활동 시간을 알차게 보낼 수 있도록 하고, 같이 부대끼고 있으면 시너지가 날 수밖에 없는 조직을 만들고자 했다. 다른 동아리로 건너가는 인원이 생기면, 이런 문화와 시스템의 부재로 갈증을 느끼도록 하고 싶었다. 그리고 좋은 사람들이 우리 동아리로 건너올 수 있도록 그런 문화들을 적극적으로 공개하려고 했다. 스터디 팀 먼저, 동아리 활동 시간의 대부분을 스터디로 채우고자 했다. 모바일 앱 개발이라는 주제로 모였지만, 각자가 공부하는 포지션(iOS 개발, Android 개발, 백엔드 개발)이 다르므로 그만큼 공부하는 주제와 방식이 달라지기 때문이다. 따라서 2, 3학년으로만 구성된   정규 스터디 라는 것을 만들었다. 이들은  스터디 리드 의 역할을 맡는다. 그리고 동아리의 1학년은 원하는 정규 팀에 참여한다. 그리고 동아리 구성원들은 언제든  비정규 스터디 를 만들 수 있었다. 예로 동시성 프로그래밍과 같이, 포지션 구분 없이 공부할만 한 주제가 자주 생기기 떄문이다. 여기에는 인원이나 학년 제한, 진행 기간 등 거의 모든 것을 자유롭게 뒀다. 만약 동아리 인원끼리 해커톤이나 공모전을 나가게 되는 경우에도 이 방식을 통해 결성한다. 모두 활동을 기록하고, 각 구성원이 동아리에서 진행 중인 여러 활동들 중 어디에 속해 있는지를 서로가 정확히 알 수 있게 하기 위함이다. 이렇게  정규 스터디 와  비정규 스터디 라는 제목의 과목이 만들어져, 매 주마다 동아리 활동 스케줄을 짜기 위한 재료로 사용됐다. 직계 선배한테 질문하는 건 참 어렵다. 괜히 시간 뺏는 것 같고, 조금만 더 찾아보면 알 수 있는 거 괜한 질문을 하는 게 아닐까 싶은 감정이 생길 때가 많다. 자기 질문 마음껏 받아줄 사람이 정해져 있는 게 도움될 것이라고 생각했다. 정규 스터디에는 웬만하면 학년별로 인원수를 맞추려고 했다. 동아리에 속한 모든 3학년은 2학년을, 2학년은 1학년을  직계 로 두는 문화를 만들기 위해서였다. 직계는 ‘후배의 성장을 적극적으로 서포트하는 멘토&#39; 정도의 역할을 한다. 직계에는 몇 가지 규칙이 존재했다. 무작정 다 도와주는 게 아니라, 자립을 도와주는 방향으로 코칭할 것 되도록 졸업 후에도, 직계가 업계에 나올 수 있을 때까지 챙겨줄 것 이런 시스템은 동아리의 조직력을 크게 늘리는 데에 기여했고, 실제 구성원들 각자의 성장에도 많은 도움을 줬다. 회고 동아리는 일주일마다 모인다. 학교 생활 일주일은 충분한 변화를 경험할 수 있는 기간이라고 생각했다. 각자 어떤 성장을 했고, 다음주의 계획은 무엇이고, 어려웠던 점을 공유하는 회고 시간을 반 교시에서 한 교시 정도에 걸쳐 진행했다. 체험학습이나 대회 참가 등으로 회고에 참여하지 못하는 경우, Slack에 자기 분량의 내용을 남기도록 했다. 사실 이런 피드백들은 개인 단위에서도 관리할 수 있지만, 동아리에서 그 내용을 공유하다 보면 서로 의견도 나눌 수 있고 확실히 목표에 무게감이 더해지는 것 같았다. 문서로 공개하기 이런 컨텐츠들을 &#39;문화&#39;라는 이름으로 정리해 최대한 공개했다. 면접 질문, 가이드라인, 템플릿 등을 GitHub Wiki를 통해 공개하고, 진행하는 소프트웨어 프로젝트, 스터디, 라이트닝 토크, 회고의 내용 등의 활동 데이터를 되도록 모두 GitHub에 업로드했다. 우리의 활동이 기록되는 효과도 있었고, 이런 활발함이 공개되면서 자연스레 홍보가 되는 효과도 있었다. 문서 작업은 특별한 게 아니고 시간 투자의 싸움이다. 당시에 나는 이런데에 쓸 시간이 많았다. 노는 시간 줄여서 문서 작업에 시간을 투자하는 게 아깝지 않았기 때문이다. 물론 지금 보면 이렇게 거창하게 &#39;노는 시간 줄여서 썼다&#39;고 말하기엔 참 부실하고 부족하다. 졸업하고 나서 : 지금의 GRAM을 보며 드는 생각 나는 동아리 시간이 기다려지는 곳을 만들고 싶었다. 그 목표를 위해 많은 것들을 시도했고, 함께 동아리를 꾸려나가던 고마운 친구들은 자신들의 소중한 시간을 부족한 동아리장 돕는 데에 써줬다. 덕분에 Plan A였던 ‘폐교 전까지 해체되지 않는 동아리’를 만드는 데에 어느 정도 성공했던 것 같다. 내가 졸업한 뒤 GRAM은 New GRAM으로 이름을 변경해서 활동했고, 올해에 다시 GRAM이라는 이름이 동아리 판에 복귀했으니 말이다. 동아리는 처음부터 완벽하기 어렵고, 나는 동아리 운영을 천재적으로 잘 하는 사람이 아니었기에 GRAM도 완벽하지 못했다. 기존의 동아리들과 조금 다른 돌연변이로서 어느 정도 좋은 평가를 받았지만, 분명히 실패한 부분도 있었다. 물론 지금 후회하면 늦은 거다. 시기 상으로도 늦었고, 이미 졸업했으니 건드리면 안 되는 구역이기도 하다. 동아리의 운영권을 쥐게 된 후배들이, 우리가 만들고자 했던 동아리의 모습을 잘 해석해 알아서 성장시켜 주길 바랄 뿐이다. 그리고 고맙게도, 성공 궤도에 올라간 것 같다. 우리가 겪었던 실패는 지금의 동아리장과 피드백하고 있는 비밀이니, GRAM이 올해 성공하고 나면 공개하기로 하고 이만 여기까지 하겠다 :-) 그래서.. 하여튼, 전공동아리 GRAM은 내가 운영하던 당시 성공했다고 자신있게 말하진 못 하겠다. 그러나 당시 수많은 시행착오와 성장통을 짧은 시간에 압축해 충분히 경험했다. 이제 GRAM은 성공할 일만 남았다. 어차피 만들어진 김에, 아득바득 살아남아 학교라는 작은 사회 안에서 멋진 역사를 만들었으면 좋겠다. 모든 동아리는, 자신의 1학년 시절을 기억하며 구성원들이 어떤 곤경에 빠질 수 있는지를 인지하고 있어야 한다. 그리고 이런 힘듦을 앓고 있는 후배들의 자립을 도와주는 게 동아리와 선배의 진짜 역할이다. 동아리 운영은 분명 재밌는 일이다. 단순히 그런 재미 외에도, 사람을 다룬다는 생소한 경험을 해볼 수 있는 기회기도 하다. 그러나 동아리는 구성원들의 성장에 큰 장애물이 될 수도 있기 때문에 책임감을 가져야 한다. 커리어와 같은 목적으로 동아리 운영을 가볍게 생각하면 안 된다고 본다. 후배들한테 민폐다. 개인적으로는 우리 학교의 선후배 네트워크가 더 끈끈했으면 좋겠다. 당연히 재학생 입장에서는 &#39;꼰대는 나가있어&#39; 싶을 수 있다. 그러나 대마고에서 몇 년 전까지 아침운동 욕하고, 공부하고, 취업 준비하던 기억을 가진 경력 2년 된 엔지니어가 도움이 안 될 것 같지는 않다. 사람도 챙기고 동아리도 뒤처지지 않도록 만드는 것은 참 힘들다. 아무리 고민하고 연구해도, 동아리 운영은 어려운 일이다. 긴 글 읽어줘서 고맙습니다. 요새 다들 Quotation이나 이모지 많이들 써서 예쁘게 글 꾸미던데, 오랫동안 다른 지면에서 글을 쓰다 보니 텍스트로만 구성하는게 익숙하네용 ㅎㅎ 여기서 이모지 많이 써야지 🤔 🤨 😐 😑 🥺 😞 😟 😒 😓 😔 😕 🙃 느낀 점 테스트 습관 테스트 방법론은 배울 게 많다 테스트를 작성하는 것과, 테스트의 대상이 될 로직을 작성하는 것은 마치 서로 다른 사람이 하는 것처럼 구성해야 한다고 느꼈다. 내 입장에서 TDD의 원칙이 도움이 되었던 건, 테스트를 먼저 공격적으로 작성해두고 나서 그 요구사항을 충족시키기 위해 로직을 방어적으로 개발하게 되었던 부분이다. 로직을 먼저 작성하고 이걸 바탕으로 테스트를 만들면, fail이 나지 않게 하고 싶어서 괜히 테스트를 더 보수적으로 작성하곤 했으니 말이다. 커버리지 100%가 다가 아니다 테스트 커버리지가 100%인 코드도 버그가 생길 수 있다. 커버리지라는 게 솔직히 그냥 &#39;코드가 이만큼 실행됐다&#39;는 거지 &#39;모든 시나리오로 테스트되었다&#39;가 아니기 때문이다. 커버리지가 100%라고 해서 마냥 안심할 게 아니라, 어떻게 하면 내가 만든 코드가 에러를 뿜게 할 수 있을지 별 짓을 다 해보는 게 중요하다. 신규 작업자가 걱정 없이 리팩토링할 수 있는 수준이어야 한다 &#39;테스트는 얼마나 작성해야 하나?&#39;라고 했을 때, 테스트 덕분에 신규 작업자가 특별한 배경지식 없이도 코드를 마음껏 리팩토링할 수 있으면 충분한 것이라고 생각한다. 쉽지 않은 일이고, 내가 내년에 정말 많이 노력해야 할 부분이다. unit test에 너무 얽매이지 말자 외부 의존성이 없어야 하는 게 unit test의 조건이다. 나는 API와 관련된 부분을 많이 작업하는데, 보통 다 DB와 연계되어 있어서 unit test를 제대로 작성하려면 mock, stub 등의 방법론을 통해 고립을 보장해야 한다. 그러고 나서는 DB와 연결해 로직을 테스트하는 integration test도 작성해야 한다. 그러나 한정된 시간 내에서 작업하는 와중에 unit test에 욕심 부리기는 힘들다고 느꼈다. 테스트의 효용성과 테스트 퀄리티 간의 트레이드오프라고 정리하면 될 것 같은데, 애초에 커버리지도 낮은 와중에 빠르게 변화하는 프로덕트에 발맞춰서 이상적인 테스트 코드를 작성하긴 어려웠다. Integration test라도 빡세게 만들자. idempotent에 투자하자 integration test는 보통 사이드이펙트를 만든다. 테스트 A는 어느 테이블에 몇 번의 insert/update를 가하며 api 호출을 하고, 테스트 B는 테스트가 종료될 때 그 테이블을 truncate한다고 치자. 싱글 프로세스로 테스트가 돌아갈 땐 문제가 발생하지 않겠지만, 여러 프로세스가 테스트를 실행하는 상황을 가정해 보겠다. 프로세스 1이 테스트 A를 실행하는 와중에 프로세스 2가 테스트 B를 실행하면 테이블의 내용이 중간에 truncate되어 테스트가 실패할 가능성이 생긴다. 테스트 각각은 독립적이어야 하며, 순서에 의존하지 않아야 한다. 프로세스 20개가 동시에 무작위로 돌려도 문제 없는 테스트를 만들어야 한다. 이래서 난 공부해야 한다 코드 퀄리티를 챙길 시간이 없다 나는 정해진 시간 내에 만들어낼 수 있는 output의 수준이 높으면 &#39;capacity가 높다&#39;고 이야기한다. 나보다 capacity가 높은 사람이 대충 만든 결과물이 내가 공들여서 만든 결과물보다 나을 수 있다. 업무 과중의 기준은 상대적이다. 어쩔 수 없이 나쁜 코드를 작성할 수는 있지만, &#39;어쩔 수 없이&#39;의 빈도를 낮출 수는 있겠다고 느꼈다. 그 방법이 뭐던 간에 capacity를 올려야겠다. 조직의 상향평준화에 기여하자 내가 사람을 평가한다면 &#39;함께 일하고 싶은 사람인지&#39;를 따져볼 것 같다. 내가 그런 사람이 되려고 노력하면 자기계발에 긍정적일 것 같았다. 물론 내 자신의 실력 수준에 아직 자신감이 많진 않다. 그만큼 올해에 성장을 크게 하지 못 하기도 했고. 레벨업을 좀 하긴 했는데 스탯이 여기저기에 분배된 느낌. 열심히 하는 것보다 잘 하는 게 더 중요하다 얼마 전에 이게 꼰대들이 하는 이야기라는 걸 봤다. 그래서 앞으로 남들한테 이 말을 하진 않겠지만(..), 누가 나한테 이 이야기를 한다면 정말 많이 동의할 것 같다. Production에서 잘 돌아가는 코드를 작성해야 한다 소프트웨어라는 게 참 여기저기에 많이 얽혀있다. 운영체제나 설치된 패키지 버전, 프로세서의 비트 수, 서버에 설정된 네트워크 규칙 등 production에서는 신경써야 할 게 꽤 많다. 알고리즘은 일반적인 방법이어야 한다 알고리즘은 어떤 입력 값에 대해서도 대응할 수 있는 일반적인 방법이어야 한다. 꼼수는 어떻게든 무너지게 되어 있다. &#39;되게 만들기&#39;와 &#39;잘 되게 만들기&#39;는 수준 차이가 큰 것 같다. 내가 아는 건 그냥 기본 소양일 뿐이다 소프트웨어 전체로 따졌을 때, 나는 아직 많이 아는 상태가 아니다. 적어도 아는 것보다 모르는 게 더 많다. 뭐 좀 더 안다고 까불고 다닐 게 아니라 내년이면 5~6년째 일하고 있는 사수 따라잡는다 생각하고 공부해야 하는 게 맞다. 팀플레이 질문은 정리해서 하자 정리되지 않은 질문은 보통 환영받기 어렵다. 질문을 얼버무리기 시작하면 팀플레이에 큰 손해를 준다. 올해에 내가 그런 적이 많기도 했고, 외부에서 정리되지 않은 질문을 받아보기도 하니 경험적으로 확실히 느꼈다. 동료를 돕는 데에 시간을 내자 어차피 내 주변 사람들은 &#39;도와주면 잘할 놈들&#39;이다. 동료를 돕는 데에 시간을 내면, 그 시간동안 단순히 내 작업을 하는 것보다 더 많은 output이 잠재적으로 보장되는 경우가 꽤 많았다. 일의 효율에 영향을 주는 게 있다면, 지원을 요청하자 일이 잘 되게 하는 요소가 있다면 건의하고, 일이 안 되게 하는 원인이 있다면 &#39;이래서 못했다&#39;는 핑계를 댈 게 아니라 주변에 도움을 요청하면서라도 해결해나가야 한다. 그러라고 돈 받으면서 일하는 거니까. 실패한 것들 낮은 안정감 퍼포먼스에 기복이 생기는 경우가 많았다. &#39;적어도 무조건 이 만큼은 할 것&#39;이라고 보고 일을 맡길테니, 내년엔 확실히 보장된 capacity를 확보해야 한다. 연재가 멈춰진 시리즈 글 야심차게 진행했던 &#39;백엔드가 이 정도는 해줘야 함&#39;이 계획해 두었던 내용의 20% 남짓만 공개되고 연재가 멈춰졌다. 파이썬이나 Flask 관련 시리즈도 한두 챕터만 작성하고 말았다. 차라리 남는 시간이 있었더라면 내년 초부터라도 다시 진행해봤을텐데, 책 집필에 시간을 쏟게 되어 적어도 내년 4월까지는 연재가 멈춰진 채 두어야 한다는 게 너무 아쉽다. 드랍된 프로젝트 레포만 만들어 놓고 손대지 않은 프로젝트가 꽤 많다. tf-idf 구현체, 마인크래프트 모드, 간단한 http 프레임워크, 앱 프로젝트 등등.. 레포 만들자 마자 바로 코딩해야 뭐라도 나오는데 그냥 미뤄버려서 보류된 채 가만히 두게 됐다. 내년 계획   집필 순조롭게 끝내서 출판   데이터 사이언스 좀 배워두기   보류된 프로젝트들 챙기기   서브 언어 좀 확실하게 배워두기   어디 큰 데 가서 발표 한 번 하기   기획했던 시리즈 하나라도 끝내기 2018년 7월에 백엔드 엔지니어로 일을 시작해서 곧 2020년이 된다. 이런저런 느낀 것들이 많아 1년차 정도가 되었을 때 글을 쓰려 했는데, 회고하는 겸 연말에 글을 쓰게 됐다. 궁금하지도 않을 내 얘기만 써서 따분한 글이 될까 싶어, 느낀 점들로 뒤쪽에 내용을 많이 채웠다. 쓰다 보니 내용이 너무 많아져서, 2~3개의 글로 나누어 작성해보려 한다. 성과 글에 대한 인정 올해 2~3월과 6월에는 내가 썼던  &#39;백엔드가 이정도는 해줘야 함&#39; 시리즈 와  내게 실용적이었던 프로그래밍 공부 방법들 이 꽤 많은 곳에 공유됐었다. 여러 페이스북 페이지, 트위터, 한빛미디어 dev letter, ppss 미디어, 네이버 메인 테크판 등등.. 바이럴에 생각 이상으로 많이 돌아다녀서 꽤 놀랐다. GitHub 활동에 대한 인정 고등학생 때 만들어서 유지하고 있는 repository 삼대장이 꽤 많은 사람에게 닿았다. 열심히 갈고닦은 결과물이 인기를 얻으니 만족스럽기도 하고, GitHub 프로필 자체가 꽤 풍성해져서 좋다.   내가 만든 라이브러리를 쓴 익명의 누군가가 감사인사를 보내주거나 이슈를 남겨주는 게 이렇게 즐거운 일인지 몰랐다. 6개월 전 쯤에 프로토타입만 만들어서 간단히 배포하고 신경을 안 쓰고 있던  google-play-scraper 라는 라이브러리가 있었는데, 몇 주 전에 repository에 들어가 보니 많은 사람들이 이슈를 남겨주었다.   대부분 crash에 대한 제보라 사용자들에게 미안한 마음은 있었지만, 그래도 누가 내 코드를 쓰고 있다는 게 감격스러워서 적극적으로 업데이트 버전을 릴리즈했다. 그리고 또 시간이 흘러 메일을 한 통 받았다.   대충 고맙다는 내용이었다. 나름대로  고생해서 만든 결과물이 바다 건너 누군가에게 도움이 됐다 는 게 정말 만족스러웠다. 책 집필 얼마 전에 시간을 조금 들여 썼던 글  Python 3.8의 새로운 기능들 을 읽고 출판사 기획자님이 메일로 연락을 주셔서, 파이썬 튜토리얼을 주제로 300페이지 정도 분량의 책을 쓰게 됐다. 몇 개월간 많이 고생하겠지만, 좋은 글로 기초를 널리 알리고자 하는 욕심을 해소할 좋은 기회가 된 것 같아 만족스럽다. 최소 경력이 된 것 같은 느낌 좋은 의사결정을 하려면 지식도 경험도 많아야 한다.  의사결정을 위한 양질의 후보 들을 많이 뽑아내야 하기 때문이다. 작년에 비해, 어떤 문제를 해결하던  &#39;오래 갈 수 있는 방법&#39; 을 더 잘 찾아낼 수 있게 됐다. 회사에서 도전도 많이 해보고, 그만큼 사고도 많이 치고, 프로젝트도 이것저것 시도해 보고 하니 경험이 좀 쌓였나보다. 동료와 부대껴서 무언가 이뤄낼 수 있을만한 경험적인 준비가 어느 정도 된 것 같은 느낌이 든다.  함께 자라기 - 애자일로 가는 길 에서는, 1984년부터 1986년까지 92개 회사에서 600명 이상의 개발자를 대상으로  경력과 업무 수행 능력 간의 상관성 을 연구한 자료를 인용했다. 그 자료는 아래와 같은 내용이었다. 경력이 10년인 개발자가 2년인 개발자보다 더 우수하지 않았다. 경력과 생산성은 아무 상관관계가 없었다. 단, 언어를 접한 경험이 6개월 미만인 개발자들은 전반적으로 나머지 개발자들보다 성적이 저조했다. 연구에 어떤 오류가 있을지 모르니 맹신할 수는 없지만, 적어도 공감은 한다.  최소한의 경험치만 넘어가면 경력과 직무 성과의 상관성이 생각보다 낮다 는 것이다. 경력의 양보단 질이 중요하며, 도전을 칭찬하는 조직에서 한동안 수준 높은 경험을 하고 나니 꽤 많이 성장했다는 게 느껴진다. 느낀 점들 아래에서 이야기할 것들은 이 글을 보고 있는 여러분이 주니어 시절 느꼈거나, 느낄 것들과 같지 않을 것이다. 일을 시작한 시기, 배경지식, 학업 성과, 속한 조직의 성격에 따라 누군가는 평생 느끼지 않았을 내용도 있다. 그러니 공감되는 것만 같이 공감하면 되겠다. 마음가짐 나이는 핑계가 아니라 무기 어떤 기회로 말하게 됐는지는 기억이 안 나는데, 올해 초에 회사 사람들이 다 모여있는 곳에서  &#39;어린 나이가 핑계가 아니라 무기인 사람이 되겠다&#39; 고 이야기했었다. 솔직히 &#39;나 고등학생인데 이만큼 한다&#39;하는 것도 어차피 내 동료들은 내 나이때 나보다 훨씬 더 잘했고, &#39;이만큼밖에 못하지만 어리니까 괜찮은 거 아님?&#39; 하는 회피를 하기 싫었으며, 나이 어린 게 핑계거리가 되는 것만큼 추한게 없다고 생각해서 했던 말이었다. 지금 되돌아 보면, 말했던 만큼 좋은 모습을 보여주지 못했던 것 같다. &#39;회사의 성장에 도움이 되어 줘서 고맙다&#39;고 하는 글을 전사에 공유하신 분은 과연 나를 떠올렸을지 생각해 보면, 별로 그런 것 같지 않아서 그렇다. 10대 생활이 이제 거의 끝나가는데, 더 많은 것을 이뤄낼 수 있었음에도 안일했던 게 마냥 너무 아쉽고, 내년에는  조금 더 완성도 높은 엔지니어로 제품에 더 많이 기여 할 수 있었으면 좋겠다. 실수가 반복되지 않게 만들자 실수는 일어날 수 있지만, 반복되면 안 된다.  동일한 실수가 두 번 이상 일어나면 그건 정말 잘못한 게 맞다.  실수가 생기면 단순히 &#39;앞으로는 이러지 말자&#39;고 다짐하고 말 게 아니라,  원인을 근본적으로 해결 해야 한다. 그렇지 않으면 내 동료들도 나와 똑같은 실수를 할 수도 있기 때문이다. API에서 버그가 생겼다면, 그냥 고치고 끝내지만 말고 적어도 테스트를 보완하는 작업 정도는 해야 한다. 제목이 그냥 &#39;실수를 반복하지 말자&#39;가 아닌 게 이런 이유다. 지치지 말자  학교 학습 처럼 성과가 정량적으로 측정되는 공부가 아니라, 명확한 평가 기준이 없이 미래에 뭔가 도움이 되기 위한 성장 위주의  야생 학습 은 학교에서의 학습 전략을 그대로 가져와 사용하기 쉽지 않았다. 학교에선 당장 실력이 빨리 늘어야 하고 취업이 되어야 하니 매일 에너지를 방전시켰는데, 그 습관을 사회에 나와서까지 유지시키려고 하니 어려운 점이 많았다. 야생 학습에 맞도록 전략을 바꿔야 했는데, 내 경우에는  지치지 않도록 완급조절 을 하는 게 많은 도움이 됐다. 당장 이뤄야 할 큰 목표가 없다면, 에너지를 과소비하지 않으려고 한다. 열심히 하는 만큼 한 번 힘들기 시작하면 끝도 없었다. 하루에 10시간씩 3개월 공부하고 지쳐서 몇 주 쉬는 것보다, 하루에 2시간씩 학습하는 걸 오랫동안 이어가는 게 졸업 후의 성장에 더 많은 도움이 됐다. 컨디션 관리도 실력이다 프로는 부상을 예방하는 데에 신경쓴다. 올해엔 몸이 좋지 않아서 휴가를 쓴 적이 많았는데, 내년에는 최대한 줄여봐야겠다. 단순히 전공의 실력을 늘리는 것만으로 자기관리가 끝나는 것이 아니니 말이다. 실수하고 났을 때의 멘탈 관리도 정말 중요하다 느꼈다. 이케아 효과 금지 내가 만든 해결책을 과대평가 하지 말자. 이건 겸손을 떨자는 게 아니라 현실이 그랬다. 어쩌다 운이 좋아서 정답에 가까운 의사결정을 했더라도, 누군가는 더 잘 할 수 있었을거라는 생각을 꾸준히 하려고 한다. 학습 습관 블로그에 튜토리얼은 웬만하면 피하자 가장 후회했던 공부 방식을 꼽자면,  블로그에 튜토리얼을 썼던 것 이다. 그 경험으로 글 솜씨가 늘고, 기초를 더 잘 설명할 수 있게 된 것은 틀림없지만 성장에 가장 도움이 덜 된 학습 방법이었다. 물론 튜토리얼을 작성하는 게 성장에 도움이 되는 스타일의 사람도 있으니 나의 비추천을 너무 쉽게 받아들이진 않았으면 좋겠다. 공부는 무작정 열심히만 하지 말자 시간이 지날수록 계속해서 올림픽의 신기록이 갱신되는 건, 옛날 사람들보다 지금 사람들이 유전적으로 우수하고, 더 잘 먹고, 더 열심히 했기 때문이라기보단  어떻게 부족한 부분을 채우고 더 잘 해낼 수 있을지 고민 하는 과정에서 비롯된 것이라고 생각한다. 코드를 똑같이 1만 줄 작성한다고 쳤을 때, 그 과정에서 얻는 경험치는 사람마다 서로 다를 것이다. 학교에서 닥치는 대로 프로젝트에 들어가서 비슷한 코드 붙여넣어가며 공장처럼 수천 줄을 작성했던 때보다, 더 좋은 결과물을 위해 많은 부분을 고민하며 작성한 2천 줄 남짓의 코드가 훨씬 더 많은 경험치가 됐다. 각 잡고 테스트를 작성해본 것도, CI를 달아본 것도, 코드 퀄리티를 측정해본 것도, 로그 시스템을 구성해본 것도, 모니터링을 시도해본 것도 처음이었으니 말이다. 그 때는 내 자신이 너무 자랑스러워서 페이스북에 자랑 글도 썼었다.   지금 보면 부끄러울 정도의 수준이지만, 그 코드가 보고싶다면  여기로! 대충 붙여넣어 1시간에 100줄의 코드를 작성하는 것보다, 더 나은 방법을 의식적으로 고민하며 1시간에 10줄의 코드를 작성하는 게 성장에 도움이 되는 경우가 많았다. 물론 일정이 빠듯한 경우는 어쩔 수 없지만. 공부법을 몰라서 공부를 못 하는 게 아니다 수능 만점자 공부법이고 서울대 도서관 백색소음이고 공부 동기부여 영상이고 그런 게 학습의 효율을 높이는 데에 기여할 수는 있어도,  애초에 공부를 별로 하질 않으면 딱히 의미가 없다 고 생각했다. 차라리 너무 잘하려고만 애쓰다 보니 학습 초기부터 즐기기가 어려웠다. 그냥 부담 없이 힘 빼고 멍청한 방법으로라도 공부를 시작하고 지속하다 보면 훨씬 즐겁기도 하고, 자기만의 공부법이 만들어질 수밖에 없는 것 같다. 이걸 여태껏 많이 경험했음에도, 새로운 언어를 배운다거나 할 때마다 너무 잘하려고만 해서 많은 부분을 실수했던 한 해였다. 이제 너무 각만 잡지 말고 그냥 무작정 도전해봐야겠다. 코딩 습관 Internal Server Error가 나는 케이스를 최대한 방어하자  &#39;예상치 못한 이슈&#39;는 필연적으로 생긴다 고 가정하며 개발하곤 했지만, &#39;예상치 못함&#39; 중 &#39;예상&#39;의 범위를 많이 넓히지 못했다. 예를 들어 통계 데이터를 조회하기 위한 날짜 범위를 너무 길게 요청해서 API가 timeout이 난다면, 그렇게 긴 범위를 요청한 사용자를 탓할 게 아니라  범위를 제한하지 못한 최초의 설계를 탓 하고 고쳐나가야 한다. 클라이언트는 무엇이든 입력할 수 있다 최근에 아주 교훈적인 사고가 하나 있었다.  서버 개발자는 클라이언트 데이터를 믿지 마라 라는 글의 내용인데,  수능평가원에서 폼 데이터를 조작해 수능 성적표를 미리 발급 받을 수 있었던 이슈였다. 코드의 로직만큼 중요한 게  검증(validation) 이라고 생각한다. 요청의 body 중 URL이 들어오길 기대하는 필드가 있다면, 그걸 그대로 가져다가 사용할 게 아니라 타입은 문자열인지, URL 포맷에는 맞는지 등을 검증해야 한다. Validation을 제대로 하지 않아  status code 400을 내려줘도 될 요청에 500을 내려주는 상황 이 꽤 자주 일어나서 아쉬웠다. DRY한 코드에 신경쓰자 내가 학교에서 작성하던 코드들은 애초에 비즈니스 로직이 복잡하지 않아서 코드의 중복을 매우 쉽게 해결할 수 있었다. 그러면서 코루틴이나 커링같은 트릭들을 공부하는 데에 많이 신경썼는데,  좋은 코드를 위한 최고의 기본기는 DRY 라는 생각이 들었다. 라이브러리처럼 코딩하자  YANGI(You Aren&#39;t Going to Need It) 라는 말이 있다. 소프트웨어적 요구사항의 예측은 빗나감을 가정하며, &#39;나중에 필요하겠지&#39; 하는 예측보단  당장 필요한 코드만 최소한으로 유지하고자 하는 마인드 로 프로그래밍에 임해야 한다는 것이다. 섣부른 예측으로 추가된 코드가 복잡도에 나쁜 영향을 줄 가능성이 크다는 것은 인정하지만, 개발하다 보면  확실하게 사용 시나리오가 예상 되는 경우가 종종 있다. 그럴 때마다 &#39;그냥 라이브러리처럼 만들어 보자&#39;고 생각하면, 어느 정도의 범용성을 갖춘 결과물이 나오는 경우가 꽤 있었다. 결과적으론 YANGI의 원칙을 위반하는 게 되지만, 확실한 근거를 바탕으로 한 예측은 나쁘지 않다고 느꼈다. 코드 한 줄 한 줄이 빚이 되는 상황에, &#39;오래 갈 수 있는 코드&#39;를 만드는 건 수준 높은 기여라고 생각한다. 2편에서 이어집니다. 6월 4일에는  Python 3.8.0b1 이, 7월 4일에는 두 번째 베타 버전인  Python 3.8.0b2 가 릴리즈됐다. 이는 Python 3.8이  feature complete 하게 되었다는 것을 의미한다. 정식 릴리즈가 10월에 이뤄질텐데, 그 전에 이 베타 버전을 통해 Python 3.8의 새로운 기능들을 살펴보자. 이해하기 쉽고 headline이라고 볼 수 있는 변경 사항들만 언급할테니, 외의 내용들은  파이썬 공식 문서 를 읽어보기 바란다. Walrus Operator  Assignment Expression 이라는 이름으로  PEP 572 에 소개된  walrus operator  개념이 포함되었다.  NAME := expr 이라는 표기법을 사용하여 변수 할당을 할 수 있게 만드는 것이다.  condition capturing 이라는 어휘로 이해하면 될 것 같다. 이는  if statement의 entry point  레벨에서,  해당 block scope에 대한 변수 를 정의할 때 사용할 수 있다. 그리고  while statement에서 iteration마다의 변수 할당 에 사용할 수 있다. 이는 디테일한 iteration을 구현할 때 매우 많은 도움이 된다. 예를 들어 파일의 내용을 순서대로 16바이트씩 읽어 처리하는 모종의 스크립트를 작성한다고 하면, Python 3.8은 walrus operator 덕분에 더 간결하고 깔끔해 진다. comprehension에서도 사용할 수 있다. 위에서도 말했듯  condition capturing 이라는 어휘로 이해하자. 응용한다고 쳤을 때, 대화형 CLI 어플리케이션이나 socket 관련 어플리케이션을 만들 때 사용할 수도 있겠다. Debug support for f-strings 타이틀만 봤을 땐 fstring이 디버깅 관련 문제가 있어서 이걸 개선했겠거니 싶었는데, fstring에 대한 문법이 추가된 것이었다. 바로  =  specifier다.  f&#39;{expr=}&#39;  식으로 작성된 섹션은,  해당 표현식 그대로의 텍스트 와,  평가된 표현식 의 순서대로 문자열이 된다. 예제에도 포함되어 있듯이,  expression에 들어 있는 공백이 보존 되기 때문에 매우 유용하다. Positional-only parameters keyword-only parameter를 위해  *  specifier가 지원되고 있었는데, Python 3.8에서는  positional-only parameter  개념이 생겨나며 함수에  /  specifier가 새로이 지원된다.  PEP 570 에 이 내용이 명시되어 있으며, 따라서 Python 3.8부터는 파라미터를  positional-only ,  positional-or-keyword ,  keyword-only 로 나누어야 한다. 60챕터 정도로 계획을 잡았고, 그동안 약 20개의 글을 통해 17개 챕터의 내용을 공유했다. 그러나 이런 주제로 글을 쓰는 게 개인의 성장에 그리 큰 도움을 주지 않는 것 같아 그동안 연재를 일시중지하고 있었다. 내용의 난이도가 높아서가 아니라, 교과서를 쓰는 느낌이라서 그렇다. 언젠가부터 다시 글을 쓰긴 할텐데, 커리큘럼들을 그냥 공유해 두고 있는 게 마음이 편할 것 같아 이번 글에서는 계획해 두었던 커리큘럼을 털어놓으려고 한다. 17챕터까지의 내용을 정리하고, 앞으로 계획하고 있는 내용들을 정리하겠다. 17챕터까지의 내용 개요 컨텐츠의 시작을 알리는 이런저런 이야기를 했다. 버전 관리 시스템과 버전 관리 웹호스팅 서비스 결정 버전 관리 시스템과, 이러한 버전 관리 시스템을 사용하는 프로젝트를 지원하는 웹호스팅 서비스를 의사결정했다. 개발 프로세스 정립 이슈 관리, 작업 진행 방식, 작업의 제품 반영 과정과 같은 것들에 대한 규칙을 정리했다. API 설계 원칙과 직렬화 포맷 결정 API 설계 원칙과 직렬화 포맷을 결정했다. 사용자 인증 방식 결정 리소스가 특정 사용자에게 귀속되는 서비스라면 꼭 필요한 사용자 인증 방식을 결정했다. API 스펙 설계와 문서화 방식 결정 API 스펙 설계를 위한 가이드라인을 일러두고, 실제로 API 스펙을 설계했다. 프론트엔드 팀에게 전해줄 문서를 작성해야 하므로, API 문서를 어떤 식으로 작성하고 관리할지 결정했다. 어플리케이션 기술스택 결정과 Hello World 서버 작성 어플리케이션 레벨의 기술스택을 결정하고 Hello World 서버를 작성했다. 의존성 관리 도구 결정 의존성 관리 도구를 결정했다. Compute Engine 결정과 Hello World 서버 배포 서버를 실행할 위치인 Compute Engine을 결정하고 Hello World 서버를 배포해 봤다. 데이터베이스 선정과 인스턴스 시작 서비스 운영을 위한 메인 데이터베이스를 결정하고, AWS 위에 해당 데이터베이스 엔진을 사용하는 인스턴스를 띄워 봤다. 배포 자동화 배포 자동화에 대한 의사결정을 하고, 실제로 배포 자동화를 구성해 봤다. 어플리케이션 레벨 의사결정 코드를 작성하는 데에 있어서 판단의 기반이 될 의사결정을 진행했다. 웹 어플리케이션 개발 웹 어플리케이션 개발에 있어서 몇 가지 &#39;일러두기&#39; 설명을 했다. 웹 어플리케이션 개발 과정 회고 웹 어플리케이션 개발 과정을 회고했다. 테스트에 대한 이야기와 의사결정 테스트에 대해 이야기하고, 테스트 프레임워크에 관해 의사결정했다. 테스트에 대한 고민 테스트를 작성하며 생길 수 있는 고민들을 미리 이야기해 봤다. RDS 인스턴스에 새로운 Security Group을 만들어 연결하기 Security Group이라는 것을 미리 알아두기 위해, 언젠가는 마땅히 했어야 할 Security Group 관련 설정을 진행해 봤다. RDS에서 돌아가고 있는 MySQL에 아무도 접근할 수 없게 만들었다. 앞으로의 내용 Local DB에 관한 작업 테스트 코드는 Production DB에 영향을 주지 않아야 하므로, 테스트 코드 실행 시 항상 로컬의 MySQL을 사용하도록 한다. 어떻게 하면 DB Host에 관해 개발자가 실수할 일이 없는 환경을 만들 수 있을지 고민해 본다. 테스트가 성공했을 때만 배포하게 하기 CI에서 배포하기 전에 테스트를 수행하도록 만들고, 테스트가 성공했을 때만 배포하게 해 본다. 테스트 코드가 항상 로컬의 MySQL을 사용하도록 했으니, 테스트 실행 전에 MySQL을 로컬에 띄우도록 해 본다. unit test에 대한 고민 API test를 통해 간접 테스트되는 함수들을 그대로 내버려두는 게 맞는 것인지 정말로 mock을 사용해 unit test를 작성하는 게 국룰인지 integration test를 중점적으로 테스트를 작성했을 때의 장단점을 살펴보며 의사결정을 하고 state verification, behavior verification과 함께 mock, stub, fake와 같은 test double에 대해 이야기 테스트할 수 없는 코드는 없다 API 서버라고 API만 테스트할 이유가 없으니, 테스트를 바라보는 여러 관점에 대해 이야기 testability, DRY한 코드를 작성하라고 그렇게나 강요하는 이유에 대해 이야기 CI 워크플로우 다듬기 PR이 올라가면 테스트를 수행하게 하기 테스트가 성공하지 못하면 merge가 불가능하게 두기(branch protection) 배포할 땐 테스트하지 않게 하기 : PR용과 merge용으로 CI Job을 별도로 구성 vs buildspec에서 if문을 써서 처리하기 저장소 다듬기 테스트 커버리지 시스템 연동하기 코드 퀄리티파이어 추가하기 Black 적용하기 저장소 다듬기 2 fork해서 작업하는 워크플로우 구성하기 pull request에서 리뷰어의 approve가 없으면 merge할 수 없게 하기 스키마에 대한 고민 hard delete와 soft delete created_at과 updated_at 스키마 관리에 대한 고민 Liquibase 스키마 변경을 어떻게 기록할 수 있을까? 릴리즈 준비 배포된 어플리케이션의 API 호출해 보기 : DB 접근 권한 문제로 에러가 날 것. WAS용 security group을 생성하고 해당 security group을 DB inbound로 허용한 후, zappa_settings.json에 security group에 관련된 내용을 설정 zappa certify로 도메인을 달기 DDL에 관한 이야기 : SQLAlchemy에서 제공하는 테이블 생성 메소드를 사용할지, 별도의 DDL을 export해서 사용할지 등에 대해 의사결정 예민한 데이터를 Amazon SSM으로 관리하기 Amazon SSM의 Secrets Manager로 예민한 데이터를 관리하기 시작한다. 위험한 쿼리가 허용되지 않은 유저 만들기 개발자들이 개발 용도로 사용하는 유저는 DROP Table같은 위험한 쿼리를 하지 못하게 해야 한다. 권한이 잘 설정된 유저를 만들어 본다. 개발용 서버를 따로 두기 막 붙이면서 테스트할 수 있는 환경이 필요하다. CORS 적용하기 CORS를 적용한다. 프론트엔드 배포 돕기 S3 upload, 이에 관한 CI 세팅 cloudfront 세팅 S3 bucket에 직접 접근하는 것에 대한 restricting 저장소 다듬기 3 README.md에 빌드 상태, 테스트 커버리지, 코드 퀄리티, black에 대한 badge 달기 Issue Template, Pull Request Template 추가하기 CONTRIBUTING.md 추가하기 파일 업로드 다듬기 스토리지 서비스와 CDN을 사용하기 IAM Role 잘 다루기 Zappa가 자동으로 생성한 role 말고, 별도로 role을 생성해 달아주기 Lambda 배포 시 생기는 다운타임 문제 해결하기 Lambda에 새로운 버전의 함수가 배포되면 cold start에 의해 다운타임이 생기곤 한다. alias를 이용해 이러한 문제를 해결하는 방법을 이야기한다. DB에 read 전용 replica 두기 master/slave나 primary/secondary같은 분류의 범주에 들어가는, read replication을 해 본다. DB Access하는 로직을 별도로 분리하기 WET한 코드를 줄이기 위해 로직을 분리하기 시작한다. Repository Pattern과 DI를 적용하기 분리한 비즈니스 로직을 repository화 하고, Dependency Injection 구조를 사용해 비즈니스 로직을 테스트하기 좋게 만든다. DAO, DTO, DO, marshal과 같은 개념을 살펴본다. JWT 로직을 개선하기 identity는 어떻게 생성해줘야 할 지, blacklisting은 어떻게 해야 할 지, refresh 정책은 어떻게 두어야 할 지 등을 결정한다. 로그 시스템과 사투하기 New Relic같은 별도의 SaaS APM을 쓸 지, 로그를 CloudWatch에 남겨서 ElasticSearch로 넘길지, Elastic APM을 써볼지 등등에 대해 의사결정한다. CloudWatch도 써 보고, Elastic APM도 써 보고, New Relic도 써 보고, ELK Stack도 써 보고, TICK Stack도 써 본다. 이것저것 써보는 동안 Grafana같은 걸로 로그 시각화도 한 번씩 해 본다. StatsD같은 로그 집계 프록시를 로그 파이프라인 사이에 끼워넣어 본다. 결론적으로 우리에게 가장 쓸만한 솔루션은 무엇일지 검토한다. API Scenario Test를 작성하자 Runscope를 통해 API 사용 시나리오를 작성하고, 일정 시간마다 실행되게 만들어 본다. Alert 연동하기 alert를 잘 도와주는 툴을 찾아 scenario test가 실패했을 때 나한테 전화가 오게 만들어 본다. Alert의 범위를 넓히기 그동안 구성해 뒀던 로그 시스템들에 alert policy들을 만들어 본다. 이것도 슬랙이나 전화 등의 창구로 alert을 받아볼 수 있게 해 본다. Queue와 Worker 이메일 전송과 같은 것들을 위해 worker를 만들어서 HTTP blocking으로 생기는 레이턴시를 줄여 본다. 시스템을 정리해 보기 front-end tier, back-end tier, data tier, monitoring tier로 나누어 시스템의 현재 상태를 정리해 본다. ECS로 인프라 이동하기 지금 API 서버가 Lambda로 만족스럽게 운영할 수 있는 상태인지 검토한다. 그렇지 않다고 가정하고, ECS를 위해 Docker와 친해져 본다. ECS로 인프라를 이동해 본다. space-time tradeoff in-memory caching을 이용해 API의 속도를 높여 본다. 테스트를 Docker Container에서 실행하기 MySQL과 같은 테스트를 위한 인프라도, 어플리케이션도 dockerize해서 잘 정의된 테스트 코드 실행 환경을 만들어 본다. Terraform 시작하기 Terraform으로 IaC를 시작해 본다. GitOps 시작하기 GitOps를 시작해 본다. Go 언어에는  gofmt 라는 도구가 있다. Go를 설치하면 기본적으로 제공되는  콘솔용 코드 포매팅 프로그램 인데,  gofmt -w main.go 같은 커맨드를 통해 Go 코드를 포매팅하는 식이다. indent 맞춰 주고, 구조체를 align 시켜주는 등 코드의 비주얼적인 개선 작업들을 한다. Visual Studio Code에서 Go extension을 설치하면,  파일을 저장할 때마다 gofmt를 실행 해 주어서 매우 편했었다. 이건 lint와 관련된 몇 가지 도구들을 더 쓰는지 unused import, variable같은 것도 지워준다.   파이썬에는  PEP 8 이라는  공신력 높은 코드 스타일 가이드 가 있으며,  unused import를 찾는 것과 같은 정적 검사 도 가능할테니, 이런 비슷한 걸 해주는 도구가 있지 않을까 싶었다. 이 글에서는  파이썬 코드 스타일 체킹과 포매팅 에 관련된 이런저런 이야기들과 함께 대표적인 도구들 몇 개를 간단히 소개하고, 이어지는 글에서는 내가 자주 쓰는  Black 이라는 도구를 소개하고자 한다. 코드 스타일! 코드 스타일?  코드 스타일 은 쉽게 말해  편집 규약 이다.  코드 컨벤션 이라고도 말한다. 어차피 코드를 기계가 읽을 때는 괄호 위치나 네이밍 컨벤션같은 것들이 결과에 영향을 끼치진 않겠지만, 사람이 더 잘 읽을 수 있게 배려하는 것이 좋다. 따라서 코드 스타일은  코드의 퀄리티를 측정하는 지표 가 되기도 한다. 코드 스타일은  통일 될수록,  대표적인 스타일을 사용 할수록 좋다. 파이썬을 사용하는 조직에서 별다른 코드 스타일 없이 마음대로 코드를 작성하는 것보다, PEP 8같은  스타일 가이드를 따르며 코드를 작성 하는 게 결과적으로  더 높은 퀄리티의 코드를 만들어낼 가능성이 높다. 사실 좀 귀찮다. 파이썬은 다행히도 언어를 만든 쪽에서 직접 코딩 컨벤션을 지정해 두었기 때문에, 취향 차이로 엇갈릴 일이 비교적 적다. 그러나 컨벤션에 따라  함수와 함수 사이에는 blank line을 두 개 둔다 거나, line length가 너무 길어지면  코드를 여러 줄로 나누어 작성한다 거나 하는 게 마땅히 해야 하는 일임에도 불구하고 사실 좀 귀찮다. 파이썬의 공식 스타일 가이드인 PEP 8에는 아래와 같은 것들이 명시되어 있다. indent는 4 spaces를 사용한다. 함수와 함수 사이에 blank line을 2개 둬야 한다. line length의 최대치는 79다. 각각의 import들은 comma로 연결하지 말고, 별도의 라인으로 나눈다. 다들 알만한 것들만 몇 개 가져왔지만 사실 이보다 훨씬 많은 스타일 가이드들이 명시되어 있다. 그런데 보통 컨벤션이라는 게  기계적으로 측정 가능한 것 들이 많아서, 따로 외우고 다닐 필요 없이 그냥  자동으로 검사해주는 도구 가 있을 법 하다. 코드를 체크만 해주는  style checker , 체크한 결과를 가지고 변경까지 해주는  formatter 로 나눌 수 있겠다. Code Style Checker  pycodestyle(pep8)  PEP 8에 명시된 스타일 가이드 를 기반으로  파이썬 코드를 체크 해서 알려주는 CLI 라이브러리다.  pep8 이라는 이름으로 더 많이 알려져 있다. 실제로 이 라이브러리는  pep8 이라는 이름으로 개발하기 시작해, 2016년에  귀도 반 로썸의 부탁 으로 이름을  pycodestyle 로 변경하여 개발을 지속하고 있는 상태다. usage는 아래와 같다.  pyflakes pyflakes는 pycodestyle처럼  파이썬 코드를 verification 해주는 툴인데,  스타일에 대한 검사가 제외 되어 있다.  error checker 에 더 가까울 수 있다고 볼 수 있는데, 예를 들면 아래와 같은 것들이다. import되었지만 사용하지 않는 라이브러리. ex) &#39;click&#39; imported but unused 정의되지 않은 이름. ex) undefined name &#39;res&#39; 스타일 체킹이 빠졌으니 일반적으로 pycodestyle처럼 스타일까지 체크하는 툴들보다 빠르다. usage는 아래와 같다. 이미 PyCharm같이 잘 되어 있는 IDE를 쓰고 있다면 IDE가 warning을 보여주는 것에 익숙해서 별 감흥이 없을 수도 있을텐데, vim같은 걸로  일반 텍스트 파일 수정하듯 파이썬 코드를 작성한다 고 생각하면 이게 왜 쓰이는지를 느낄 수 있을 것이다.  pylint  lint 라는 이름이 달린 툴답게 이런저런 방면에서 코드를 검사해 준다. usage를 보면 어떤 느낌인지 알 수 있을 것이다.  style checking ,  error checking ,  리팩토링과 관련된 조언 과 함께  코드에 점수 도 매겨 준다. 외부 의존성으로  syntax tree 를 위한  astroid , 알파벳 순서로  import를 정리 하는  isort ,  McCabe 복잡도 를 구현한  mccabe 만을 가지고 있는 것을 보아,  자체적인 lint 알고리즘 을 사용했다는 것을 알 수 있다. 설정을 customize할 수 있는 범위도 꽤 다양해서, IDE를 사용하고 있더라도 서드파티로 추천하고 싶다.  flake8  pycodestyle + pyflakes + 복잡도 검사 기능 이라고 생각하면 된다. pylint처럼 복잡도 검사를 위해  mccabe 를 사용하지만, style/error checking에 대해  pycodestyle 과  pyflakes 를 사용한다. 그냥  라이브러리 여러 개 묶은 wrapper  형태다. 아래는 usage다.  Exxx ,  Wxxx  형태의  pycodestyle 실행 결과 와  Fxxx  형태의  pyflakes 실행 결과 가 함께 보인다. 복잡도가 높은 부분이 발견되었다면, 해당 detection 정보가  C9xx  형태의 에러 코드로 보여진다. Code Formatter  autopep8  pycodestyle 의 결과를 기반으로  코드를 수정 해 준다. 그런데 개인적으로는 조금 더 적극적으로 formatting해주면 더 좋을 것 같았다. README.md에 적혀 있는  Usage  파트를 살펴보면 너무 보수적인 formatting 규칙을 알 수 있다.  yapf Google이 만든 formatter인데, autopep8처럼  특정 가이드라인 기반으로 lint error를 파악하고 이것을 제거 하는 것보단  &#39;시각적으로 좋아 보이는 코드&#39; 를 만드는 데에 주력한다. 정말 괜찮다고 느꼈는데, 아래와 이어지는 글에서 이야기할 black을 써보고 나서부턴 그냥 계속 black만 쓰고 있다.  black CPython의 개발을 주도하고 있는 파이썬 공식 organization인  Python 에서 개발한 formatter다. README에 black이  어떤 방식으로 코드를 포매팅하는지 직관적이고 쉽게 설명 되어 있고, black이 자동으로 파일들을 포매팅하도록 PyCharm에서 설정하는 방법이 제공되는 등  code reformatting 라이브러리에게 사용자가 무엇을 원하는지 잘 알고 있는 툴 처럼 느껴졌다. 필자의 환경 PyCharm에  File Watcher  플러그인을 설치해서,  파이썬 모듈이 저장될 때마다 black을 실행 하게 해 두었다.  README.md의 Editor integration 파트 에 잘 설명되어 있다. PyCharm에  pylint  플러그인을 설치해서 real-time으로 warning이 보여지게 해 두었다. 나는 보통 재능이나 공부의 양으로 친구들의 성장 속도를 따라가기 힘들었다. 그래서 &#39;무작정 열심히&#39;보단, &#39;의식적인 연습&#39;을 지속해 나가야 했다. 이득충이 되는 방향으로 공부를 하다 보니까, 내가 어떤 방식으로 공부를 하는 지 어느 정도 정리가 됐다. velog의 독자들은 &#39;경험기&#39;같은 글에 니즈가 꽤 있는 것 같아서, 부족하지만  내 공부를 위한 매개체 들을 쭉 소개하고,  내가 어떻게 공부하는지 를 짧게 이야기하고자 한다. 책 지식을 전달하는 책은 목차를 위주로 나는 취사선택을 좋아한다. 그냥 SQL  UNION  쿼리를 주제로 다룬 아티클만 해도, 온/오프라인에 셀 수 없이 많다. 책을 대하는 태도도 비슷한데, 아무리 유명하고 좋은 책이라고 해도 나랑 안 맞으면 그만이다. 그리고 보통 지식을 전달하는 내용이 위주인 책은,  목차만 보고 그대로 구글링해서 공부 하는 편이 취사선택에 유리했다. &#39;SQL 첫걸음&#39;이라는 책을 읽었을 때 효율이 좋았다. 새로운 걸 공부할 때마다 이 방법을 사용한다. 단, 희귀한 주제의 책에는 적용하기 어려운 경우가 조금 있었다. 경험적으로는, &#39;프로그래밍 언어론&#39;, &#39;객체지향의 사실과 오해&#39;가 그랬다. 그냥 재밌는 토픽은 밤마다 읽자 리팩토링, SQL Antipatterns, 알고리즘 도감처럼 그냥 재밌어 보이는 주제를 다루는 책은 밤마다 심심풀이로 읽기 좋았다. 엔지니어링 쪽은 보통 제목이 재밌으면 내용도 재밌는 경우가 많아서, 굳이 이리저리 조사하지 않고 그냥 사는 편이다. 온라인 Stackoverflow 주니어 입장에서 stackoverflow는 그냥  &#39;모르는 거 생기면 다 해결할 수 있는 곳&#39; 이다. 그만큼 지식이 많은 곳이라, 내가 좋아하는 태그 몇 개 가지고  가끔가다 한 번씩 검색 해 본다. 나도 답변할 수 있을만한 질문이 올라오면 종종 답변을 달기도 한다. 영어로 뭔가를 설명하는 것도 정말 좋은 경험이다. 습관적으로 들어가진 않고, 어쩌다 생각날 때 한 번씩 들어가 본다. Reddit  프로그래밍 서브레딧 에 정말 재밌는 글이 많이 올라온다. 프로그래밍이라는 카테고리도 주제가 굉장히 광범위해서, 특별히 어떤 지식을 얻기 위해서 보기보단 이런저런 요즘의 기술 이야기들을 보기 좋다. 출퇴근 길이나 식당에서 밥 기다릴 때 페이스북 대신 하는 느낌으로 들어가 본다. 유튜브 유튜브에는 개발을 주제로 한 유튜브 채널들이 생각보다 꽤 많다. 나는  Engineer Man 과  Nomad Coders 라는 채널을 구독하고 있다. 유튜브라는 플랫폼의 특성 상  파이썬으로 5분만에 스네이크 게임 만들기 같은 재밌는 챌린지들로 영상을 올리곤 한다. 어차피 자기 전이나 일 하다가 쉴 때마다 게임영상 보러 유튜브에 들어가는 거, 이런 것들도 한 번씩 섞어서 본다. 영어 리스닝에 도움이 되기도 하고, 그냥 한 번 보기 시작하면 재밌게 봐진다. Velog velog도 정말 여러 분야의 글이 한 곳에 모이는 플랫폼이며,  아두이노를 이용한 사볼콘 제작기 같이 재밌고 말랑말랑한 주제의 글이 트렌딩에 올라 잘 대우받는 곳이라서 reddit처럼 sns 하듯이 읽기 좋다. 좋은 글을 찾는 것에 대해 비용이 정말 적게 소모돼서 좋은 것 같다. 가끔 글 쓰러 들어올 때, 트렌딩에 올라와있는 글 몇 개씩 읽곤 한다.  44bits.io 프로그래밍과 클라우드 관련 글들이 올라온다. 좋은 글을 써낼 수만 있으면 누구나 기고할 수 있는 형태인 것 같다. 백엔드 편향적인 지식을 원하는 내게는 정말 그냥 필독 수준의 블로그다. AWS VPC, Docker, Terraform같이 이미 잘 쓰여진 글이 많은 주제를 가지고, 그들보다 훨씬 더 잘 써낸다. 글 올라오면 그냥 무조건 읽는다. feedly에 개인 블로그들 rss 모아놓기  feedly 는 rss 주소들을 넣어두면 그걸 계속 조회해서 최신 글 같은 것들을 정리해주는 툴이다. 나는 좋은 개인 블로그가 보이면 rss 주소 얻어서 여기다 모아둔다. medium같은 데서 유저 팔로우하는 것과 비슷한 논리다. 코드와 관련된 것들 미니 프로젝트 공부하고 싶거나, 만들고 싶은 게 생겼을 때 &#39;해야지&#39;하고 미루면 끝도 없다. 떠오르는 게 있으면 바로 미니 프로젝트를 해보는 편이다. 파이썬으로 스네이크 게임 만들기, Play 스토어 크롤러 만들기, Django로 게시판 서비스 API 만들어보기, Flutter로 조그만 가계부 만들어보기 등이 그 예다. 지식의 범위를 넓히는 데에 도움이 많이 된다. 모든 개체를 판단할 때는 그 개체를 공부해야 하므로, 좀 더 잘 알고 깝치기 위함이다. 클론 코딩 이미 나와 있는 서비스의 기획과 디자인을 베끼고, 구현은 내가 직접 하는 것을  클론 코딩 이라고 부른다. 결과물을 알고 있는 상태에서, 어떻게 개발되었는지는 모르니 내가  여태껏 배웠던 스킬들을 점검 하기에 정말 좋다. 넷플릭스를 클론코딩하는 과정에서 동영상 스트리밍을 MPEG-DASH로 구현했다고 치면, 내가 찾아낸 방법과 넷플릭스 팀이 찾은 방법은 아마 다르겠지만 나만의 방법을 찾아서 결과물을 만들었다는 걸 매우 보람차할 것이다. 나는 클론 코딩을 할 때, 정말 빡센 서비스 하나 잡아서 나를 많이 힘들게 만드는 편이다. 클론 코딩은 정말 실용적인 프로그래밍 공부 방법이라고 생각한다. 그러나 한 번 시작하고 나면 잘 끝내야 효과가 있고, 그렇게 되기까지 소모되는 자원이 많으므로 6개월에 한 번, 작업 시간 200시간 미만 정도의 서비스를 잡아서 해보는 정도다. 코드 리딩 당장 뭔가를 해결해야 하는 상황에서는, 라이브러리를 아무 생각 없이 가져다 쓸 때가 많다. 그러다가 튜토리얼 몇 번 보고 나서는 &#39;항상 쓰는 라이브러리&#39;로 굳혀지는 경우가 많았는데, 에러를 아무리 검색해도 안 나와서 디버깅을 걸고 라이브러리의 코드를 따라갔던 것을 시작으로 코드 리딩을 하기 시작했다. 보통  star 많은 라이브러리는 좋은 설계와 코드 베이스 를 가지고 있어서 배울 점이 정말 많다. 가끔 아무 것도 하기 싫을 때, 에디터 열어 놓고 대충 자주 쓰는 라이브러리 끌어다가 코드 쳐다보는 시간을 가진다. 정리 글 쓰기 블로그를 처음 시작했을 때는, 1일 1글이고 튜토리얼이고 하며 괜히 진부한 주제에다 글을 더 잘 써보려고 용쓰다가 시간 낭비를 너무 했었다. 예로, 파이썬에서 for문 다루는 건 10분이면 정리할 수 있는데, 그걸 글로 옮기려고 5~6시간을 썼으니 말이다. 게다가 그렇게 시간을 많이 쏟아도, 똑같은 내용을 더 잘 설명한 글은 차고 넘쳤다. 반대로 지금은 정말로 &#39;글로 써야겠다&#39;싶은 주제가 생각났을 때만 글을 쓰고 있다. 예로 얼마 전에는  파이썬으로 URL 가지고 놀기 라는 3편짜리 글을 쓰며, URL에 밀접한 관계가 있는 기능을 리팩토링하며 얻게 된 지식들을 정리할 수 있어서 좋았다. 선천적으로 글을 잘 쓰는 사람이 아니고서야, 적은 시간 내에 좋은 글을 쓰는 건 정말 오랜 시간동안 단련이 되어야 한다. 따라서, 글을 쓰는 건 보통  투자한 시간에 비해 공부의 양이 적다 고 생각한다. &#39;진짜 이 글은 써보고 싶다&#39;라는 생각이 들기 전에는 굳이 실행에 옮기지 않는 편이다. 삽질 정리 개발과 관련된 작업을 진행하다 보면 필연적으로 삽질을 한다. 그럴 때마다 그 주제들을 따로 어딘가에 적어두고, 자유시간이 있을 때 그들을 정리하는 편이다. 주제에 대해 좋은 글을 찾고, 읽고, 글 링크와 함께 한두 문장으로 내용을 정리한다. 삽질한 게 없으면 그냥 평소에 알고 싶었던 주제들을 공부해서 정리한다. 그렇게 만들어진 게  Let&#39;s Study 라는 저장소다. 나만의 TIL이라고도 할 수 있겠다. 내가 공부를 지속하는 방법 나는  챌린지 설정 - 공부 - 챌린지 수행 - 피드백 - 휴식  사이클을 짧게는 반년, 길게는 1년 정도마다 반복한다.  챌린지 설정  :  이번 사이클에서 할만한 챌린지 를 설정한다. &#39;React를 공부해서 풀스택으로 인스타그램을 클론코딩 한다.&#39;가 그 예고, 나는 보통  적당히 큼지막한 서비스의 클론 코딩 을 챌린지로 잡는다.  공부  :  챌린지를 더 잘 수행하기 위해 위해 필요한 지식  쌓기. 미니 프로젝트 진행, 책, 관련 글, 튜토리얼 읽어보기 등등. &#39;velog 클론코딩&#39;, &#39;미니 인스타그램 만들기&#39;처럼  챌린지와 연관된 미니 프로젝트 를 위주로 한다. 메인퀘스트 진행하기 전에 서브퀘스트로 경험치 채우는 느낌?  챌린지 수행  : 설정해 둔 챌린지 수행.  마음에 들 때까지  이 단계에서 계속 머물러 있는다.  피드백  : 프로젝트를 진행하며 새롭게 알게 된 것을 GitHub이나 블로그에 글로  정리 하고, 내  구현을 리뷰 받기  휴식  : 회사 밖에서는 마치 코딩이 단지 취미인 사람인 것처럼 살기. 길면 2~3달 씩도 쉬어준다.  지치지 않기 위한 번아웃 조절 이고, 뒤처지면 안 되니 reddit과 44bits.io에 올라오는 건 계속 읽어준다. 또한 이 사이클은  평소의 생활과 완전히 단절되어야 한다 는 규칙을 만들어서 지키고 있다. &#39;학교 다니느라, 프로젝트 하느라 못 한다&#39;라는 핑계를 대지 않기 위함이다. 학교 다니면서 프로젝트 하느라 바쁠 때는 그 만큼 사이클의 유지 시간을 길게 뒀고, 반대로 방학 기간이어서 쉴 때는 투자할 수 있는 시간이 많으므로 그 동안 사이클 하나를 돌리기도 했었다. 지금 나는 저 사이클 중  휴식  단계에 있다. 이전 글 :  파이썬으로 URL 가지고 놀기 - yarl 편 yarl은 immutable에 적극적이며 익숙한 개발자에게 urllib의 좋은 대안이 될 수 있는 라이브러리다. 그러나 나는 yarl이 그렇게나 까는 mutable 객체를 제공하는 라이브러리를 원했다. 아래와 같은 이유에서다. Python은 immutable에 민감한 언어가 아니다. 객체의 매 변화마다 새로운 객체의 copy가 생성되는 것(immutable)보다, 그냥 기존 객체에 변화가 반영되는 것(mutable)이  인식적인 입장에서 더 자연스럽고 쉽다.  예를 들면, 주유소에서 자동차에 연료를 채울 때, 해당 자동차의 연료 상태가 변화하는 것이 연료가 채워진 새로운 자동차가 생성되는 것보다 더 자연스럽다. 객체의 상태(state) 변화는 실수를 일으키기 쉬우며, 동시성 위에서 버그가 잦다는 것, 그리고 게임 캐릭터와 같은 복잡한 객체가 아니라면 객체 copy에 큰 비용이 소모되지 않으므로 immutable이 더 일반적이라는 것을 인정하지만 그냥 mutable이 쓰기 더 편할 것 같았다. 기술적으로 더 합리적인 라이브러리가 아니라  그냥 더 편한 라이브러리를 찾는 과정 이었기 때문이다. 길은 가까이에 있었는데, yarl이 &#39;우리랑 비슷한 건데 얘는 immutable이 아니라서 우리가 더 나아요&#39;하는  furl 이었다. furl 설치  $ pip install furl Quickstart 아래는 URL에 path와 query parameter를 추가하는 예제다. furl도 URL의 요소를 쪼개는 형태는 yarl과 비슷하니 이야기하지 않겠다. .copy()  copy()  메소드는 새로운 furl 객체를 만들어 반환한다.  copy 와 함께 in-line modification 메소드인  add ,  set ,  remove 도 사용해 보겠다. 결론 yarl은 immutable에 익숙해지기만 한다면 충분히 편하게 쓸 수 있는 라이브러리다. furl은 문서화가 비교적 직관적으로 잘 쓰여져 있고, 당장 쓰기 편했다. 추가적으로, yarl과 furl의 소스 코드는 정말 배울 점이 많아 보인다. 시간 있을 때 한 번쯤 읽어봐도 좋을 것 같았다. 이전 글 :  파이썬으로 URL 가지고 놀기 - urllib.parse 편  urllib.parse 와 함께한 시간은 너무나도 힘들었다. 다른 건 다 봐줄 만 한데, query string을 다루는 건 너무나도 비직관적이었다. 그렇게 찾아낸 게  yarl(Yet another URL library) 였다. yarl 설치  $ pip install yarl Quickstart  URL  클래스가 모든 작업의 시초가 된다. URL의 각 요소들을 쪼개는 방식은 urllib과 매우 유사하다. manipulation yarl은 기본적으로  immutable을 지향 한다. 따라서 모든 수정 작업은  새로운 URL 객체를 반환 하게 되어 있다. 요약 urllib이 가지고 있는 immutable 개념을 유지하면서, 기능을 잘 확장해  &#39;더 편한 urllib&#39;  느낌이 나게 설계되었다고 생각한다. 그러나 언어 자체가 immutable에 민감한 것도 아닌데  이렇게까지 immutable을 고집할 필요가 있나  싶었다. 내가 프로그래밍에 경험이 많지 않아서 든 생각일 수도 있겠지만, 이 이유 때문에 yarl에는 그렇게 정을 붙이지 못했다. 나는 조금 더 편하길 원했고, URL을 다루는 것에 대해 좋은 아이디어를 가지고 있는 사람이 한두명으로 끝나지 않을 것 같았고, 무려 &#39;URL&#39;을 다루는 라이브러리라면 star가 1000개 넘는 것도 분명 있을 것 같았다.  파이썬으로 URL 가지고 놀기 - furl 편 으로 이어진다. 내가 일하고 있는 업계(Marketing Tech)가 URL을 많이 다루는 곳이라서 그런지,  URL에 query string 추가 는 어떻게 해야 되는지,  어떻게 path 부분만 예쁘게 떼낼 수 있을지 같은 것들을 고민하게 된다. urllib을 보면서, 아래같이 Pythonic하게 URL을 다룰 수 있으면 좋을 것 같다고 생각했다. 직접 만들자니 아무래도 URL이라는 게 꽤 예민하다 보니까 간단한 일이 아니기도 해서, urllib으로 URL을 다루면서 불편하지만 참았던 경험, 관련 라이브러리를 이것저것 찾아서 써본 경험도 공유하고자 한다. 참고로,  urllib의 사용법 보단  URL을 더 잘 다루기 위해 고민 한 것들이 글의 내용을 이룰 것이므로 튜토리얼이 필요하다면  urllib 라이브러리 라는 글을 읽어보기 바란다. urllib.parse urllib은 파이썬 표준 라이브러리 중 하나다. HTTP 요청, 파싱과 관련된 하위 패키지들이 존재하며, URL 파싱과 관련된 것들은 거의 다  urllib.parse 에 들어 있다. Python 2의  urlparse 가 옮겨진 것이다. urlparse, urlunparse urlparse  urlparse 는 URL을 6개의 요소로 이루어진  namedtuple 로 만들어 반환한다. 정확히는,  URL을 다루기 위해 만들어진 namedtuple 을  상속받아 정의 한  ParseResult 의 객체다. namedtuple 특성 상  프로퍼티들은 기본적으로 immutable 이고, 값을 변경하려면  _replace 를 사용해서  새로운 프로퍼티가 반영된 새로운 객체 를 반환받아야 한다. urlunparse  ParseResult 를 다시 URL로 만드려면,  geturl  메소드나  urlunparse 를 사용하면 된다.  ParseResult.geturl = lambda self: urlunparse(self) 라고 보면 된다. query string 바꿔치기  _replace 를 쓰면 프로퍼티를 변경할 수 있다. 그러나 query string은  sort=name&amp;keyword=planb 와 같이 문자열 형태로 이루어져 있기 때문에, query string 중  sort 를  like 로 변경한다거나 하는 작업이 쉽지 않다.  urllib.parse 에는  query string을 파싱해서 collection으로 반환 해주는  parse_qs 와  parse_qsl  함수가 있다.  parse_qs 는 key에 대해  value들을 list로 묶어서 dictionary로 반환 하고,  parse_qsl 은  key-value pair 각각을 tuple로 만들어서 list로 반환 한다. 그냥 납작한 딕셔너리로 관리하지 못하는 이유는, query string의 key가 표준에 의해서  중복이 허용 되기 때문이다.  urllib.parse 를 통해 URL에서 query string의 수정 작업을 진행하려면, 아래와 같이 코드를 작성해야 한다. 요구되는 코드 양이 파이썬 치고 그렇게 적은 편은 아니었어서, 나랑 똑같은 불편함을 겪는 사람이 그 불편함을 참지 못해 만든 라이브러리가 있을 것 같았다.  파이썬으로 URL 가지고 놀기 - yarl 편 으로 이어진다.  abc 는 Python 2, 3 모두에서 사용할 수 있는 파이썬 표준 라이브러리 중 하나다. abc는  Abstract Base Class 의 약자인데, 말 그대로 객체지향에서의  abstract  개념을 파이썬에서 잘 사용할 수 있도록 도와준다.  PEP 3119 에서 2007년 4월에 최초 제안되었다. Java의 추상 메소드 이야기 OOP를 내세우는 언어들은 보통  추상 메소드 가 있다. 나는 Java가 편하므로 Java를 예로 들겠다.  abstract 가 명시된  추상 메소드를 가진 추상 클래스 , 혹은  인터페이스 를 상속받은 일반 클래스는, 해당  추상 메소드를 모두 override하지 않으면 에러가 발생 한다. 객체지향 5원칙인 SOLID 중 L인  리스코브 치환 원칙(LSP, Liskov Substitution Principle) 에게 필요한 개념이다 뭐다 이런 이야기들을 하는데, 구체적인 것들은 이 글의 주제를 벗어나므로 직접 알아보기 바란다. Python에서 추상 메소드 표현하기 abc 없이 하기 Python에는  abstract  키워드와 같은  언어 레벨의 추상 메소드 표현법이 따로 없다.  abc가 세상에 널리 알려지기 전까지는, 추상 메소드를 표현하기 위해 메소드의 body에  raise NotImplementedError 를 두는 방법을 사용하곤 했다. 대표적인  old-school way 이며, abc를 사용하는 것에 비해 허점이 많다. abc의 도움을 받기 기본적으로,  NotImplementedError 를 사용하는 방식은  엄격하지 않다.  추상 메소드를 구현하지 않더라도, 메소드를 실제로 호출하기 전까지는 알아차릴 수 없다. 추상 메소드와 관련된  에러를 raise하는 시점이 런타임 이라는 것이다. 만약 인스턴스화 시점, 클래스 정의 시점, 컴파일 타임 등 이보다  더 상위의 시점에 추상 메소드의 구현 여부를 확인 할 수 있다면 더 좋을 것이다.  abc.ABC 를 상속받고, 원하는 메소드에  abc.abstractmethod  데코레이터를 달아주면 된다. collections.abc 또 다른 표준 라이브러리인  collections 의 서브 모듈  collections.abc 에서 abc를 잘 쓰고 있다. 이 모듈은  어떤 클래스가 특정 기능을 지원하는지 여부 를 테스트하는 데 써먹을 수 있는 추상 클래스를 제공한다.  hashable, callable 여부  등을 예로 들 수 있다. 이런저런 복잡한 것들을 제외하고 쉽게 왜곡해 설명하면, 메타클래스로  abc.ABCMeta 를 상속받은 클래스를 비교 대상으로 하여  isinstance  호출 시  __subclasshook__  메소드가 그 결과를 결정하게 된다. 예제로 살펴보자. Go의 defer  A Tour of Go 를 통해 처음 Go언어를 배우면서 재밌었던 부분은  defer 였다.  defer [statement]  형태로 사용하며, 여기에 정의해 둔 statement는  함수의 call stack이 사라지는 시점 에(쉽게 말하면,  함수가 종료되기 직전 에) 평가된다. 아래 코드는 텍스트 파일을 열고, 이 파일을 닫는 함수 호출을 defer하고, 파일의 내용을 print한다.  defer 한  f.Close 를 그냥 함수의 맨 마지막 라인에 둬도 상관 없지 않을까 싶겠지만, 이는 마치 예외 처리를 위해 보통 쓰이는  try 의  finally 절과 비슷한 역할을 한다. defer절 자체에 문제가 없다면,  그 아래에서 에러가 나더라도 이는 실행 된다.  defer 는 위의 경우처럼  자원을 해제하는 코드의 실행을 안정적이게 만드는 데에 유용 하다. Python의 defer Python에서도 defer를 사용할 수 있다. 가장 유사한 것은  contextlib.ExitStack 이라고 생각하는데, 여기까지의 흐름을 부드럽게 하기 위해  with 문의 구조를 이용해 defer를 표현해 보기도 할 것이다. 유사한 것 : with문  with 문은 해당 블럭에 들어갈 때 전달된 객체의  __enter__() 를 호출하며 해당 함수의 리턴을  as [name]  부분에 명시된 이름에 바인딩하고, 블럭이 종료될 때 종료의 사유가 어떻든  __exit__() 을 호출한다. 이러한 magic method들이 정의되어 있어  with 문이 정상적으로 흐름을 관리할 수 있는 객체를 파이썬 세계에서  context manager 라고 부른다. 무의미하지만 간단한 코드를 통해, context manager를 대충 살펴보자. 위 코드를 실행하면, &#39;enter&#39;, &#39;hi&#39;, &#39;exit&#39; 순서로 출력된다. 만약  ContextManager  클래스가  인스턴스 변수로 콜백들을 관리 하고,  __exit__() 에서 실행하게 한다면 대충 defer같은 구조를 만들어볼 수 있다. &#39;before exit&#39;, &#39;exit called&#39;, 1, 2가 순서대로 출력된다. contextlib.ExitStack  contextlib.ExitStack 은 context manager이며, 위에서 시도해 본 callback같은 구조를 자체적으로, 그리고 안정적으로 구현해 두었다. 이런저런 기능들이 많지만, 여기서는 callback에 관한 예제만 첨부한다. &#39;done&#39;, 9, 8, 7, 6, 5, 4, 3, 2, 1 순서로 출력이 진행된다.  PEP 570 -- Python Positional-Only Parameters 에서는  Positional-Only Arguments ,  Keyword-Only Arguments  개념이 제언되었다.  Accepted  상태지만 Python 3.0부터 3.7까지 Keyword-Only Arguments만이 반영되어 있다. 이건 파이썬에서 함수의 인자 형태를 구분하는 방식을 이해하고 있으면 더 알기 쉽다. Python에서 함수의 인자 구분 함수를 정의하는 입장 함수를 정의하는 입장에서, 인자는  필수(required) 인자 와  선택(optional) 인자 로 구분할 수 있다. 두 인자의 차이는  기본값 정의 유무 이며, 파이썬 인터프리터에서는 이들을 각각  non-default argument ,  default argument 라는 어휘와 섞어 사용한다. step 만큼의 공차를 가진, start부터 end-1 사이의 등차수열을 만들어 리스트로 반환하는 함수다. print문 부분을 보면 이해가 더 쉽다. 아무튼, 여기서  range_list  함수의 인자 3개를 구분해 보자. start : 필수 인자(non-default argument) end : 필수 인자(non-default argument) step : 선택 인자(default argument) 함수를 호출할 때 필수 인자를 모두 채우지 않으면  TypeError 가 발생한다. 여담으로, 선택 인자를 필수 인자 앞에 정의하면  SyntaxError 가 발생함에 주의해야 한다. 함수를 호출하는 입장 이번 글의 핵심은 이 부분인데, 함수를 호출하는 입장에서 인자는  위치(positional) 인자 와  키워드(keyword) 인자 로 나뉜다. 함수가  인자를 정의하는 부분에 문법적인 추가 작업 을 하지 않았다면, 함수 호출자는 두 가지 방식으로 인자를 전달할 수 있다. 값을 전달할 인자의  이름을 별도로 명시 한다면  키워드 인자 ,  명시하지 않는다 면  위치 인자 라고 구분하면 된다. 일반적인 함수에 인자를 전달할 때는  위치 인자와 키워드 인자 형태를 마음대로 사용 할 수 있는데,  PEP 570은 이를 강제하는 문법 을 제언한다. X-Only Arguments Positional-Only Arguments PEP 570에서는  /, 라는 문법을 통해 positional-only를 명시할 수 있도록 제안하고 있다. 실제로 Python 언어 스펙에 반영되어 있는 것은 아니라서 아래의 함수 정의문은  SyntaxError 가 발생하지만, 문법적으로 가능하다고 가정한 채 예제를 작성해 보겠다. Keyword-Only Arguments PEP 570에서는  *, 라는 문법을 통해 keyword-only를 명시할 수 있도록 제안하고 있으며, 이는 실제로 Python 언어 스펙에 반영되어 있다.  *   앞의 것들은 positional-or-keyword ,  뒤의 것들은 keyword-only argument 를 의미하게 된다. 참고로, X-Only Arguments는 단지 hinting만이 아니며 추가적인  문법적 제약을 명시하는 것 임을 알고 있어야 한다. 아래처럼, type hinting은 무시해도 되지만 X-Only Arguments 제약은 무시하면 에러가 발생한다. 테스트 코드와 관련된 챕터에 글을 쓰고 나서, 거기서 얘기한 테스트 코드를 모두 작성한 뒤에 챕터를 진행하려고 했더니, 평일에 하루종일 코딩하다 집 들어와서 다시 코딩해야 하는 상황이라 너무 진행이 되질 않습니다. 따라서, 이제부턴 테스트 코드 작성과 챕터 진행을 동시에 진행하려고 합니다. AWS에서 인스턴스 기반으로 움직이는 요소(EC2, RDS 등)들은 기본적으로  보안 그룹 이라는  가상 방화벽 이  인바운드/아웃바운드 트래픽을 제어 해 준다. 이걸 대충 배워서, 새로운 Security Group을 만들고 RDS 인스턴스에 할당해 보자. 이 귀찮은 일을 하는 것에는 많은 이유가 있다.  우리가 작성한 테스트는, 저번에 이야기했던 대로 테스트 메소드 하나가 종료될 때마다 모든 테이블에 대해  DROP TABLE 이 실행된다.  16챕터  때 이야기했던 것처럼, 개발자가 그냥 아무 생각 없이 production DB를 쓰도록 설정을 바꾸고 돌려버리는 경우에 확실한 대비책이 없는 현재의 상태를 커버해야 한다. 물론 코드 상에서 원격 DB config 클래스는 데이터베이스 연결 정보(user, password, endpoint 등)를 환경 변수에서 가져오고 있어서( 코드 ), 이들이 모두 설정되어 있지 않은 환경에 대해서는 방어할 수 있겠으나 나중에 이 코드가 어떻게 될지 모르기 때문에 안심할 수가 없다.  원치 않는 주체의 트래픽을 아예 차단 해버리는 것이 더 낫다고 생각한다.  RDS는  데이터베이스를 생성하면서 Security Group도 자동으로 생성 하는데, 여기에 유일하게 인바운드 트래픽이 허용되어 있는 대상은  생성자 본인의 IP 밖에 없다. 따라서 지금은  Lambda로 배포된 우리의 WAS가 RDS에 접근할 수 없는 상태 다. 이번 챕터에선 WAS의 RDS 접근과 관련된 부분들까지 다루지는 않겠지만, 이번 챕터에서 쌓일 Security Group에 대한 아주 기본적인 지식이, 추후 서비스 릴리즈와 관련된 챕터를 진행할 때 도움이 될 수 있도록 판을 깔아두기 위함이다.  Security Group을 사용하면 우리가  명시한 요소의 트래픽만을 허용 할 수 있다. 잘 설정해 둔다면, 데이터베이스 연결 관련 정보가 탈취되었더라도 조금이나마 안심할 수 있다.  인바운드엔 IP만이 아니라 Security Group도 넣을 수 있어서, Security Group을 잘 정리해 두면 나중에 써먹기 좋다.  API 라는 이름의 Security Group을 만들어 두고, Security Group  DB 에서  API 를 인바운드로 허용하는 등을 예로 들 수 있다.(이 부분은 지금 이해하지 못해도 상관없는 내용이고, 위에서도 말했던 것처럼 릴리즈와 관련된 챕터를 진행할 때 다시 이 내용을 풀어서 설명할 예정이다.) 새로운 Security Group을 만들어서 바꿔치기 자동 생성된 Security Group 확인하기 우리가 과거에 만들었던 RDS 인스턴스를 선택하면 나타나는 대시보드에서  &#39;연결 &amp; 보안&#39;  탭의  &#39;보안&#39;  섹션을 보면,  &#39;VPC 보안 그룹&#39; 이라는 요소에 RDS가 데이터베이스를 생성하며  자동으로 생성한 Security Group 이 보일 것이다.   링크를 클릭하면, EC2 관리 콘솔의  &#39;보안 그룹&#39;  탭으로 리다이렉트된다.  sg- 로 시작하는 그룹 ID, 아마도  rds-launch-wizard 라는 그룹 이름을 가진 Security Group이 보일 것이다. 우리가 주목해야 할 것은 아래쪽에 보여지는 추가 정보들인데,  &#39;인바운드&#39;  탭을 클릭해서 현재 상태를 확인해 보자.    본인의 IP 가  유일한 인바운드로 허용 되어 있을 것이다. 만약 내가 개발을 진행하다가 실수로 production DB 정보를 가지고 테스트 코드를 돌리게 된다면, DB 날아가고 아주 난리가 날 것이다. Security Group 새로 생성하기 자동으로 생성된 Security Group은, 이름이 너무 명시적이지 않다.  rds 라는 키워드는 들어갔지만, 조금 더 확실한 이름이 좋을 것 같다. 그러나 사실 한 번 생성된 Security Group은 이름을 바꿀 수가 없어서, 새로 만들어야 한다.  &#39;보안 그룹 생성&#39;  버튼을 클릭하고, 이름과 설명 정도를 기입한 뒤  &#39;생성&#39;  버튼을 누르자. 나는  RDB 라는 이름으로 생성하려고 한다.   새롭게 생성된 Security Group을 눌러보면,  인바운드 룰이 하나도 설정되지 않은 것(기본 상태) 을 확인할 수 있을 것이다.   DB 인스턴스에서 Security Group 바꿔치기 이제  RDS Console 에 들어가서,  DB 인스턴스 대시보드 에 접속한 후,  &#39;수정&#39;  버튼을 눌러 인스턴스 수정 페이지에 접속해  새로 생성한 Security Group을 연결 시켜 주자.   자동 생성된 Security Group인  rds-launch-wizard 와, 이를 대신하기 위해 생성한 Security Group인  RDB 가 동시에 연결될 것이다. 말했던 대로  rds-launch-wizard 를  RDB 로 대신하고자 하니,  기존에 연결되어 있던 Security Group을 해제 하자. 아래 캡처와 비슷한 모습이어야 한다.   아래로 쭉 내려가서  &#39;계속&#39; 을 누르고, 수정 사항을 확인한 뒤  &#39;DB 인스턴스 수정&#39;  버튼을 누르자. 그러고 나면, 아래처럼 Security Group 설정 변경이 진행되며,   조금 기다리면 성공적으로 Security Group 바꿔치기가 완료된다.   Security Group의 정상 작동을 확인하기 이제 우리가 새로 생성한 Security Group이 잘 동작하는지 확인해 보자. 가장 쉬운 방법은  인바운드에 내 IP를 허용 한 다음  DB에 접속 해 보는 것이다. Security Group 관리 콘솔로 들어가서,  인바운드에 본인의 IP를 허용 하자. 인바운드 규칙을 편집하는 창을 띄우고, 다른 것들 건들 거 없이  &#39;소스&#39;  컬럼의 드롭박스를 열면  &#39;내 IP&#39; 를 선택할 수 있게 되어 있다.   해당 항목을 클릭하면 IP가 알아서 기입된다.  &#39;포트 범위&#39;  컬럼에 MySQL의 기본 포트 번호인  3306 을 입력하고,  &#39;저장&#39;  버튼을 눌러 새로운 인바운드 룰을 적용하자. 먼저  인바운드 설정이 잘 적용되었는지 확인 하고,   DB에 접속해보자. 연결 정보를 까먹었으며 챕터를 착실히 따라왔다면, Lambda Management Console에 접속해 우리가 배포한 Lambda를 확인해 보자. 이전에 데이터베이스 연결 정보를 환경 변수로 넣어두었을 것이다. MySQL 클라이언트는 입맛대로 사용하자. 나는 평소에  DataGrip 을 사용하는데, 지금 글을 쓰고 있는 데스크탑에는 설치되어 있지 않으니 예전에 설치해 뒀던  MySQL Workbench 를 사용할 것이다. MySQL Workbench에 있는  &#39;Test Connection&#39;  기능을 통해 연결이 잘 되는 것을 확인했다.   이제 Security Group  RDS 에서 인바운드 룰을 제거하고, 다시 연결을 시도해 보자. 연결에 실패해야 한다.   rds-launch-wizard 걷어내기 드디어  자동 생성된 Security Group을 제거해도 되는 상태 가 되었다. 기존에 RDS에 연결되어 있던 Security Group을 선택한 후  &#39;작업&#39;  드롭박스를 열고,  &#39;보안 그룹 삭제&#39;  버튼을 눌러 제거해 주자.  별도의 경고 없이 삭제 확인 버튼이 활성화되어 있는 상태 여야 한다.   만약  삭제하려는 Security Group이 아직 어딘가에 연결 되어 있는 상태라면, 어디에 연결되어 있는지의 정보와 함께 삭제 버튼이 활성화되지 않는다. Security Group  RDB 를 삭제하려고 시도해 보면 알 수 있다.   삭제까지 완료되었다면, 나름대로의 레거시 하나가 청산된 것이다. 기본 Security Group과 함께 두 개의 Group만이 남아 있게 된다.   마음에 들도록 Security Group을 재할당했으므로 이제 여기에 필요한 인바운드 룰들을 세팅해 두면 되는데, 당장 RDS에 인바운드 트래픽을 열만한 주체는 WAS 정도밖에 없다. 그러나 이 부분은 위에서도 말했듯 나중에 이야기해보도록 하고, 지금 당장은 누구에게도 인바운드 트래픽을 허용하지 않은 상태로 둔 채 다음 챕터로 넘어가자. 원래 type hinting을 주제로 글을 쓰려다가, 타입 추론에 대해 글을 써내려가다 보니 이거 하나만으로도 글 하나가 대충 완성될 것 같았다. 그래서 이번에는 그냥 타입 추론 이야기를 해보려고 한다. 타입 추론 Python은 타입 검사가 동적이기 때문에,  모든 타입이 컴파일 타임이 아니라 런타임에 결정 된다. 컴파일 타임에는  세 변수 모두 타입을 모르는 상태 였다가, 코드가 실제로 실행되는  런타임에 statement들이 하나씩 해석 되며  a 는  int 로,  b 는  str 로,  c 는  float 로 추론된다. 타입 추론이 가능한  JavaScript 나  Kotlin 같은 언어에서 변수의 선언문 앞에 붙이는  var ,  val ,  const 같은 변수 선언용 예약어가 없다는 점이 특징인데, 이 때문에  초기값 명시 없는 변수 선언이 불가능 하다. 예를 들어 JavaScript의 경우, 아래와 같이  변수의 선언 과  초기화 를 두 개의 독립적인 statement로 나눌 수 있다. 그러나 Python은 초기값 없이 변수를 선언하는 것이 불가능하다. 그래서  &#39;변수가 선언되었으나 초기화는 되지 않았다&#39; 를 표현하기 위해,  None 을 초기화 값으로 사용하곤 한다. 사실 JavaScript도 정의만 해 둔 변수는 자동으로 초기값이  undefined 로 들어가는 것을 생각하면 이와 비슷한 맥락이기는 하다. Python은 초기값을 자동으로 넣어준다는 일이 불가능한데, 이는  a 가 변수 선언식임을 확정지을 수 없기 때문이다. 조금 더 풀어서 설명하자면, JavaScript의  var a; 에는  var 라는  변수 선언을 위한 예약어 가 있기 때문에 컴파일러가 당연히  변수 선언에 관한 instruction 을 수행할테고,  &#39;초기값이 없으니 undefined로 채운다&#39; 라는 논리까지 수행하도록 언어의 스펙을 만들어낼 수 있게 된다.  초기값 명시 없는 변수 선언 이 가능한 것이다. 그러나 Python의  a 는 이게  변수 선언 을 의미하는 것인지, 어딘가에 선언되어 있을  a 에  접근하는 expression 을 의미하는 것인지를 판단할 수 없으니, 초기값 명시 없이 변수를 선언하는 것이 불가능한 것이다. 사고방식의 전환 나는 파이썬을 하기 전까진 Java를 했었는데, 파이썬을 시작하고 나서 가장 까다로웠던 게 클래스였다. 그 이유는 Java와 파이썬이 인스턴스 변수를 다루는 방식이 달라서였는데, Java의 예는 다음과 같다. 클래스에서 사용할  인스턴스 변수를 class level 에 미리 정의해놓고,  this 로 접근하는 방식이다. Python에서는 아래처럼 작성한다. class level에 무언가를 따로 정의해두지 않았음에도 불구하고,  self 에 잘 들어간다. 이는 파이썬에서 모든 객체가  dynamic attribute 기 때문에 가능한 일이다.  16. 테스트에 대한 고민 - (1) 에서 이어집니다. 고민 간접 테스트에 만족할 것인가? 개발해 두었던 어플리케이션의 코드를 보면, DB에 쿼리하는 부분들을 모두  ORM 모델의 class method 로 만들어 두었다. 예를 들어, ID 중복 체크는 아래처럼 메소드화되어 있다.  16. 테스트에 대한 고민 - (1)  챕터에서, 딱 찝어서 말한 건 아니지만 문맥 상  &#39;우리는 API를 테스트하는 코드를 작성하겠다&#39; 고 이야기한 적 있었다. 그럼 예를 들었을 때  ID 중복체크 API 는 확실한 테스트 대상이 되겠지만, 위의  is_id_already_signed 는 API 핸들러에 의해  간접적으로 테스트 된다. 내 경우  &#39;뭐 굳이 저것까지 따로 테스트할 필요 있나?&#39; 하고 넘겼던 적이 많은데, 확실히 짚고 넘어가고자 한다. 핵심 테스트가 들어 있는 코드를 유지보수하는 입장에서 유심히 바라봐야 할 지표는  테스트가 성공하는지 와,  어떤 코드가 테스트되고/되지 않는지를 아는 것 이라 생각한다.  &#39;이 코드가 확실히 테스트되겠다&#39; 고 안심할 수 있다면 간접 테스트로 만족할 수 있다고 판단하려고 한다(물론 &#39;이 코드가 확실히 테스트되겠다&#39;라는 생각이 맞는지를 검사하기 위해, 추후에  테스트 커버리지 에 대해 이야기할 예정이다). 안심할 수 없거나,  &#39;뭐 대충 API 테스트하면서 같이 테스트 되겠지&#39; 하는 생각이 드는 곳은  따로 테스트를 작성 할 것이다. 그 예는 다음과 같다.   /app/hooks/error.py 의 에러 핸들러들 : 우리가 API를 테스트하는 코드에서 비정상적인 요청을 날리며 schematics의  ValidationError 도 발생하고, 로직을 점검하는 테스트에 의해  abort 가 실행되며 werkzeug의  HTTPException 도 발생할 것이다. 그러나 만약  abort(403) 이 실행되어서 status code  403 을 반환받았다고 하더라도, 이게 정말로  http_exception_handler 가 실행된 결과인지에 대해 확신할 수 없다. 이 에러 핸들러를 실수로 register해두지 않아서, 그냥 Flask에 있는  default error handler가 그대로 403번을 응답 해 준 걸수도 있다.  따로 테스트를 작성해야 한다 고 생각한다.   /app/decorators/validation.py  :  validate_with_schematics  데코레이터에  PayloadLocation.args 를 전달하면 정말로 query params에 접근하는지, 함수에 데코레이터를 달았을 때 실제로 잘 실행되는지,  BaseModel 의 추상 메소드인  validate_additional 이 정말로 실행되는지 등에 대해서는  API 테스트 코드에서 디테일하게 테스트되진 않을 것 이라 판단한다. 따로 테스트를 작성하는 것이 좋다고 생각한다. 이들을 제외하고는 API 테스트 코드로 작업 내용을 채울 것이다. 사실 테스트 자체에 대한 경험과 배경지식이 많을 수록  테스트의 대상을 더 잘, 그리고 쉽게 정리 할 수 있으며  테스트하기 좋은 코드를 작성하는 방법 을 안다. 그래서 테스트를 잘 하는 사람들 입장에선 위에서 얘기했던 방식도 그리 좋은 방법은 아닐 것이다. 그래도 일단 차근차근 가자. 테스트에 대해서는 앞으로도 할 얘기가 많다. 테스트의 Idempotent를 어떻게 보장할 것인가?  Idempotent 는  멱등성 이라는 뜻인데,  &#39;연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질&#39; 을 뜻한다. 함수형 프로그래밍을 좀 했다는 사람들은  pure function 을 떠올리면 된다. 단적으로 어떤 함수를 실행했을 때, 항상 동일한 결과가 나오지 않는다면 그 함수는  비멱등성(non-idempotent)하다 고 말한다. 이걸 왜 얘기하냐면, 테스트 코드들은  멱등성이 지켜져야 하는 것이 좋기 때문 이다. 멱등성이 지켜진 테스트 코드를 작성해 두면, 테스트를  실행하는 입장에서 두려움이 없기 때문 이다.  &#39;아 이 테스트 제대로 돌리려면 DB에 게시글 5개 넣어둬야 하는데&#39; 같은 생각이 드는 테스트는 잘못 짠 테스트다. Idempotent를 보장할 방법 자, 우리는 아직 mocking에 대해 이야기하지 않았으니까 아래의 룰대로 테스트 코드를 작성해서 idempotent를 보장해 보자.  조회가 기반이 되는 API(조회, 수정, 삭제)를 테스트하는 코드에선,  직접 데이터를 생성 한다.  SQLAlchemy의 도움을 받아,  setUp 에서 모든 테이블을 생성하고,  tearDown 에서 모든 테이블을 drop한다. 추가적으로, 테스트 코드의 진행에 따라 실행될  DROP  쿼리가 RDS에 올라가 있는 production DB에 적용되면 안 되므로, 데이터베이스는  로컬에서 돌아가고 있는 MySQL을 사용 하도록 할 것이다.  &#39;실수로 production DB 쓰게 설정 바꾸고 돌려버리면 어떡함?&#39; 이라는 의문은 17챕터에서 한 번 커버하고, 2~30챕터 사이에 언젠가 한 번 더 커버할 예정이다. 작업 테스트 코드를 작성하자. 13챕터 때처럼 작업들을 적절히 쪼개서 이슈로 만들어 두고,  Project Board 로 관리할 계획이다. 개발 완료 직후 코드 스냅샷 ... 오늘 이야기할 내용은 사실 내가 떠드는 거 읽으면서 간접경험하는 것보다, 어떤 언어든 프레임워크든 상관 없으니 실제로 코드를 짜 보면서  직접경험을 하는 편이 훨씬 낫다.  나는 책이고 강의고 뭐고 그냥 코딩 엄청 해보는 게 최고의 경험이라고 생각한다. 그럼에도 불구하고 글을 쓰는 이유는, 테스트 코드를 작성하기 이전에  13. 웹 어플리케이션 개발  챕터에서 했던 &#39;일러두기&#39;같은 것이 필요하다고 느꼈기 때문이다. 어쨌든 독자 여러분들은 남이 작업하고 난 코드를 보는 입장일텐데,  &#39;아니 대체 왜 이렇게 했음?&#39; 이라는 의문을 미리 해결해줄만한 내용을 이야기해 보자. 실제로 내가 과거에  테스트 코드라는 걸 처음 마주쳤을 때 했던 고민 들이 대부분이다. 그러나 난 테스트에 대한 조예가 깊지 않으므로 &#39;에이 이건 아닌데?&#39; 싶으면 그냥 아닌 거라고 생각하고 넘어가 주길 바란다. 고민 unittest의 구조를 어떻게 써먹을 것인가? 우리가  15챕터 에서 쓰기로 결정했던 테스트 프레임워크인 unittest를 조금 살펴보고 나면, 아래의 내용을 이해하고 있을 것이다.   unittest.TestCase 를 상속받아 테스트 클래스를 먼저 정의한다.   test 로 시작하는 이름의 메소드가 실제 테스트 실행 대상으로 잡힌다.  몰라도 되는 내용이긴 하지만, 알파벳 순서대로 실행된다.   setUp 과  tearDown  메소드가 각 테스트 메소드의 수행 전과 후마다 실행된다.   setUpClass 와  tearDownClass  메소드가 각 테스트 클래스의 수행 전과 후마다 실행된다. 이러한 구조를 어떻게 하면 잘 써먹을 수 있을지 생각해 보자. test_post_api, test_auth_api, ... 내가 가장 처음 테스트 코드를 작성했던 방식은, 테스트 클래스 하나에  API 그룹(게시글 API, 회원가입과 로그인 API)마다 테스트 메소드를 하나씩  만들고 이것저것 다 집어넣는 것이었다. &#39;회원가입 API 테스트하고 나면 로그인도 테스트해야겠다&#39; 하면서 테스트 메소드 하나에 같이 테스트할만한 거 다 묶었었다. 그렇게 되니까, 메소드 하나가 아래의 것들을 모두 테스트했다.  게시글 작성 API에 대해 실패하는 케이스들을 모두 테스트한다.  게시글 작성 API의 성공을 테스트한다.  게시글 목록 API를 호출해서, 작성된 게시글의 ID가 존재하는지 테스트한다.  작성된 게시글의 ID를 가지고, 게시글 내용 조회 API를 테스트한다.  그 게시글 ID를 그대로 가져다가 게시글 수정 API를 테스트한다.  그거 갖다가 또 게시글 삭제 API를 테스트한다.  다시 게시글 목록 API를 호출해서, 삭제한 게시글 ID가 나타나지 않는지 테스트한다. 테스트를 처음 작성하는 입장에서는  &#39;흐름대로 테스트한다&#39; 는 느낌이라 아마 이런 방식이 더 편할 것이다. 사실 테스트 코드를 작성하면서 가장 절제해야 하는 것이 &#39;흐름&#39;인데, 그 이유는 다음과 같다.  테스트 코드에선  assert 를 사용한다.  assert [expression]  식인데,  &#39;expression이 True로 평가되어야 한다&#39; 라는 뜻이다.  assert response.status_code == 200 같은 식으로 사용할 수 있을 것이다. 모종의 이유로 이 expression이 False로 평가되면,  AssertionError 가 raise되어서 해당  테스트 메소드가 거기서 종료 돼버린다. 위의 예로 따졌을 때, 게시글 작성 API가 status code 201을 내려줘야 하는데 다른 걸 내려줘서 assert가 실패하면, 그  아래에 있는 수정 API 테스트와 삭제 API 테스트는 아예 실행되지도 않는다 는 것이다. 모든 테스트는  다른 테스트 코드에 의존하지 않아야 한다.  테스트는  외부 상태에 최소한으로 의존 해야 한다. 단적으로 얘기했을 때 DB가 내려갔거다거나 하는 정도가 아니라면, 지금 DB 상태가 어떻든 간에  &#39;테스트 코드 자체&#39;에서의 문제가 없어야 한다 는 것이다. 예를 들면,  &#39;test_id&#39; 라는 ID로 회원가입 API를 테스트했다가, 다시 실행했을 때 --이미 그 ID에 해당하는 유저가 DB에 들어 있어서 테스트에 실패--하는 경우다. 게시글 조회 API를 테스트하고자 한다면, 앞쪽에서 게시글 작성 API 테스트한거 갖다가 쓸 게 아니라  얘 전용으로 따로 insert 해주는게 맞다.  메소드 하나에 싹 넣어버리면, 테스트가 실행된 결과를 보는 입장에서  정리가 제대로 안 된다.  게시글 수정 API랑 삭제 API는 멀쩡한데 작성 API가 고장나서  test_post_api  메소드가 실패했다는 결과를 보는 것보다,  test_post_write 는 실패하고  test_post_modify 와  test_post_delete 는 성공했다는 결과를 보는 것이 훨씬 낫다. 따라서, 해당 방식은 좋지 않다는 생각이다. URI마다 한 클래스, HTTP 메소드마다 테스트 메소드 하나씩 위의 방식이 되게 불편했어서, 그 다음으로 시도했던 것이다.  URI마다 한 테스트 클래스 를,  HTTP 메소드마다 테스트 메소드를 하나씩  두는 것인데, 아래는 그 예다.   /board/posts 에서 동작하는 게시글 API를 테스트하기 위해  unittest.TestCase 를 상속받은  TestPostAPI  클래스를 만든다.  게시글 작성 API를 테스트하기 위해  test_post_write , 게시글 수정 API를 테스트하기 위해  test_post_modify , 게시글 삭제 API를 테스트하기 위해  test_post_delete 같은 식으로 메소드 만들고, 여기서  실패 케이스랑 성공 케이스 이것저것 다 테스트 한다. 각각의 테스트 메소드가  비교적 덜 뚱뚱해질 것 이지만, 이것도 결국  메소드 하나가 여러 테스트를 한 번에 수행 하는 구조라서 위에서 얘기했던 단점들을 시원하게 해결해주진 못한다. 엔드포인트마다 한 클래스, 단일 목적을 가진 테스트 메소드 요새 쓰고 있는 방식이다. 그렇다고 정답은 아니겠지만, 이 방식을 설명하자면,   엔드포인트마다 한 테스트 클래스 를 만든다. API 클래스의 이름에서,  &#39;API&#39;  앞에  테스트하고자 하는 메소드 를 붙이고, 맨 뒤에  &#39;Test&#39; 를 붙인다. 예를 들어,  PostAPI 를 테스트하기 위해  PostPostAPITest ,  PostGetAPITest ,  PostItemAPI 를 테스트하기 위해  PostItemGetAPITest ,  PostItemPatchAPITest ,  PostItemDeleteAPITest 처럼 클래스를 만들 수 있다.  해당 엔드포인트에 대해  테스트하고자 하는 것마다 메소드 를 만든다. 게시글 내용 조회 API를 테스트하는  PostItemGetAPITest  하위에,  유효한 게시글 ID를 통해 내용을 조회 하는  test_get_with_valid_id ,  유효하지 않은 게시글 ID를 통해 내용을 조회하고, status code 404가 응답되는지 검사 하는  test_get_with_invalid_id_404  메소드 등을 만들 수 있을 것이다.  한 테스트 클래스는 한 엔드포인트만을 테스트할테니,  setUpClass 에서 메소드나 URI같은 요청 관련 데이터를 초기화하도록 한다. 이런 식으로 테스트 코드를 작성하다 보니, 딱히 큰 불만 없이 테스트 코드를 작성할 수 있었던 것 같다. 여기서도 이 스타일을 사용할 계획이다. 테스트를 얼마나 구체적으로 할 것인가?  테스트를 어느 정도까지 작성해야 하느냐 의 이야기인데, 정량적인 지표는 없고  &#39;테스트를 다 통과하면 배포해도 된다&#39; 고 말할 수 있을 때까지 작성하면 된다고 생각한다. 조직이 코드에 대한 걱정이 얼마나 많느냐에 따라 테스트 코드의 양이 결정된다. 난 이정도를 테스트할 것이다. ID가 중복되지 않으면 회원가입 성공, 중복되면 409를 응답하는 것처럼,  API가 제공할 수 있는 모든 결과 케이스 리소스가 생성/수정/삭제되는 테스트라면,  DB를 직접 조회 해 정말로 잘 생성/수정/삭제되었는지 확인 다음 챕터에서 몇가지 고민을 더 이야기해 보고, 테스트 코드를 작성하도록 하자. 해당 챕터는 &#39;아 그래서 테스트를 코드로 작성하는 것이 좋구나&#39; 정도만 이해하고 넘어가도 좋습니다. Python과 Flask에 익숙하지 않은 개발자라면, 굳이 코드 전체를 이해하려고 용쓰지 않아도 됩니다. API를 개발하고, Lambda라는 완전 관리형 컴퓨팅 엔진에 이를 배포해 둔 입장에서 가장 무서운 것은,  API가 원하는 대로 동작하지 않는 이슈가 생기는 것 이다. 분명 게시글 목록 API가 데이터들을 제대로 응답해줘야 하는데 비어있다거나, ID와 비밀번호를 제대로 입력했는데도 로그인이 제대로 수행되지 않는다거나 하는, 쉽게 말하면  API에 버그가 생기는 것 이다. 독자 여러분이  테스트 라는 개념을 모르고 있더라도, 무언가 코드 작업을 하고 나면  &#39;잘 돌아가나?&#39;  하고 한 번씩 확인을 거치곤 했을 것이다. 내가 옛날에 처음 백엔드 개발을 했었던 기숙사 시스템 프로젝트에서도 버그 해결이 뭐 이런 식이었다.  따로 로그 시스템은 없었으니까,  &#39;2017년의 급식 데이터가 싹 다 안 불러와진다&#39; 라는 버그 리포트를 받는다.  PostMan으로 2017년의 아무 날짜나 잡아서 API를 호출해 보니, 서버로부터 500이 반환된다.  로컬에서 서버를 열고, PostMan에서 호스트를 localhost로 변경한 후 다시 한 번 요청을 보내고, Exception을 확인한다.  문제가 되는 코드를 고친다.  다시 PostMan으로 요청을 보내 보고, 잘 동작하니까 배포한다. 수동 테스트의 문제점 위에서 얘기한 것도 사실 일종의 테스트다. 13챕터에서 API 작업을 할 때도 로컬에 MySQL 띄우고, 로컬에서 서버 열고, Insomnia라는 HTTP 클라이언트 툴을 통해 로컬에 요청을 날려보는 식이었다.   내가 생각하기에  체크해야 될 것 같은 부분들을 눈으로 직접 확인 했다. 예를 들어, 회원가입 API의 테스트는 다음과 같았다.   정상적인 범주(happy path)에 대해 요청 을 보내고, 회원가입이 잘 처리되었는지( 201 Created 가 잘 응답되는지, 데이터베이스에 잘 들어갔는지, 비밀번호가 잘 해시되었는지) 확인한다.   이미 가입된 ID를 사용해 요청 을 보내고,  409 Conflict 가 잘 응답되는지 확인한다.  비밀번호의 제약조건인 &#39;최소 길이는 8자리&#39;를 어기고,  400 Bad Request 가 잘 응답되는지 확인한다.  닉네임의 제약조건은 &#39;최대 길이는 32자리&#39;를 어기고,  400 Bad Request 가 잘 응답되는지 확인한다. 이 정도 양의 테스트를  우리가 작성한 API들에 모두 적용 해야 한다. HTTP  요청 전송 버튼만 50번 넘게 눌러야 한다 는 것이다. 여기서 우리가 주목해야 할 것은 다음과 같다.  API 테스트는 배포하기 전에 꼭 해야 한다.  손으로 직접 하면 시간 소비가 너무 크고, 사람이 관여하게 되니 실수할 수도 있다.  테스트의 내용은 항상 정해져 있어서,  순서도로 표현 할 수 있으며, 이는  코드로 옮길 수 있는 여지 가 있다는 것이다.  Python과 Flask가 지원해 주는 여러 테스트 헬퍼들이 이런 일을 쉽게 할 수 있도록 도와준다. 그럼 우리가  테스트를 코드로 작성 해 두면, 손으로 직접 할 필요 없이  테스트를 수행하는 커맨드만 실행해 두고 가만히 있으면 된다 는 것이다. 쉽게 생각하자.  이미 가입된 ID를 사용해 회원가입 API를 호출하는 테스트 를 작성한다고 치면,  회원가입 API가 동작하고 있는 엔드포인트 로  회원가입과 관련된 데이터들을 JSON 형태로 만들어 HTTP 요청 을 보낸 후,  응답의 status code가 409번인지 확인 하면 된다. 다 알겠는데 코드로 어떻게 옮겨야 할 지 모르겠으니까, 구글에  &#39;flask test&#39; 같은 키워드로 검색 돌려서 나온  Testing Flask Application  문서를 조금 참고해서 코드로 옮기면 이런 식으로 작성해볼 수 있겠다. &#39;대충 이런 식으로 짤 수 있겠다&#39;하고 생각하면서 작성한 것이라 제대로 동작하진 않을 것이다. 아무튼 대충 이런 식이 된다. 직접 DB에서  이미 가입된 사용자 ID를 가져와서 → 요청 정보를 수정하고 → 직접 버튼을 누르고 → 직접 응답을 확인 하는 번거로운 작업을 수동으로 할 필요가 없어진다. 만약 위 테스트에서  response.status_code 가 409가 아니라면  AssertionError 가 발생하면서  테스트가 실패 할 것이고, 테스트를 실행하며 기다리던 개발자는 테스트가 실패한 것을 보고 API를 고치던 테스트 코드를 고치던 할 것이다. 테스트 코드를 작성한다는 게 정말로 의미가 있는가? 테스트 코드를 작성하기 위해 시간을 써야 하니까,  그럴 시간에 그냥 직접 PostMan같은 걸로 직접 테스트하는 게 더 낫지 않나?  싶을 수 있다. 이건 실제로 프로젝트를 한다고 생각해보면 되는데, 뭔가 서비스 하나를 개발한다고 치면  13챕터에서 개발한 웹 어플리케이션보다 몇 배는 되는 양의 API 가 작성될 가능성이 크다. 테스트해야 되는 케이스는 쉽게 100개를 넘어 버린다. 여기서 핵심은,  회원가입 API 손봤다고 게시글 API 테스트 안해도 되는 게 아니라는 것 이다. 아래와 같은 상황이 연출될 수 있기 때문이다. 회원가입 API가 고장나서 찾아보니  a 라는 함수의 문제였고, 이걸 고치고 나서 잘 되길래 배포했다. 그러고 나니까 게시글 API가 오류가 나서 보니까 얘도 함수  a 를 사용하고 있었다. 어차피 내 코드가 의도대로 동작하는지 확인하려면 HTTP로 찔러보든 해서 실행을 시켜봐야 하는데, 이걸 수동으로 할 바에  시간 들여서 테스트 코드 작성해 두고 확인하고 싶을 때마다 실행시키기만 하는 것 이 속도 면에서도, 정신건강 면에서도 훨씬 낫다. 개발자가 리팩토링 등의 이유로 코드를 변경했을 때, 이  변경에 문제가 없음을 검증하기 위해 해야 하는 작업 이  &#39;테스트 코드 실행하기&#39;  하나 뿐이라면, 코드를 수정하는 모든 작업들에 안정감이 생긴다. 테스트에는 종류가 다양한데, 여기선 다른 시스템과의 연결 없이 코드만을 테스트하는  유닛 테스트 를 작성하도록 하자. 다른 것들을 알아보고 싶다면 열심히 구글링해도 되고, 챕터가 나올 때까지 기다려도 된다. 아무튼 이제 당장의 목표는  &#39;테스트 코드를 작성하는 것&#39; 으로 둔 상태에서, 이번 챕터에서는 이 목표를 이루기 위한 의사결정을 진행하자. 의사결정 테스트 프레임워크 배경과 요구사항  Python에는 많은 테스트 프레임워크들이 존재한다. 여러 개를 한 번에 적용하는 건 불가능하진 않지만 여기선 불필요하니까, 하나 정해서 그걸로 테스트 코드를 작성하자.  조직이  unittest 라는 테스트 프레임워크에 익숙하다.  Flask가 제공하는 테스트 클라이언트를 잘 써먹을 수 있는 프레임워크면 좋다. 선택지 테스트 프레임워크가 이것저것 많긴 한데, 아래 세 개가 가장 많이 쓰인다.  unittest  doctest  pytest 의사결정 unittest를 사용하겠다. 그 이유는,  조직이 unittest에 익숙하다.  난 객체지향 알못이라 이런 얘기 해도 될런지 모르겠지만,  클래스를 기반으로 한 구조 덕분에 얻을 수 있는 이점 이 많다. 상속하고 뭐하고 뚝딱뚝딱 하다 보면 잘 빠진 코드가 나오곤 했던 경험이 있다.  doctest는 API 테스트보단  라이브러리 테스트에 더 어울린다.  글을 마무리하기 전에 링크할 파이썬 테스트 관련 문서를 보면 느낌이 올 것이다.  pytest는 pytest만이 가진 독특한 스타일 때문인지, &#39;pytest 써봐야겠다&#39; 하며  입문은 쉽더라도 잘 쓰기는 어려웠던 기억 이 있다.  테스트 입문을 다 unittest로 해서 그런지, 파이썬 개발자들 사이에서 unittest는 &#39;기본 소양&#39;같은 느낌이라, 새로운 개발자가 &#39;아 pytest네요?&#39; 하면서  러닝커브를 감당하지 않아도 되지 않을까  하는 작은 바람도 있다. 테스트 자체에 대한 이야기는 outsider님의 글  유닛테스트에 대한 생각 , 파이썬 테스트에 관련해선  코드 테스트하기 - The Hitchhiker&#39;s Guide to Python  문서가 아주 잘 작성되어 있습니다. Hitchhiker에 있는 문서들은 책으로 발간될 정도로 양질의 내용이 많으니, 짬나는 시간에 읽어보면 정말 좋습니다. 자바스크립트에 타입 구문 도입 제안 원문:  https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/ 저희는 오늘 선택적이고 제거 가능한 타입 구문(syntax)을 자바스크립트에 도입하는  0단계 제안 을 지원하고 협업한다는 사실을 발표하게 되어 기쁩니다. 이 새로운 구문은 코드의 실행 방식을 바꾸지 않기 때문에 효과적인  주석의 역할  을 할 것입니다. 저희는 이 제안이 개발의 규모에 상관없이 타입스크립트를 보다 쉽고 빠르게 적용할 수 있도록 도와줄 것으로 생각합니다. 이 글에서는 이 제안을 추진하게 된 이유와 어떻게 동작하는지 설명하고자 합니다. 제안 배경 저희 팀이 발견한 자바스크립트 생태계의 최근 트렌드 중 하나는 빠른 이터레이션(iteration) 주기와 빌드 단계의 간소화에 대한 수요입니다. 즉, &quot;더 빠르고 간단하게&quot; 만들고 싶은 것이죠. 사실 이미 진행되고 있습니다. 사용자가 별도로 재설치하지 않고도 업데이트가 가능한 에버그린 브라우저의 성공 덕분에 개발자들은 자바스크립트를 오래된 런타임에서 실행하기 위해 새로운 버전의 자바스크립트를 이전 버전으로 컴파일하지 않아도 됩니다. 번들링도 마찬가지입니다. 대부분의 브라우저는 모듈에 대한 지원을 내장하고 있기 때문에 번들링은 필요에 의해서라기보다는 최적화를 위한 과정이라고 볼 수 있습니다. 이러한 것들이 진행되고 있는 상황 속에서 타입스크립트는 어떻게 따라가고 있을까요? 타입스크립트가 처음 발표되었던 2012년으로 돌아가보면, 자바스크립트 생태계는 지금과 확연히 달랐습니다! 일부 브라우저는 배포가 자주 있었지만 모든 브라우저가 그렇진 않았습니다. 얼마나 오랫동안 인터넷 익스플로러의 화석 버전을 고려해야 할지 불분명했고, 이로 인해 번들러와 컴파일러 같은 도구들이 채택되었습니다. 자바스크립트에 빌드 스텝을 추가하는 것이 당연했던 시대였기에 타입스크립트는 크게 번창할 수 있었습니다. 어쨌든 자바스크립트를 컴파일해야 한다면, 타입도 컴파일하지 않을 이유가 없었죠. 하지만 위에서 언급한 트렌드가 계속된다면, 타입을 컴파일하는 것이 타입스크립트를 작성하고 실행하기 위한 유일한 단계가 될 수 있습니다. 저희는 좋은 개발자 경험을 방해하는 장애물이 되고 싶지 않습니다! 어떤 면에서 저희의 자바스크립트 지원은 이 차이를 메워주는데, Visual Studio Code나 Visual Studio 같은 에디터를 사용하신다면 보셨을 것입니다. 에디터에서  .js  파일을 만들고 JSDoc 주석의 형태로 타입을 더할 수 있습니다. 단지 주석이기 때문에, 코드의 실행에는 전혀 관여하지 않습니다. 하나의 문서의 형태일 뿐이죠. 하지만 타입스크립트는 이를 사용하여 코드 자동 완성, 리팩토링 등을 통해 더 나은 자바스크립트 에디팅 경험을 제공합니다. 파일 최상단에  // @ts-check  주석을 추가하거나  checkJs 의 타입스크립트 컴파일러로 파일을 실행하는 것으로도  타입 검사 를 할 수도 있습니다. 이를 통해 아주 손쉽게 빌드 단계 없이 타입스크립트를 경험할 수 있습니다. 작은 스크립트나 기본적인 웹 페이지, Node.js 서버 코드 등에 간단하게 사용하기 좋을 것입니다. 하지만 작성해야 하는 코드가 조금 많다는 사실을 알아차리셨을 겁니다. 무거운 컴파일 없이 가볍게 자바스크립트를 작성할 수 있다는 점은 좋지만, 단순히 타입만 작성하면 되는 타입스크립트의 편리함은 놓치고 있습니다.  가벼움과 편리함을 모두 가져갈 수는 없을까요? 타입스크립트 문법과 비슷하지만 마치 주석처럼 자바스크립트가 완전히 무시한다면 어떨까요? 저희 팀은  충분히  가능성 있다고 생각하며, ECMAScript 표준 위원회인 TC39에  제안서 를 제출했습니다. 어떻게 동작할까요? &quot;언제 타입이 자바스크립트에 도입되나요?&quot; 라는 질문을 받았을 때 저희는 대답을 망설여야 했습니다. 문제는 개발자들에게 자바스크립트 타입에 대해 무엇을 염두하고 있는지 물어본다면 너무 다양한 답변을 한다는 것입니다. 어떤 사람들은 타입이 완전히 무시되어야 한다고 생각했고, 또 어떤 사람들은 타입이  어떠한  의미를 가져야 한다고 생각했습니다. 런타임 유효성 검사를 한다거나 내부 검사를 가능하게 한다거나 엔진이 최적화를 수행할 때 힌트로 동작하는 등 말입니다. 그러나 지난 몇 년 동안 저희는 사람들의 의견이 타입스크립트가 지향하는 방향으로 수렴하는 것을 확인했습니다. 타입은 런타임에 완전히 무시되고 제거될 수 있어야 한다는 것이죠. 타입스크립트 사용의 증가과 함께 사람들의 의견이 수렴했다는 것은 저희 팀 외부의 자바스크립트, 타입스크립트 개발자가 &quot;주석으로서의 타입&quot; 제안에 대해 다시 한 번 접근했을 때 더욱 확신을 갖게 했습니다.  이 제안의 핵심 아이디어 는, 엔진에서는  완전히 무시하지만  타입스크립트, Flow와 같은 도구가 사용할 수 있는 타입 구문을 자바스크립트에 만들 수 있다는 것입니다. 이로써 타입스크립트의 장점(타입 검사와 에디팅 경험)은 그대로 가져가면서 빌드 단계는 제거할 수 있습니다. 따라서 코드를 작성하고  실행  할 때 그 과정이 조금 달라질 것입니다.   한편, 코드 작성과  타입 검사  는 동일하게 유지됩니다. 개발자는 타입스크립트를 지원하는 에디터에서 즉각적인 타입 검사 피드백을 받을 수 있고 커맨드 라인으로 타입스크립트를 실행할 수 있으며 CI 작업의 일부로 타입스크립트를 추가할 수 있습니다. 가장 큰 차이점은 빌드 스텝이 필요하지 않기 때문에 자바스크립트 개발자가 타입과 훌륭한 도구를 경험할 수 있도록 진입 장벽을  크게  낮출 수 있다는 것입니다.   이를 위해 자바스크립트는 최소한, 변수 및 함수에 대한 타입 주석, 매개변수와 클래스 멤버에 대한 선택적 제어자(optionality modifiers) -  ? , 타입 선언 ( 인터페이스 와  타입  별칭) 그리고 타입 단언 연산자 ( as  및  ! )와 같은 구문을 추가할 필요가 있습니다. 이들은 모두 주변 코드의 실행에 영향을 주지 않습니다. 접근 제한자(예:  public ,  private ,  protected )도 범위에 포함될 수 있습니다. 하지만 열거형, 네임스페이스 및 매개변수 프로퍼티는 런타임에서 데이터를 관찰하는 역할을 하기 때문에 이번 제안의 범위에 들어가지 않았습니다. 이 요소들은 피드백을 기반으로 별도의 ECMAScript 기능으로 제안될 수도 있지만 현재 목표는 자바스크립트에 중요한 추가 기능이 될 수 있는 타입스크립트의 최대한의 하위 집합을 지원하는 것입니다. 이 제안을 통해 타입 검사기가 더욱 발전할 수 있는 여지를 남겨두었습니다. 엔진은 타입이 엉망이어도 코드를 기꺼이 실행시키겠지만, 타입 검사기는 런타임보다 원칙적이고 더 엄격한 제약 조건을 적용할 수 있고, 또 적용해야 합니다. 이 제안으로 다양한 타입 검사기에서 맞춤형으로 커스텀 하거나 타입스크립트 또는 다른 타입 검사기가 마음에 들지 않는다면 완전히 제거할 수도 있습니다. 이 제안이 포함하지 않는 것은 무엇인가요? 이 제안에  포함되지 않는 것  이 무엇인지 언급할 필요가 있습니다. 저희 팀은 타입스크립트의 타입 검사를 모든 브라우저와 자바스크립트 런타임에 두는 것을 제안하지 않습니다. 어떠한 새로운 타입 검사기가 브라우저에 추가되는 것도 제안하지 않습니다. 그럴 경우에 런타임 성능, 기존 타입스크립트와의 호환성 문제, 그리고 타입 검사의 발전을 막을 위험과 같은 다양한 문제로 인해 자바스크립트 및 타입스크립트 사용자 모두에게 문제가 될 수 있다고 생각합니다. 그 대신 저희는 타입스크립트와 호환되고 타입스크립트에 의해 발전한 구문을 제안하고 있습니다. 어떠한 타입 검사기에서도 사용될 수 있고 자바스크립트 엔진에서는 건너 뛸 수 있습니다. 저희는 이 방식이 가장 가능성이 높으며 타입스크립트, Flow 등의 혁신도 계속해서 가능하게 할 것이라고 생각합니다. 다음 단계는 무엇인가요? 저희는 다가오는 2022년 3월 TC39 전체 회의에서  1단계   제안서 를 제출할 계획입니다. 이 제안의 공동 주연인 블룸버그(Bloomberg)의  Rob Palmer 와 이갈리아(Igalia)의  Romulo Cintra 로부터 지원과 가이드를 받아 진행할 예정입니다. 1단계에 도달한다는 것은 표준위원회가 ECMAScript에 대한 타입 구분 지원을 고려할 가치가 있다고 생각함을 의미합니다. 이것은 확실한 것은 아닙니다. 위원회 내부에는 많은 의미있는 관점이 있으며 어느 정도의 회의적인 시각이 있을 것이라 예상합니다. 이런 제안은 많은 피드백과 적절한 조사를 받게 됩니다. 그 과정에서 많은 설계의 변경이 포함될 수 있으며 결과를 도출하는 데 몇 년이 걸릴 수도 있습니다. 그러나 이 모든 것을 해내면 자바스크립트 생태계에서 가장 영향력 있는 개선 사항 중 하나를 만들 수 있습니다. 저희는 매우 기대하고 있으며 여러분도 그렇기를 바랍니다. 세부 사항과 현재 방향에 대해 더 알고 싶다면  제안 저장소 를 확인하세요. 여러분들의 의견을 기다립니다! 마지막으로, 타입스크립트 팀과 챔피언 그룹은  선행 기술 에 힘써준 모든 분들과 타입 주석을 도와준 모든 컨트리뷰터들, 특히 그 선두에 서준  Gil Tayar 에게 감사의 뜻을 전하고 싶습니다. 열정적인 커뮤니티에 참여 할 수 있어 감사합니다. 🚀 한글로 된 프런트엔드 아티클을 빠르게 받아보고 싶으시다면 Korean FE Article( https://kofearticle.substack.com/)을  구독해주세요! 꼭 써봐야 하는 10가지 리액트 커뮤니티의 훅(hook)들 원문:  https://www.dawsoncodes.com/posts/3/10-react-community-hooks-you-should-be-using 프런트엔드 개발에서 리액트는 최고의 도구라고 말 할 수 있습니다. 리액트 그 자체로도 매우 강력하지만, 리액트 커뮤니티에서 만들어진 훅(이하 &#39;커뮤니티 훅&#39;)을 사용하면 코드가 훨씬 명확하고 간결해질 뿐만 아니라, 불필요한 리렌더링 및 성능 문제를 방지할 수 있습니다. 우리는 항상 클린 코드를 위해 노력해야 합니다. 제 기준에서 클린 코드에 가까워지며 성능이 뛰어난 코드를 작성하는데 도움이 되는 10가지 커뮤니티 훅을 뽑아봤습니다. 1.  React hook form 리액트만으로 폼을 만들려면 입력값의 검증과 그에 수반되는 코드가 지저분해질 수 있다는 문제는 물론이고, 각 입력에 대한 상태를 생성하고 업데이트하는 일이 매우 까다로울 수 있습니다. React hook form을 사용하면 간단한 코드 몇 줄만으로 모든 무거운 작업을 처리할 수 있습니다. 훨씬 더 간결한 코드로 데이터를 검증하고 에러를 처리할 수 있으며 해당 에러를 사용자에게 표시하는 것 또한 손쉽게 가능합니다. React hook form은 여기서 언급하는 것보다 훨씬 더 많은 기능을 갖고있습니다. 더 다양한 기능에 대해 알고 싶으시다면,  여기 를 참고해주세요. 간단한 사용 예시: 2. useUpdateEffect 리액트 애플리케이션에서 특정 상태가 업데이트될 때만 함수를 호출하려는 경우가 있는데, 이는 업데이트 시에만 동작하는 useEffect라고 볼 수 있습니다. 다른 서드파티 훅을 사용하지 않고도 코드를 작성할 수 있지만, 코드가 지저분해질 수 있다는 문제가 있습니다. 다음은 라이브러리 없이 사용하는 방법입니다. 다음은 훌륭한 훅을 많이 제공하고 있는  react-use  라이브러리를 사용해서 더 깔끔하게 사용하는 방법입니다. 3. useCopyToClipboard 이 훅은 간단합니다. 상태와, 상태를 업데이트하고 클립보드에 복사하는 함수를 반환합니다. 상태는 사용자가 클립보드에 복사하는 문자열 값을 가집니다(사용자의 클립보드에 이미 저장된 텍스트는 읽을 수 없으며 사용자가 웹 사이트에서 복사한 텍스트 값만 가져올 수 있습니다). 함수가 실행될 때 에러가 발생할 경우에는 이 상태 값에 에러 프로퍼티가 추가됩니다. 아래와 같이 간단하게 적용할 수 있습니다. 4. useLocalStorage 브라우저 로컬 스토리지의 사용은 때때로 답답할 수 있습니다. 컴포넌트가 마운트될 때만 로컬 스토리지에 접근할 수 있기 때문에  useEffect  훅 내부에서만 로컬 스토리지를 사용해야 하고, 이에 따라 코드는 더욱 복잡해집니다. 이것이 바로 이 훅이 필요한 이유입니다. useLocalStorage 훅은 2가지 인자를 가집니다. 첫 번째는 로컬 스토리지에 저장하고 싶은 아이템의 key 값이고, 두 번째는 해당 아이템의 초기값입니다. 만약 해당 아이템이 사용자의 로컬 스토리지에 저장되어있지 않을 경우 초기값을 사용하게 됩니다. 이 훅은 3가지 값을 갖는 배열을 반환합니다. 첫 번째는 아이템의 값이고, 두 번째는 아이템의 값을 업데이트 할 수 있는 function, 마지막은 로컬 스토리지에서 해당 아이템을 제거할 수 있는 함수입니다. 사용 예시: 5. useHover 이 훅은 특정 엘리먼트가 hover 됐는지 확인할 때 사용됩니다. 이 훅은 다른 훅과는 조금 다른 형태를 가집니다. JSX 엘리먼트를 useHover에 넘기면 2가지 값을 갖는 배열을 반환합니다. 첫 번째 요소는 JSX 안에 사용할 엘리먼트이고, 두 번째 요소인 isHovered는 엘리먼트가 hover 됐는지 여부를 담고 있는 불리언 상태값입니다. 다음과 같이 적용합니다. 6. useIdle 이 훅은 사용자가 유휴(idle) 상태가 되었는지 아니면 사용자가 활성 상태인지를 확인할 때 사용됩니다. 두 가지 인자를 넘기는데, 첫 번째는 사용자가 유휴 상태가 되었는지 확인할 시간(밀리초)이고 두 번째는 초기값으로,  true  또는  false  값을 줄 수 있습니다. 초기값을 설정하지 않을 경우, 디폴트 값인  false 로 설정됩니다. 7. useClickAway 이 훅은 특정 UI 컴포넌트의 외부를 클릭할 때마다 함수를 트리거하고자 할 때 유용합니다. 예를 들어 열려 있는 모달 외부를 클릭할 때 모달이 닫히기를 원하는 경우가 있습니다. 이는 즉 사용자가 모달이 아닌 곳을 클릭할 경우, 모달을 닫는 함수를 실행하고자 하는 것입니다. 8. useDebounce 이 훅은 API로 쿼리를 검색하고 싶지만, 사용자가 단어를 입력할 때마다 요청을 보내고 싶지는 않은 경우에 제일 많이 사용됩니다. (사용자가 단어를 입력할 때마다 요청을 보낸다면 너무 많은 불필요한 API 요청이 가게 되고 서버에 부하가 생길 수 있기 때문입니다.) 이 훅을 활용하면, 사용자가 입력을 마칠 때까지 기다린 후 요청을 보냅니다. 9. useWindowSize 이 훅은 스크린의 높이, 너비 값을 반환하고 스크린 사이즈가 변할 때 자동으로 그 값을 업데이트합니다. 10. useSwr 이 훅은 컴포넌트가 마운트될 때 발생하는 요청을 쉽게 처리할 수 있게 해줍니다. 두 가지 인자를 받는데, 첫 번째는 요청의 url이고 두 번째는 서버에 요청을 보내는 fetcher function 입니다. 훅의 반환값은  isValidating ,  error , 응답 데이터로,  isValidating  상태값은 일반적인 로딩 상태값과 동일하게 동작합니다.  mutate()  라는 함수도 반환하는데, API를 다시 페치하는 데에 사용할 수 있습니다. 이 기능은 할 일 목록에서 할 일을 삭제하는 등 일부 데이터를 변조할 때 유용합니다. 작업이 성공한 후  mutate()  함수를 다시 호출하여 최신 데이터를 가져올 수 있습니다. 다음은 컴포넌트가 마운트 될 때 데이터를 페치하는 간단한 예시입니다. 이것이 제가 꼽은 꼭 써봐야 하는 10가지 훅이었습니다. 이 글이 유용했길 바라며, 만약 그렇다면 공유해주시면 감사하겠습니다. 이 글을 읽어주셔서 감사합니다, 혹시 궁금하신 점이나 댓글이 있으시면 언제든지 트위터에 연락해주시고, 매일 글을 올리고 있으니 팔로우 부탁드립니다. Website:  https://dawsoncodes.com 자바스크립트 프레임워크에서 효율적인 하이드레이션(Hydration)이 어려운 이유 원문:  https://dev.to/this-is-learning/why-efficient-hydration-in-javascript-frameworks-is-so-challenging-1ca3 하이드레이션은 자바스크립트 프레임워크에서 페이지가 서버에서 렌더링된 이후에 브라우저에서 초기화되는 프로세스를 말합니다. 서버가 초기 HTML을 생성하면, 그 결과에 이벤트 핸들러를 붙이고 브라우저에서 인터랙티브하게 동작하도록 애플리케이션 상태를 초기화해야 합니다. 대부분의 프레임워크에서 하이드레이션은 페이지를 처음 로드할 때 상당히 큰 비용을 수반합니다. 자바스크립트를 로드하고 하이드레이션이 완료되는 데 걸리는 시간이 오래 걸릴수록 우리는 인터랙티브해 보이지만 실제로는 그렇지 않은 페이지를 오랜 시간 마주하게 됩니다. 이는 사용자 경험에 치명적이며 특히 디바이스의 성능이 좋지 않을수록, 또 네트워크가 느릴수록 이를 경험할 확률이 높습니다. 이 문제를 해결할 수 있는 많은 방법이 있을 거라고 생각하실 겁니다. 실제로 해결법은 많지만, 어떤 것도 완벽하지 않습니다. 라이브러리 개발자들은 수 년 동안 이 기술을 점진적으로 개선해오고 있습니다. 그래서 오늘 저는, 우리가 다루고 있는 문제를 가장 잘 이해하기 위해 구체적으로 하이드레이션이라는 주제에 대해 알아보려고 합니다. 서버 렌더링이 만능 해결책은 아닙니다   제일 선호하는 클라이언트 렌더링 자바스크립트 프레임워크를 사용해서 서버 렌더링에 사용합니다. 더 나은 SEO, 더 좋은 성능 모두를 얻을 수 있죠. ... 아닙니다. 그만 멈추세요. 이것은 흔한 오해입니다. 단순히 서버가 SPA(Single Page App)를 렌더링한다고 모든 것이 해결되지는 않습니다. 오히려 자바스크립트 코드를 증가시키며, 애플리케이션이 인터렉티브 할 때까지 걸리는 시간이 단순 클라이언트 렌더링보다 더 길어질 수 있습니다. 네? 뭐라고요?!... 장난치는 게 아니에요. 대부분의 프레임워크에서 하이드레이션 준비 코드는 궁극적으로 두 가지 작업을 모두 수행해야 하기 때문에 일반적인 클라이언트 코드보다 큽니다. 처음에는 하이드레이션만 할지라도 당신의 프레임워크는 클라이언트 측 렌더링을 허용하기 때문에 그것을 위한 코드도 필요합니다. 또한, 데이터를 로드할 때 사용자에게 보여줄 수 있는 HTML 페이지를 보여주는 대신, 서버에서 전체 페이지가 로드되고 렌더링될 때까지 기다려야 합니다. 게다가 그 페이지는 모든 HTML과 애플리케이션이 부트스트랩에 필요한 데이터를 포함하고 있기 때문에 훨씬 큽니다. 나쁜 점만 있는 것은 아닙니다. 일반적으로는 브라우저가 자바스크립트를 로드하기 위한 추가 왕복 시간을 기다릴 필요가 없기 때문에 메인 콘텐츠가 더 빨리 보이게 됩니다. 하지만 애플리케이션을 하이드레이션 하기 위한 자바스크립트를 포함하고 있는 애셋의 로딩을 지연시킵니다. 주의: 이는 사용자 네트워크와 데이터 지연 시간에 크게 좌우됩니다. 또한 스트리밍과 같이 로드 성능 타이밍을 해결하기 위한 많은 기술이 있습니다. 그러나 이것이 명백한 해결책이 아니며 새로운 트레이드오프와 고려사항이 있다는 것을 설명하고자 합니다. 근본적인 문제 클라이언트 측 하이드레이션의 경우 두 가지 매우 아쉬운 점이 있습니다. 하나는 서버에서 렌더링을 한 후, 브라우저에서 하이드레이션 하기 위해 또 다시 렌더링을 해야한다는 것입니다. 두 번째는 우리가 모든 것을 HTML로 한 번, 자바스크립트로 한 번, 총 두 번 전송한다는 것입니다. 일반적으로 3가지 형태로 전송됩니다. 템플릿 - 컴포넌트 코드 / 정적 템플릿 데이터 - 템플릿을 채우기 위한 데이터 구현된 뷰 - 최종 HTML 템플릿 뷰는 번들된 자바스크립트와 렌더링된 HTML, 두 가지 모두에 포함되어 있으며, 데이터도 페이지에 렌더링된 스크립트 태그와 최종 HTML의 일부, 두 가지 모두에 표시됩니다. 클라이언트 렌더링의 경우 템플릿을 보내고 렌더링할 데이터를 요청합니다. 중복은 없습니다. 그러나 무언가를 표시하려면 자바스크립트 번들을 로드하는 네트워크를 기다릴 수 밖에 없습니다. 따라서 서버에서 구현된 HTML을 사용하면 서버 렌더링의 모든 이점을 얻을 수 있습니다. 이는 사이트를 표시함에 있어 자바스크립트 로딩 시간에 구애받지 않게 해줍니다. 하지만 서버 렌더링으로 인해 발생하는 추가적인 비용은 어떻게 해결해야 할까요? 정적 라우팅 (하이드레이션 없음)   예시:  Remix ,  SvelteKit ,  SolidStart 여러 자바스크립트 SSR 프레임워크에 채택된 아이디어 중 하나는 일부 페이지에서  &lt;script&gt;  태그를 제거하는 기능입니다. 이 페이지들은 정적이고 자바스크립트가 필요하지 않습니다. 자바스크립트가 없다는 것은 추가적인 트래픽, 데이터 직렬화, 하이드레이션 등이 없다는 것을 의미합니다. 물론 자바스크립트가 필요하지 않다면요. 페이지에 바닐라 자바스크립트를 몰래 넣을 수도 있고 어떤 경우에는 괜찮을 수도 있겠지만, 바람직하진 않습니다. 이는 두 번째 애플리케이션 계층을 생성하는 것입니다. 터무니없지는 않습니다만, 현실적으로 한번 동적 요소를 추가하면 프레임워크를 활용해서 모든 것을 끌어 들이고자 합니다. 이 접근 방식은 SSR을 통해 항상 가능했지만, 유연하지 못합니다. 멋진 요령이지만 대부분의 경우 해결책이 되지 않습니다. 자바스크립트 레이지로딩 (점진적 하이드레이션)   예시:  Astro (섬(Islands)과 결합해서) 이 방법은 &quot;점진적&quot; 또는 &quot;레이지(Lazy)&quot; 하이드레이션라고 말합니다. 자바스크립트를 바로 로드하지 않고 인터렉션에 따라 로드하는 것을 의미합니다. 마우스를 클릭하거나, 움직이거나, 스크롤 될 때 등 인터렉션에 따라 로드합니다. 심지어 만약 인터렉션이 없다면 자바스크립트를 아예 보내지 않을 수도 있습니다. 하지만 한 가지 문제가 있습니다. 대부분의 자바스크립트 프레임워크는 하향식으로 하이드레이션 합니다. 이것은 리액트에서도, 스벨트에서도 해당됩니다. 따라서 애플리케이션에 (단일 페이지 애플리케이션처럼) 공통 루트(root)가 포함되어 있는 경우 이를 로드해야 합니다. 그리고 렌더 트리가 너무 얕지 않다면, 화면의 중간 버튼을 클릭했을 때 엄청난 양의 코드를 로드하고 하이드레이션 해야 합니다. 사용자가 무언가를 할 때까지 오버헤드를 미루는 것은 좋지 않습니다. 사용자를 기다리게 할 것이라는 것이 확실하니 오히려 더 안좋다고도 말할 수 있습니다. 하지만 사이트의 라이트하우스 점수는 좋겠죠. 따라서 넓고 얕은 트리가 있는 애플리케이션에서는 도움이 될 수 있겠지만, 최신 SPA에서는 그렇지 않습니다. 클라이언트 측 라우팅, 컨텍스트 제공자(Context Provider) 및 경계(Boundary) 컴포넌트(서스펜스, 에러 또는 기타)등의 패턴으로 인해 깊은 트리가 만들어지기 때문입니다. 이 방법만으로는 사용할 수 있는 모든 데이터를 직렬화하는 것을 막을 수 없습니다. 결국 무엇이 로드될지 모르기 때문에 모든 것을 사용할 수 있어야 합니다. HTML에서 데이터 추출   예시:  Prism Compiler 보통 사람들이 바로 생각하는 다른 방법은 렌더링된 HTML에서 상태를 리버스 엔지니어링 하는 것입니다. 큰 JSON blob을 보내는 대신 HTML에 삽입된 값으로부터 상태를 초기화합니다. 겉으로 보기에는 나쁘지 않은 아이디어입니다. 문제는 모델과 뷰가 항상 1 대 1로 대응되지 않는다는 것이죠. 만들어진 데이터를 또 다른 데이터로 만들기 위해 원본으로 되돌리려는 것은 대부분의 경우 불가능합니다. 예를 들어 포맷팅된 타임스탬프를 표시한다고 했을 때, 해당 HTML에서는 초단위를 인코딩하지 않았지만 초단위를 허용하는 다른 UI로 변경하려는 경우 어떻게 해야 할까요? 아쉽게도 이것은 초기화한 상태뿐만 아니라 데이터베이스와 API로부터 오는 데이터에도 적용됩니다. 또 단순히 모든 것을 직렬화하지 않을 수도 없습니다. 대부분의 하이드레이션은 브라우저가 탑다운 방식으로 초기화하는 시점에 애플리케이션을 다시 실행한다는 것을 유념해야 합니다. 동형(Isomorphic) 데이터 페칭(fetching) 기능은, 데이터를 전송하지 않고 일종의 클라이언트 사이드 캐시를 설정하지 않으면, 이 때 브라우저에서 페칭을 다시 시도합니다. 섬 (부분 하이드레이션)   예시:  Marko ,  Astro 웹 페이지를 브라우저에서 다시 렌더링하거나 하이드레이션할 필요가 없는 거의 정적인 HTML이라고 상상해보세요. 그 안에는 사용자가 인터렉션할 수 있는 몇 개의 장소가 있는데, 이를 &quot;섬&quot;이라고 부릅니다. 이러한 접근 방식을 부분 하이드레이션이라고 하는데, 그 이유는 이러한 섬에만 하이드레이션 하면 되고 페이지의 다른 부분에 대한 자바스크립트 전송을 건너뛸 수 있기 때문입니다. 이러한 방식으로 설계된 애플리케이션에서는 인풋 또는 프로퍼티를 최상위 컴포넌트에 직렬화하기만 하면 됩니다. 더 상위에 상태를 저장하고 있는 것이 없다는 것을 알고 있기 때문입니다. 상위 레벨에서의 리렌더링은 절대 일어나지 않습니다. 섬 밖에 있는 것들은 바뀌지 않습니다. 따라서 단순히 사용하지 않는 데이터를 보내지 않는 것만으로도 이중 데이터 문제를 많이 해결할 수 있습니다. 최상위 인풋이 아니라면 브라우저에서 필요할 리 없습니다. 그렇다면 경계(boundaries)는 어디에 둬야 할까요? 컴포넌트 수준에 경계를 두는 것은 이해할 수 있기에 합리적입니다. 하지만 섬들은 더 세분화 될수록 더 효과적입니다. 섬 아래에 있는 어떤 것이든 다시 렌더링 될 수 있다면 그 코드는 브라우저로 전송해야 합니다. 하나의 해결책은 하위 컴포넌트 레벨에서 상태를 확인할 수 있을 정도로 스마트한 컴파일러를 개발하는 것입니다. 그렇다면 우리 트리에서 정적인 가지뿐만 아니라 상태를 저장하고 있는 컴포넌트 아래에 중첩된 가지도 제거할 수 있습니다. 그러나 이러한 컴파일러는 크로스 모듈 방식으로 분석될 수 있도록 특화된 DSL(Domain Specific Language, 도메인 특화 언어)이 필요합니다. 더 중요한 것은, 네비게이션 시 서버에서 각 페이지를 렌더링한다는 것입니다. 이 다중 페이지(MPA) 접근 방식은 웹이 고전적으로 동작하는 방식입니다. 그러나 클라이언트 측 트랜지션으로 네비게이션 하지 않기 때문에 클라이언트의 상태가 손실됩니다. 사실상 부분 하이드레이션은 위에서 언급한 정적 라우팅에서 사용하는 기능에 대해서만 비용이 발생하도록 개선된 버전입니다. 순서가 뒤바뀐 하이드레이션   예시:  Qwik 부분 하이드레이션이 정적 라우팅의 개선된 버전이라면, 순서가 뒤바뀐 하이드레이션은 레이지 로딩의 개선된 버전입니다. 하이드레이션이 일반적인 하향식 렌더링 프레임워크에 의해 제한되지 않는다면 어떨까요? 그렇다면 화면 중간 버튼의 하이드레이션이 컴포넌트 계층의 상위에 있는 클라이언트 라우팅과 상태 관리 로직을 로딩하는 것과 상관없이 가능합니다. 여기엔 꽤 어려운 제약이 있습니다. 이 기능이 작동하려면 컴포넌트가 부모에 의존하지 않고 초기에 작동하는 데 필요한 모든 것을 갖추고 있어야 합니다. 그러나 컴포넌트는 인풋 또는 프로퍼티를 통해 부모와 직접적인 관계를 가집니다. 한 가지 해결책은 각각의 컴포넌트에 의존성을 주입하여 모든 인풋값을 주는 것입니다. 이로써 부모 자식들 사이에 직접적인 관계를 갖지 않게됩니다. 또, 서버 렌더 시 모든 컴포넌트의 인풋을 직렬화할 수 있습니다(물론 중복이 발생하겠죠). 하지만 이것은 컴포넌트에 전달되는 하위 요소들(children)에게도 적용됩니다. 모든 하위 요소들은 사전에 완전히 렌더링될 필요가 있습니다. 현존하는 프레임워크들은 매우 타당한 이유로 이러한 방식으로 작동하지 않습니다. 지연 평가(Lazy Evaluation)는 하위 요소가 어떻게 그리고 언제 삽입되는지 제어할 수 있는 능력을 줍니다. 한때 하위 요소들이 한번에 평가되도록 동작했던 거의 모든 프레임워크들이 이제는 지연 평가를 사용하고 있습니다. 우리에게 익숙한 부모 자식 상호 작용의 규칙들이 조정되고 제한될 필요가 있기 때문에 익숙하지 않은 방식으로 개발되게 됩니다. 또한 이 방식은 레이지 로딩과 마찬가지로 데이터 중복을 줄일 수 없습니다. 어떤 컴포넌트를 실제로 브라우저로 전송해야 하는지 알 수 없기 때문입니다. 서버 컴포넌트   예시:  리액트 서버 컴포넌트 부분 하이드레이션을 적용하지만, 그 후에 서버에서 정적인 부분을 다시 렌더링한다면 어떨까요? 그렇게 한다면 서버 컴포넌트가 있어야 합니다. 컴포넌트 코드 크기가 줄어들고 중복 데이터가 제거되므로 부분 하이드레이션의 많은 이점을 가져가면서 네비게이션 시 클라이언트 측 상태를 유지하는 것도 포기하지 않을 수 있습니다. 문제는 정적인 부분을 서버에서 다시 렌더링하려면 기존 HTML과 차이를 비교할 수 있는 특수한 데이터 형식이 필요하다는 것입니다. 또한 초기 렌더 시 일반 서버 HTML 렌더링을 유지해야 합니다. 이는 훨씬 더 복잡한 빌드 단계와 서버 컴포넌트와 클라이언트 컴포넌트 간에 다른 종류의 컴파일 및 번들이 필요함을 의미합니다. 더 나아가서, 증가하는 오버헤드를 제거했더라도 이 작업을 수행하려면 브라우저에서 더 큰 런타임이 필요합니다. 따라서 이 시스템의 복잡성은 더 큰 웹사이트와 어플리케이션이 될 때까지 비용을 상쇄하지 못할 것입니다. 하지만 그 한계점에 다다른다면, 이 방법은 무엇이든 가능하다고 느껴집니다. 초기 페이지 로드를 최대화하는 최선의 방법은 아니지만 자바스크립트 코드를 증가시키지 않고도 SPA의 이점을 유지할 수 있는 고유한 방법입니다. 결론 이것은 계속해서 연구되고 있는 분야이기 때문에 새로운 기술들이 끊임없이 등장하고 있습니다. 그리고 이 문제의 핵심은 다양한 기술의 조합이 최선의 해결책일 수 있다는 것입니다. 하위 컴포넌트 섬을 자동으로 생성하고, 순서가 뒤바뀐 하이드레이션이 가능하고, 서버 컴포넌트를 지원하는 컴파일러를 사용한다면 어떨까요? 우린 세상에서 가장 좋은걸 가질 수 있을 거에요, 그렇죠? 혹은 트레이드오프가 너무 커서 사람들이 사람들이 이해하는 방식과 맞지 않을 수도 있습니다. 해결책이 너무 복잡할 수 있죠. 이 문제가 해결될 수 있는 방법은 다양합니다. 이 글로 인해서 현대 자바스크립트의 가장 어려운 문제들 중 하나를 해결하기 위해 지난 몇 년간 진행되어온 작업에 대한 더 많은 인사이트를 얻었기를 바랍니다. 🤷‍♂️ JWT란? JWT는  Json Web Token  JWT 인증 방식은 이름에서 알 수 있듯이  토큰 을 사용하는 토큰 기반 인증 방식이다. JWT를 사용하기 이전에는  세션 을 통해서 사용자 인증을 진행하였다. 💁‍♂️ 토큰 기반 인증 시스템을 사용하는 이유 쿠키  라는 것을 사용하여 클라이언트 측에서 기억하고 있어야 했다. Cookie? 클라이언트가  웹사이트에 접속할 때, 정보를 기록하게 되는 일련의 파일 ID, Password  까지 저장하여 사용했었다.  당연하게도 , 쿠키에 민감 정보를 저장함으로써  보안 문제 공유 가 불가능하고 쿠키 사이즈가 제한되어  충분한 데이터 를 저장할 수가 없었다. 쿠키의 보안 문제를 해결하기 위해 Session이 등장한다. Session?  Session이란? 클라이언트의 요청에 따른 정보를 세션 아이디 파일을 만들어 서비스중인  서버 의 (DB,메모리 등에) 저장하는 것  클라이언트가 서버한테 정보를 요청했을 때, 지속적인 메시지 교환을 위해서 통신을 마칠 때 까지 방문자 정보를  서버 에 저장하는 논리적인 연결이다. 자물쇠로 치자면, 서버가 자물쇠가 되고 클라이언트가 가지는 식별 값이 ID가 되어, 서버에서 저장하고 있는 특정 인증 정보를 인증하게 되는 방식이다. 서버 기반 인증 시스템 흐름   하지만, 위 방식은 서버를 확장하는데 문제가 생긴다. 저장소 문제 세션을 메모리나, DB, 디스크에 저장하게 되면서 클라이언트의 수가 많아질 수록 서버의 램에 과부화가 걸린다거나, DB 성능에 문제가 생길 수 있다. 확장성 여러대의 서버로 확장하게 되었을 때, 유저가 처음 로그인 했던 서버로 요청을 보내지 않으면 인증이 되지 않기 때문에 확장성에 문제가 생긴다. 🤷‍♂️ 그래서 JWT가 뭔가요? 인증에 필요한 정보들을 Token에 담아 암호화 시켜서 사용한다.   stateless  - 토큰 자체가 인증된 정보이기 때문에 별도의 세션 저장소가 필요하지 않다.  JWT 구조   HTTP의 헤더로 전달될 때 문자열의 형태로 인코딩하게 된다. .을 기준으로 Header, Payload, Signature을 구분하게 된다.  해당 토큰을 Json 형식으로 디코딩하면 다음과 같은 구조를 가진다. Header   alg는 해싱 알고리즘, typ는 토큰 타입을 의미한다. Payload   토큰의 담을 정보(클라이언트의 고유 ID값, 생성날짜 등) 를 지닌다.  Signature 비밀키 로만 복호화 할 수 있기 때문에 토큰의 위변조 여부를 확인할 수 있다. 인증 과정   클라이언트의 고유 ID 등의 정보를 Payload에 담아 서버에 전달한다. 서버에서의 비밀키를 통해 암호화하여 JWT(Acess Token을 발급한다. 클라이언트는 발급받은 토큰을 가지고 요청할 때 마다 포함시켜 전달한다. 서버는 토큰의 Signature을 비밀키로 복호화하여 위변조 여부 및 유효기간을 확인하고, 유효하다면 응답한다. 물론 , 장점이 있는 만큼 단점도 존재한다. 단점 JWT 토큰의 길이가 길어, 인증 요청이 많아지면 그만큼 네트워크 부하가 심해진다. Payload에 중요한 정보를 담을 수 없다. 토큰 탈취에 대처하기 어렵다.(한번 발급되면 유효기간 만료 전까지 사용이 가능하기 때문) 특정 사용자의 접속을 강제 만료하기 어렵다. ❌보안 전략 JWT 사용시 위와같은 단점들을 보완하기 위한 전략으로 다양한 방법을 채택할 수 있다. 짧은 만료 기한 설정 토큰의 만료 시간을 짧게 설정하여, 탈취 시 피해를 최소화 한다. 하지만 사용자가 자주 로그인해야 하는 단점이 있다. Refresh Token 클라이언트가 로그인 요청을 보내면  Access Token 보다 긴 만료 기간을 가지는 Refresh Token 그러나 , Refresh Token을 서버의 저장소에 저장해야 하므로 추가적인 I/O 작업이 발생하여 빠른 인증을 자랑하는 JWT의 장점을 상쇄시킨다. Sliding Session 참고 블로그  https://webcoding-start.tistory.com/50 https://tech.toktokhan.dev/2021/04/30/JWT/https://tecoble.techcourse.co.kr/post/2021-05-22-cookie-session-jwt/ https://tecoble.techcourse.co.kr/post/2021-05-22-cookie-session-jwt/   [SOLID란 무엇 인가?]  SRP  (Single Responsibility Principle) :  단일 책임 원칙  OCP  (Open Closed Principle) :  개방 폐쇄 원칙  LSP  (Liskov Substitution Priciple) :  리스코프 치환 원칙  ISP  (Interface Segregation Principle) :  인터페이스 분리 원칙  DIP  (Dependency Inversion Principle) :  의존 역전 원칙 1. SRP(Single Responsibility Principle) - 단일 책임 원칙 어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다.  장점  - 클래스를 여러가지로 분할하여 유연하게 설계할 수 있는 장점을 가짐.  단점  - 너무 많은 분할로 인해 책임이 여러군데로 파편화 되있을 경우  &lt; 산탄총수술 &gt; 로 응집력을 높여주는 추가 작업이 필요. SRP가 지켜지지 않은 메서드 SRP를 지킨 메서드 2. OCP(Open Closed Principle) - 개방 폐쇄 원칙 클래스, 모듈, 함수 등 소프트웨어 구성요소는  확장에 대해 열려있어야  하고  변경에 대해서는 닫혀 있어야  한다.  이는 변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 가능한 극대화 해야 한다는 의미이다.  Interface 구현 을 통해 이를 해결한다. OCP가 지켜지지 않은 경우   FileStorage에서 Oracle, MySQL 말고 새로운 파일을 저장해야 할 때, save_to_XXX() 라는 메서드를 추가하여 기존의 코드를 변경하게 되어 OCP를 지키지 못하게 된다. OCP가 지켜진 경우 3. LSP(Liskov Substitution Principle) - 리스코프 치환 원칙 서브 타입은 언제나 자신의 기반 타입으로 교체 할 수 있어야 한다.  하위 클래스의 인스턴스를  상위형 객체 참조변수 에 대입해  상위 클래스의 인스턴스 역할 을 수행하는데 문제가 없어야 한다. LSP가 지켜진 경우와 지켜지지 않은 경우 4. ISP(Interface Segregation Principle) - 인터페이스 분리 원칙 ISP는 SRP와 비슷하지만 인터페이스를 통한 다른 해결책을 제안하고 있다. 일반적으론 ISP보다 SRP 할 것이 권장된다.  EX) 큰 카테고리로 분류가 되면 ISP로 적용 하는것이 유리. SRP를 우선적으로 적용 하기로 약속한다. 5. DIP(Dependency Inversion Principle) - 의존 역전 원칙  고차원 모듈 은  저차원 모듈 출처:  https://sjh836.tistory.com/159 https://velog.io/@lsb156/객체지향-개발-5대-원칙-SOLID https://blog.naver.com/jenny25697/222664023806 https://yoongrammer.tistory.com/97   Compose에서는 Composable로 화면을 표현한다. 또한 State를 통해서 데이터 변경을 감지하고 Recomposition을 실행함으로써 화면을 재구성 하게 된다. ** 관찰 가능한 상태 객체를 우리는 mutableStateOf()을 통해서 생성하게 된다.**      ✏ mutableStateOf    mutableStateOf 은, value와 policy를 받아  SnapshotMutableState 를 생성하게 되면서   MutableState  인터페이스의 구현체가 된다.    SnapshotMutableState 로 생성하게 되면, RecomposeScope는 value의 변경사항을  구독 하면서 변경될 때 마다 Recompose를 예약하게 된다.   ✏ mutableState, State     State 인터페이스는, 읽기만 가능한  상수(val) value 가 선언되어 있어서, 값을 변경할 수가 없다. MutableState 인터페이스는 State에서 val로 선언되어 있던 value를  변수(var)  로 선언하게 되면서 변경 가능한 값이 된다.   ✏ 구조 분해 MutableState는  구조 분해 구문 을 사용하고 있는데, operator라는 연산자 오버로딩을 사용한다.  operator fun componentN() 로  반환할 멤버나 람다식을 구현하게 되면 1부터 N번째 까지 구조 분해를 했을 때 순서대로 할당이 된다. 위와 같이 분리 선언된 코드를 컴파일 하게 되면 아래 코드가 된다.  객체를 여러 변수로 분리하길 원할 때 , 구조 분해 구문을 사용하게 되면 여러 개의 변수로 생성할 수 있다. 위의 예제에서는 Getter와 Setter를 생성하면서 객체를 생성하고 있다. Compose에서는 데이터의 상태가 변경되었을 때, setContent가 다시 호출된다. 이를 Recomposition이라고 하는데, 따로 데이터를 저장해 두지 않는다면, Recomposition 되었을 때 데이터가 초기화 되어버린다. 💡 Compose 용어 설명  Composition  : Jetpack Compose가 Composable을 실행할 때 빌드한 UI에 관한 설명  Initial Composition  : 처음 Composable을 실행하여 Composition을 생성  Recomposition( 재구성) : 데이터가 변경될 때 Composition을 업데이트 하기 위해 Composable을 다시 실행하는 것 Compose 에서는, 명령형 기반 뷰와는 달리, 데이터가 변경되면 상태를 명시적으로 알려줘야 한다. ex) TextField에서 onValueChange를 정의해줘야 입력한 문자가 뷰에 표시된다. 1) remember 사용   MutableStateOf은, Observable한 MutableState 를 생성하고,  런타임 시 Compose에 통합되는 Observable 유형이다.   value가 변경 되면 이를 감지하고  Recomposition 이 예약된다. MutableState를  remember 라는 composable을 이용하여 변수를 선언하게 되면  initial composition에서 메모리에 저장 되어 Recomposition 때 값을 반환받아 사용할 수 있다. 또한 값이 변경되어 ReComposition 할 때 마다 값을 저장할 수도 있다.  하지만 , 화면이 회전되는 경우 Activity가 재 시작하기 때문에, 다시 그려지게 되면 remember로도 값이 유지되지 않는다. 이 때는  rememberSaveable 2) 기존의 ViewModel 사용    💡 ViewModel 이란 ?  AAC(Android Architecture Components) 중 하나로 UI 관련 데이터를 저장하고 관리해 주는 역할을 한다. 액티비티와 생명주기를 동일하게 가져가기 때문에 remember 사용하지 않아도  데이터를 유지 할 수 있다.  UI와 컨트롤러가 분리되어,  관심사 분리 를 통한 코드의 유지보수가 용이하다.  프래그먼트  간의  데이터 공유 가 쉬워진다.     3) Compose ViewModel 사용 이번에는 Compose에서 제공하는 ViewModel을 사용한다. setContent 내에서 사용할 수 있다. 위의 2번에서 ViewModel을 사용해 데이터 유지를 할 수 있었으나, ViewModel의  멤버 변수를 조작 한다는 문제가 발생한다. 따라서, 본 데이터를  private  으로 선언하고 Compose에서 추적할 수 있는 State형의 데이터를 하나 생성하여, Getter 처럼 사용할 수 있게 한다.  또한, changeValue 라는 메서드를 만들어서 View에서는 값이 바뀌는 내부 동작에 대해서는 몰라야 하는  관심사 분리 를 만족한다.      [출처]   https://growup-lee.tistory.com/entry/Android-Compose-State-관리 https://www.charlezz.com/?p=45464   Compose에서 RecyclerView를 사용하다가 Native하게 RecyclerView를 사용하려고 하다 보니 엄청 어렵게 느껴졌다..  ✏️ RecyclerView란? 개발자가 각 항목의 모양을 정의하고, 대량의 데이터 목록을  동적으로 표현 해주는 뷰, ListView에 비해  재사용성 ✏️ RecyclerView를 구현하기 위한 순서 RecyclerView를 배치할 레이아웃 생성 목록 아이템 View 생성 목록에 보여줄 값 데이터 클래스 생성 목록을 관리할 커스텀 어댑터 생성 액티비티(프래그먼트)에서 어댑터 생성 및 연결 1. RecyclerView를 배치할 레이아웃 생성 recyclerView.layoutManager에 레이아웃 매니저를 할당한다. 어떻게 정렬 할지에 따라 어떤 레이아웃 매니저를 할당할지 선택한다.  LinearLayoutManager : 1차원 목록으로 정렬한다.  GridLayoutManager : 2차원 그리드로 정렬한다. 2. Item View 생성 오준석의 안드로이드 생존코딩 샘플에서는,  각 항목마다 TextView를 두개 가지는 아이템 을 정의하였다. 3. 목록에 보여줄 데이터 클래스 생성 4.  커스텀 어댑터 생성 Adapter, ViewHolder 클래스를 구현하여 데이터 표시 방식을 정의한다. Adapter : 필요에 따라 ViewHolder 객체를 만들고, 뷰에 데이터를 설정 →  이를 binding이라고 함 어댑터를 구현할때 RecyclerView.Adapter을 상속받으며 세개의 메소드를 재정의해야 한다.  getItemCount() : 아이템의 개수를 가져온다.  onBindViewHolder() :  항목 뷰에 데이터를 연결한다.  onCreateViewHoder() : 항목에 사용할 View을 생성하고 ViewHoder을 반환한다. ViewHolder : 목록에 있는 개별 항목의 레이아웃을 포함하는 View의 래퍼 5. 액티비티(프래그먼트)에서 어탭터 생성 및 연결 이 코드에서는 어댑터를 생성하면서  콜백 메서드를 인자 로 보내고 있다. 전달되는 콜백 메서드는 todo라는 인자를 받았을 때 viewModel.selectedTodo에 할당하고, 캘린더뷰가 있는 프래그먼트로 화면 전환 한다는 메서드이다.  [출처]   [안드로이드 코틀린] 리사이클러뷰(RecyclerView) #1 구현하기 소프트웨어 개발은, 늘 그랬듯이  최소한의 비용 [재사용성] ,  [유지보수] ,  [효율적] ,  [생산적]  이라는 말은 개발에서 뗄레야 뗄 수 없는 단어가 되었다. 설계할 때 지금 당장 갖고 있는 문제를 해결해야 할 뿐 아니라, 나중에 생길 문제나 추가된 요구 사항도 수용할 수 있도록 해야 하고, 이전의 코드를 재사용하여 생산성을 높이는 일도 해야하고.... 개발자들은 이러한 문제들에 대해 늘 어떻게 하면 해결할 수 있을지 고민해 왔다. 디자인 패턴  기존 환경 내에서 반복적으로 일어나는 문제들을 어떻게 풀어나갈 것 인가에 대한 일종의 솔루션  모듈의 세분화된 역할이나 모듈들 간의 인터페이스 구현 방식을 설계할 때 참조할 수 있는 전형적인 해결 방식 어떠한 클래스, 라이브러리를 지칭하는 것이 아닌  전체적인 구조 를 의미한다. 디자인 패턴은 설계자로 하여금,  재사용 이 가능한 설계는 선택하고  재사용 을 방해하는 설계는 배제하도록 도와준다. 또한 패턴을 쓰면 이미 만든 시스템의  유지보수 나  문서화 도 개선할 수 있고,  클래스의 명세 도 정확하게 할 수 있으며,  객체 간의 상호작용 또는 설계 의도 까지 명확하게 정의할 수 있다. GoF(Gang of Fout) 디자인 패턴 1995년,  GoF (Gang of Four)라고 불리는 Erich Gamma(에리히 감마), Richard Helm(리차드 헬름), Ralph Johnson(랄프 존슨), John Vissides(존 블리시디스)가 처음으로 디자인 패턴을 구체화 하였다.   생성 패턴 ,  구조 패턴 ,  행위 패턴 1.  생성 패턴(Creational Pattern) 생성 패턴은  객체의 생성 과 관련된 패턴이다. 객체의 인스턴스 과정을 추상화하는 방법으로  객체의 생성과 참조 과정을 캡슐화 하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록 하여  프로그램에 유연성 을 더해준다.  생성 클래스 패턴 은  객체를 생성하는 일부를 서브클래스가 담당 하도록 하며,  생성 객체 패턴 은 객체 생성을 다른 객체에게 위임한다.   2.  구조 패턴(Structural Pattern) 구조 패턴은  클래스나 객체들을 조합해 더 큰 구조로  만들 수 있게 해주는 패턴이다.  구조 클래스 패턴 은 상속을 통해 클래스나 인터페이스를 합성하고,  구조 객체 패턴 은 객체를 합성하는 방법을 정의한다.   3.  행동 패턴(Behavioral Pattern) 행위 패턴은 클래스나  객체들이 서로 상호작용  하는 방법이나  어떤 태스크, 어떤 알고리즘을 어떤 객체에 할당하는 것이 좋을지를 정의하는 패턴 이다. 즉, 객체나 클래스의 교류 방법에 대해 정의하는 것이다. 행위 패턴은 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 그들 간의 결합도를 최소화 할 수 있도록 도와준다.  행위 클래스 패턴  은 상속을 통해 알고리즘과 제어 흐름을 기술하고,  행위 객체 패턴 은 하나의 작업을 수행하기 위해 객체 집합이 어떻게 협력하는지를 기술한다. https://gmlwjd9405.github.io/2018/07/06/design-pattern.html https://readystory.tistory.com/114 https://4z7l.github.io/2020/12/25/design_pattern_GoF.html https://velog.io/@evergreen_tree/Android-Call-Back-%EB%A9%94%EC%84%9C%EB%93%9C%EB%9E%80    이벤트 리스너를 사용하거나 나 비동기 처리를 하는 경우 콜백 함수가 필요한 상황이 생긴다. 위 그림에서 보다시피,  “버튼 클릭이 일어났을 때”  사용자가 지정한 동작이 일어나야 하기 때문이다. 해당 글의 코드는 임의로 작성한 것이고, 절대로 실제 내부 코드와 일치하지 않음을 알립니다. 1. Listener 구현  Listener  :  뷰 에서 발생하는 이벤트에 대해 작업을 처리해 주는 곳 OnClickListener →   클릭에 대한 작업을 처리 해 주는 곳, MouseMotionListener →  마우스 동작에 대한 작업을 처리 해 주는 곳을 말할 것이다. Listener는 작업을 처리해 주는 곳이니까,  어떤 작업을 처리하는 지 명시 해야 할 것이다.  또한, 어떤 개발자가 어떤 작업을 처리하려고 할 지 모르기 때문에,  인터페이스   2.  setOnClickListner 구현   뷰에는 리스너의 구현체를 저장할 변수 mOnclickListener를 선언한다. 3. 이벤트 등록 및 테스트 여러 방법이 있지만, 가장 정석적인 방법 두가지로 이벤트를 등록하려고 한다. 1. Listener를 상속받은 클래스 구현   2. 무명 클래스를 사용하여 구현   인터페이스의 구현체, 즉 인터페이스의 메서드들의 동작을 구현하여 전달함으로써, Button 클래스는 클릭 명령을 받았을 때  구현체의 onClick을 호출하면 된다. 버튼을 클릭한다고 가정하는 userClick()   https://drcode-devblog.tistory.com/193   이전 포스팅에 이어서 프래그먼트 생명주기를 정리해 보았다. 액티비티와 별개로 자체 생명 주기를 가지고 있지만, 액티비티의 생명주기와 유기적으로 연관되어 있다. 1. onAttach()  프래그먼트가 액티비티에 붙을 때 호출  인자로 Context가 주어진다.  프래그먼트가 액티비티의 호출을 받아 생성  Bunddle로 액티비티로부터 데이터가 넘어옴   UI 초기화는 불가능   레이아웃 inflate 담당  savedInstanceState로 이전 상태에 대한 데이터 제공  View와 관련된 객체를 초기화 할 수 있음  onCreagteView()를 통해 반환된  View 객체는 onViewCreated()의 파라미터로 전달  된다.  이 때 Lifecycle이  INITIALIZED 상태로 업데이트 가 됨  때문에  View의 초기값 설정, LiveData 옵저빙, RecyclerView, ViewPager2에 사용될 Adapter 세팅은 이 메소드에서 해주는 것이 적절함  저장해둔 모든 state 값이 Fragment의 View의 계층 구조에 복원되었을 때 호출 ex) 체크박스 위젯이 현재 체크되어있는가  View lifecycle owner :  INITIALIZED → CREATED  변경  사용자에게 보여질 수 있을 때 호출  Activity의 onStart() 시점과 유사  Fragment의 childFragmentManager을 통해 FragmentTransaction을 안전하게 수행할 수 있음  View lifecycle owner :  CREATED → STARTED  변경   사용자와 프래그먼트가 상호작용 할 수 있는 상태일 때 호출  Fragment가 보이는 상태에서 모든 Animator와 Transition 효과가 종료되고, 프래그먼트와 사용자가 상호작용 할 수 있을 때 onResume Callback   Fragment가 visible 일 때 onPause()가 호출  이 때  Faragment와 View의 Lifecycle이 PAUSED가 아닌 STARTED가 됨  Fragment가 더 이상 화면에 보여지지 않게 되면 onStop() 콜백 호출  부모 액티비티, 프래그먼트가 중단될 때, 상태가 저장될 때 호출  View와 Lifecycle :  STARTED  →  CREATED  API 28버전을 기점으로 onSaveInstanceState() 함수와 onStop() 함수 호출 순서가 달라짐, 따라서  onStop()이 FragmentTransaction을 안전하게 수행하는 마지막 지점 이 됨   모든 exit animation, transaction이 완료되고 Fragment가 화면으로부터 벗어났을 경우 호출  view와 lifecycle :  CREATED → DESTROYED  가비지 컬렉터에 의해 수거될 수 있도록  Fragment View에 대한 모든 참조가 제거되어야 함  getViewLifecycleOwnerLiveData()   Fragment가 제거되거나, FragmentManager가 destroy 됐을 경우, onDestroy() 콜백 함수가 호출  Fragment Lifecycle의 끝을 알림   프래그먼트가 액티비티로부터 해제되어질 때 호출된다. https://asong-study-record.tistory.com/69 https://developer.android.com/guide/components/fragments?hl=ko 어디에서나 찾아볼 수 있는, 흔하디 흔한 내용이지만 생명주기를 이해하고 있어야 리소스 해제와 할당 작업을 적절히 처리하여 리소스 낭비를 줄일 수 있다. 다른 블로그에서 설명히 자세히 나와있기에 역할에 대한 간단한 설명만 남기겠다.   1. onCreate()   앱이 실행될 때 최초로 실행되는 콜백  변수, 객체 초기화 가능  savedInstanceState를 활용하여, 보류되었던 값 가져올 수 있음   onCreate() 콜백이 실행 된 다음 실행되는 콜백  액티비티가 사용자로부터 상호작용 받을 수 있도록 준비   onStart() 콜백이 실행 된 다음 실행되는 콜백  특정 이벤트가 발생하여 포커스가 떠나기 전(onPause 전) 까지 현재 단계에 머무르면서 사용자와 상호작용을 주고받음   앱이 일시정지 되었을 때 실행되는 콜백  포커스가 앱을 떠났을 경우, 백그라운드 상태가 되었을 경우   포그라운드 상태가 아니면 필요 없는 기능이나 리소스를 정지  시키거나 해제할 수 있음   앱이 중단됨 상태일 때 호출되는 콜백  포그라운드 상태가 아니면 필요없는 기능들을 해제시켜줄 수 있음   앱이 백그라운드에 있다가 다시 시작하기 전에 바로 호출됨  바로 다음 onStart() 호출  앱이 완전히 소멸될 때 최초 한번 실행되는 콜백   앱에 의해 종료 호출되는 경우, 화면 회전하는 경우, 사용자에 의해 종료되는 경우 호출  소멸 전 리소스 해제를 처리해야 한다. https://brunch.co.kr/@mystoryg/80   Observe 패턴이나 이벤트 리스너 등, Callback의 쓰임이 앞으로도 많을 것 같아서 포스팅하면서 내용을 정리하려 한다. 콜백 메서드의 정의) 1. 다른 함수의 인자로써 이용되는 함수(고차 함수) 2. 어떤 이벤트에 의해 호출되어지는 함수 고차함수 인자로 전달)   (받을 함수의 인자) -&gt; (받을 함수의 반환 타입) 형식을 사용한다. 람다 식을 인자로 전달)   람다식은 이름 없는 함수로, 사용 방법은 다음과 같다. 1) 정식 포맷  val sum : (Int, Int) → Int = {x, y → x+y} 2) 스마트 캐스트로 인해 간결해진 코드  val sum = {x: Int, y: Int → x+y} 다시 본 코드로 돌아가면, void 타입을 반환하고 String을 인자로 받는 함수가 function의 인자로 들어가게 되고,  그러나 위의 예제들은, 순차적으로 위에서 부터 실행하는 순차적인 코드로, 콜백이 아니더라도 만들 수가 있다.  하지만 ** 이벤트 리스너나, 비동기 프로그래밍**에서는 비 순차적인 함수 호출이 일어날 수 있다.  https://velog.io/@evergreen_tree/Android-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A6%AC%EC%8A%A4%EB%84%88%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EC%9E%90 https://satisfactoryplace.tistory.com/18 Retrofit을 통해 API 인터페이스를 호출 가능한 객체로 바꾸는 과정에서 당연하게 사용하던 :: 심볼에 대한 궁금증이 생겼다..    retrofit.create(UserApi::class.java) .java 리플렉션 :: 기호는 리플렉션을 의미한다. ** 클래스 리플렉션   className:class  ** ** 인스턴스를 통한 클래스 리플렉션  instanceName:class  ** 클래스 리플렉션을 바로 불러오거나, 인스턴스를 통해서 가져올 수 있다. 리플렉션은 레퍼런스 객체를 통해서 참조할 수 있는데, 아래와 같이 사용하면 된다.  val kClass: KClass&lt;out className&gt; = className::class ex)  kClass.isAbstract   kClass.memeberProperties 그래서 .java는 뭔데? * 코틀린에서 쓰는 클래스와, 자바에서 쓰는 클래스는 다르다! 하지만 걱정할 필요는 없다.    위 메서드는, KClass의 확장함수이고, .java를 이용해 자바 클래스 타입을 반환한다.  즉, .java를 이용하여 KClass로부터 자바 클래스 값을 받아올 수 있는 것이다. 정리하자면, retrofit의 create() 함수의 인자로 자바 클래스 값을 넘기기 위해, 코틀린 리플렉션의 자바 클래스 타입을 얻어온다고 말할 수 있다. 참고 블로그  https://sabarada.tistory.com/190 https://yoon-dailylife.tistory.com/46 Compose에 대해 알아보기 전에, 왜 Compose가 등장했고 사용해야 하는지에 대해 말해보려 한다. 명령형 프로그래밍 xml 에서 UI를 선언하고, 그 후  xml 에서 UI 속성을 조작하거나,  Class 에서 findViewById나 ViewBinding을 통해 속성을 조작하였다. 이러한 방식을 ** &quot;명령형 프로그래밍&quot; **이라고 부른다.      명령형 프로그래밍을 사용하여 UI를 제작하게 되면 다음과 같은 단점이 발생한다. 1. 보일러 플레이트 코드의 증가 예를 들어 뷰를 100개 만들었다고 하자, 이렇게 되면 findViewById 코드를 100개 만들고 그에 대한 이벤트도 각각 처리해야 한다. 즉, ** 보일러 플레이트 코드 ** 가 많아지게 된다는 의미이다. 뿐만 아니라, 의도하지 않는 UI를 만들거나 정의하게 될 수도 있다.  보일러 플레이트 코드?  최소한의 변경으로 여러 곳에서 재 사용되며, 반복적으로 비슷한 형태를 띄는 코드 2. 생산속도의 저하 액티비티와 xml을 오가면서 작업하게 되면 효율성이 떨어질 수 밖에 없다. 또한, 개발자가 getter와 setter을 통해 내부 동작을 만들고, 그 과정에서  실수 가 발생하거나  불필요한 코드 Jetpack Compose Library  https://developer.android.com/jetpack/compose?hl=ko  선언형 프로그래밍?  필요한 것을 달성하는 과정을 하나하나 기술하는 것보다  필요한 것이 어떤 것인지 기술하는 데 방점 을 두고 애플리케이션의 구조를 세워 나가는 프로그래밍 구조 XML 레이아웃을 수정하거나, Layout Editor를 사용하지 않고 단지 Jetpack Compose 함수를 호출하여 원하는 요소를 말하면 Compose 컴파일러에서 나머지 작업을 완료한다. 장점) ** Less Code ** : 적은 수의 코드로 더 많은 작업을 하고 버그 클래스를 방지함으로써 코드가 간단하고 유지 관리가 쉽다. ** Intuitive ** : 원하는 요소를 말하면 Compose 컴파일러에서 처리하고, 앱 상태가 변경되면 UI가 자동 업데이트 된다. ** Accelerate Developement ** : 기존 코드와 호환되고, Android Studio에서 실시간 미리보기를 지원한다. ** Powerful ** : Android 플랫폼 API에 직접 액세스하고, 머터리얼 디자인, 테마, 애니메이션 등을 지원하는 앱을 만들 수 있다. Compose를 활용한 프로젝트 세팅  https://developer.android.com/jetpack/compose/setup?hl=ko#kts     에러)  error: failed to push some refs to &#39;https://github.com/EvergreenTree97/kotlin-exercise.git&#39;    소스트리를 사용하여 코틀린 프로젝트를 깃에 푸시하다가 갑자기 이러한 에러가 발생했다.   원인) **   local의 데이터  와  github 저장소에 있는 데이터 가 일치하지 않을 때 발생한다.**   필자같은 경우에는 프로젝트를 푸시하기 전에 깃허브에서 리드미를 수정했었다. 결국 로컬에 있는 리드미의 내용과 github 저장소에 있는 내용이 달라서 해당 오류가 발생했다. error)  FloatingActionButton 의  tint 속성 해결 방법)    android:tint=&quot;@color/white&quot;   android:  -&gt;  app:으로 바꿔주면 된다.  app:tint=&quot;@color/white&quot;   이유가 무엇인가?   android라는 접두어 를 통해 접근할 수 있다는 의미이다.  http://daplus.net/android-%EC%99%9C%EC%9D%B4-%EC%A4%84-xmlns-android-http-schemas-android-com-apk-res-android%EA%B0%80-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-xml-%ED%8C%8C%EC%9D%BC%EC%97%90/  xmlns:android xmlns:app xmlns:tools  : 안드로이드 스튜디오의 디자이너 도구 등에서 화면에 보여줄 때 사용된다.(앱이 실행될 때는 적용되지 않음)  com.google.android.material.floatingactionbutton.FloatingActionButton   안드로이드 디자이너에서  오른쪽 어트리뷰트 에 있는 tint 속성에 값을 넣으면 android:tint에 설정이 적용되기 때문에 바뀌지 않는다. 플로팅액션버튼은 외부 라이브러리에서 참조하기 때문에, app:tint 속성을 사용함으로써 tint 속성이 적용되지 않는 것을 해결할 수 있다.   CSS는 어디부터 어디까지를 배워야 할 지 모르겠어요! CSS in JS, TailwindCSS 이런 것들을 쓰고 있는데 글을 읽다보면 CSS 자체를 잘 알아야 한다는 글이 있어요. 그냥 CSS를 잘한다는 것은 어떤 것일까요? 이번 글에서는 위 질문에 대한 정확한 답은 아니겠지만 CSS에서 알아야 할 내용과 그리고 내가 얼만큼 알고 있는지에 대한 자가진단을 할 수 있으면 좋지 않을까 해서 실무에서의 중요도와 함께 알려드리면 좋을 것 같아서 작성해보았습니다. 프롤로그 요즘의 개발환경에서 당연히 순수 CSS를 가지고 작성을 하는 경우는 드뭅니다. CSS는 프론트엔드에서 중요한 영역이긴하지만 학습에 있어서 큰 비중을 차지하고 있지 않고 있습니다. 최근에는 mui나 antd와 같이 완성형 컴포넌트도 잘 나오는데다가 CSS를 그냥 쓸 일이 없다보니 대부분 부딫혀가며 CSS를 실무레벨에서 필요한 것들 위주로 배우게 되는 것 같아요. 이러한 방법은 좋은 접근이라고 생각합니다. CSS의 모든 것을 알 필요도 없고 실무에서 쓰이는 것은 한정적이니까요. 또한 CSS는 예전에 만들었던 방식을 버릴 수가 없기에 지금은 사용하지 않아도 되는 구 스펙들을 다 알 필요도 없긴 합니다.  다만  내가 알고 있는데 안쓰는 거랑 몰라서 안쓰고 있는 것은 다르기에  CSS를 깊게 파지는 않더라도 어떤것들이 있는지 정도는 알면 좋은데 막상 deep dive를 하기에는 방대한 양으로 인해 또 부담이 되는 것이 사실입니다. 그래서 CSS도 한번 공부를 해봐야겠다고 생각하는 분들을 위해서 한번 나는 어떤 것들이 부족한지 어떤것을 공부해야 할지 어떤것이 중요한지 어떤것들은 그렇게 중요하지는 않는지 한번 정리를 해봤습니다. 학습을 하실때 알면 좋은 팁!  🔥  난이도와 중요도는 별개입니다. 착각하기 쉽습니다. 어렵다고 중요한게 아닙니다!  사실 모든걸 다 알 필요는 없습니다. 실무에서는 중요한것만 반복해서 쓰기 때문에 핵심 20%만 알아도 필요한 것들은 다 할 수 있습니다.  (대신 그 핵심이 뭔지를 알려면 다 알긴 해야한다는게 함정)  CSS는 같은 화면은 여러가지 방법으로 만들 수가 있습니다. 그렇기에 같은 방법을 여러개를 찾아보고 그중에서 을 선택하시면 됩니다. (이 과정은 끊임없이 최신식으로 업데이트가 되어야 합니다!) 사용되는 기호의 의미 중요도를 알면 그렇다면 조금더 전략적으로 학습을 하는데 도움이 되지 않을까 싶어서 이후 나올 자가진단 목록에는 실무에서의 중요도를 표기하기 위해서 아래와 같은 기호들을 붙여두었습니다.   자가진단 START! 나는 과연 CSS에 대해서 얼마나 알고 있을까요? 각 항목에 대해서 로 한번씩 체크를 해보시면 내가 어떤 것을 공부해보면 좋은지 어느정도 알고 있는지 알 수 있을 거라고 생각합니다. 주의: 현재 진단문장의 내용이 일관성이 없습니다.😅 원래 의도는 property를 감추고 상황에 맞는 property나 혹은 CSS 코드를 떠올릴 수 있기를 바랬습니다. 모든 property에 대해 퀴즈나 상황형식으로 만드는게 쉽지 않네요. 주의2: 출처나 참고자료 같은거는 없습니다. 제 주관적으로 작성된 내용이라는 점 다시 한번 알려드립니다. CSS 입문  🔰    a의 target attribute가 &quot;_target&quot;인 노드만 스타일을 적용할 수 있다. CSS 이론  😎    아래 코드가 무슨 의미인지 안다. CSS Selector  🔥    :root를 알고 있다. CSS Value  😎    rem을 알고 있다. 색상  😎    svg의 색상을 글자 색상으로 바꿀 수 있다. CSS Box Model  🔥    border와 outline의 그려지는 차이를 알고 있다. Box 꾸미기  😎    스크롤시 배경이미지를 고정하는 CSS 효과를 줄 수 있다. 🔥 flexbox 레이아웃 (제일 중요!)  😎    flexbox에서 컨텐츠의 원본크기를 유지하는 방법을 알고 있습니다. 레이아웃(grid)  🤔    grid-area를 이용해서 사이트 레이아웃을 작성할 수 있다.     반응형 크기  🔥    aspect-ratio를 알고 있다.  😎    미디어 쿼리 없이 적절한 반응형 크기를 만들어 낼 수 있다. calc()  🔥    calc를 실전에서 사용해본적이 있다. 글자  😎 writing-mode: 텍스트의 행을 가로 또는 세로로 배치할지 여부와 다음 행이 흐르는 방향을 정의합니다 Text  🔥    띄어쓰기나 줄바꿈을   🤔    margin-block- , padding-block-  🤔    margin-inline- , padding-inline- 에 대해 알고 있다. Text Overflow  🔥    가운데 부분만 ... 말줄임을 할 수 있다. Overflow와 스크롤  🔰    스크롤바를 원하는 모양으로 변경할 수 있다. scroll snap  😎    어떤 점이 css로 scroll snap이 js보다 좋은지 어떤 점이 반대로 어떤 점이 한계인지 설명할 수 있다. overscroll-behavior  😎    중복된 scroll이 있을때 부모 스크롤까지 이동해버리는 현상을 막을 줄 알다. 링크  🔰    이미 방문한 링크의 스타일을 변경할 줄 안다.         목록  🤔    목록의 모양에 이미지를 적용할 줄 안다. Table  😎    tr와 td의 스타일링 차이를 알고 있다. 레이아웃(기타)  🤔    글을 2단, 3단으로 나눌 줄 압니다. Overlay https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Fundamental_Layout_Comprehension      Animation  😎    codepen등에서 css animation 샘플을 보면 적절히 응용해서 내 프로젝트에서 넣을 줄 안다. CSS Reset  🔥    reset에 쓰이는 style의 의미를 알고 있다.     미디어 쿼리  🔥    다크모드 대응을 할 줄 안다. Mobile  😎 모바일 디바이스에서만(반응형X) CSS를 적용되게 할줄 안다. Chrome Dev Tool  😎    :hover, :active 등의 조건이 걸린 스타일을 확인 할 줄 안다.     클린코드  🔥    나만의 style을 분리하는 원칙이 있다. CSS 방법론  🤔    OOCSS, SCMASS, PRECSS, .. 뭐 아무튼 옛날 방법론등을 알고는 있다. 현대 CSS를 다루는 방법  🔥    TailwindCSS, AdorableCSS와 같은 Atomic CSS 방식을 쓸 줄 안다. CSS Variable  🔥 어떤 값들을 css variable로 만들면 좋을지 알고 있다. 끝으로... 가벼운 마음으로 작성을 시작했던 내용들이 쓰다보니 &#39;아... 맞다 이것도 있었지?&#39; 이런식으로 조금씩 늘어나다보니 꽤 길어졌네요. CSS를 다룰때 제일 중요한 컴포넌트와 디자인 시스템에 관련된 항목은 일부러 제외하고 일단 최대한 순수 CSS에 초첨을 맞춰 봤습니다. 놓친게 있다면 댓글로 알려주세요. 막연히 내가 알고 있는 CSS의 능력을 이런식으로 하나씩 체크하면서 생각을 하다보면 객관적으로 내가 어떤것을 잘 모르고 있고 어떤것을 잘 알고 있는지 알 수 있는 계기가 되었으면 좋겠습니다. 그래서 이 글이 내가 무엇을 공부해할지 어떤 것들은 나중에 해도 되고 어떤 것들은 조금 더 살펴보면 좋을 지 이정표의 역할을 할 수 있었으면 좋겠습니다. 생각이 날때 마다 조금씩 해당 리스트를 정제하고 또 업데이트해서 CSS를 공부하려고 하는 분들에게 제대로된 이정표와 같은 역할을 할 수 있기를 바래봅니다. 이 글이 그래도 나를 한번 챙겨보고 혼자 공부하게 될 CSS의 로드맵을 정하는데 도움이 되기를 바랍니다. 감사합니다. ❤️ CSS로 출판제안을 받아서 한번 작성을 했었지만 여러사정으로 출판 프로젝트가 부러지면서 완성되지 못한  원고 (가 아니라 메모)를 보면서 이 메모들은 개인 메모로만 남을 것 같아 아까운 마음에 완성되지 않은채로라도 일단 공개를 하려고 합니다. 조금씩 완성도를 올려서 블로그에 올릴까 했지만 이미 블로그에 올라간 내용과 중복된 내용들도 많고 출판 프로젝트가 부러지면서 살짝 동력을 잃은 관계로 손이 잘 안가더라구요. 그래도 CSS를 학습을 하고자 하는 사람들에게는 대략적인 학습 방향성이나 구조 그리고 인사이트 까지는 얻을 수 있지 않을까 하는 생각에 미완성된 메모이나 도움이 되지 않을까 싶어서 공유해봅니다. 주의: 이 글은 차마 완성이 되지 못한 비운의 원고입니다. 완성도가 박살나있는 글이니 정독보다는 유투브 2배속 마냥 휙휙 넘겨가며 읽어주세요. 😅😆😜🤫 머릿말 웹은 태초에 문서를 공유하기 위한 용도로 시작했습니다. 그러다 보니 문서를 조금 더 잘 보여주기 위해서 디자인적인 요소들이 가미되었고, 어느순간 HTML에는 디자인과 컨텐츠가 뒤섞여 아주 복합한 형태가 되어 버렸습니다. CSS는 문서에서 컨텐츠와 서식을 분리하고자 하는 시도에서 탄생한 언어입니다.  문서를 꾸미기 위한 목적에서 만들어진 CSS이지만 웹은 문서에만 그치지 않고 사용자와의 인터렉션을 통해 웹 서비스로 웹앱으로 발전을 하게 되었습니다. 그러다 보니 CSS의 역할이 필요 이상으로 커지게 되었고 문서를 만드는 방식을 온갖 방법으로 응용하여 화면을 만드는 자기들만의 방법들이 난무하기 시작했습니다. 당시 표준은 아니지만 표준이었던 인터넷 익스플로러의 6, 7, 8등 버전마다 다른 CSS 동작방식들로 하여금 웹 표준이라는 것들이 만들어지면서 CSS는 겨우 발전을 시작 할 수 있었습니다. CSS와 웹이 과도하게 성장을 하면서 겪는 성장통을 겪으면서 필요한 스펙들을 만들어 보았지만, 웹은 이렇게 한번 만들어진 스펙을 버릴 수 없기 때문에 어떤 부분은 좋고 어떤 부분은 부족하고 어떤 부분은 해결된 채로 어떤 부분은 아직도 계속 방법을 찾아내는 중으로 계속 변하고 있습니다. 웹은 점점 거대 산업으로 발전을 하게 되면서 HTML, CSS 등을 배우려고 하는 사람들도 굉장히 많아졌습니다. 그러다 보니 학습컨텐츠가 시대를 따라잡지 못한 채 계속 확대 재생산되면서 이제는 잘 쓰이지 않는 예전 방식를 공부한다거나 예전에는 중요했지만 지금은 중요해지지 않은 부분들이 여전히 중요한 것 처럼 설명되고있어 현재와는 맞지 않는 괴리감이 느껴집니다. CSS가 어려운 점 하나로 알려진 &quot;같은 화면을 만들 수 있는 수많은 방법들이 존재한다&quot;는 문제점은 입문자나 초보자들에게는 어떤 것이 더 나은 방법인지를 모르게 합니다. 그냥 화면이 나오는 것에 만족을 하고 예전의 방식을 그대로 학습하게 됩니다. 다행히(?) CSS의 스펙이 변화하는 속도는 점점 줄어 들고 있지만, 같은 스펙을 가지고도 사람들이 같은 화면을 어떻게 하면 더 효율적으로 만들 수 있는지 어떤 식으로 CSS를 관리를 하면 좋을지 방법론등에 대해서는 예전보다 더 많이 발전을 하고 있는 상태입니다.  그래서 저는 여러분이 기본적으로 학습한 CSS의 스펙을 실제로 사용하는 방법들 가운데 2022년 지금 시대에 맞는 연구가 된 트렌드한 방법을 알려드리고 싶었습니다. 어떤 것들은 제가 연구한 방법으로 다소 주관적일수도 있는 부분들은 근거를 들어 왜 좋은지도 설명을 함께 드릴 예정입니다. 아울러 왜 이렇게 하는게 더 좋은 방법이 되었는지 간단한 역사와 내용을 짚어 볼 생각입니다. 흐름을 이해하고자 알려드리는 이야기이기 때문에 지나간 방법에 대한 자세한 기술적인 이야기는 일부러 하지 않을 생각입니다. 15년 넘게 발전한 CSS의 내용 중에서 지금 당장 필요한 것들만 최대한 추려서 제가 생각하는 지금의 Best Practice를 공유하려 합니다.  이 책이 현대 CSS의 체계를 빨리 이해하는데 도움이 되기를 바랍니다.   목차  CSS가 어려워진 이유 CSS가 어려워지는 이유 나만의 Best Practice가 필요하다!  CSS의 역사를 배워보자.  CSS Selector 이야기  Specify War!  Selector가 복잡해진 이유  Selector가 단순해진 이유  이름짓기는 어려워! CSS 방법론  🔥 시멘틱한 단순한 이름: BEM 컨벤션이 필요한 이유? Block__Element--Modifiter 단순함의 미학  🔥 직관적인 비주얼한 이름: Atomic CSS mt10은 좋은 CSS일까? 시멘틱에 밀려나다... 왜 다시 Atomic인가?  CSS Reset  옛날 방식은 밀어버리자! * { margin:0; padding: 0;} 🔥 box-sizing: border-box img { display: block; max-width: 100%; } * { font: inherit; color: inherit } * { flex-shrink: 0} button { border: 0; } table { border-collapse:collapse; border-spacing:0;}  CSS Property CSS 스펙 학습이 어려운 이유1 - 사전식 나열과 중요도 없음 CSS 스펙 학습이 어려운 이유2 - 레이아웃의 과도기적 발전 실제로 관련이 있는 것 끼리 묶어서 생각하자  https://9elements.com/css-rule-order/ 일단은 레이아웃과 레이아웃이 아닌것으로 분리하는 것이 시작! CSS Property 순서 컨벤션 잘 안쓰이는 것은 나중에 공부하자.  레이아웃이 아닌것  글자 🔥 font: Font에서 쓰이는 용어와 시각화 letter-spacing line-height text-align  색상 color background-color border-color svg와 currentColor  테두리 border border로 삼각형 그리기 border-radious border-radious로 원 그리기 CSS Battle  그림자 box-shadow box-shadow로 만드는 디자인 text-shadow  배경 background cover vs contain object-fit 과  &lt;img&gt;  tag를 써야 할 때 background: fixed  투명도 opacity  Effect(투명도, 필터, ....) transform (translate는 뒤에 레이아웃에서 다시 한번 자세히 다룰예정) filter backdrop-filter  레이아웃 I  들어가기 전에... 🔥 레이아웃이 어려운 이유 🔥 margin을 쓰지 말자! [부록] margin을 써야 할때...  🔥 Flexbox 시각적으로 스펙을 이해하자. (with figma AutoLayout) row vs column / hbox vs vbox align-items / hbox(top) vs vbox(left) / align-items는 stretch를 가지고 있다! justify-content / hbox(right) vs vbox(bottom) / justify-content는 space-between을 가지고 있다! gap padding  🔥 Flexbox 실전! Flexbox로 생각하기. 레이아웃 분할 자르기! 연습 과제  Grid Grid와 Flex의 차이점 Grid가 더 최신 스펙인데 Flex대신 Grid로만 레이아웃이 가능할까? (flex는 대체 불가!) 언제 Grid를 써야 하는가?  레이아웃 (Overlay)  Position absolute relative fixed sticky  Layer  Z-index  고급 Position, 퍼센트, vh... margin, top, left, transform 뭐가 다를까? %와 절대값을 잘 섞어 쓴다. calc까지!  Overflow (scroll, ellipsis, line-clamp, ...)  자르는 것 (clip)  text와 함께 1줄 말줄임 만들기... 여러줄 말줄임 만들기... (주의 새로운 스펙이 나올 예정입니다!)  이미지와 함께 여러줄 말줄임 만들기... (주의 새로운 스펙이 나올 예정입니다!)  flex와 함께 overflow:auto인 경우에는 flex에서 무한정 늘어나게 된다. 주의!  스크롤 스크롤 만들기(x, y, auto, always) 스크롤 바의 문제 해결 방법 (스크립트) 스크롤 바 스타일링과 한계점  스크롤 스냅 CSS로만 캐로셀 만들기 응용하기  Overflow와 Overlay를 함께 써야할때 (스크립트) Dropdown, Popover  Interaction (cursor, :hover, :active, ...)  Pseudo class (hover, active) Mobile 주의! 뒤에 설명  Pseudo class (hover, active)  Responsive (media query, max-width, ...) media query로 반응형 레이아웃 만들기  Animation (transform, animation, ...) absolute top, left,   CSS Selector Advanced +, ~, &gt; 이 Selector들은 언제 써야 하나?  Mobile CSS hover를 주의해서 쓰자! font-adjust-size touch-call-action user-select:none  잘 안쓰이지만 알아두면 좋은 CSS 글자  https://medium.com/@theAngularGuy/7-amazing-css-properties-you-may-not-know-yet-4f7b67f80644 vertical-align aspect-ratio 1장. CSS가 어려워진 이유 CSS가 어려워지는 이유 웹은 문서를 공유하기 위해서 만들어졌습니다. 그리고 그 문서를 조금 더 잘 보여주기 위해서 서식이 만들어졌습니다. 이러한 서식과 데이터가 복잡하게 공존하게 되면서  서식과 컨텐츠를 분리해야겠다는 의도 에서 CSS가 탄생하게 되었습니다. 초기에는 문서와 서식을 잘 분리해서  보다 적은양의 코드를 통해서 같은 컨텐츠를 다양한 서식을 적용할 수 있도록 발전 을 하였습니다. 그러나 웹 산업이 급격히 발전을 하게 되면서 웹은 단순히  문서 의 역할을 너머  서비스와 어플리케이션 의 형태로 발전을 하게 되었습니다.  문서에서 어플리케이션까지 웹 서비스의 범위가 확장 이 됨에 따라 CSS에도 여러가지 요구사항들이 생겨났고 그에 맞는 여러 가지 좋은 스펙들이 발명이 되었습니다. 또한 그 과정에서 여러가지 시행착오를 겪기도 했었습니다. 특히 문서을 만들기 위해서 시작된 설계를 바탕으로 이후 어플리케이션을 위한 추가 방안을 마련하는 과정이 더욱 그랬습니다.  이렇게 이미 한번 만들어진 스펙은 되돌릴수가 없기에  좋았던 부분과 그렇지 못한 부분들을 우리는 함께 사용하고 있습니다. 또한 당시에는 시대에 맞게 의도대로 설계를 했지만 웹 산업이 급격하게 발전을 하면서 생겨난  새로운 요구사항을 이미 만들어진 스펙이나 설계가 못 따라오는 시기 가 존재했고, 그 안에서 어떻게든 방법을 찾다 보니  의도와는 다른 방식으로 CSS 스펙을 차용 해서 화면을 만들게 되었습니다.  또한 이렇게 우회해서 해결하는 방식들이 Tip에서 출발해 하나의 정석(?) 이 되어 공부를 해야하는 것이 되고 이런것들이 웹 문서로도 커리큘럼으로도 재생산이 되게 됩니다. 그리고 안타깝게도  최초 문서를 위해 설계된 방법들은 여전히 어플리케이션을 제작하기 위한 개념과는 충돌 하는 부분이 존재를 하고 있습니다. 이러한 부분들은 현대 산업에서 덩치가 큰 CSS를 이용한 프로젝트를 안정적으로 유지하게 어렵게 만드는 원인이 되고 있습니다. 그리고 이를 개선하기 위해서 CSS 스펙으로 해결하지 못하는 부분들은 여러가지 도구들을 발명해서 또 해결을 하고자 하게 됩니다. 그러면 또 우리는 이 새로운 도구를 배워야 하죠. 이후  이러한 문제를 해결할 수 있는 새로운 스펙 출시가 되거나 더 나은 방법이 발견이 되면 기존에 찾아냈던 방식들은 전부 좋지 못한 방법 이 됩니다. 그렇지만 예전에 이미 생산된 커리큘럼이나 작성된 내용들은 남아있기에 뭐가 더 나은 방식인지 모른 채 학습을 하게 되죠.  그렇다고 무조건 최신을 따르자니  새로운 스펙이 모든 브라우저에 보편적으로 적용이 되기까지에는 또 시간이 필요합니다.  그러다 보니 특정 브라우저에는 제대로 보이지 않을수도 있기에 무조건 새로운 스펙을 바로 도입할수도 없죠.  그러니 기존의 방식 역시 알고는 있어야 하는 상황이 발생하게 됩니다. 당장의 최신 기술을 쓸 수 없으니 그렇다고 안정성만 추구해 계속 현재의 방법만 고수를 한다면 변화하는  웹 생태계에 따라가지 못한채 낡은 코드와 낡은 패러다임으로 인해 우리의 코드는 레거시가 되게 됩니다.  언제나 더 나은 방법을 찾아내고 개선을 하고자 하는 것이 개발자들이니까요. 그러기에  언제 새로운 스펙으로 갈아탈지  어떤 기능이 나왔는지 어떠한 관점과 기술들이 나왔는지 우리는  꾸준히 관찰을 하고 학습 을 하여  적당한 시기에 더 나은 방법으로 꾸준히 업데이트 를 해나가야만 합니다. 종합하자면, 문서에서 어플리케이션으로 넘어오는 과도기적 시행착오로 인해 CSS 자체가 규모가 큰 서비스를 만들기에 이미 태생적인 문제가 있다는 것이 첫번째 어려움이며, 이를 극복하기 위해 새롭게 만들어지는 스펙들과 도구들이 범람을 하는데 그 중에서 무엇이 좋은지 알기가 어렵고 무조건적으로 최신기술을 선택할 수는 없기에 적절한 기준점을 가지고 적당히 좋은 도구를 적당히 좋은 시기에 꾸준히 업데이트를 해야하는 것이 두번째 어려움입니다. 나만의 Best Practice를 꾸준히 만들어보자! 웹 산업의 분야는 다양하기에 하나의 기술과 패러다임이 정답이 아닙니다. CSS 기술은 항상 시대를 반영해서 발전을 해왔고 내가 홈페이지를 만들고 있는지 솔루션을 만들고 있는지 백엔드 입장인지 프론트엔드 입장인지에 따라서 좋은 방법과 나쁜 방법이 다 달라지게 됩니다.  CSS 역시 어디에서든 통하는 은빛총알 같은 것은 없습니다.  CSS에는 상황에 맞는 여러가지 도구들이 존재하고 있으며 어떠한 도구가 어디에 잘 어울리지는 지 역시 스스로 알아야 하겠지요. 제가 항상 CSS를 알려드릴때 하는 말이 있습니다.  CSS를 잘 하기 위해서는 본인만의 Best Practice를 가져야 된다 고 말입니다. CSS는 JS와는 달리 깊은 이해도 어느 정도 필요하겠지만 그것보다는 숙달이 되어 있는 것이 훨씬 더 중요합니다. 왜냐하면 디자인을 내가 원하는 대로 만들 수 있고 요구하는 디자인을 정확하고 신속하게 만들어줘야 CSS를 잘 한다는 장점을 챙길 수 있기 때문에 CSS는 깊은 이해보다는 상대적으로 연습이 더 중요합니다. 그렇기에 내가 거대한 CSS와 디자인을 잘 다루기 위해서는 반복 숙달이 필요하고 그러다 보면 자기만의 루틴이 만들어지게 됩니다. 이 루틴이라는 것은 좋고 효율적인 걸 가지고 있어야겠죠.  CSS와 브라우저는 계속 성장을 하고 있기에 처음에 배웠던 그 방식이 지금은 최선이 아닐수도 있습니다.  그렇기에 내 도구들을 항상 점검하고 새로운 스펙들을 주시하고 있어야 합니다. 아쉽게도 무조건 최신을 택할 수도 없는 것이,  브라우저는 여러 종류 가 있고  데스크탑과 모바일  그리고  아직 업데이트를 하지 않은 유저 들도 있기 때문에 적절한 밸런스를 잡아야 합니다. 또한 그간 CSS 신문물의 척화비 역할을 하던  IE11의 퇴출이 확정 이 되었고,  CSS에도 JS의 영역이 가세 하면서 CSS의 도구나 패러다임이 업그레이드가 될 예정입니다. 최신 스펙뿐만이 아니라 CSS를 개발하기 위한 좋은 도구들을 꾸준히 바꿔가는 것 역시 우리가 낡은 개발자가 되지 않는 길이기도 합니다. 그러기 위해서 먼저 CSS 역사를 배워보자.   출처: https://github.com/ManzDev/frontend-evolution 어느 분야든  역사를 공부한다는 것은 지금 이것이 왜 이렇게 만들어져있으며 앞으로는 어떻게 될지 방향성을 예측해 볼 수 있는 좋은 공부 가 됩니다. 특히 CSS의 경우 웹 문서로 출발해 홈페이지, 게시판 그리고 현재 웹 어플리케이션으로 넘어가는 과정에서 당시에는 CSS 스펙이 지원하지 않아서 만들어졌던 방법들이나 패러다임의 전환등이 많았기에 CSS를 지금 처음 배우는 사람들 입장에서는 예전과는 다른 환경에 쓰여진 말들이 어느 것이 맞는건지 잘 모르게 되는 경우가 생기게 됩니다. CSS뿐만 아니라 모든 개발의 내용은 필요에 의해 생기고 필요는 그때 당시의 상황을 반영하게 됩니다. CSS의 역사를 이해함으로써 앞으로 CSS 관련 글들을 읽었을때 어떠한 갈래와 패러다임에 해당하는 내용인지 알 수 있는 넓은 시야가 생기는데 도움이 되었으면 좋겠습니다. 또한 앞으로 새로운 스펙이나 도구 기술등이 나왔을 때에도 어떠한 맥락에서 이게 만들어졌는지 이해할 수 있는 단초가 되어 줄거라 생각합니다. 2장. CSS의 역사 https://velog.io/@teo/css-history-1 3장. CSS Selector와 방법론 (역사에서 이미 언급 했으니 그중에서 Selector와 방법론을 중심으로 간단한 리캡과 함께 세부적인 내용을 설명하고 Selector의 종류나 내용에 대한 이론을 추가하는 방향으로 다시 작성해보겠습니다.)  https://wattenberger.com/blog/css-cascade 보통 CSS의 간단한 역사와 소개 그리고 문법을 배우고 나서 맨 처음에 배우는 것이 바로 이 Selector입니다. CSS의 Selector에 대해서 개념적으로 한번 생각을 해보는 시간을 가져볼게요. 워드 프로세서를 상상해봅시다. 내가 원하는 어떤 영역을 드래그 해서 영역을 만들고 그 곳의 색상을 바꾼다거나 크기를 키우는 작업을 할 수 있습니다. 이때 이때 마우스를 누르고 드래그해서 선택 영역을 만드는 이 행위를 컴퓨터에게 시키려면 어떻게 해야 될까요.   HTML에서 태그를 다는 행위가 곧  &lt;div&gt;드래그해서 영역을 만들어내는 행위&lt;/div&gt; 이고 여기에 이름을 붙여둬서 컴퓨터가 찾아 갈 수 있게 해줄 수 있습니다. 어디를 찾아가야 할지 알려주는 주소같은 역할을 바로 Selector라고 합니다. Selector가 복잡해진 이유 초창기에는 4가지의 단순한 Selector만이 존재했습니다. 하지만 점점 Selector는 복잡해졌죠. 왜 그럴까요? 웹 문서가 근본이었던 시절 문서와 디자인이 한데 섞이는게 싫어서 분리를 했다고 앞서 설명을 드렸습니다. 문서란 세부 내용이 잘 변하지 않습니다. 하지만 디자인은 계속해서 변화해 갈 수 있겠죠. 그래서 하나의 컨텐츠에 여러 가지 서식을 적용할 수 있도록 하는 방법이 중요한 아젠다였습니다. 그 당시 그러한 취지의 게시판이나 쇼핑몰 솔루션, 블로그등의 서비스가 유행했다는 사실을 떠올려보세요. 그러다 보니까 HTML을 건들지 않고 CSS만으로 디자인을 잘 하는 법이 중요했습니다. HTML을 변경할 수가 없다보니 내가 원하는 어떤 엘리먼트만 지정하기 위해서는 정교한 Selector가 필요하게 되었습니다. 그렇지 않으면 의도하지 않은 영역이 선택이 되어 버려 원치 않는 결과가 나오게 됩니다.  #navbar &gt; ul &gt; li.foo a[href] { color: red } 더욱이 초창기에는 4개 밖에 없는 Selector를 가지고는 영역을 잘 못 지정하는 경우가 많다보니 정교한 Selector의 요구사항이 늘어나게 되었습니다. 그래서 이 당시에는 Selector를 잘 쓰는 것이 중요했기 때문에 많은 방법의 Selector 사용법을 익히는 것이 중요했습니다. Selector가 단순해진 이유 지금은 어떨까요? 아시다시피 지금은 HTML과 CSS를 프론트엔드에서 작업을 합니다. Ajax가 생겨나면서 HTML을 만들던 백엔드는 이제 데이터만 전달을 하게 되고 HTML의 편집권을 프론트엔드에게 넘겨주게 되었습니다. 그리고 이제는 더 이상 하나의 동일한 컨텐츠에서 여러가지의 스타일을 만들 필요가 적어졌습니다. 예전에는 커스텀을 할 수 있는 것들이 주요한 가치였다면 지금은 하나의 세련된 디자인이 가치를 만드는 세상이 되었습니다. 아직도 네이버 블로그나 티스토리와 같이 테마들을 제공하는 서비스가 있지만 현대에 와서는 미디엄, 브런치, velog등과 같이 아이덴티티가 있는 하나의 디자인을 제공하는 것이 추세가 되었습니다.   누구가 아는 인스타그램을 보세요! 디자인이 곧 아이덴티티입니다. 그러다보니 더더욱 HTML의 편집이 자유로워지고 이는 곧 CSS의 셀렉터를 복잡하게 만드는 것 보다 HTML에 class를 추가하는 편이 더 관리하기가 쉽다는 것을 알게 됩니다.   vs   그래서 더이상 복잡한 Selector를 쓰기보다는 class의 이름을 잘 지어서 붙이는 식으로 발전을 하게 됩니다. 이름짓기는 어려워! CSS 방법론 HTML의 편집권을 가져오면서 이제 복잡한 Selector의 잠재적인 위험에서는 벗어났지만, 웹이 거대해지면서 이름 붙여야 할 것들이 엄청나게 많아지다보니 이 이름을 짓는 것에서 엄청난 어려움에 봉착하게 됩니다. 가뜩이나 CSS의 경우 global scope를 가지고 있는 태생적인 한계로 인해서 모든 이름들은 겹치지 않아야 합니다. 또한 HTML의 계층과 CSS의 계층이 다르므로 이해를 할 수 있는 계층구조를 잘 표현 할 수 있어야 했고 특히 협업을 할때 서로의 이름을 짓는 방법이 달라서 여간 고생이 아니었습니다.   ITCSS, SMACSS, OOCSS, BEM, CUBE CSS 등 한번쯤 들어봤던 이 CSS 방법론이라는 것은 결국 어떻게 하면 이 이름을 잘 지을 수 있는가에 대한 노력들이었습니다. 여러가지 방법론이 논의되었으나 현재 살아남은 승자는 BEM와 Atomic CSS(Utiliy-First) 이므로 이 2가지에 대해서만 살펴보겠습니다. (집필하고 있는 이후에 뭔가 새로운 게 또 나올지도 모르겠습니다. 여기에 없는 이름이라면 배우세요! 뭐든 최신의 것을 배우세요!) 🔥 구조를 포함하는 단순한 명명법: BEM  http://getbem.com/introduction/ (BEM에 대해서는 자세히 다시 쓰겠습니다.)      🔥 직관적인 비주얼한 이름: Atomic CSS(Utiliy-First) 이른바 유틸리티 CSS로 자주 쓰는 CSS등을 미리 만들어서 사용하는 방식입니다. CSS의 초창기부터 오래된 논쟁거리 중 하나였습니다.   .mt10 { margin-top: 10px } 은 좋은 이름인가? (2022년) 지금은 어떨까? React의 점유율이 높아져 주류가 된 지금 React와 CSS의 궁합이 사실상 좋지 못했던 부분을 Styled Component와 같은 CSS in JS라는 방식을 통해서 해결하려는 움직임이 나타나기 시작했습니다. CSS in JS에서는 더이상 Selector는 더더욱 무의미해졌습니다. Svelte나 Vue등에서는 single File Component방식으로 인해 모듈화를 시켜주고 있습니다. StateOfCSS의 2021년 자료에는 이제 CSS의 방법론이라는 항목조차 사라졌습니다. CSS가 하던 디자인을 구조화하고 모듈화 하는 역할은 이제 프레임워크가 다 가져가 버렸습니다. 앞으로도 복잡한 Selector를 써야 하는 경우도 CSS의 Selector를 써야 하는 방향도 점점 줄어드는 방식으로 진행이 될 것입니다.  그럼에도 Selector라는 스펙이 있고 이걸 써야할 상황은 오겠죠? 그래서 특별히 Selector를 써야하는 경우에 대해서는 부록으로 책 후반부에 기록해 두었습니다. 이 챕터의 제목이 Selector의 사용법이 아니라 Selector 이야기인 이유입니다. 이러한 배경을 이해하고 나면 어떤 것이 오래된 개념이고 어떤 것이 최신의 것인지를 알게 되어 배움이나 사용에 있어 조금더 트렌드한 것들을 선택할 수 있는 지식이 되기를 바랍니다. CSS Property   4장. CSS Reset 이야기 왜 CSS Reset이 생겨났을까?  https://velog.io/@teo/2022-CSS-Reset-%EB%8B%A4%EC%8B%9C-%EC%8D%A8%EB%B3%B4%EA%B8%B0 참고 할만한 사이트 모음 reset:  https://www.joshwcomeau.com/css/custom-css-reset/ https://github.com/jgthms/minireset.css https://shadows.brumm.af/ https://www.joshwcomeau.com/css/stacking-contexts/ https://100dayscss.com/days/1/ https://cssbattle.dev/ CSS Tip  https://medium.com/@theAngularGuy/7-amazing-css-properties-you-may-not-know-yet-4f7b67f80644?source=email-e012841b24ec-1640453102286-digest.reader--4f7b67f80644----1-58------------------fcd017cc_21ce_442c_8aee_c5f8875cdeb4-16-5bed67e9_97ae_456d_8e82_cf48783ce2bb  https://medium.com/@jacobgreenaway12/taming-the-css-beast-master-positioning-5882bad14458?source=email-e012841b24ec-1640625996212-digest.reader--5882bad14458----1-71------------------88295d11_d57e_49a6_8a55_3f76ecd3b1be-27-b84705ed_4694_40f0_94ec_c641c0f44f94  https://medium.com/swlh/css-flexbox-fundamentals-visual-guide-1c467f480dac  https://brunch.co.kr/@eddwardpark/51 [출판] 샘플원고: Flexbox 편 https://hackmd.io/vDwTGL5HRo-XaaSgRerMHA 이 컨텐츠의 앞에는 기본적인 서식과 box-model 등 문서기반의 CSS은 설명을 했을거라고 가정합니다. Normal Flow에 대한 언급은 반드시 필요하겠네요. 유틸리티 클래스 방식에 대해서는 언급이 되었을거라고 생각합니다. MDN: CSS 레이아웃 입문서 ... 각각의 기술은 저마다 용도가 있고, 장단점이 있으며, 어떤 기술도 독립적인 용도를 갖추도록 설계되지는 않았다. 각 메서드가 어떤 용도로 마련된 것인지 이해하게 되면 해당 작업에 가장 적합한 도구가 어떤 것인지 파악하는 데 유리한 입지를 점하게 된다. ...  이번 장에서는 CSS의 꽃이라고 불리는 flexbox Layout에 대해서 알아보도록 하겠습니다! 4장. Flexbox - 핵심 편 문서에서 앱으로 진화하는 과정에서 생긴 레이아웃 스펙의 과도기 시절 Web은 최초 문서를 만들기 위해서 만들어졌지만 웹 산업이 점점 발전하면서 사용자와 인터렉션이 강화되면서 점점 단순한 문서가 아니라 홈페이지의 형태로 그리고 점점 더 어플리케이션과 같은 역할을 하게 되면서 웹 디자인의 요구사항이 변화하게 되었습니다. CSS는 처음에는 이러한 어플리케이션 UI를 만드는 의도를 가진게 아니었기 때문에 이러한 어플리케이션 UI와 레이아웃을 만드는 방법이 없었습니다. 그래서 원래 이미지와 문서를 어울리게 배치를 하기 위한 float라든가 표를 만들기 위한 table, 기타 inline block과 같은 문서를 만들기 위한 스펙들을 조립해서 복잡하게 레이아웃을 해야하는 과도기 시절이 있었습니다. flexbox는 Application 레이아웃을 하기 위해 태어났다. 그래서 사람들은 CSS로 복잡한 UI를 만드는 것에 불만이 있었고 이러한 레이아웃을 하기 위한 새로운 스펙을 만들어야 했습니다. 이후 2009된 출시된 box라고 붙여진 레이아웃방식이 태어났지만 다양한 레이아웃을 다 담아내지 못했기에 한번 deprecated 되었고 이후 flexbox라는 스펙이 2012년 정식으로 태어났습니다. 하지만 당시 Major 브라우저인 IE의 지원부족으로 인해 여전히 복잡한 CSS를 통해서 레이아웃을 해야만했고 사람들이 습관처럼 당연히 IE를 지원을 해야하다 보니 해당 스펙이 보편화가 되기까지는 오랜시간이 필요했습니다. 그러면서 이때 만들어진 자료들이 제일 많았기 때문에 flexbox의 사용법이나 응용법에 대해서는 저마다의 방법들이 달랐으며 덕분에 CSS의 레이아웃은 여전히 어려운 스킬이었습니다. 앱 레이아웃의 시작은 가로로 배치한다는 것 flebox는 문서가 아니라 어플리케이션의 UI를 만들기 위해서 탄생을 했다고 하였습니다. 그렇다면 문서와 어플리케이션 UI의 가장 큰 차이점이 뭘까요? 아니 기존 CSS에서 가장 하기 힘들었던 UI는 어떤 것이었을까요? 기존 문서기반의 CSS에서 가장 어려웠던 것이 바로 콘텐츠를 가로와 중앙에 배치한다는 거였습니다. 그래서 flex라고 만들어졌던 것들 처음에 기본 개념이 아무것도 속성하지 않았을 때는 가루로 배치된다는 걸 알 수가 있죠. 여하튼 콘텐츠에서 가로로 배치한다는 거는 굉장히 중요합니다. 그래서 플렉스 박스는 내가 어느 방향으로 콘텐츠를 배치할지를 결정할 수 있고 이 콘텐츠를 어떤 식으로 놓을지 어떤 식으로 간격을 벌려놓을지 그리고 남는 크기에 따라서 어떻게 크기를 지정을 할 수 있을지 이러한 단계로 레이아웃을 결정할 수 있게 됩니다. 이때부터 컨테이너라는 개념이 생겼다. 이때부터 컨테이너라는 개념이 생겨납니다. 그전까지 CSS 레이아웃의 기준이 항상 본인을 중심으로 하는 개념이었다면 처음으로 레이아웃을 중심으로 하는 자식의 레이아웃을 구조를 반영하는 부모가 레이아웃을 컨트롤하는 어떤 형태의 구조가 나왔다라고 보시면 될 것 같습니다. 그래서 앞에서 배웠던 css와는 다르게 외부에서 레이아웃을 잡아주는 형태로 생각을 하셔야 돼요 그래서 나의 레이아웃이 아니라 이 자식들의 콘텐츠 간의 배치를 돕는 속성이다라고 생각을 해 주시면 좋을 것 같아요. 그래서 가로로 배치를 하게 되면 지금 보시는 것처럼 내가 어떤 콘텐츠가 있을 때 내가 콘텐츠를 가로로 배치할 것인가 세로로 배치할 것인가 결정을 할 수가 있습니다. 자식 컨텐츠(=컴포넌트)의 레이아웃 요소를 배제하고 레이아웃만 담당하는 컨테이너로 배치를 하는 방식이 보편화 됨. 과도기는 끝났다! 이제는 flexbox만 써도 되는 상황이 왔습니다. 2022년 현재 flexbox는 사용하지 못하는 브라우저가 없으며 인지도 및 사용율의 거의 100%에 가까운 스펙이기에 레이아웃을 한다면 flexbox를 사용하는 것이 너무 당연한 정석이 되었습니다.  그러나 아직도 오래전에 만들어진 사이트들이 float등으로 레이아웃이 되어 있기도 하고 이미 만들어진 커리큘럼이나 웹 문서등으로 인해 flexbox의 최신 방법들이 아닌 레이아웃 방식이 아직 남아있기도 합니다. 지금은 flexbox나 grid가 아닌 다른 방식이 아닌 방식으로 레이아웃을 설명하고 있다면 문서의 연도를 꼭 확인해보시기 바랍니다. flexbox가 모든 브라우저에 동작을 하고 사용자들의 경험치가 쌓이면서 이제는 각자만의 Best Practice들이 정립이 되고 있는 중입니다. flexbox의 스펙 역시 모든 스펙을 사용할 필요가 없습니다. 이번 장에서는 제가 정립한 flexbox의 핵심 내용을 함께 배워 보려고 합니다. 이제 옛날 스펙 레이아웃은 사실상 쓸모가 없다. 원래 의도로만 써야한다. float, inline-block, table 로 레이아웃을 해야할 필요가 없다. XX장에서는 기타 레이아웃 속성을 모아서 이해할 수 있도록 모아두었습니다. 해당 레이아웃의 취지를 이해하고 그 스펙으로만 할 수 있는 레이아웃을 작업 하도록 합시다. flexbox는 현재 CSS의 보편적인 레이아웃을 쉽게 만들어 낼 수 있는 스펙이기에 꼭 알아야할 CSS의 꽃과 같은 존재입니다.  Flexbox 시작하기에 앞서... 필독! CSS는 많이 아는 것보다 Best를 찾는게 중요하다. (다시 써야됨. 아래 내용은 글이 아니라 메모 입니다. ) CSS는 여러가지 방법으로 같은 모양을 만들어 낼 수 있다. 방법을 많이 아는게 중요하지 않다. 간단하고 최소한의 노력으로 원하는 모양을 만들어 내는 방법을 알고 있는 것이 중요하다. 여기에서도 깊게 얘기하지 않고 꼭 필요한 핵심만 먼저 적을 것이다. 더 몰라도 되니 이것의 사용법에 먼저 익숙해져라. 이후 고급편에 다시 추가적으로 더 알면 좋을 만한 스펙을 알려줄 것이다. 절대로 하나씩 하나씩 다 깊게 팔 배우고 하는 게 아니라 자기 손에 꼭 맞는 베스트한 방법들을 찾는 게 중요하고요 여기서 설명드릴 것은 저도 가장 간소한 방법에 대해서 간단하게 플렉스 박스를 할 수 있는 방법에 대해서 알려드리려고 합니다. CSS는 숙달이 더 중요하기 때문에 핵심만 먼저하고 추가적인 이론을 뒤에 다루는 방식으로 진행하겠습니다! Best Practice의 소스: figma의 AutoLayout!   figma AutoLayout은 flexbox의 subset으로 일부 개념만 축소해서 가져왔다. 그럼에도 거의 대부분의 디자인이 가능! 디자이너가 모든 스펙을 쓰지 않아도 디자인이 되는데 개발자가 굳이 복잡하게 바꿔줘야할 이유가 없다. 제가 써왔던 경험과 AutoLayout을 근거로 Flexbox의 핵심과 Best Practice를 알려드립니다. figma AutoLayout의 핵심 구성 (figma AutoLayout의 UI 설명 - 책에서 사용해도 되나? 아니면 언급 정도만 하면서 넘어가자.) 방향 - 가로, 세로 배치 + (space-between) 패딩 간격 크기 - hug content, fixed width, fill-container 이것만으로 충분하니 이 정도의 범위만 핵심으로 익히고 실습을 해서 익히고 나면 고급을 배우도록 하자! flexbox도 이 부분만 가지고 얘기를 하겠습니다. Flexbox 시작하기 콘텐츠를 가로로 배치할 것인가 세로로 배치할 것인가: flex-direction(= flex-flow) 구 버전에서는 horizontal, vertical이어서 조금 더 직관적이었다고 생각합니다. row=가로, column=세로로 기억해두자. 기존 스펙을 덮어 쓸 수 없다는 점이 있고 타이핑 측면에서는 지금이 나은 것 같다. 그리고 이렇게 방향이 결정이 되었다면 이제 콘텐츠들이 박스에서 어디에 놓일지를 한번 생각을 해봅시다 콘텐츠가 존재한다면 이 박스는 레이아웃의 가운데에 배치될지 상단에 배치될지 혹은 하단에 배치될지 왼쪽에 배치될지 오른쪽에 배치될지 혹은 가운데 배치될지 이런 9가지의 배치 방법이 존재합니다. flow-direction은 방향을 설정한다. flex-flow는 방향과 flex-wrap을 함께 적을 수 있는 속성이다. 결국 짧은 CSS를 작성하는게 좋으니 이후 flex-direction대신 flex-flow로 작성을 하겠습니다. 메인 축과 교차 축   (컨텐츠를 배치하는 9군데 영역, 다 그려서 펼쳐주는 방식으로 그려두자!) 박스형 컨테이너 내부에 컨텐츠를 배치하게 된다면 우리는 위와 같은 다양한 방법으로 컨텐츠를 배치할 수 있게 됩니다. flexbox는 이렇게 다양한 배치를 하기 위해 크게 2가지의 방향으로 나눠서 어떤식의 배치를 할지 조립하도록 설계가 되었습니다.   (이건 좀 좋게 다시 그리자!, 가로 세로 둘다..) 좌.우.가운데, 늘리기! : align-items 메모: (사람이 바라보고 양팔을 벌리고 있는 그림) (좌, 우, 가운데, 늘리기를 팔로 보여주고 있는 그림) align-items는 크로스, 좌우, a키를 누르고 있는 것을 상상해보자. (왼쪽 오른쪽) 가로에서 보았을때는 start가 위, 아래 세로에서 보았을때에는 start가 좌, 우 이것은 글자를 쓰는 순서와 연관이 되어 있다. 어떻게 모아둘까? 벌려둘까? : justify-content align이 늘리기라고 외웠으면  justify-content는  space-between  과 짝꿍. 꼭 함께 외워야 한다. (그림으로 보여주기, 왼쪽, 오른쪽, 가운데, space-between) 조합 연습해보기 그래서 다음과 같은 순서대로 작성을 해봅시다. 계속 크로스로 확인하는 것이 포힌트 (말로 설명하니까 이상하다 이 과정을 그림으로 보여주자.) 이러한 방향들은 글을 쓰는 방향을 기준으로 만들어졌다.  헷갈린다면 계단을 그려보자! 방향, flex-end, flex-end ➡️⬇️➡️ ⬇️➡️⬇️  연습해보기 다음 예시들을 보고, 방향, align-items, justift-content 알아맞혀 보기 (예시 배치 그림 그리기) 이런 것들을 게임으로 해볼 수 있는 연습 방법이 존재한다. flexbox froggy, flexbox 좀비. 추천! flexbox 세부적인 디자인 잡기 이제 세부적인 디자인은 바로 간격!! 간격은 크게 2가지 (이것도 좀 그림으로 그리자) 이제는 margin으로 간격을 조절하는 것은 좀 old한 방법... (마진을 쓰면 누구에게 마진을 줘야할지 고민하는 내용의 그림) (일반적인 디자인 명세서와 함께 gap의 의미를 설명하는 그림) 이 것이 컨테이너 개념으로 생각하는 연장선상! margin이 나쁘거나 쓰면 안된다는 얘기가 아니다~ margin을 안씀으로써 우리가 더 편하고 일관되게 CSS를 쓸 수 있다는 의미! 필요하면 써야지. 융통성을 가지자! 그래서 지금은 gap과 padding을 쓰자! gap이 없던 시절에는 &gt;*+* 올빼미를 썼다. gap 스펙은 아직 IE 11과 사파리 14 이하 버전에서 동작하지 않는다. 지금 현재 쓰고 있는 주류 브라우저가 브라우저에 아직까지 사파리 14 이하나 이 11이 존재하고 있다라고 하면 예전에 쓰고 있던 갭을 사용할 수 있기 때문에 그대로 사용하셔도 괜찮습니다. 다른 크기의 gap이 필요할 때 1? space (코드 보다는 이미지가 낫겠다.) 다른 크기의 gap이 필요할 때 2? sub-flexbox 컨테이너와 콘텐츠의 크기 figma에서는 3가지 타입으로 나눈다. hug-contents, fixed-size, fill-container 우리도 이렇게 3가지로 나눠서 생각하자. 컨텐츠에 따라서 vs 고정된 크기로 width, height가 auto인 경우에는 내부 컨텐츠의 크기를 따라간다. 크기를 지정하면 컨텐츠와 관계없이 크기가 고정이 된다. flexbox에는 추가로 가변 크기가 존재한다. flex: 1 flex-grow?, flex-shrink?, flex-basis? 일단 * { flex-shrink: 0} 으로 설정하고 flex: 1만으로 충분히 다 커버가 가능하다. 자세한 개념은 고급 편에서 다시 설명을 합니다. 일단 flex:1 의 활용법을 익혀봅시다. (flex:1을 이용하고 있는 예시 이미지들) 나만 특별해! align-self, justify-self 특별히 하나의 컨텐츠만 크기가 다르면 콕 집어서 align-self 혹은 justify-self를 사용해 줄 수 있습니다. 컨텐츠마다 정렬의 기준이 다를 때 사용합니다. (예시 카톡의 채팅방 디자인의 시간대 표기) tip2: fill-container를 만드는 방법 align-self: stretch @TODO: 내용 좀 더 추가할 것 디자인을 보고 flexbox로 생각하기 (대충 가이드가 없는 디자인) 실전에서는 어떻게 레이아웃을 잡을 수 있느냐 디자인이 있다면 일단 여기 디자인에서 내가 적절한 선으로 잘라주시면 되겠습니다 가로 선을 긋고 새로 선을 긋되 겹치지 않도록 그 선이 선을 지나가지 않도록 선을 최대한 잘라보시면 될 것 같습니다. (가이드를 그려준 디자인) figma의 AutoLayout는 flebox 모든 기능을 다 쓰지 않지만 디자인이 가능하다. 지금까지 배운 것들만 가지고 flexbox를 먼저 이해하고 실습을 한 뒤에 고급을 들어가도록 합시다! 실습을 통해 Flexbox를 익혀보자. UI Component 만들기! 지금까지 배웠던 flexbox의 내용을 통해 자주 쓰이는 UI Component를 만들어보면서 flexbox를 내것으로 만들어보자! 아이콘이 있는 Button 만들기 (샘플 디자인) (샘플 코드) Toolbar 만들어보기 (샘플 디자인) (샘플 코드) Card 만들어보기 (샘플 디자인) (샘플 코드) Modal Dailog 만들기 (샘플 디자인) (샘플 코드) Tabbar 만들기 (샘플 디자인) (샘플 코드) 스크롤 스냅과 flexbox를 이용해서 케로셀을 만들어보자. flexbox 복습 및 정리 5장. Flexbox - 고급편 고급이라고 쓰고 특수한 경우라고 읽는다. 어렵다는 얘기는 그만큼 쓸 기회가 적다는 것을 의미한다! 컨텐츠도 줄바꿈을 해보자! flex-wrap flex-flow에 wrap을 추가할 수 있다. flex-wrap 전용 배치 align-content flex-wrap이 되어 있으면 컨텐츠간 정렬을 해야하는 방식이 필요해집니다. align-items와 헷갈릴 수가 있는데 justiy-content에서 왜 content라고 이름 붙였는지 생각해보자! (그림으로 컨텐츠 사이의 간격을 표기 해주자!) 이러한 정렬을 하기 위해서 align-content 스펙은 다음과 같은 경우의 수를 가집니다. (스펙과 배치 이미지 나열) 자주 사용되지는 않고 특수한 경우가 아니라면 grid layout을 통해서 해당 배치를 만들어 낼 수 있다. 물론 목적인 다르기 때문에 알고는 있어야 한다. grid vs flexbox-wrap 미묘하게 서로가 유리한 조건이 다르다. 특히 반응형을 처리해야할 때. 컨텐츠의 크기가 제각각인 경우라면 flexbox로 해야하고 컨텐츠의 크기 (정확히 말하자면 레이아웃의 격자)가 균든하면 grid가 훨씬 더 유연하다. 해당 방식의 차이는 7장 grid 편 에서 다시 다루도록 하겠습니다. HTML 수정 없이 순서를 바꿀수 있다. order! 그래서 반응형이나 아니면 조건부 랜더링에서 이 오더를 사용하시면 좋다라고 말씀드릴 수 있을 것 같아요. 특정 조건에 맞는 정렬을 하는 방식으로도 사용이 가능하다! 특정 상황일때 이 컨텐츠만 맨위로 보이게 하기. flex-shrink와 말줄임... flex-basis  https://css-tricks.com/understanding-flex-grow-flex-shrink-and-flex-basis/ 모든 스펙들이 골고루 쓰이지 않는다. 많이 쓰는 것 위주로 간단하게 쓰자. 유틸리티 클래스 사용해보기 (유틸리티 클래스 방법에 대한 설명은 앞 장에서 이미 언급을 했을 것) 유틸리티 클래스를 사용해보자. tailwindCSS, AdorableCSS 앞서 실습한 내용중 1~2개를 유틸리티 클래스 기반으로 만들어보기 tailwindCSS로 구현해보기, AdorableCSS로 구현해보기 CSS 최적화 ...  SideNav  창 크기를 조절(파란색 border)할 때  하드웨어 가속을 위해 transform 을 사용하고 싶었지만,  SideNav  를 collapse를 하면,  Contents  부분이 전체 영역을 차지할 수 없게됩니다. 그래서 창크기 조절을 할 때마다  flex-basis 를 줄이고 늘리는 식으로 사용했습니다.  transform을 사용하는 방법 은 없을까요??  왜  trasform으로 바꿔보고 싶어 하는지는 알 것 같아요. 하지만  trasform으로는 레이아웃 을 변경할 수 없어요. 질문에 언급된  하드웨어 가속  에 대한 개념과 함께  Critical rendering path ,  reflow ,  repaint 와 같은  CSS 에니메이션 최적화 에 대한 얘기를 해보면 좋을 것 같아 이 글을 쓰게 되었습니다. 프롤로그 CSS 에니메이션을 공부하다 보면  하드웨어 가속 이나  렌더링 최적화 에 대한 글을 접하게 되고  transform으로 에니메이션을 만들어야 가장 빠르다  라는 얘기를 종종 듣게 됩니다. 그래서 내가 만들고자 하는 에니메이션을 어떻게 transform으로 바꿔보려고 하지만 도저히 그렇게 되지 않는 경우가 만들어지곤 합니다. 그래서 한번 reflow, repaint, 하드웨어 가속등 CSS 에니메이션에 대한 이해를 한번 해보고 나면 왜 해당 에니메이션을 transform으로 만들 수 없는지 아시게 될 거에요.  이번 글에서는 CSS Animation에 대해 다음과 같은 이야기를 해볼까 합니다. ⭐️ Critical rendering path 이렇듯 브라우저에서는 실제 코드 변경으로 인해 다시 화면이 변경이 되기까지간의 일련의 과정이 존재합니다. 이것을   Critical rendering path   라고 합니다. 이 과정을 세분화 해보면 아래 그림과 같습니다.   간단하게 정리하면 JS, CSS가 변경이 되면 그에 맞는 다시 레이아웃을 계산하고 레이어에 픽셀을 그린 후 조합해서 하나의 화면을 만들어 화면에 보여주는 과정을 통해서 변경된 화면을 우리가 볼 수 있게 됩니다. DOM과 Style     출처:  구글: 모던 웹 브라우저 들여다보기 (파트 3)  꼭 읽어 보세요! CSS Animation   우선 먼저 에니메이션에 대해서 생각을 해봅시다.  에니메이션이란 서로 다른 정지된 이미지를 일정시간 이하의 간격으로 빠르게 다시 그리면 움직이는 것처럼 보여지는 것을 말합니다. 다시말해 에니메이션이 제대로 동작하기 위해서는  빠른시간내에 다시 그리는 것 이 중요합니다. 브라우저에서는 어떻게 하면 다른 이미지로 보여줄 수 있을까요? 간단합니다. 자바스크립트 코드에서 DOM을 조작하거나 스타일을 변경하게 되면  변경된 부분을 렌더링 엔진이 다시 그려주게 됩니다. Reflow, Repaint 하지만 JS, CSS 변경이 되어도 이 모든 과정을 항상 거치는 것은 아닙니다.  화면을 다시 그린다는 것은 UI 프로그래밍 성능에 있어 가장 중요한 부분 이기에 최대한 효율적으로 계산하여 적은 수의 변경을 만들어 내려고 하게 됩니다.   이미 그려져 있는  화면에서 Layout을 다시 하는 것을  Reflow  ,  화면을 다시 그리는 것을  Repaint  , * 각각 만들어진 레이어들을 하나의 이미지로 출력하는 과정을  Composite  * 라고 부릅니다. 가급적 이러한 단계를 생략할 수 있다면 좋겠죠? 그래서 여러가지의 렌더링 과정 중 Layout와 Paint의 과정을 생략할 수 있다면 훨씬 더 나은 성능을 보여줄 수 있게 됩니다. ⭐️ Reflow (= ReLayout)   웹 브라우저에서 inline과 block으로 인한 레이아웃을 normal-flow라고 합니다. reflow라는 용어는 이 flow를 다시한다는 데에서 유래했고 직관적으로는 레이아웃을 다시 잡는다고 보시면 됩니다. 브라우저의 DOM 요소들의 크기가 위치들은 상대적인 개념을 가지고 있습니다. 글자의 양에 따라 width와 height가 변경이 되고, 부모의 크기나 위치에 따라 내 위치가 결정이 됩니다. 또한 내 앞의 엘리먼트에 따라 위치가 가변적이죠. 이말은 곧 내 위치가 결정되기 위해서는 부모든 이전 노드의 위치가 필요하다는 의미입니다. 이러한 특성이 있기에 훨씬 더 UI 개발을 편하게 만들어 줍니다. 모든 것들이 절대 좌표였다면 컨텐츠를 삭제하고 추가할때마다 일일히 위치를 계산해줘야 할 것입니다. 이러한 부분들은 브라우저가 대신해주고 있죠. Reflow가 느린 이유   DOM은 하나의 Layout이 결정되기 위해서는 선행되어야 하는 Layout이 존재해야 합니다. 바꿔 말하면 선행되는 Layout가 변경이 된다면 도미노 처럼 다음 레이아웃이 변경되고 또 그로인해 다음 Layout이 변경이 된다는 의미입니다. 예를들어 우리가 반응형을 만들때 root의 width가 변하면 연쇄적으로 다른 모든 레이아웃들이 변하고 있다는 것을 알고 있잖아요. 그렇기에 과도한 reflow가 발생하는 형태의 animation, 가령, width가 바뀐다거나 margin등이 변경이 되어 하나의 레이아웃의 변경이 미치는 파급력이 큰 경우 많은 양의 계산과 대규모의 화면 변환이 필요하기에 가급적 reflow가 발생하지 않도록 해야 합니다. ⭐️ Repaint   repaint는 다시 그렸을때 레이아웃의 변화가 없는 속성들입니다. 나만 다시 그리면 되니 상대적으로 속도가 적을 수 밖에 없습니다. 글자와 색깔, outline등이 포함됩니다. 도미노 효과가 없으므로 상대적으로 에니메이션 속도가 빠른 편에 속합니다. 어떻게 확인해야 할까? 크롬을 기준으로 한다면 콘솔 &gt; 하단 패널 &gt; 렌더링 탭 으로 들어가면 paint와 layout을 확인 할 수 있는 체크 버튼이 존재합니다.   에니메이션을 만들거나 DOM의 변화를 만들어낼 때 과도한 layout변경이 일어난다면 그렇게 하지 않기 위해서 구조를 변경할 필요가 있습니다. 하드웨어 가속 그러면 어떻게 하면 layout도 수정하지 않고 paint도 다시 하지 않는데 화면이 변경이 되는 에니메이션을 할 수 있을까요? 비밀은 렌더링의 마지막 과정의 Composition에 있습니다.  Composition은 레이어로 쪼개긴 픽셀 데이터를 순서대로 다시 그리면서 하나의 이미지 데이터 배치하는 작업을 말합니다. 엄밀하게는 아니지만 직관적으로 개념을 이해하기 위해서 opacity를 예를 들어 보겠습니다. 일단 우리는 Layout와 Paint를 통해 만들어진 이미지가 있습니다. 해당 이미지를 투명도를 조절하는 fade 에니메이션을 하고 싶어요.  그러면 우리는 배치를 할때 이미 그려놓은 원본픽셀 데이터에 각 필셀마다 opacity를 곱해버리기만 하면 원하는 불투명한 이미지를 만들어 내는 것을 상상할 수 있습니다. 이러한 경우에는 에니메이션 과정에서는 Paint의 동작이 필요없다는 것을 알게 됩니다. 원본데이터는 바뀌지 않았고 원본 데이터의 각 픽셀에 불투명도의 값만 다른 값을 곱해서 만들어 내되면 됩니다. 이렇게 원본픽셀 데이터의 일부 연산을 통하여 변환하는 것을  matrix multiplication  이라고 부르며 이러한 동작은 CPU가 아니라  GPU의 도움을 받을 수 있으므로 훨씬 더 빠른 속도(= 하드웨어 가속) 로 장면을 만들 수 있게 됩니다. GPU를 이용한 하드웨어 가속이 더 빠른 기술적인 이유 400x300 사이즈의 이미지를 불투명하게 만들기 위해서는 400x300의 연산이 필요합니다. cpu는 순차적인 방식으로 동작하도록 되어 있기에 이러한 연산은 120,000의 반복회수가 필요하게 됩니다. 하지만 각 이미지 픽셀 변환은 독립적인 동작이기에 순차적으로 진행할 필요가 없습니다. gpu의 경우에는 병렬로 처리해야할 연산들을 한번에 처리할 수 있습니다. 그렇기에 120,000이 아니라 1회에 모든 연산 결과를 출력할 수 있게 됩니다. Why can GPU do matrix multiplication faster than CPU? https://stackoverflow.com/questions/51344018/why-can-gpu-do-matrix-multiplication-faster-than-cpu  https://www.google.com/search?q=gpu+matrix+multiplication&amp;oq=gpu+mat&amp;aqs=chrome.1.69i57j0i512l6j0i10i512j0i512l2.3848j0j4&amp;sourceid=chrome&amp;ie=UTF-8   출처:  https://developers.google.com/web/updates/2018/09/inside-browser-part1 원본이미지를 변형하는 방식인 translate, rotate, scle, skew, opacity, blur와 같은 filter 등만 하드웨어 가속이 가능하며 처음 질문을 했던 레이아웃을 조절하기 에니메이션 요구사항을 transform으로 해결할 수 있는가에 대한 대답은 No 입니다. 어떤 속성이 reflow, repaint, compoition을 만들어낼까? 브라우저마다 조금씩 달라서 잘 정리해둔 사이트를 공유합니다.  어떤 속성이 reflow, repaint, composition을 만들어 낼까? https://csstriggers.com/ 하지만 이 역시 브라우저와 상황에 따른 케바케이기 때문에 이러한 이론을 머리 속에 기억 해 둔채 실전 경험을 통해서 익혀두시길 바랍니다. 또한 opacity, transform, blur 등의 속성을 가지고 있으면 자동으로 하드웨어 가속을 받게 되는데 브라우저 렌더링 엔진은 하드웨어 가속을 받는 렌더링 엔진과 일반 렌더링 엔진 2가지로 분리가 되어 있습니다. 그래서 opacity: 1과 opacity: 0.99는 다른 식으로 동작하기도 합니다.  그래서 하드웨어 가속처리를 미리 해둬야 하는 경우에는  transform: translateZ(0.1px) 나  will-change: transform  과 같은 속성을 통해서 다른 렌더링 엔진을 통해 그려내기도 합니다.  [CSS] opacity는 reflow가 발생 안 한다구요...? 정말?? https://blinders.tistory.com/93 그러면 전부 하드웨어 가속을 받으면 좋지 않을까요? 당연히 아니겠죠? 여러가지 이유가 있지만 gpu의  하드웨어 가속을 받기 위해서는 해당 원본데이터를 메모리에 보관 을 해두어야 합니다. 브라우저의 메모리 용량은 정해져 있기 때문에 남는 메모리의 용량이 적으면 스왑이 자주 발생하게 되면서 오히려 느려지는 경우가 발생을 하게 됩니다. 그리고 대부분의 경우 브라우저 자체에서 가능한 최적화가 될 수 있도록 하고 있습니다. 그러니 큰 문제가 없다면 그냥 놔두길 바랍니다. 애써 건드린다고 해서 더 드라마틱한 성능 개선을 기대하기는 힘듭니다. 그러면 will-change는 뭔가요? will-change속성은 어떤 속성과 요소가 조작될 가능성이 있는지 브라우저에 미리 알려주는 방법입니다. 그러면 내부적으로 해당하는 요소에 대한 정보를 미리 메모리에 올려두는 등 브라우저에서 해당 속성을 통한 에니메이션 처리를 할기 위한 사전 작업을 미리하여 조금 더 부드럽게 에니메이션 처리를 할 수 있도록 해줍니다. 일부 특수한 경우를 제외하고는 많은 부분에 will-change를 거는 것은 위에서 모든 요소들에게 하드웨어 가속을 받도록 하는 것은 오히려 성능 저하를 일으킵니다.   제일 추천하는 방법은 CSS에서는 사용하지 않고 JS에서 에니메이션이 시작될때 will-change의 값을 지정했다가 animation이 끝나면 다시 auto로 돌려두는 것이 가장 좋습니다.  CSS will-change Property: When and When Not to Use It https://www.digitalocean.com/community/tutorials/css-will-change 그래서 실전에서는 어떻게 하면 좋을까요? 그냥 하세요. 크게 생각을 하지 말고 에니메이션을 만듭시다. 브라우저도 최적화를 시도하기에 대부분은 크게 문제가 없습니다. 다만 absolute top, left이나 margin에 비해서 translate를 사용했을때 원하는 바가 같다면 translate를 사용해 주는 것이 좋겠죠 가령 width를 변경해야 한다면 윤곽선으로만 에니메이션을 처리하고 끝나는 시점에 width를 한번에 바꾸면서 fade in / out으로 에니메이션을 하는 착각을 주는 법도 있습니다. 가급적 레이아웃을 중간 과정 없이 그리도 proxy로 에니메이션을 대체하고 (윤곽선이나 반투명) 한번에 반영하는 형태 물론 디자이너와 합의를 통해서 설명을 드리면 멋진 결과물을 만들어 주실 거에요! Javascript에서 Style 사용시 최적화 하기 will-change는요?  https://www.digitalocean.com/community/tutorials/css-will-change 감사합니다. 완성도가 없는 글인데도 혹시 여기까지 읽어주셨다면 너무 너무 감사드립니다. 완성되지 않은채로 블로그에 올리는 일은 없었으면 했지만 여기에서 올린 글은 당분간은 완성도를 올리는게 너무 하기 싫을 것 같아요. 😅 그래도 현재 CSS Framework을 만들고 홍보(?)를 하고 있으므로 CSS와 관련된 주요한 포스팅과 내용들인 flexbox나 grid layout, CSS Animation이나 컴포넌트 제작 팁, 디자인 패턴과 같은 이야기들은 준비하고 있습니다. 좋은 하루 되세요 :) 세상 귀여운 CSS Framework! https://developer-1px.github.io/adorable-css/   프롤로그 안녕하세요! 스프린트 5기의 결과물  &quot;당신에게 주겠상&quot;  프로젝트를 공유합니다!!! 👏👏👏  https://serene-golick-21e934.netlify.app/ https://github.com/FECrash/am0318   스프린트는 다음과 같이 진행이 됩니다. 첫째날과 셋째날에는 저와 함께 Team Canvas, MAP, Sketch, PL선정 까지의 과정을 진행합니다. 주말 이틀동안에는 오롯이 팀원끼리만 개발을 진행을 진행합니다. 월요일 모두가 만들어낸 결과를 데모하고 테스트를 통하여 피드백을 하고 다같이 회고를 해봅니다. 이번 포스팅에서는 첫째날, 둘째날, 셋째날 당일 회고록과 함께 테스트와 회고 이야기를 함께 담아내고 있습니다. 우리의 경험을 기록한 이 글이 다른 분들에게도 도움이 되기를 바랍니다. 첫째날 안녕하세요~ 테오입니다. 첫 만남   Team Canvas   (역대급으로 팀 캔버스가 제일 화려했던 것 같아요. ㅋ)         내 아이디어를 소개합니다.   두구두구... 그래서 스프린트 5기에서 하게 될 주제는 바로바로.....    당신에게 주겠상! 으로 선정이 되었습니다 :) why? what? 그래서 서로에게 상을 줄 수 있는 플랫폼 &#39;당신에게 주겠상!&#39; 을 생각해보았습니다! how? if? 선정된 주제의 목적에 대해 함께 생각해보기 그리고 &#39;당신에게 주겠상!&#39; 서비스의 목적이 무엇인지 한번 생각해보는 시간을 가졌습니다!   첫째날 과제 조금 더 깊게 이러한 서비스가 생긴다면 어떻게 서비스가 구성이 되고 실제로 사용하게 될 지 한 번 충분히 상상해오기 바랍니다. :)   그때까지 오늘도 행복한 하루 되기를 바래요 ❤️ 둘째날 불과 2시간 남짓한 시간이었지만 정말 많은 생각들을 주고 받으며 멋진 스프린트의 지도를 만들게 된 것 같아요. 특히 끝나고 다같이 모여서 우리들의 공간과 추억을 만든 시간들이 아직도 기억에 남네요~   ~ (어떻게?) ~  궁극적인 목적  연결해보기 궁극적인 목표 설정하기     서비스의 대상 찾아보기   생각하고 있는 대상들이 다양하고 현재 서비스의 구체적인 모습이 그려지지 않았기 때문에 대상을 분명하게 하는 것은 조금 보류해보았습니다. 우리 스프린트에서는 이러한 사람들 중 조금 더 명확하고 구체적인 방법과 대상을 통해서 스토리를 좁혀가는 시간을 가져보려고 합니다 어떻게 하면 ~ 할 수 있을까? 이 플랫폼에 참여하는 이들에게 서비스가 주고자 하는 목적을 전달하기 위해서 우리는 어떤 것을 받아야 하고 어떤 것을 줄 수 있는지 그것을 하기 위해서는 어떠한 방법과 아이디어가 필요할 지 논의해 보는 시간을 가졌습니다.   칭찬의 감성 전달 - &quot;상장&quot;   서비스에서 제공해주고 픈 것들    관계를 어떻게 할까?   공유 기능!   우리들의 생각이 모여 와 같은 테마들로 이야기들을 할 수 있었습니다. 비판적인 시선으로 바라보기   그래서 자칫 아이디어를 논의하는 과정에서 잘못된 방향으로 가지 않도록 다음과 같은 내용으로 빠지지 않도록 하는 경계선을 마련하였습니다.   지도를 만들기 위한 여정 이렇게 만들어진 주제와 테마를 가지고 다시 열띤 토의를 시작하였습니다.   그리고 만들어진 지도입니다. &quot;정리왕 조이&quot;가 수고를 해줬답니다 :)   최종적으로 스케치를 할 수 있는 요소들을 뽑아서 정리를 해보았습니다! 👏👏   🔥 둘째날 과제 우리 서비스에서 사용 될 장면과 유사한 서비스 컨셉 레퍼런스 모아오기 각 장면별로 간단하게 스케치 연습 해보기 (연습만 해보세요) 그 밖에 갑자기 생각난 아이디어 스케치나 이미지 그리고... 오늘은 PL을 뽑는 날!! 오늘 스케치가 끝나고 나면 우리들의 주말을 책임져줄 PL을 뽑는 날입니다. 지금 결정할 필요는 없어요. 오늘 모든 과정을 함께하고 누가 우리 스프린트의 PL이 되면 좋을지 생각해보길 바랍니다. 끝나고 난 뒤... 친해지길 바래~ 역시 모르는 사람과 이야기 스타트에는 MBTI 만한게 없더군요.    겹치지 않는 것도 신기 신기 유독 이번 스프린트에서는 I가 많이 보였네요 ㅎ 그리고 잡다한 이야기의 꽃을 피우며 벌어진 &quot;실시간 드로잉 쇼&quot;   이 그림을 보면서 나중에라도 이 시간들이 다시 떠 오르며 한번은 피식~ 할 수 있는 시간이었길 바랍니다.  셋째날 안녕하세요~~ 테오입니다!     셋째날 스케치 리뷰 시작합니다! 레퍼런스를 찾아 봅시다   내가 좋다고 생각하는 아이디어들은 항상 누군가도 생각해봤기 마련입니다. 참고를 할 만한 좋은 자료와 디자인 컨셉들을 모아보면서 우리에게 가장 알맞는 fit이 무엇을지 한번 생각을 해보았습니다! 스케치전 워밍업!!! 본격적으로 하루종일(?) 그림만 그려야 하는 시간이기에 손과 입을 풀자는 의미에서 재미를 챙길 가벼운 아이스브레이킹 활동을 해보았습니다. 알고는 있었지만 다들 그림을 참 잘 그리는 것 같아요!     다시 한번 이때를 상상하고 한번 피~식 웃어 보기를 바래요 😆 본격 스케치!! 여기는 양이 워낙 많아서 그냥 캡쳐를 하고 넘어갑니다. 다들 아시죠? ㅎ       현실적인 목표와 MVP, 그리고 단계적 업데이트   우리의 PL을 뽑아봅시다!!   🔥 Tip: BDD를 알려드리고 저는 갑니다!! 개발 PL은 처음일 &#39;노아&#39;와 협업이 생소할 우리 스프린트 팀을 위해서 팁을 하나 공유하자면 최대한 Task를 잘게 쪼개되 개발해야할 단위가 아니라 사용자의 행동관점에서 행동단위로 Task를 나누면 놓치는 거 없이 협업하기 수월할 거에요. 이것을 BDD라고 하는 데 (Behavior Driven Development) 전문지식은 몰라도 되며 given-when-then이라는 포맷만 기억해주세요. 장면(상황), 행동, 결과 라고 생각하시면 됩니다.   순서는 크게 상관이 없습니다. 장면을 통해서 사용자가 할 수 있는 동작을 추려내거나 사용자가 할 수 있는 동작들을 모아서 장면을 만들어도 됩니다. given: 상장 입력 화면 결정을 하면서 진행을 해보면 좋을 것 같아요 :) === 주말 주말에는 모두 모두 게더타운에 모여 각자 작업과 협업을 하고 있었습니다. 저는 사진만 찍기 위해서 몰래 잠입하고 호다다닥 나왔답니다. :)   마지막날 테스트 이틀간 만들어진 서비스를 한번 테스트 해보기로 하였습니다. 우리가 만들고자 했던 목적이 잘 구현이 되었을지 한번 확인해보도록 하였습니다.   처음 진입시 선서를 할 수 있도록 해서 뭔가 나쁜말을 하려고하는 마음이 사라지는 것 같았습니다!   https://github.com/FECrash/am0318 이 서비스가 궁금하신 분들은 꼭 한번 시도해보시기 바랍니다. 회고 5일만에 아이디어의 검증을 넘어 컨셉과 디자인 디자인 그리고 백엔드까지 서비스가 개발이 되었습니다. 다들 너무 너무 수고가 많았습니다. 조금 더 컨셉이나 사용방법등의 안내가 될 수 있는 UX 개발과 몇 가지 기능들이 포함이 되면 좋겠다는 발전을 위한 기분 좋은 숙제들을 공감하고 멋진 스프린트를 마무리 할 수 있었습니다. 스프린트를 돌아보며 좋았던것, 배웠던것, 더 잘할 수 있었던 것, 앞으로 해볼 것이라는 4LS의 회고를 통해 스프린트를 마무리 하였습니다.         스프린트는 그 결과물이 아니라 좋은 사람들과 아이디어를 논의하고 구현하고 협력하는 과정을 배우는 것이기에 너무 소중한 시간이 아니었나 생각합니다. CS로 보는 객제 지향 프로그래밍 그 자체의 개념이 뭔지 궁금하네요. 이번 글에서는  객체지향 프로그래밍 에 대해 이야기를 해보려고 합니다. 그리고 자바스크립트의 객체지향은 일반적인 객체지향 프로그래밍과는 어떻게 다른지 그리고 javascript에서는 객체지향 프로그래밍을 어떻게 해야하는게 좋을지 한번 이야기 해보고자 합니다. (이번 블로그 소재를 제공해준 단테에게 고맙다는 말을 전합니다.) 프롤로그 프로그래밍 세계에서 무언가를 학습하려고 할 때에는 그 이론 자체를 이해하기보다는  먼저 그 기술이 나오게 된 배경을 이해하는 것이 굉장히 중요 합니다. 그래야 새로운 변화구를 맞이하였을때 맥락에 맞게 내 것으로 이해를 하기 쉬워지기 때문입니다. 프로그램 뿐만 아니라 기술의 발전은 대략 다음과 사이클로 돌아가게 됩니다. 첫번째 시기: 문제 인식 프로그램을 하다 보면 누구나 한번쯤 겪을 법한 문제 인식들이 쌓이기 시작하는 단계입니다. 그러면 이러한 문제를 해결하기 위해서 저마다의 여러가지 해법들을 찾아보게 됩니다. 문제 인식에 대한 공감대는 합의가 되었지만  이 문제를 해결하기 위한 최선의 방법은 아직 등장하지 않는 시기 입니다. 두번째 시기: 명명된 새로운 기술의 등장 여러가지 해법들이 쌓여가다보면 모두가 합의할만한 이론이나 기술이 등장하고 이러한 문제 인식과 해법에 대해  이름이 붙여지는 시기  입니다. 그리고 이로인해 대부분의 사람들이 명확하게 이 문제와 해결방법에 대해서 인식을 하게 됩니다. 여기서 중요한 사실은 대부분 컨텍스트와 해결 방법은 이미 먼저 나온 상태에서 이것들에 대해 정리된 이론이나 개념들은 나중에 이름 붙여진다는 사실입니다. 이때 보통 패러다임이 전환이 되었다라고들 하게 되죠. 세번째 시기: 기술의 부흥 이러한 패러다임의 전환으로 인해 이러한 이론과 개념들 그리고 문제 해결 방법이 정립이 되고 나면  이후 발생하는 모든 문제들은 새로운 시각인 이 방법을 가지고 해결해보려는 시도 들이 발생하게 됩니다. 그러면서 개념과 기술이 폭발적으로 성장하는 시기를 겪게 됩니다. 기존의 문제들이 세련된 형태로 대부분 해결이 되며 이 기술을 당연한 것으로 배우게 되는 시기입니다. 네번째 시기: 안정기(혹은 정체기) 패러다임 전환으로 폭발적인 변화의 시기를 통해 성장을 하고나면  새로운 한계점 을 마주치게 됩니다. 기존의 방식으로 만들어진 문제점들이 그 패러다임으로는 해결이 되지 않는 문제점들을 발견하게 되며 기존 방식으로 이를 해결을 하려다보면 굉장히 복잡해 보이는 방식으로 해결해야 한다는 사실을 알게 됩니다. 이러면서 문제인식을 가지고 다시 첫번째 시기가 되어 기술 발전의 사이클이 돌아가게 됩니다. 위 내용을 React에 대입해도 좋고 컴퓨터나 스마트폰에 대입해도 좋습니다. 그렇게 알고 있는 기술에 빗대어 한번 곱씹어 보길 바랍니다. 대부분의 기술 발전은 위와 같은 사이클을 가지게 되어 있습니다. 우리가 프로그래밍을 하다보면 만들어지는 개념들이나 배워야 하는 것들은 대부분  세번째 시기  때에 만들어지는 응용법들을 배우고 학습하게 됩니다. 이러한 맥락과 해결방법은 자연발생한 결과물인데 이러한 결과물에 이름을 붙이고 이론을 다듬는 과정에서 만들어진 생소한 용어와 정의 그리고 개념을 맥락 없이 이해하려면 상당히 어렵습니다.  결국 기술이란 지난 문제들을 해결하기 위해서 만들어졌기 때문에  기술에 대한 용어나 개념의 이해가 없이도  왜 이러한 기술이 필요했고 어떠한 발전 과정을 거쳤는지 를 이해를 한다면 새로운 용어에 대한 정의나 개념의 이해가 더 쉽게 될 것입니다. 이번에 적어 볼 이야기는   객체 지향 프로그래밍  입니다. 위와 같은 흐름에 맞춰 설명을 하려고 하니 한번 다시 리마인드를 하고 읽어 주시면 좋겠네요.  객체지향 프로그래밍에 대한 간단한 역사와 내용 그리고 자바스크립트에서는 이러한 전통적인 객체지향과는 어떠한 차이점이 있는지에 대해서 한번 알아봅시다. 주의: 앞으로 객체지향의 용어와 개념을 자연스럽게 설명하기 위해서 객체지향 프로그래밍의 발전과정이 마치 선형적으로 진행된 것 처럼 풀어나갈 것이나 실제로는 그렇지 않다는 점 그래서 다소 비약이 있을 수 있다는 점 미리 알려드립니다. 객체지향 이전의 이야기 객체지향 패러다임이 존재하기 전으로 가봅시다. 바로 상상하기는 쉽지 않을테니 이 글을 읽는 사람은 최소한 자바스크립트를 알고 있다는 가정 하에 javascript에서 Object를 쓰지 않고 boolean, string, number와 if, for, while 만으로 개발을 한다고 한번 상상 해 보세요. (예시 코드는 그 시절 언어보다는 이해하기 편하게 javascript로 통일하였습니다.) 순차적 프로그래밍과 goto 완전 초창기 프로그래밍에서는 프로그램은 순서대로 실행이 되었습니다. 지금도 프로그래밍을 하다보면 그전에 만들어 둔 것과 같은 반복적인 동작이 필요하다는 것을 알게 됩니다. for나 while가 같은 반복문이 존재했지만 일부 반복의 범위가 코드를 다시 실행을 해야 할 경우가 발생을 했고 함수라는 개념이 없던 시절에는  특정 위치로 실행 순서를 강제로 변경하는 goto문 을 만들어내게 됩니다. 이렇게 강제로 실행 순서를 바꾸다 보니 코드가 커져가면서 이 코드의 흐름을 제어하기가 힘들어지고 무언가 방법을 찾게 됩니다. 절차적(구조적) 프로그래밍 그 이후 실행순서를 강제로 바꾸는 것이 아니라 일정하게 반복되는 코드를 따로 만들어두고  해당 하는 코드를 호출하고 나서 다시 원래 자리로 돌아오는 방식의 프로시저(함수)를 통해서 개발 을 하는  절차적 프로그래밍  패러다임이 탄생하면서 지금의 함수와 같은 개념이 생겼습니다. 즉 절차적 프로그래밍은 데이터와 데이터를 처리하는 동작을  함수단위로 코드를 분리하고 재사용하는 형태로 프로그래밍 을 하는 방식이 됩니다. (함수라는 용어를 쓰기는 하지만 함수형 프로그래밍 하고는 다릅니다.) 절차적 프로그래밍은 우리에게 아주 익숙한 방식입니다. 현재에도 간단한 코드들을 작성을 할 때에는 이러한 방식으로 프로그래밍을 하고 있습니다. 언제나 문제는 코드의 덩치가 커질때 발생한다. 패러다임의 한계는 프로그램의 덩치가 커져야 알 수가 있습니다. 이러한 방식으로 코드가 커지게 되면 다음과 같은 문제가 발생했습니다. 일단 기본적으로 절차적 프로그래밍에서는 전역 변수의 형태로 만들었습니다. 그러다보니 프로그램의 덩치가 커지면 커질수록 변수에 같은 이름을 쓸 수가 없게 됩니다. 그러다 보니까 이 변수명 관리가 굉장히 복잡해지게 됩니다. 그러다보니 이름 앞에 foo_x, foo_y, bar_somthing과 같이 prefix가 늘어만 가고 매번 이렇게 prefix를 붙이지 않고  하나의 파일단위 혹은 모듈단위로 prefix를 부여해서 관리하는  namespace(네임 스페이스)   라는 방식이 등장을 합니다. 데이터를 묶어서 관리해보자! = 구조체 그러나 namespace만으로는 비슷한 형태의 데이터들을 여전히 쉽게 다룰 수는 없었습니다. 가령 게임을 만든다고 가정해보면 하나의 캐릭터에 속해있는 이름, hp, mp, item 등 구조의 형태를 가지는 변수를 만들기 위해서는 여전히 prefix를 붙여서 만들어야 했습니다. 위와 같은 식으로 프로그래밍을 하게 될 경우 캐릭터가 2개, 3개만 되어도 만들어야 할 코드와 중복될 내용이 눈에 선하죠. 그래서 이렇게 서로  연관이 있는 데이터들을 하나로 묶어서 namespace처럼 관리하여 해당 변수에 접근을 할 수 있는  구조체 라는 형식을 생각하게 됩니다. 이를 통해서 의미있는 단위로 변수들을 하나로 묶음으로써 변수명의 중복을 줄이고 함수나 배열등에서도 하나의 변수처럼 활용할 수 있게 되면서 코드가 덩치가 커져도 일관성을 유지하면서 코드를 짤 수 있게 되었습니다. 여기까지의 개념으로 만들어진 언어중에서 가장 유명한것이 바로  C언어  입니다.  struct https://ko.wikipedia.org/wiki/Struct 객체 지향 프로그래밍의 등장 구조체가 생기면서 산재해 있는 데이터들를 의미있는 데이터로 구조화 시켜서 프로그래밍을 하니 동작보다는  데이터를 중심으로 코딩을 하게 되면 코드의 덩치가 커져도 일관성을 유지하기 좋다 는 것을 깨닫게 됩니다. 그러면서 코드를 한데 모으다 보니 다음과 같은 패턴이 자주 만들어진다는 것을 알게 됩니다. 위와 같이  특정 구조체만 가지고 동작을 하는 함수군 들이 만들어진다는 것을 알게 되었고 함수 역시 전역네임스페이스를 쓰고 있다보니 character_와 같은 prefix를 달아야한다는 것을 알게되었습니다. 그러면 구조체에 항상 쓰이는 함수들도 하나로 합치는 것은 어떨까? = class 그래서 구조체와 항상 쓰이는 함수들을 하나로 묶어서 구조체와 함께 함수까지 포함하는 개념을 만들게 되고 이를  class  라고 불렀습니다.  struct + function(struct, ...) = class 이렇게 만들고 보니 기존의 데이터와 처리방법을 분리해서 개발하던 절차식 프로그래밍과 달리  데이터와 처리방식이 하나의 모듈로 관리 를 하게 되면서 마치  작은 프로그램들이 독립적으로 돌아가는 형태  를 띄게 되어 덩치가 큰 프로그래밍을 작성을 하더라도 하나의 목적을 가진 큰 프로그램을 만들어가는 것이 아니라  작은 부품들을 미리 만들어두고 이를 조립하고 결합하는 방식  으로 개발을 할 수 있다라는 것을 알게됩니다. 그렇다면 이러한  부품을 만드는 설계도 를 만들어두고 공장에서  찍어내듯이 부품을 만들고  이것들을 조립을 하는 것과 같은 개념으로  class 와  object 가 등장을 합니다.   기존의  구조체와 함수를 합쳐서 선언하는 것을  Class   라고 부르기로 했고 Class를 통해 만들어진 결과물을  값 과  동작  을 함께 가지고 있는 것이  주위 사물과 유사하다고 하여  Object   라고 부르기로 했습니다. 이런식으로 작은 문제를 해결하는 것들을 모아서 하나의 문제를 해결하는 프로그램으로 개발하는 방식을   Bottom-up   방식이라고 하여 이렇게  작은 문제를 해결하는 독립된 객체를 먼저 만들고 조립하자는 개발방식 은 다음과 개념이 확장이 되게 됩니다. 프로그램은 모두 객체로 만들어져있고 객체들간의 메시지를 주고받는 상호작용으로 이루어진다. 이렇듯  프로그램을 객체로 바라보는 관점 으로 프로그래밍을 하는 것을   Object-Oriented Programming (OOP) = 객체지향 프로그래밍   이라고 부르게 되었습니다.   독립된 객체를 조립해서 사용하는 방식은 곧 레고와 같이  재사용이 가능한 객체들을 많이 만들어 놓는 것이 중요 하다는 것을 알게 되고  객체의 재사용 을 높이기 위해 OOP에는 아래와 같은 여러가지 개념들이 추가되었습니다. 외부에서 알 필요 없는 것들은 숨겨놓자! - 캡슐화 작은 문제를 해결하는 독립된 객체를 사용하게 되면서 객체의 모든 데이터에 접근을 해야 할 필요가 없다는 것을 알게 되었습니다. 내부의 데이터는 내부에서 알아서 조작을 할 수 있도록 하고 외부에서는 필요한 내용만 만들어 두는 편이 프로그램의 안정성과 사용성 측면에서 낫다라는 것을 알게됩니다. 그래서 꼭  외부로 노출해야 하는 값과 내부에서만 사용하는 값을 구분하는 기능 을 추가하도록 합니다. 이를 데이터를 보호해주는 캡슐과 같은 것으로 보고 내부 데이터에 바로 접근을 하지 못하게 하고 필요한 메소드만 열어두는 특성을   캡슐화   라고 부릅니다. 객체지향 프로그래밍에서는 이러한 캡슐화를 객체의 안정성을 높이고 필요한 메소드만 열어둠으로써 객체의 재사용성을 높일 수 있도록 하였습니다.  은닉을 향한 자바스크립트의 여정 https://ui.toast.com/weekly-pick/ko_20200312 객체의 일부분만 재사용은 어떻게 해야 되지? - 상속! 객체가 중심이 되어 객체를 재사용을 하는 것은 좋은데 객체는 여러개의 변수와 여러개의 함수가 섞여 있다보니 일부는 재사용을 하고 일부는 달라져야 하는 경우가 빈번하다는 것을 알게 됩니다. 그래서  객체의 일부분만 재사용을 하는 방법이 필요하다 는 것을 알게 되었습니다. 그래서 이러한 반복을 안 하기 위해서 어떤 방법을 생각을 했을까요? 스타크래프트를 한번 만든다고 상상 해 봅시다. 우리는 열심히 코딩을 해서 저글링 클래스를 만들었습니다. 그리고 이제 히드라를 만들어보려고 합니다. 그런데 히드라를 만들다 보니 저글링과 동일한 로직이 너무 많습니다. hp가 0이면 죽고 땅으로 이동하는 알고리즘도 동일합니다. 하지만 모션도 다르고 공격방식도 다르고 hp도 다르죠. 그래서  객체에서 공통된 부분만 따로 만들어서 그 코드를 같이  상속  받아서 활용 을 하고 나머지 달라지는 것들만 각자 코드를 작성하는 방식으로 만들면 어떨까하는 생각을 하게 됩니다.  상속을 받을 수 있는 객체 이름을 따로 지어줘야겠다! - 추상화 그렇다면 객체에서 공통된 부분의 코드를 어떻게 만들고  어떻게 이름을 붙여줘야 할까요? 저글링도 히드라리스크도 함께 포함되고 있는 속성을 함께 가지고 있을 이름을 찾다보니 Unit이라고 부르면 좋을 것 같네요. 우리가   사과 ,  바나나 를 한데 모아  과일  이라고 부르듯이  공통적인 부분을 모아서 상위의 개념으로 새롭게 이름을 붙이는 것을  추상화 라고 합니다. 이렇게   상속  과   추상화   를 통해서  객체의 일부분을 재사용을 하는 방법 을 찾게 되었습니다. 우리는 다 같이 움직이지만 각자의 방식으로 움직여요! - 다형성   이렇게 해서 상속과 추상화를 통해서 객체를 만들면 어떤 점이 좋아질까요? 스타크래프트에서 드래그 해서  저글링 과  히드라 ,  뮤탈리스크 ,  오버로드 를 함께 섞어  유닛 들을 선택한 다음에 어디로  이동 을 하라고 하는 내용을 구현한다고 생각해보겠습니다. 저글링과 히드라는 걸어서  이동 하고 뮤탈리스크와 오버로드는 공중으로  이동  을 할 것입니다. 각자 이동하는 속도나 방법도 제각각이죠. 하지만 우리는 이 모든 것들이 하나의  이동 이 가능한  유닛  으로 취급하여 같은 타입으로 취급을 할 수 있게 됩니다. 이렇듯 추상화된  유닛 이라는 타입은  저글링 과  히드라 ,  뮤탈리스크 ,  오버로드  등 하위 타입인  여러가지 타입 으로 참조할 수 있다는 개념이 바로   다형성   입니다.  상속 과  추상화  그리고 같은 Unit의 메소드를 사용하지만 각자 정의된 방식이 있다면 각자의 방식대로 동작 할 수 있도록 하는  다형성 을 통해서  객체의 일부분만 재사용이 가능하도록  설계가 되었습니다. 객체 지향 프로그래밍의 발전   이렇게 객체지향 프로그래밍의 개념들이 정립이 되고 다듬어져 c++과 같이 객체지향 프로그래밍을 할 수 있는 언어들이 등장하기 시작했습니다.  객체지향 프로그래밍은 점차 주류 패러다임이 되며 완전 객체지향 패러다임을 지향하는  Java의 등장과 함께 객체 지향 프로그래밍은 프로그래밍 생태계에 주류 패러다임 이 됩니다.  이제 프로그래밍을 할 때에는 객체 지향은 너무나도 당연한 것이고  &quot;모든 것이 객체다&quot; ,  &quot;객체간의 관계&quot;  를 중요시하며 객체를 만들어내는 관점으로 프로그래밍을 바라보게 되었고 객체단위로 만들어지는 재사용 라이브러리나 모듈들로 인해서 기존 절차적 프로그래밍에 비해 훨씬 덩치를 키우기가 용이해졌고 독립적인 단위의 객체를 작게 만들고 조립한다는 개념은 엔터프라이즈 단위의 프로그래밍에서 훨씬 더 빛을 발하게 되었습니다. 그러나 객체지향은 언제나  복잡함  이라는 것을 가지고 있는 개념이기에 그냥 class와 object를 쓴다고 나아지는 것이 아니라 객체지향을 잘 하기 위해서는  객체들의 관계  를 잘 설정해야 하고 이로 인해  초기 설계에 굉장히 노력이 많이 들어가기에  객체지향 그 이상의  설계를 하는 원칙이나 방법 들이 발전하게 되었습니다. 은빛총알은 없다. 객체지향도 잘 해야지! - S.O.L.I.D   이제 기존 프로그래밍 개발의 한계를 벗어나 훨씬 더 덩치가 큰 단위로 개발을 하다보니 객체지향을 쓴다는 것이 무조건 능사는 아니라는 것을 알게 되었습니다. 객체지향을 잘 하기 위해서는 class, object만 써서 되는게 아니라 여기에서도 하면 안되는 것들, 해야만 하는 것들이 발견되게 됩니다. 이러한 과정 속에서  S.O.L.I.D 와 같은  객체지향을 잘 하기 위한 원칙 들 같은 것들이 나오면서 객체지향의 의미를 살릴 수 있고 문제점들을 해결할 수 있다는 것들을 알게 됩니다. 이렇게 객체지향은 조금씩 더 발전을 하기 시작합니다. SOLID가 궁금하신 분들은 제가 예전에 작성했던 글을 한번 읽어보세요 :)  Javascript에서도 SOLID 원칙이 통할까? https://velog.io/@teo/Javascript%EC%97%90%EC%84%9C%EB%8F%84-SOLID-%EC%9B%90%EC%B9%99%EC%9D%B4-%ED%86%B5%ED%95%A0%EA%B9%8C 디자인 패턴의 등장   이렇게 개발 패러다임은 이제 완전히 객체지향 프로그래밍으로 넘어오게 되었습니다. 그리고 객체지향 패러다임으로 오랜동안 경험치가 쌓이다 보니 객체지향을 통해서 만들어지는 보편적인 설계 패턴들이 보이기 시작했습니다.  소프트웨어 디자인 패턴(software design pattern) 은 소프트웨어 공학의 소프트웨어 디자인에서 특정 문맥에서 공통적으로 발생하는 문제에 대해 재사용 가능한 해결책이다. 소스나 기계 코드로 바로 전환될수 있는 완성된 디자인은 아니며, 다른 상황에 맞게 사용될 수 있는 문제들을 해결하는데에 쓰이는 서술이나 템플릿이다. 디자인 패턴은 프로그래머가 어플리케이션이나 시스템을 디자인할 때 공통된 문제들을 해결하는데에 쓰이는 형식화 된 가장 좋은 관행이다. - 위키백과  늘상 부딫히는 문제와 해결하기 위한 객체지향의 설계 그리고 예제코드등을 묶어서 하나의 패턴이라고 이름을 붙여놓고 서로 이러한 문제를 해결하는 관행처럼 사용을 한다 면 훨씬 더 객체지향에 적합한 코드를 만들기가 쉬워질 것입니다. 이런식으로 만들어진 패턴 중 유명한 것들은 대략 20여개 정도가 존재합니다. 이러한 패턴들을 숙지하면서  적절한 문제에 적절한 설계구조 를 만들게 된다면 다소 복잡할지언정 좋은 객체지향 프로그래밍 구조를 만들 수 있게 되었습니다. 우리가 보통 객체지향을 배운다고 하면 도달하는 종착지와 같은 곳입니다.  refactoring.guru | 디자인 패턴을 잘 정리한 사이트를 공유합니다 https://refactoring.guru/design-patterns 자바스크립트와 객체지향   저가요... OOP 디자인 패턴을 배웠거든요? 근데 javascript에서는 어떻게 해야할지 도저히 모르겠네요.. 객체 지향 프로그래밍과 SOLID, 디자인 패턴등을 배우고 나면 마치 모든 프로그래밍을 객체 지향으로 할 수 있을 것만 같고 아주 효과적인 디자인 패턴을 통해서 멋진 설계를 가진 프로그램을 할 수 있을 것 같다는 생각이 듭니다.  (과장이  아니라 실제로 그렇습니다.) 그리고 나서 자바스크립트를 만나게 되면 당황하게 됩니다. class는 어디있지? (- 그래서 지금은 생겼습니다.) interface는 어디 있나요? (- 그래서 typescript가 생겼습니다.) private, protected가 없으면 캡슐화는 어떻게 하죠? (- 그래서 지금 만들려고 하고 있죠.) 자바스크립트도 객체지향의 패러다임이 가장 핫한 시기에 만들어진 언어니 객체지향의 영향을 받지 않을 수 없었습니다. 하지만 자바스크립트를 맨 처음 설계한 사람은 객체 지향 프로그래밍에 회의적인 시각을 가지고 있었습니다. 그렇기에 당시 유행했던 객체지향의 개념은 그대로 가져오되  주류였던 Java와는 전혀 다른 방식으로 OOP를 풀어내게 됩니다. Java와는 다르다! java와는...  https://stackoverflow.com/questions/245062/whats-the-difference-between-javascript-and-java What&#39;s the difference between JavaScript and Java?   javascript 탄생비화 javascript를 창시한 Brendan Eich는 언어를 개발할 당시 유행하던 객체지향에 한계를 느끼고 LISP, scheme등 함수형 프로그래밍에 관심을 가지고 있었기에 함수형 프로그래밍의 형태로 언어를 만들고 싶어 했습니다. 하지만 Netscape의 그의 상사는 당시 개발자들이 제일 많이 쓰던 Java와 같은 문법으로 만들기 요구했기 때문에 결국 둘의 혼종의 형태로 세상에 나오게 되었습니다. :) 자바스크립트는 설계자의 철학도 그랬지만 웹 브라우저에서는 처음부터 복잡한 언어를 만들 생각이 없었습니다. 그저 아주 간단하고 작은 형태의 스크립트 언어면 될 거라고 생각을 했어요.  그래서 복잡한 class나 설계, 추상화나 다형성등을 만들고 싶지 않았습니다. 하지만 당시 가장 인기가 있었던 Java 개발자들을 끌어 들이고 싶었기 때문에  Java의 문법과 패러다임은 최대한 유지 를 해보고자 노력을 하게 되었습니다. 그래서  class가 없는 함수형 언어를 기반으로 하지만 객체 지향 프로그래밍 맛을 느낄 수 있는 언어 가 탄생하였습니다. javascript 설계자에 빙의가 되어 봅시다!  &#39;OOP는 너무 복잡해! 특히 class 문법은 너무 너무 복잡해. 최대한 간단하게 만들자... 그러면서도  객체 지향 처럼 상속, 추상화, 다형성을 할 수 만  있으면 되는거 아닐까?&#39; 라는 목적을 가지고 javascript 최초 설계를 어떻게 했을지 한번 상상을 해보았습니다.  class가 없는데 객체는 어떻게 만들게 할까?  타입이 없는데 객체가 가진 메소드는 어떻게 동작 해야 될까?  그러면 상속이랑 추상화, 다형성은 어떻게 할건데? 상속을 받는다는게 아니라 없으면 찾아간다는 식으로 연결을 해보는 건 어떨까?  그래도 class와 new를 이용해서 객체를 생성하는 방식은 필요하지 않을까? 이렇게 해서 class가 없이 object에 prototype체인은 연결하는 방식을 통해 객체지향의 문법과 객체지향의 상속, 추상화, 다형성을 해결하였습니다. 그리고 이러한 객체를 바탕으로 Object, String, Number, Function, Array등에도 객체지향의 개념을 부여한 기본 라이브러리를 만들어서  class는 없지만 마치 객체지향의 언어를 사용하는 느낌으로 코드를 작성할 수 있는 언어가 탄생 하였습니다. 🎉 아니! 그래도 class가 없이 어떻게 객체지향을 하나요? 당시에는 class가 없이 프로그래밍을 한다는 것은 상상도 하기 힘들었습니다. 그렇기에 javascript 처음 출시가 되었을때에는 수준이 낮은 언어로 폄하당했습니다. 브라우저의 성능의 한계도 있었고 언어도 엄청 단순하게 구성이 되었는데 당연히(?) 있어야 할 class마저 없었으니 말이죠. 그래서 당시에는 수도없이 많은 class처럼 코딩을 하기 위한 라이브러리들이 엄청 많았고 그중에서 prototypejs가 큰 인기를 끌었습니다. 홈페이지를 보면 class를 쓰기 위한 API가 맨 처음 소개되는 것을 확인 할 수가 있습니다.  prototypejs http://prototypejs.org/learn/ 결국 제작자의 의도와 관계없이 가장 많이 요구하던 문법적인 기능이 바로 class였으며 결국(?) ES6에 와서는 class가 정식 문법이 되었습니다. 하지만 ES6의 class는 javascript 객체지향의 근간인 prototype 방식을 문법적으로 class처럼 보이게 만들어준 도구에 불과하지요.   타입도 없고 interface도 없네요?   오리처럼 걷고, 오리처럼 꽥꽥거리면 오리지...  Duck Typing https://ko.wikipedia.org/wiki/%EB%8D%95_%ED%83%80%EC%9D%B4%ED%95%91 자바스크립트는 타입으로 인한 복잡성을 추구하지 않기 위해서 객체의 타입을 따지지 않습니다.  같은 이름의 변수나 메소드를 가지고 있다면 같은 타입의 객체 라고 사용 할 수 있습니다. 이를 통해서 복잡한 객체지향 프로그래밍의 설계를 복잡한 타입정의와 상속을 통해 interface를 맞추지 않고 아주 간단하게(?) 만들어 줄 수가 있습니다. (물론 전통적으로 강력한 타입을 기반으로 하는 설계가 중요한 전통언어의 시각으로 보기에는 어딘가 조잡해 보였겠지요. 그래서 Typescript가 생겨났다는 것을 기억합시다.) 마! 우리는 함수가 1급 객체다!   논란이 많은 자바스크립트 였지만 그래도 초기 설계 중에 가장 칭찬을 받는 점! 바로 함수가 1급 객체라는 점입니다. javascript에서는  document.body.onclick = function(event) { ... }  와 같은 엄청 단순한 1줄짜리의 코드가 Java에서는 이러한 Listener 구현하기 위해서 상당히 복잡한 패턴을 사용해야 했습니다. 함수를 값으로 넘길 수 있고 익명함수와 클로저를 통해서 값을 보관하고 전달할 수 있다는 개념을 통해서 기존의 객체지향에서 복잡하게 구현을 해야했단 수많은 패턴들이 아주 아주 간단하게 해결이 되는 것을 확인했습니다. 이러한 함수가 값이 될 수 있다는 점은 추후 많은 객체지향 언어에 새로운 영감을 주었고 지금은 객체지향만 고집하지 않고 함수형과 객체지향을 적절히 섞어 쓰는 방식으로 발전을 하고 있습니다. 객체지향의 시각으로 보았을때 모자라던 언어가 이제는 객체지향의 패러다임에게 영향을 주고 있는 언어가 되었습니다. 그래서 javascript에서는 객체지향을 어떻게 해야 하나요? 언제나 그렇듯 코딩에는 정답은 없습니다. 그리고 계속 트렌드는 바뀔테니까요. 객체지향의 패러다임이 충만하던 시기에서 바라보던 javascript는 class도 없는 열화판 객체지향을 흉내낸 언어였습니다. 물론 이 사이 지극정성으로 ES를 돌봐주었기에 지금 사람같은 언어가 된 면도 있지만 결국 객체지향을 완벽히 지향하지 않았기에 지금의 자바스크립트가 생겨났고 이러한 개념이 다른 객체지향언어에 영향을 줄 만큼 강력하다는 것을 우리는 배웠습니다. 대부분의 객체지향 프로그래밍의 이론이나 설계등은 Java의 최전성기 시절에 구축되었던 방법론들입니다. 모든 것이 객체이며 객체간의 메시지의 흐름이 중요하고 객체를 중심으로 설계를 해보려고 하니 타입과 인터페이스들로 복잡한 프로그램이 만들어졌고 이러한 패턴들을 또 모아서 학습을 하곤 했습니다. javascript는 java와는 태생이 다르기에 그 모든 것을 이해하더라도 결국은 javascript스럽게 하는 것이 가장 좋다입니다. 극단적으로 객체지향을 배제할 필요도 없고 복잡하게 객체지향으로 설계를 해야할 필요도 없습니다. 객체지향의 개념으로 데이터와 메소드를 통해 독립적인 작은 프로그램으로써 만들어 편리하게 재사용하는 장점을 취하되 객체들의 결합이 높아져서 프로그램이 과도하게 복잡해지지 않도록 굳이 객체로 만들지 않아도 될 부분들은 함수형으로 만들어서 결국  간단하고 가독성있고 덩치가 커져도 유지보수하기 좋으며 재사용이 편리한 코드를 만들어 내는 것 이 javascript를 잘 하는 것이겠지요. javascript는 객체지향과 함수형의 2가지 관점을 모두 가지고 있는 언어기에 이러한 밸런스를 잡는 것이 중요합니다.  물론 언제나 말은 쉽습니다. 실천이 어려운 것이지요. 끝으로... 객체지향 프로그래밍은 프로그래밍 산업이 발전하면서 프로그램의 덩치가 커져가면서 생기는 어떤 문제점을 해결하기 위해서 나온 하나의 관점이나 방법론입니다. 기존의 방식으로는 변수들을 하나씩 관리하다 보니 변수명을 공유해서 써야 되는 문제들이 생기는 문제들이 발생했습니다. 연관있는 이름들을 하나로 묶어주는 구조체 라는 타입을 만드니 데이터를 중심으로 프로그래밍을 할 수 있게 되었습니다. 그렇다면 데이터와 함수를 한데 묶어서 관리를 하면 어떨까? 이렇게 하니 하나의 큰 프로그래밍을 작은 문제를 해결하는 독립적인 단위로 만들수가 있게 되었습니다. 이렇게 작은 단위로 관리를 할 수 있게 되니 개발과 유지보수가 간편하게 된다는 장점을 알게 되었습니다. 이러한 객체를 설계하고 찍어낼 수 있는 구조를 클래스라고 하고 클래스에 만들어진 인스턴스를 Object라고 하여 프로그래밍의 모든 것들을 이러한 객체로 간주하여 객체간의 상호작용을 중심으로 생각하고 설계하는 프로그래밍 개념이 바로  Object-Oriented Programming (OOP) = 객체지향 프로그래밍  입니다. 객체라는 개념을 기반으로 만들어진 코드의 일부분들을 보다 효율적으로 재사용을 위해서 캡슐화, 상속, 추상화, 다형성이라는 추가적인 개념이 추가되면서 객체지향은 발전해 왔습니다. 그러던 중 javascript라는 언어는 객체지향의 패러다임은 계승하면서도 단순하고 간단한 언어를 추구하다보니  Java의 문법을 쓰지만 함수형을 기반으로 하는 class-free 프로토타입 기반 OOP 라는 독특한 변화구를 가진 객체지향맛 언어가 탄생했습니다. javascript가 쏘아올린 작은 공으로 인해 객체지향 언어가 최고라는 패러다임은 적절히 함수형 프로그래밍과 섞으면 좋다 라는 것을 알게 되었고 Typescript가 대중화되면서 다시 Type과 Class, Interface가 있는 언어가 되었지만 이미 패러다임은 이미 바뀌었습니다. javascript는 함수형 언어도 객체지향 언어도 아니지만 또 함수형 언어이기도 하고 객체지향 언어이기도 합니다. 많은 사람들의 손이 타다보니 여러 취향을 반영할 수 있는 재미난 언어가 되어버렸습니다. 객체지향의 패러다임은 대부분은 Java가 전성기이던 시절에 완성이 되었습니다. 물론 지금이야 멀티패러다임 언어가 흔해졌기에 모두가 그렇지는 않지만 대부분의 객체지향 패러다임은 온전히 javascript와는 맞는 옷은 아닙니다. 데이터와 메소드를 기반으로 작은 문제를 독립적으로 해결할 수 작은 프로그램을 만들어 코드의 재사용을 높이고 간결한 문법을 통해 개발과 유지보수를 편하게 할 수 있다는 장점은 취하고 객체를 연결하는 과정에서 과도하게 객체지향을 통해 만들어진 복잡한 구조를 만들지 않도록 지양하고 이를 함수형 프로그래밍이 가지고 있는 장점과 결합을 하여 적절한 선을 찾아내고 만들어 가는 것이 현대 javascript에서 객체지향 프로그래밍을 잘한다라고 볼 수 있는 것 같아요. 그러기 위해서는 역시 많은 경험을 통해서 무엇이 좋고 무엇이 나쁜지 알아가서 본인만의 눈을 기르는 것이 중요하겠지요. 이 글이 그래도 무작정 경험을 쌓기보다는 조금 더 전략적으로 접근을 할 수 있는 길잡이가 될 수 있었기를 바랍니다. 긴 글 읽어 주셔서 감사합니다 ❤️  If? 프롤로그 결과를 미리 알면 재미가 없는 것 같아서 어떠한 생각의 발전을 통해서 최종 결과물이 나왔는지 이 여정을 함께 해주었으면 좋겠습니다. 정말 멋진 결과물이 나왔으니까 꼭 끝까지 함께 읽어주세요. 스프린트의 결과물은 글 맨 마지막에 두었습니다. 첫째날: 스프린트가 4기 시작합니다. 이렇게 스프린트 4기에 참가 신청을 해준 이안, 세인트, 아이뽀송, 다나, 춘식, 단테, 준, 데비니 모두 모두 고마워요! 좋은 사람들과 또 어떠한 이야기가 만들어질지 생각하니 설레네요. ❤️ 게더 타운에 모였습니다.   Team Canvas 서로를 알아가는 시간 팀 캔버스 ~  소리가 잊혀지지 않습니다. ㅋㅋ (고마워요!)   🔥 팀 캔버스는 다른 스터디를 하거나 사이드 프로젝트를 할때 꼭 한번 시도해보세요. 처음 만난 사람이 어색하지 않게 생각을 하나로 만들어 주는 좋은 시간이고 프로그램입니다.  제 기준 가장 재밌었고 각자의 개성이 잘 드러났던 주제들을 선정해보았습니다.   서로을 보완해줄 수 있는 사람들이 이렇게 모인다는 것은 참 소중한 인연이라고 생각해요 :)   &quot;다같이 불화없이 행복하고 5일동안 이 정도면 애썼다 최선을 다했다 할만큼 하면서도 이런것도 했다는 결과물을 만들어 내고 또한 스프린트의 과정이 기억에 남고 많이 배울 수 있는 시간이 되기를 바랍니다!&quot; 아이디어 경진 대회!! 각자의 너무나도 소중한 아이디어가 있었고 최종 논의 결과 npm react 라이브러리 배포라는 준의 아이디어가 결정이 되었답니다. 👏     무엇을 만들게 될지는 모르겠지만 앞으로 만들 라이브러리를 그려본 채 첫째날이 마무리 되었습니다. 둘째날: 각자의 생각을 탐색해보고 방향성 정해보기   일단 각자 생각해 온 아이디어를 먼저 작성을 해보되  결정하기전 서로 논의가 어긋나기 않도록 먼저 가치에 대해 합의를 하는 시간을 가졌습니다. &quot;우리 라이브러리는 이랬으면 좋겠다. 목적, 가치&quot;   어그로가 잘끌리는 readMe 이 기능을 만들때에는 이 라이브러리를 쓰면 돼 하는 이스터에그 쉽고 직관적이어야 한다 재미있는 아주 개성이 넘치거나 아쉬울때 넣으면 확실한 대체제 여기서 살짝 머리가 복잡해지기 시작했어요.  아무래도 서비스가 아니라 라이브러리를 선택한 만큼 라이브러리의 정체성을 벗어나는 방향으로 튀지는 않을까 염려가 되었습니다.  그래서 구현 컨셉보다 라이브러리에 대한 정체성 부터 함께 fit을 맞추고 시작해야하나? 고민을 잠시 했지만 잠깐 환기를 시키는 선에서 마무리 해봤습니다. (잘한 것 같아요) 그리고 우리의 지도를 찾기 위한 먼 여정을 떠나보도록 했습니다! 우리가 찾아낸 워딩을 질문으로 바꿔서 deep dive를 해봐서 모두가 합의할 수 있을만한 것들을 찾아내는 시간을 가졌습니다. 어떻게 하면 어그로 잘 끌리는 README.md가 될까? 어떻게 이스터에그를 만드는게 좋을까요? 어떻게 쉽고 직관적인 라이브러리가 될까? 어떻게 하면 이 기능을 만들때 이 라이브러러를 쓰면 돼 라는 말이 나올까?       (중략...) 여기에서 대부분의 마음이 일치하면서 gif, demo가 필요한 컨셉으로 진화 할 수 있을거라고 생각했습니다.      그리하여 일단 npm에 배포할 react 라이브러를 만들어보자라는 생각은 컨셉이 확실한 디자인이 예쁜 컴포넌트 라이브러리의 형태로 방향성이 모아졌습니다.   정말 여기까지 머리 쥐어짜내진다고 엄청 고생했을텐데 다들 너무 너무 수고 많았어요!!! 👏👏👏👏 셋째날: 스케치와 결정하기 레퍼런스 공유와 개인 스케치 발표     결정의 시간부터...   스케치 아이스 브레이킹!!       본격 스케치 시간관계상 라이브러리를 형태에 대해서만 스케치를 해보는 시간을 가졌습니다.     이제부터는 그들만의 시간입니다! 주말동안 열심히 각자 페어 프로그래밍을 하는 모습이었습니다!         결과물 발표: 우리는 무엇을 만들었을까요? 👏👏👏     React Season Component https://www.npmjs.com/package/react-season-component https://ppo-f-man.github.io/react-season-component-web/       와!! 생각했던 것 이상으로 너무 멋진 결과물이 나왔답니다!! 꼭 한번 구경해보시길 바래요!!     회고 하기 정말로 멋진 5일이라는 시간이 지나고 지난 날을 돌이켜 보는 시간을 가졌습니다. 해냈다는 느낌도 중요하지만 이걸을 기록하고 다시 돌아보면서 무엇이 좋았고 무었기 아쉬웠고 무엇을 하고싶다는 것을 느낌이 아닌 기록으로 남겨보고자 회고를 해보았습니다!          끝으로... npm 라이브러리를 만들어보자라는 새로운 주제로 인해서 많은 고민도 있었고 우리 스프린트는 완성이 아니라 체험이 목표였지만 주말에 열정을 갈아넣어 (미안해요 ㅠㅠ) 멋진 결과를 만들어진 스프린트 4기 정말 정말 수고 많았어요. 이 글을 통해서 다시 한번 그 시간을 돌이키며 추억을 소환하는 시간이 되기를 바랍니다. 긴 글 읽어주신 모든 분들도 모두 모두 감사합니다 :)   다른 사람 회고 보러가기 * 이번 4기 스프린트를 참여하며 어떤 기술적 고민을 했는지 적어보았습니다 🙂 * https://velog.io/@jay/react-season-component-sprint-4th  테오의 구글 스프린트 4기 후기 (+npm 배포 🙌) https://velog.io/@deli-ght/%ED%85%8C%EC%98%A4%EC%9D%98-%EA%B5%AC%EA%B8%80-%EC%8A%A4%ED%94%84%EB%A6%B0%ED%8A%B8-4%EA%B8%B0-%ED%9B%84%EA%B8%B0-npm-%EB%B0%B0%ED%8F%AC  NPM 배포 어렵지 않아요 https://velog.io/@junghyeonsu/NPM-%EB%B0%B0%ED%8F%AC-%EC%96%B4%EB%A0%B5%EC%A7%80-%EC%95%8A%EC%95%84%EC%9A%94-with-%ED%85%8C%EC%98%A4-%EA%B5%AC%EA%B8%80-%EC%8A%A4%ED%94%84%EB%A6%B0%ED%8A%B8-4%EA%B8%B0   typescript를 꼭 해야하나요? typescript는 어떤 게 공부하는 게 맞을까요 ㅠㅠ 도무지 감이 안 잡힙니다.  이번에 이직 면접 보면서 typescript 이야기 나와서 일단 왜 도입하는지 본인 나름대로 정리는 해두는게 좋더라구요 그렇더라도 처음 배우는 입장이라면 바닐라js는 한번 학습한 뒤에 ts를 더해서 학습해야 헷갈리는 부분이 덜하지 않을까 싶은데, 다른분들 의견은 어떠신지 궁금하네요 🙂 타입스크립트를 100% 활용하려면 OOP로 설계를 하는 것이 맞는지 궁금합니다..! 이번 글의 소재를 제공해주신 많은 분들께 감사를 드립니다. 이번 글에서는 타입스크립트와 관련된 이야기들을 모아서 하나로 정리해보았습니다. 프롤로그 지금 현재 개발하는 상황을 보면  Typescript 은 피할 수 없는 어떤 하나의 대세가 된 것 같습니다. Typescript가 나온 이후로 점점 Typescript로 만들어지고 있는 라이브러이나 코드의 비중은 높아지고 있고 아직도 상승중으로 보입니다. 초기 자바스크립트 같은 경우에는 애초에 이렇게 웹이 커질 거라고 생각하지 않았기에 단순한 형태의 간단한 스크립팅 언어로 만들려고 했습니다. 그래서 대부분 짧은 형태의 간단한 코드들로 이루어 질 거라고 생각을 했었습니다. 그러다보니 최대한 간단하게 만들기 위해서 언어의 어떤 복잡도를 최소화하는 방향으로 구성을 하게 되었습니다. 그러면서 러닝커브를 낮추기 위해 당시에 가장 유행을 하고 있던 C++, Java의 문법을 빌려오는 방법으로 구상이 되었습니다. 그래서 Java계열 문법을 차용하면서도 type을 제거하고 class와 같은 복잡성을 야기하는 부분들도 전부 제거하여  간결한 문법을 가지면서도 타입없이 객체지향도 함수형 프로그래밍도 할 수 있는  prototype 객체기반 함수형 동적타입 스크립트  라는 아주 독특한 컨셉의 언어 가 만들어졌습니다. 그 당시 정통 언어(?)를 하던 개발자들이 보기에는 javascript는 아주 형편없는 언어였습니다만, 웹 산업의 발전이 급격해지면서 자바스크립트는 웹 개발의 필수언어가 되다보니 강제적으로 성장을 할 수 밖에 없었습니다.  그래서 javascript를 Java처럼 만들기 위한 노력이나 javascript을 python처럼 만들기 위한 coffeescript등 아니면 javascript를 쓰더라도 class처럼 개발을 하기 위한 수많은 라이브러리들과 javascript를 대체하기 위한 언어의 개발은 꾸준히 있어 왔습니다.   이러한 모든 시도들은 결국 성공하지 못했지만  Typescript는 그걸 해내고 말았습니다.  과연 Typescript는 어떠한 언어이고 그리고 현재 Typescript는 어떤 위치인지 Typescript를 배우거나 사용하기 위해서는 어떻게 접근을 하면 좋을 지 한번 이야기 해 보고자 합니다. ECMASCRIPT 4는 왜 없을까? https://evertpot.com/ecmascript-4-the-missing-version/ 우리가 사용하는 javascript의 사양이 되는 ECMAScript는 ES3, ES5, ES6,... ES4가 없다는 사실을 알고 있었나요? 무려 20년도 더 전인 1999년부터 2008년까지  javascript를 좀 언어다운 언어로 업그레이드를 해보자 는 프로젝트가 진행이 되었습니다. 그래서 javascript에 class, 정적타이핑, 인터페이스, 제네릭 등 javascript에 당시에 사용하던 다른 언어 (라고 쓰고 정적타입 객체지향 패러다임) 의 개념들을 넣기 위한 논의가 시작되었습니다.     이렇게 정상적인(?) 언어로 다시 탄생할 뻔 했던 javascript는 여러가지 이해관계자들이 모여서 각자의 이해관계를 논의하게 되면서 prototype과 함수기반의 체계를 이미 가진 언어에서 class와 정적타입 기반의 언어로 체계를 바꾸는 것은 너무 많은 변화와 하위호환성 유지의 어려움을 지적받게 되며  javascript의 체계를 유지하면서 조금씩 고쳐나가자는 방향 으로 바뀌게 됩니다.   ECMAScript 4 뒷얘기 http://channy.creation.net/blog/454 이 사양은 결국 2008년 정식으로 폐기가 되었지만 ECMAScript4를 그대로 이어받아서 만들어진 Flash의 ActionScript3도 만들어지고 이때 논의되었던 내용들을 계기로 여전히 자바스크립트를 좀 다른 언어로 바꿔야겠다는 시도는 끊임없이 일어나게 됩니다. 그 당시 OOP 패러다임이 지배하고 있던 세상에서는 javascript에  OOP를 도입하기 위해 필요한 라이브러리 들을 여전히 시도되었으며  javascript의 부족한 문법을 개선 하고자 조금더 python 스럽게 만들어 보고자 했던  coffeescript 가 또 한때 인기를 끌게 됩니다. (이러한 coffeescript의 인기로 인해 arrow function이나 구조할당분해, template literal 같은 문법들이 es6에서 표준이 되기도 합니다.) 이후  babel 이 등장을 하게 되면서  여러가지 문법적인 개선시도 를 하게 되어 decorator나 optional chaining, nullish등 여러가지 문법적인 개선이 시도되고 그중 호응을 얻었던 것들은 Native에 편입이 되는 식으로 javascript가 발전을 하게 됩니다. javascript를 바꾸고 싶다는 열망과 시도들은 굉장히 많았으나 결국 javascript가 살아남고 현재의 모습을 하고 있는 것은   prototype 객체기반 함수형 동적타입 스크립트   라는 당시에는 이 괴상한 조합이  알고봤더니 굉장히 쓸만하다는 것 에 대한 합의때문입니다. 실제로 객체지향에 함수형 프로그래밍 컨셉을 얹은 이 방식은 Java에서 파생된 Kotlin같은 언어에 일부 도입이 될 만큼 유용한 구조였습니다. 결국 모두의 힘이 모여  javascript는 체계는 유지하되 문법을 지속적으로 개선하는 방향으로 성장 을 하면서 사람들이 많이 쓰고 또 사랑하는 언어가 되었습니다. 그렇지만 웹에서 대규모의 엔터프라이즈급의 서비스들이 등장하면서 사람들은 javascript의 체계에서 아쉬운 것을 하나 발견하게 됩니다. 그렇습니다. 그것은 바로   Static Typing   입니다. 최근에 끝났던 statofjs 2021에서도 자바 스크립트에서 가장 부족한 점, 가장 먼저 개선돼야 될 과제에서 첫 번째로 꼽혔던 게 바로 이  Static Typing  이었죠.   javascript는 타입이 없기에 굉장히 문법이 단순하며, Dictionary와 Object를 하나로 통합해서 객체를 다루듯이 데이터를 다룰 수 있고 Prototype을 통해 동적으로 타입을 변경할 수도 있고 메소드를 동적으로 교체를 할 수 있으며 Duck Typing을 통해서 굉장히 유연한 체계를 가진다는 장점이 있었습니다. 하지만 이 장점은 프로그램의 사이즈가 작고 이러한 장점을 잘 사용할 라이브러리들에는 아주 유용한 장점이나 대규모의 협업을 해야 하기 위해서는 이미 만들어진 스키마 위에서 작업을 하는 과정에서 자잘한  오타로 인한 에러발생 과 무엇보다 그 에러는 바로 확인되는게 아니라  실행하면서 런타임이 되어서야 에러를 발견할 수 있다는 치명적인 문제 는 생산성의 큰 저하를 가져왔습니다.   이러한 연유로 기존의 타입을 통해 컴파일이 메모리 사용에 대한 최적화를 할 수 있는 그런 정적타입의 언어의 형태로 기존 javascript의 동적타입 체계를 완전히 뒤엎는 언어로 바꾸는 것은 아니지만  정적타입 언언의 장점인 빌드전에 미리 오류를 검증할 수 있다는 장점만 합치는 방향 으로 발전을 하게 됩니다. MS: 내가 원래 개발언어와 IDE 개발의 원조지! javascript를 ECMAScript4의 형태로 가장 만들고 싶었던 벤더는  Microsoft 였습니다. 이미 C++, C# 등의 언어를 만들어서 성공했던 경험이 있을 뿐더러 Visual Studio등을 통해서 IDE를 이용한 수익이나 개발 관련해서 영향력을 행사하고 있었기 떄문입니다. 마이크로소프트가 IE를 통해서 웹에 대한 주도권을 가지고 있었으나 점차 방만한 업데이트를 하고 웹에 대해서 큰 투자를 하지 않은 상황에서 브라우저엔진은 safari가, javascript v8엔진을 가진 구글과 가장 많이 쓰고 있는 react라는 웹 프레임워크를 가진 페이스북등 웹에 대한 주도권에서 마이크로소프트는 점점 멀어지고 있었습니다. 이제 다시 정신을 차리고 다시 웹쪽으로 눈을 돌린 마이크로소프트가 보기에 웹에서 영향력을 행사하기에 남아있는 부분이 어딜까를 고심을 하다보니 원래 마이크로소프트가 잘하는 언어와 IDE를 만드는 쪽의 노하우를 통해서 웹쪽 영향력을 다시 영향력을 행사하고자 하는 욕심이 있었을 거라고 생각을 합니다. 마이크로소프트웨어도 주류가 되어버린 웹으로 오게 되면서 기존에 만들었던 핵심 어플리케이션인 오피스와 함께 Visual Studio를 웹으로 옮기려는 시도를 하게 되고 우리가 너무나 잘 쓰고 있는 VSCode가 탄생하게 됩니다. 기존 Visual Studio에서의 가장 큰 강점이라고 하면 정적언어에 대한 AutoComplete와 다양한 보조도구들이었는데 javascript는 기존의 언어와는 결이 맞지 않았습니다. 그리하여 자기들이 가지고 있는 언어인 c#과 유사한 형태로 언어를 만들되 기존의 언어를 바꾸는 시도가 모두 실패했다는 것을 거울삼아 javascript를 버리고 새로운 언어를 배워야만 하는게 아니라 javascript의 원형을 그대로 살리면서 자기들의 IDE에서 제대로 동작할 수 있도록 하기 위한 언어를 만들어내기 시작합니다. 모든 css가 sass이듯이 그래해서 모든 javascript는 typescript다라는 superset이라는 컨셉으로 기존의 javascript는 typescript엔진에서도 돌아가게 만드는 방법을 택했고 이 방식은 아시다시피 상당히 유효했습니다. 굳이 타입스크립트를 해야 하나요?   (님? 왜 타입스크립트 안함?) 이제는 자바스크립트로 개발을 하고 있다면 주위에서 항상 듣는 소리가 있습니다. &quot;왜 타입스크립트를 안 써요?&quot; &quot;타입스크립트 좋아요~ 써볼 생각 없어요?&quot;  물론 자바스크립트에서 타입스크립트로 굳이 넘어가야 할 이유가 있는가? 에 대해서 사람들이 얘기하는 타입스크립트의 단점들에 대한 이야기를 먼저 한번 짚고 넘어가 봅시다! Typescript의 고질적인 문제1: 속도! typescript의 고질적인 문제는 tsc의 속도가 엄청나게 느리다는 점입니다. tsc로 타입 체크를 하고 한번 빌드를 하기 위해서는 적지않은 시간이 필요합니다. 프로그래밍의 덩치가 크면 클 수록 그 시간은 엄청나죠. 그래서 빌드와 배포가 느려진다는 것은 그만큼 생산성을 까먹는 일이기도 합니다. 그러다보면 Typescript가 좋은 건 알겠지만 굳이 필요한가 라는 생각을 하게 됩니다. 그래서 Typescript에서는 이러한 속도의 문제를 해결하기 위해서 IDE에서는 백그라운드에서 체크를 하고 실제 빌드시에는 타입체크를 하지 않고 빌드를 하는 묘수를 생각해내게 됩니다. Babel와 Typescript와의 아름다운 결합 Typescript는 결국 Javascript를 만들어내는 도구입니다. 정적타입은 유효성 체크일뿐 타입이 맞지 않다고 해서 javascript로써 동적을 하지 않는 것은 아닙니다. Typescript는 Babel과 손을 잡고 Babel의 Parser에 Typescript를 지원하게 하고 Babel에서는 Typescript의 문법만 제거해서 javascirpt로 만들어 주는 플러그인 개발을 성공합니다. 그래서 tsc로 컴파일을 하지 않고서 그냥 typescript를 javascript로 만들고 번들툴을 이용해서 빌드 하는 방식을 통해서 빌드 속도를 대폭 올릴 수 있게 되었습니다. 100배나 빠른 빌드도구 esbuild! 그 이후로는 esbuild가 나오면서 Typescript의 속도문제는 어디상 문제의 영역이 되지 않게 되었습니다. javascript가 아닌 go 언어로 만들어져서 스크립트가 아니라 native방식으로 동작하는 esbuild은 기존 번들 툴의 100배나 빠른 속도를 자랑합니다. 이로인해서 타입스크립트로 빌드하는 과정에서 속도의 문제로 인해 성능이 저하되는 대신 타입 유효성 검사와 AutoComplete를 지원한다는 트레이드 오프에서  속도는 더 이상 기회 비용이 아니게 되었습니다. Typescript의 고질적인 문제2: 잘 동작하던건데 전부 에러가 뜨데요? typescript의 대중화가 덜 된 시절에는 타입이 지정되어 있지 않은 라이브러리들이나 타입스크립트에서 지원하지 않는 동적타이핑을 통해서 만들어진 기법들로 인해서 타입선언이 되어 있지 않은 라이브러리들을 쓰면 계속 빨간 에러 표시와 함께 해야하는 것들이 스트레스였습니다. 그리고 이러한 에러를 수정하기 위해서는 타입에 any를 선언하게 됩니다. 이러한 불합리함(?)들은 Typescript의 효용성에 대한 인식을 낮추게 하며 수많은 any meme들이 생겨나기 시작합니다.   그때는 그랬지만 지금은 아닙니다. Typescript가 완전히 대중화가 된 지금 대부분 사용하던 라이브러리가 Typescript로 작성이 되어 있고 그렇지 않은 경우도 많은 압박(?)들로 인해서 대부분 @types을 내놓거나 오픈소스로 나오고 있는 형국입니다. 반대로 대부분의 라이브러리들이 Typescript를 가지고 재작성을 하게 되면서 오히려 javascript에서는 Typescript 코드를 사용하지 못하는 불상사가 생겨 버리는 경우도 있게 되었습니다. 🔥 그러니 그냥 하세요. 안해야 할 이유가 없습니다. 타입 유효성 체크를 가능하게 하고 강력한 AutoComplete를 제공받는 대신 복잡한 문법과 빌드 속도와 호환되지 않는 라이브러리로 인한 장단점이 있기에 선택입니다라고 하는 시절은 지나가버렸습니다. 지금은 javascript를 쓰더라도 babel이나 번들러를 쓰지 않는다는 것은 상상하기 어렵습니다. 최신 문법은 사용해야 하면서 하위 버전에 맞는 트랜스파일과 모듈을 이용한 번들러는 필수입니다. 그렇다면 왜 굳이 babel을 쓰나요? typescirpt를 쓰면 되죠. typescript는 javascript의 모든 문법을 포함하고 있기 때문에 굳이 typescript를 쓰지 않고 javascript라고 생각하고 써도 아무런 문제가 없습니다. 이 점이 Typescript의 가장 강력한 점이지요. 이미 javascript를 하고 있다면 곧 Typescript를 할 수 있다는 것입니다. 오히려 Typescript를 하지 않으면 javascript에서는 typescript 생태계로 돌아가는 환경을 돌릴 수가 없습니다. 그러니 아직 Typescript를 쓰고 있지 않다면 일단은 한번 시작해보는 것은 어떨까요? 타입스크립트를 대하는 마음가짐과 자주하는 오해 Typescript를 시작하기 어려워 하는 사람들이 많습니다. 아니면 굳이 필요없다고 하는 사람들도 있습니다. Typescript를 하는 것은 기존의 Javascript보다 생산성이 떨어질 거라고 생각하는 사람들도 있습니다. 그런 적도 있었지만 지금은 아닙니다. Typescript를 대한 오해와 어떤 마음 가짐으로 학습을 하면 좋을지 이야기해봅시다. Typescript에 대한 자주하는 오해 3가지 잊지 마세요. Typescript는 javascript의 슈퍼셋입니다.   Typescript는 Javascript에 조금더 문법이 추가된 언어입니다. javascript가 ES3, ES5, ES6처럼 조금씩 새로운 문법이 추가되듯이 그냥 Javascript에 조금 더 문법이 추가된 언어일 뿐입니다. 그 새로운 문법을 반드시 써야할 필요도 없습니다. Typescript는 전혀 새로운 언어가 아닙니다. 또한 Type과 Class를 이용한 전통적인 객체지향 프로그래밍을 하기 위해서 만들어진 언어도 아닙니다. Typescript를 Javascript처럼 써도 Typescript는 여전히 잘 동작할 것입니다. Typescript는 물론 배워야 할 것이 있지만 그 모든 것을 배워야만 쓸 수 있는 것이 아니라 내가 Javascript를 안다면 당장이라도 사용할 수가 있는 언어이며 필요할때 필요한 만큼만 배우면 되기에 러닝커브가 높아도 도입을 막는 허들은 되지 않습니다. 🔥 타입스크립트는 그저 자바스크립트의 자동완성 도구일 뿐이다.   Typescript를 배운다라고 하는 개념은 새로운 언어를 배우는 것이 아닙니다. OOP를 할 필요도 없습니다. 언어의 형태는 아주 유사하고 Typescript를 Java, C# 등에 빗대어 OOP로 풀어가려는 시도도 물론 있습니다. 하지만 Typescript는 그러한 객체지향 정적 컴파일 언어와는 결이 다릅니다. Typescript는 Javascript이기에 Javascript답게  prototype 객체기반 함수형 동적타입 스크립트  처럼 개발을 하고  타입검사  +  AutoComplete  가 문법적으로 추가된 개념이라고 생각해주세요. Typescript를 처음쓰면 놀랄만큼의 자동완성 기능에 다시 Javascript로 돌아가기 싫어질겁니다. 에러가 신경 쓰이면 차라리 strict를 꺼두자. any는 쓰지 마세요!   처음 타입스크립크를 쓰게 되면 잘 모르는데 빨간색 에러들이 엄청 거슬리고 무작정 해당 에러를 막기 위해서 타입들을 붙이고 코드를 수정하다보면 왜 이렇게 해야 하는지 힘이 들 때가 있습니다. 그러고는 @ts-ignore과 any를 찾게 되면서 Type이 덕지덕지 붙은 코드가 만들어지면서 Typescript 무용론을 외치게 됩니다. 처음이라 잘 모르겠다면 무수히 많은 에러를 메꾸기 위해서 any를 남발하지 말고... 억지로 Type을 붙이지 말고 그냥 strict와 lint를 잠시 꺼두길 바랍니다. 나의 기존의 개발경험을 무너뜨리지 말고 그냥 필요할때 조금씩 자동완성도구 같이 꺼내어 쓰기를 바랍니다. Typescript는 javascript 타입스크립트 학습 로드맵 Typescript 그러면 어떻게 시작하고 어떻게 공부를 하면 좋을까요? 일단 가급적 세팅이 되어 있는 프로젝트로 시작하세요. 우선 typesctipt를 맨땅부터 세팅하려고 하지는 마세요. 이미 너무 너무 좋은 세팅들과 변환도구들이 나와있습니다. tsconfig의 옵션은 방대하며 하나하나 이해하려고 했다가는 시작하기도 전에 진이 빠질 수 있습니다. 앞서 배운 마음가짐으로 내 개발경험을 해지치 않고 조금더 편하게 개발해주는 플러그인이라는 생각으로 접근을 해야합니다. https://vitejs.dev/ https://www.npmjs.com/package/tsup   변수 선언과 함수 인자 부터 https://www.typescriptlang.org/docs/handbook/variable-declarations.html .을 한번만 눌러보세요!  이렇게 필요에 의해서 조금씩 타입을 선언해보시면 됩니다. 처음에는 number, string, boolen과 같은 기본 타입과 Array와 함께 선언을 할 줄 알면됩니다. 이후 함수인자의 경우  구조분해 https://www.typescriptlang.org/docs/handbook/variable-declarations.html#function-declarations 🔥 하지만 타입 선언보다는 가급적 자동추론을 사용하자. Typescript는  자동추론 https://www.typescriptlang.org/docs/handbook/type-inference.html 굳이 쓰지 않아도 당연히 이 자리에는 이 타입이라고 알수있는 것은 Typescript는 멋지게 추론을 합니다.   가능하면 Type을 적게 적으려고 해보세요.   자동추론을 하고 있다면 굳이 Type을 중복되게 적어서 2번 수정을 해야하는 경우를 피해봅시다. 백엔드 스키마 interface를 만드는 것을 연습해보자. 프론트엔드 개발에 빼놓을 수 없는 백엔드 API 연동시에 Typescript는 빛을 발합니다. 언제나 Network를 통해서 스키마를 확인하고 어떤 필드에 어떤 내용들이 담겨 있었는지 매번 값을 보고 확인해야했지만 Typescript로 interface를 만들어둔다면 강력한 자동완성과 함께 훨씬 더 스키마를 이해하기 좋아집니다 axios나 react-query 혹은 fetch등과 함께 Response에 interface를 연결하는 작업을 한번 해보고 나면 타입을 외부에서 선언을 해주는  제네릭 이라는 개념을 함께 알게 됩니다. 깊은 것은 아직 몰라도 됩니다.   &lt;Type&gt;   표기를 통해서 적절히 Promise등에 타입을 명시할 수 있다는 개념을 이해하게 되면   Record  등을 통해서 조금 더 복잡한 구조의 타입도 정의하는 방법을 알게 됩니다. 언제까지나 Type은 보조하기 위한 수단이며 편하려고 쓰는 거라는 거 잊지 마세요. type이 맞는지 interface가 맞는지 어떤식으로 작성을 해야 좋은지는 지금은 생각하지 않아도 됩니다. callback을 인자로 만드는 방법을 공부하자  https://www.typescriptlang.org/docs/handbook/variable-declarations.html#function-declarations 이렇게 Type등을 선언해나가다보면 복잡한 Callback을 선언해야 할 일이 생깁니다. Callback의 Type선언은 다 적고 나면 복잡해보이는데 하나씩 적어 나가면 금방 적응할 수 있습니다. 헷갈린다면 별도의 type으로 빼두고 작성하고 다시 끼워 넣어 보는 식으로 Callback Type을 선언하는 법을 배워나가보세요. 축하합니다! 여기까지 오셨다면 Typescript 초급은 이제 끝났습니다. 여기까지 왔다면 이제 javascript로 돌아가기 힘들만큼 편하다는 것을 느꼈을거에요. 유틸리티를 사용하는 법 Typescript의 중급으로 넘어가는 관문은 복잡한 경우의 수에 대한 타입들입니다. 빈번하게 발생을 하지 않지만 타입의 경우의 수가 한가지만 있지 않는 경우들입니다. 대표적인 예가 바로 null와 Object를 함께 쓰는 경우 입니다 javascript는 동적타입의 언어이며 Typescript는 javascript의 체계를 거스르는 것은 아니라고 했습니다. javascript의 동적타입의 여러가지 경우에 대응을 할 수 있도록 Typescript는 여러가지 문법적인 내용들을 추가했습니다. 대부분의 경우에 대해 Typescript는 Type을 정의받을 수 있는 방법들을 제공하고 있습니다. 위와 같이 여러가지 타입을 가지고 있는 경우에는 다시 원하는 하나의 Type로도 다시 변경하는 방법들이 존재합니다.  https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards 공식문서에 다 있지만 차근차근 공부는 안해도 된다.  https://www.typescriptlang.org/docs/handbook/utility-types.html Typescript 사이트는 공식문서가 엄청 친절한 편이며 로드맵이 나쁘지 않게 되어 있습니다. 다만 워낙에 양이 방대하다보니 어디까지를 공부해야 할지 엄두가 안나고 그 방대한 양과 무수히 쏟아내는 에러에 압도되어 Typescript를 힘들어 하는 것 같아요. 공식문서는 빠르게 한번 어떤것들이 있는지 정도만 훑어보시고 거듭 말하고자하는 javascript에  AutoComplete  +  Type  검사용  플러그인  이라는 생각으로 그때 그때 필요한 것들만 찾아서 살펴보는 방식으로 접근을 하시기 바랍니다. 이제는 Error를 zero로 만들어 볼 시간! 에러가 나더라도 적당히 Typescript를 통해서 Type을 붙여보면서 여기까지 왔다면 이제는 Error를 0로 만들어 볼 도전을 하실 수 있습니다. strict도 true로 세팅하고 어떤식으로든 Type을 정리 할 수 있을 거라는 마인드로 해결해나가보시기 바랍니다. as나 any, 괜히 복잡해보이는 형태로 코드가 만들어졌다면 잘못된 방식입니다. 원래 작성하려고 했던 javascript의 모양에서 정말 최소한으로 이걸 안 붙일 수는 없는 그런 형태인가 생각하시면서 에러를 잡아나가다 보면 Typescript를 정말 편한 도구로 활용하시게 되고 이제 훨씬 더 Clean한 코드를 작성하실 수 있게 될 거에요! 끝으로.. 최대한 간단한 언어로 만들기 위해서 태어났기에 기존과는 다른 체계를 가진 매력적인 언어인 javascript! 하지만 갓 태어났을때에는 갖춰야할 것들을 못 갖춘 언어로 취급을 받았기에 javascript를 바꾸려는 시도는 끊임없이 있었습니다. 하지만 javascript의 매력은  prototype 객체기반 함수형 동적타입 스크립트  라는 컨셉이었기에 javascript는 사랑받는 언어로 성장하기 시작했습니다. 그러나 엔터프라이즈급 개발 환경에서는 그러한 매력에도 에러를 확인하거나 협업에 있어서는 다소 불편한 점이 많은 언어였습니다. javascript의 가치를 그대로 유지한채 Type검사와 AutoComplte의 엔터프라이즈 협업을 위해서 꼭 필요한 기능이 탑재된 형태의 Typescript는 이제 웹 개발 엔터프라이즈 씬에서는 완전히 주류언어가 되어버렸습니다.   javascript를 그대로 쓸 수 있으면서 Type체크와 협업을 도와주는 형태의 컨셉 은 기존 javascript 생태계를 그대로 흡수하는 결과를 가져왔습니다. 반대로 javascript로는 Typescript의 생태계를 사용할 수가 없다는 문제도 생겼고  많은 수의 라이브러리들이 Typescript로 다시 작성을 하고 있습니다. 또한 속도와 도입에 따른 번거로움의 장벽도 esbuild와 같은 Native기술의 도움으로 극복이 되고 있습니다. Typescript역시 Native기술을 이용해서 tsc를 다시 개발하고 있구요. 그러니 이제 웹을 한다면 Typescript를 하지 않아야 할 이유가 없기에 트레이드오프를 논하기 보다는  Typescript를 당장이라도 시작하기를 권합니다. 그러나 Typescript에 대한 이해가 부족한채로 무작정 시작을 했다가는 Typescript가 내뱉은 에러앞에 내 코드를 이러저리 바꾸면서 불평과 불만을 쏟아내게 될 것이고 tsc를 그대로 썼다가 한없이 오래걸리는 빌드 시간으로 인해서 Typescript의 효용가치를 잘 못느낄 수도 있습니다. OOP를 더 좋아하는 사람들이 드디어 웹에서도 OOP를 할 수 있다며 Typescript로 내놓는 여러가지 Typescript기반 OOP 관련 내용들로 인해 OOP를 해야만 할 것 같아 javascript의 개발경험을 바꿔야하는 우려도 있을 수 있습니다. Typescript를 공부한다는 것은 작정하고 Type을 기반한 class와 OOP를 다루는 것이 아닙니다. 장황한 tsconfig를 습득하거나 여러가지 Type을 정의하는 것을 미리 배워둘 필요도 없습니다. 미리 세팅되어 있는 vite나 tsup으로 시작하고 기존의 개발 경험 그대로 개발을 하셔도 무방합니다. Typescript는 그저   타입체크와 자동완성을 도와주는 플러그인   이라는 마인드로 접근을 한다면 정말 Typescript의 장점만 이용하면서 부드럽게 도입을 할 수 있을 거라고 생각합니다.   언젠가는 Typescript도 주류가 아니게 될지도 모르겠습니다. 하지만 javascript에서 가장 부족하다고 생각하는 것이   Static Type   으로 투표가 된 만큼 javascript가 늘 그랫듯이 가장 많이 쓰이는 것들을 가지고 새로운 표준이 될지도 모르겠습니다. 언젠가는 Typescript 해봐야지.. 라고 생각하셨다면 아직도 하고 있지 않다면 그냥 오늘 한번 설치해보고 그냥 Typescript로 개발을 바로 해보는 것은 어떨까요? Typescript는 javascript의 슈퍼셋이며 그저 Type체킹과 자동완성을 도와주는 하나의 플러그인이기에 그냥 시작해보세요. 그러면 어느 순간 Typescript에서 다시 javascript로 돌아오기 쉽지 않으실 거에요!   모두 모두 즐거운 개발 하시길 바랍니다!     Typo Saurus Code 하러가기 https://typo-saurus-code.vercel.app/ 빈츠, 민민, 비비, 곤이, 혜심쓰, 웹린이, 폴, 해달  모두에게 감사드려요 :)  구글 스프린트가 궁금하다면 지난 글을 먼저 읽어 보세요 https://velog.io/@teo/google-sprint-1 https://velog.io/@teo/google-sprint-2 구글 스프린트에 대한 이론적인 설명을 충분히 하였기에 앞으로는 어떤식으로 아이디어가 발전이 되어 실제 구현으로 이어지는지 리뷰의 형식으로 적어보고자 합니다. 아이디어가 구체화되는 5일간의 이야기 시작합니다! 전야제 ... 지난 번 스프린트에서 아이디어 준비와 공유하는 과정에서 어떻게 하면 좋을지 몰랐다고 아쉬웠던 부분들이 있어 다시 공유해봅니다. 막연히 생각했던 아이디어를 다음 틀에 맞춰서 한번 작성해보세요 :)  why?  what?  how?  if? 최대한 모르는 상태에서 함께 했을때의 설렘과 긴장감, 두근거림을 위해서(대신 너무 큰 기대 금지!) 스프린트 전까지는 궁금한 내용이나 문의사항은 일단은 저에게만 따로 알려주세요 :) 첫째날 리뷰   | 우리들의 의 첫 만남 - 다 모여 있고 춤추고 있어서 &#39;오?! 알아서들 잘 얘기하고 계시나?&#39; 했지만 캠과 마이크를 켠 채로 한마디도 안했다고 합니다. ㅋ 역시 OT에는 팀 캔버스가 짱인듯...   이번에도 멋진 분들이 함께 해 주었습니다. 팀 캔버스는 언제나 모든 사람들을 하나의 팀으로 만들 수 있는 좋은 프로세스인 것 같습니다.     우리가 함께 해야할 마음가짐과 목표를 다잡아 볼 수 있는 시간이었습니다. 우리가 함께할 스프린트의 주제을 합의하였습니다. (야호~) 각양각색의 재미난 의견들이 많았습니다. 그중에서 다음과 같은 의견이 합의가 되었습니다!   30분간의 즐겁고 치열한 토의(라고 쓰지만 저는 잘 모릅니다. ㅋㅋ) 끝에 우리가 함께 할 스프린트의 주제를 합의 하였습니다. 그리고 우리가 만들어야 할 상상을 통해서 다들 엄청 웃고 즐거워해주었기에 저 역시 그러한 분위기를 느낄 수 있던 시간이라 행복했어요. 그리고 간단하게 우리가 함께 만들 주제의 목적을 한번 적어보았습니다.   둘째날 리뷰 늦은 시간까지 함께 모여 즐겁게 적극적으로 생각을 나눠보는 경험이 피곤했지만 돌이켜보면 즐거웠기를 바라면서 둘째날 타임라인 리뷰 시작합니다! 둘째날에는 우리가 함께 좋다고 생각했던 &#39;개발자들을 위한 영타 게임&#39; 이라는 주제에 대한 서로의 생각들을 공유하고 모두가 함께 해야할 생각의 방향성을 일치해보는 시간을 가졌습니다.   우리 아이디어의 궁극적인 목표   우리 서비스의 가장 핵심 가치는 &quot;재미!&quot; 그리고 &quot;개발자스러움&quot; 이라고 정리를 할 수 있었어요. 목표를 질문으로 바꿔서 생각해보기  재미    개발자스러움   우리가 함께 만들어보려고 하는 이 서비스의 본질은 게임자체를 추구하지만  개발자스러움  이라는 밈이 그득한 서비스이기에 공감대를 통해서 즐거움과 재미를 함께 챙길 수 있다는 것 같아요. 이러한 생각의 공감대를 만들어 본 상태에서 각자가 생각을 해보았던 아이디어들을 한번씩 얘기해보는 시간을 가졌습니다   발산해보자! 이츠 발산 타임!! 여기까지 방향을 맞추고 재료가 모인 상태에서 마음껏 발산을 해보는 시간을 가졌습니다. 우리가 이제는 방향을 맞췄기에 각자 생각이 흩어지지 않은채로 많은 아이디어들을 떠올려 볼 수 있었습니다. 그래서 개발자라면 공감이 갈만한 개발자스러움의 밈과 방식들에 대한 이야기들을 신나게 할 수 있었습니다. ㅋㅋㅋ     우리들의 MAP을 완성하자! 아이디들을 발산만 해두다보면  &#39;아~ 재미있었네요! ㅋㅋ ...... 그래서 우리 이제 뭐해야 돼요?&#39; 하는 불상사를 막기 위해서 어쨌든 스토리보드의 형태로 시작부터 끝까지의 여정을 한번 엮어 보는 시간을 가졌습니다. 그리하여 우리들의 서비스 지도가 완성이 되었습니다! 짜잔!   아이디어 다시 보기! 어땠나요? 아마 처음에 주제가 정해지고 나서 생각했던 상상들과 지금 이렇게 구체화된 모습이 비슷할 수도 있고 전혀 생각지도 못한 방향일 수도 있습니다. 하루가 지나고 MAP을 보니 아이디어들이 다르게 보일 수도 있습니다. 지금보기에도 너무 재밌고 개발자스러운게 있는 반면 어떤 것들은 그 정도까지는 아닌것 같다라는 생각이 들 수도 있습니다. 우리가 지도에서 만든 것들은 확정된 구체화된 아이디어가 아니라 만들어야 할 영역과 우리 생각한 컨셉과 장치들임을 기억하시고 우리가 생각한 &quot;재미&quot;, &quot;개발자스러움&quot; 그리고 &quot;MAP&quot;에 맞다면 얼마든지 새로운 아이디어를 내어도 좋아요! 셋째날 리뷰 셋째날에는 우리가 만들었던 맵을 통해서 얻는 스토리보드에 맞는 각 세부적인 장면들을 그려보고 결정하는 시간을 가졌습니다. 레퍼런스를 모아보자! 우리가 상상해보던 이 아이디어를 누군가도 생각해보지 않았을까? 그렇다면 처음부터 고민하기 보다는 이미 만들어진 것들로 부터 시작해서 더 발전하고 차별화 하고 wow point를 찾기 위해서 레퍼런스를 찾아보는 시간을 가졌습니다. 이번에는 정말 역대급은 많은 레퍼런스가 공유된 것 같아 다들 준비성이 참 좋다는 점에서 놀랍고 고맙고 잘한다고 생각이 들었습니다.         아이스 브레이킹 스케치를 하기 전에 워밍업 시간으로 &quot;외계인에서 내 직업 소개하기&quot;를 한번 해보았습니다.        ㅋㅋㅋ 다들 지금 보시면서 그때의 생각들을 돌이켜 보시기 바랍니다. 본격 스케치 시작 그 중 투표를 많이 받은 몇 가지 스케치들을 공유해봅니다.       주말동안의 페어 프로그래밍 이렇게 우리의 첫만남 - 팀 빌딩 - 아이디어 선정 - 지도 작성 - 스케치 - 결정까지의 프로세스가 진행이 되었습니다. 이 모든 것이 3일만에 이루어졌다는 것이 대단하지 않나요? 새벽까지 피곤하셨을텐데 함께 해주고 즐겁게 임해주셔서 너무 너무 감사합니다. 이제는 스프린트의 하이라이트인 페어 코딩이 남았네요! 우리가 만들었던 아이디어를 구현하기 위해서 함께 고민하고 해결해나가는 과정은 지금 까지의 과정보다 더 어렵겠지만 훨씬 더 재미있고 즐거운 시간이 될 거라고 생각합니다. (그렇다고 너무 갈려나가지는 않기를 바랍니다. ㅠㅠ) 이 때부터는 팀원들간의 시간이었습니다. 후문에 의하면 엄청 즐겁게 열심히 했다고들 합니다. :) 마지막 날 리뷰     킹갓-제네럴 타이포 사우르스는 정말 재밌게 했답니다.          마무리 담소의 시간   모든 것을 끝내고 다 같이 얘기를 하는 것은 참 즐거운 시간이었습니다.  Typo Saurus Code 하러가기 https://typo-saurus-code.vercel.app/   다른 회고 보러가기  테오의 프론트엔드 구글스프린트 3기 체험기 - (feat.개발자를 위한 타자게임) https://blog.borachoi.dev/blog/google-sprint  5일간 야생에서 더 살아남기(feat.테오의 스프린트 3기) https://onlydev.tistory.com/132 테오님을 비롯한 선배님들은 spa 프로젝트 설계를 어떻게 하시나요? 언제나 좋은 소재를 제공해주시는 분들께 감사를 드립니다.  설계에 관한 이야기를 먼저 쓰려고 했는데 먼저 설계의  원칙 이라고 할 수 있는  프로그래밍 패러다임 에 대한 설명이 선행이 되어야 할 것 같아, 현재 제가 쓰고 있는 개발 패러다임인  &quot;반응형 프로그래밍(Reactive Programming)&quot;  에 대한 이야기를 해보고자 합니다.  객체지향 프로그래밍 이나  함수형 프로그래밍 과 같은 개념의 내용이라 깊게 파고 들면 방대한 내용이니 최대한 단계별로 이해할 수 있게 풀어서 적어보았으나 이해가 안되더라도 그냥 재미있게 개발이야기 정도로만 소비해주시면 좋을 것 같습니다. 프롤로그 패러다임의 전환 오늘 해볼 주제는  &quot;반응형 프로그래밍(Reactive Programming)&quot;  에 대한 이야기입니다. 우선 위키피디아로 가서 한번 &quot;Reactive Programming&quot;이 무엇인지 검색을 해보겠습니다. What is Reactive Programming? …  reactive programming  is a  declarative programming  paradigm concerned with  data streams  and the  propagation of change . -wikipidea ... 반응형 프로그래밍이란,  데이터의 흐름 과  변경사항의 전파 에 중점을 둔  선언적 프로그래밍  패러다임이다. - 위키피디아 그렇다는군요. 전에도 언급했지만 컴퓨터 사이언스에서 정의는 이해가 아니라 배워야 할 목차와 같은 거라고 했습니다.  따라서 이번 글에서는 다음과 같은 핵심키워드인   패러다임  ,   변경 사항의 전파  ,   데이터의 흐름   그리고   선언적 프로그래밍  을 머리속에 넣어두시고 읽어주시기 바랍니다. 패러다임이 뭔가요? 패러다임(영어: paradigm)은 어떤 한 시대 사람들의 견해나 사고를 근본적으로 규정하고 있는 테두리로서의 인식의 체계, 또는 사물에 대한 이론적인 틀이나 체계를 의미하는 개념이다. - 위키피디아 역시 예시를 드는 게 제일 좋겠죠. 모두가 이해할만한 좋은 패러다임과 관련한 예시로는 지동설과 천동설이 있습니다. 지구가 중심이냐? 태양이 중심이냐? - 천동설과 지동설   https://m.post.naver.com/viewer/postView.nhn?volumeNo=30794738&amp;memberNo=25828090&amp;navigationType=push ))  지구가 중심이라는 관점 을 가지고 우주의 움직임을 설명하는 천동설과  태양이 중심이라는 관점 으로 우주의 움직임을 설명하는 지동설이 존재했습니다. 이렇듯  어떠한 관점 을 가지느냐에 따라 같은 우주 움직임을 전혀 다른 2가지의 방식으로 설명을 할 수 있던 시절이 있었습니다. 흔히 지동설이 옳고 천동설이 틀린거라는 생각하는 사람들이 있지만 실제로 그러한 것은 아니라고 합니다. 정말로  관점의 차이만 다를 뿐  둘다 충분히 우주의 움직임을 설명할 수 있었다고 합니다.   [참고] 천동설은 지동설보다 열등한가? https://brunch.co.kr/@freewriter21/143 https://inmun360.culture.go.kr/content/357.do?mode=view&amp;page=3&amp;cid=103083&amp;sf_cat1=CWS1304 다만 이후  지동설이 주류가 된것은 천동설보다 훨씬 더 간결하고 단순하게 설명을 할 수 있는 관점 이기 때문이라고 합니다. 덕분에 우리는 조금 더 간결한 방식으로 우주를 바라보고 설명 할 수 있게 되었습니다. 프로그래밍에서 패러다임이란?  프로그래밍 패러다임 은 프로그래머에게 프로그래밍의  관점 을 갖게 해 주고,  결정 하는 역할을 한다. 예를 들어  객체지향 프로그래밍 은 프로그래머들이 프로그램을  상호작용하는 객체들의 집합 으로 볼 수 있게 하는 반면에,  함수형 프로그래밍 은  상태값을 지니지 않는 함수값들의 연속 으로 생각할 수 있게 해준다. -  위키피디아: 프로그래밍 패러다임 천동설과 지동설의 예시와 같이 내가 프로그램이라고 하는 것을  어떠한 관점으로 바라보고  설계를 하느냐에 따라서 같은 목적을 이루고자 하더라도 전혀 다른 형태로 프로그래밍을 할 수 있도록 해줍니다.  또한 잘 만들어진 프로그래밍 패러다임은 보다  좋은 프로그램을 만들 수 있는 방법과 시각 을 제공해줍니다. 그래서 우리가 다양한 프로그래밍 패러다임을 알고 있다면 프로그램을 이해하는 데 훨씬 더 도움을 받을 수 있게 됩니다. 우리가  객체지향 프로그래밍 이라던가  함수형 프로그래밍 에 대해서 배우는 것들도 그러한 맥락입니다.    나아가 여러가지 패러다임을 알고 있다면 그 중에서  더 간결하고 단순하게 설명하고 있는 관점을 선택 적으로 취할 수 있게 됩니다. 현대에 와서는 하나의 프로그램을 하나의 패러다임만이 아니라  여러 패러다임을 함께 섞어서 사용하려는 시도 가 늘고 있으며 특히 웹 프론트의 자바스크립트야말로 여러가지 패러다임의 공존의 장이기에 다양한 프로그래밍 패러다임을 익히는 것은 더 좋은 프로그램의 설계를 할 수 있는 토대가 되어줍니다. ... 순수한 관점에서 이질적으로 보여졌던 패러다임간의 공존이 갈수록 많이 등장하며, 상황과 맥락에 따라 패러다임간 장점만을 취하려는 시도는 계속되고 있다. -  위키피디아: 프로그래밍 패러다임 반응형 프로그래밍도 객체지향 프로그래밍과 함수형 프로그래밍과 같이 프로그래밍을 바라보는 관점을 갖게하고 결정을 하는 역할을 하는 체계라고 이해하시면 좋을 것 같습니다. 1. 반응형 프로그래밍 패러다임이란? 반응형 프로그래밍이란,  데이터의 흐름 과  변경사항의 전파 에 중점을 둔  선언적 프로그래밍  패러다임이다. 정의가 언뜻 듣기에는 어려워보이나 사실 반응형 프로그래밍은 아주 오래되고 친숙한 개념입니다. 가장 쉽게 반응형 프로그래밍의 패러다임을 이해할 수 있는 예제는 바로  스프레드 시트 입니다.   예시에 있는  C1 의 셀에는  =A1+B1  이라는 수식을   선언적   으로 작성을 해두고  A1   B1 의 값을 변경을 하면 즉시   변경사항이 전파   되어  C1 의 값이 자동으로 변경이 됩니다.  D1 에는  =A1+B1+C1  이라는 수식을   선언적   으로 작성을 해두었고  A1   B1 의 값을 변경하자   변경사항이 전파   되어 C1의 값이 변경되었고 다시 그 값이  D1 의 수식에 반영이 되어  D1 의 값이 변경이 되는   데이터의 흐름   이 만들어졌습니다. (저는 이러한 순서를 정의한 적이 없습니다.) 이러한 개념을 조금 더  확장 을 해서 이러한 관점으로 프로그래밍을 할 수 있다면 좋지 않을까 하는 패러다임이 바로   반응형 프로그래밍   입니다. 언제부터 웹에서 반응형 프로그래밍이 중요해졌을까?   (출처:  https://trends.google.com/trends/explore?date=all&amp;q=%2Fm%2F02vz4nz ) 웹 개발에서 반응형 프로그래밍이 중요해진 계기는 다들 알고있는  웹 프레임워크로의 전환 입니다. 웹 개발에서 가장 큰 패러다임의 전환,  jQuery  →  웹 프레임워크 내가 쉽게  조작하게 도와준다. → DOM을  알아서  렌더링 해준다. 웹 프레임워크의 본질을  반응형 프로그래밍 패러다임  의 관점에서 다시 한번 적어봅시다.  Web Framework의 본질 (MVVM 패턴)  값이 변경  되었을때   템플릿에 선언   해둔대로 알아서 렌더링을 해준다 = 반응형 어떤가요? 우리가 본 반응형 프로그래밍의 정의와 유사하지 않은가요? 웹 프레임워크의 등장은 기존의 프로그래밍 방식과는 혁신적인 패러다임이었기에 웹 프론트에서 아주 중요한 개념이 되었고 이를 정의하는  Reactive Programming 이라는 용어의 관심사가 올라가기 시작했습니다. 초기  Reactive Programming 의 패러다임은 이렇게  데이터의 변경을 감지 하고  선언적으로 프로그래밍 을 하는 방법을 통해  View를 업데이트 를 하는 방식으로 발전을 하기 시작합니다. 패러다임의 전환 #1 - 선언적 프로그래밍 선언적 프로그래밍이란? -  무엇을 해야할지  따로 약속(표현)을 만들어 기술하게 하고,  언제 어떻게 동작하는지는 내부 에 처리하는 방식의 프로그래밍 기법   웹 프레임워크의 가장 큰 핵심은 js를 통해  어떻게  DOM 조작을 할지가 아니라 jsx 혹은 template binding을 통해서  무엇을 해야할지  선언을 해두면 내부적으로 알아서 적절하게 렌더링을 하는 방식입니다. 언제 어떻게 해야할지 내부 매커니즘은 숨기면서 필요한 로직만 외부에서 선언을 할 수 있게 함으로써  알고리즘을 구현을 하는 데 발생하는 에러를 최소화  하고  시간과 변화에 구애받지 않고 개발을 할 수 있도록  해줍니다. 한번  https://svelte.dev/repl/hello-world  에서 위 코드를 복사-붙여넣기 해보세요 :) 패러다임의 전환 #2 - 변경사항의 전파(Pull → Push)    어떻게  화면에 그릴지를 중심으로 개발을 하다가 이렇게  무엇을  할지만 선언을 하는 방식으로 변경이 되면서 데이터를 대하는 패러다임도 변경이 됩니다. 기존에는 DOM 조작을 통해 화면을 구현을 하는 것이 중심이니  render를 해야 하는 시점에 필요한 데이터를 모두 불러와서(Pull)  화면을 출력을 하는  Pull 의 관점에서 UI 개발을 하였습니다. 하지만 새로운 반응형 프로그래밍의 패러다임에서는 미리 선언이 되어 있는 구조에서  값이 변화할때 마다 템플릿으로 데이터를 전달(Push)  를 하는  Push 의 관점으로 설계가 되도록 변화가 되었습니다. (React를 하는 분이라면 setState를 떠올려 주세요.) 반응형 프로그래밍 패러다임으로의 전환 이렇듯 웹 프로그래밍은 데이터를 가져와서 화면을 만드는 방향에서  무엇을 할지 선언을 하고 변경된 데이터를 감지하고 전파하는 방향 으로 패러다임이 변해왔습니다. 어떤가요?  스프레드 시트 와  웹 프레임워크 를 통해서  반응형 프로그래밍 이 어떠한 개념인지 감이 좀 잡히시나요? 사실 패러다임이 먼저 존재하지는 않습니다. 이러한 현상이 먼저 있고 그것들을 후에 하나의 관점으로 정리를 한 것이 패러다임이죠. 이러한 라이브러리와 방법들이 먼저 존재를 했었고 이후  Reactive Programming 이라는 것이 정립이 되는 것입니다. 그렇다면 우리는 이제 프레임워크를 당연히 쓰는 시대이니  반응형 프로그래밍 을 하고 있는 걸까요? 틀린 말은 아니지만 다시 한번 구글 트렌드의 그래프를 확인해 볼까요?  반응형 프로그래밍 은 그 이후에 개념이 확장되며 더 두각을 나타나게 됩니다. 초기에는 이 반응형 프로그래밍 패러다임을 뷰에 집중이 되었다면 이후에는 뷰를 넘어 비지니스 로직을 포함한  모든 스크립트에서 사용할 수 있도록 개념이 확장 이 됩니다. 이후 Redux를 필두로한  상태관리 라고 하는 것들 역시   데이터의 변경을 감지   하고   변경을 전파   하고   선언적으로   값을 만들어낸다는  반응형 프로그래밍 패러다임 에 속하게 됩니다. 이번 글에서는 반응형 프로그래밍 패러다임의 끝판왕 겪인  Rx 를 통해서 조금 더 이야기를 해보려고 합니다. 2. 비동기 프로그래밍과 반응형 프로그래밍 왜 프론트엔드 프로그래밍에서 반응형 프로그래밍이 중요할까요? 그것은   비동기 프로그래밍   을 잘하기 위해서입니다.   비동기 프로그래밍은 상당히 어렵습니다.  하지만 프론트엔드의 대부분의 로직이 비동기로 되어 있습니다. 프론트엔드는 사람을 상대하는 UI를 만드는 개발자이며 사람의 동작은 어떻게 동작할 지 예측할 수 없기 때문입니다. 또한 우리는 서버를 상대하는 사람이며 서버의 응답이 언제 어떻게 올지는 예측할 수 없기 때문입니다. 그렇기에 고급 프론트엔드 개발자가 되기 위해서는 이 비동기를 아주 잘 다룰수 있어야만 합니다. 왜 비동기 프로그래밍이 어려울까요?   비동기 프로그래밍은 다음과 같은 이유로 어렵습니다. 비동기 프로그래밍은  작성한 코드 순서대로 동작하지 않는다. 언제 실행이 될지 예측할 수 없다. 호출한 순서대로 동작한다는 보장도 없다. 그래서 호출 당시의 값과 실제 실행 되었을 때의 값이 그대로일 거라는 보장이 없다. javascript의 비동기 프로그래밍 대응의 역사 적어도 비동기를 작성한 순서대로 동작할 수 있게 하자!    ES6 Promise  ES7 async / await javascript는 최대한 비동기 로직을  동기 프로그래밍처럼  동작할 수 있는 방향으로 진화를 했습니다. 하지만 이것으로 충분할까요? Real world Problem!  당신은 아래와 같은 자동완성을 구현해 달라는 요청을 받았습니다. 어떻게 코딩 할 지 상상해 봅시다. 타이핑 할때 마다 서버에서 데이터를 받아서 보여주세요. 너무 잦은 요청은 부하가 심하니 타이핑 간격이 좁으면 대기하다가 입력이 늦어지면 그때 서버에 요청하세요. 같은 내용일때는 요청하지 마세요. 일정 시간 동안 응답이 없으면 3회 재시도 하고 그래도 응답이 없으면 에러 메시지를 출력해 주세요 데이터는 캐시로 보관을 해서 먼저 보여주고 요청이 완료되면 새로 갱신된 데이터를 보여주세요. 엔터를 누르면 서버로 요청한 건 취소하고 검색 결과를 보여주세요.  Promise ,  async/await  이 이 문제를 해결 할 수 있을까요?  기존  pull  기반의 비동기 순서를 맞추는 방식의 패러다임 에서는 비동기가 복합적으로 존재하면 개발 난이도가 비약적으로 어려워지게 됩니다. 전통적인 백엔드에서는 하나의 request에서 비동기가 여러개가 있더라도 순차적으로 처리해 하나의 response를 만들어주면 되지만 프론트엔드은 사용자의 동작과 서버의 동작의 비동기 동작이 혼재되어 있는 세상입니다. 어떻게 하면 이러한 복합적인 비동기 세상에서 조금 더 프로그래밍을 잘 할 수 있을까요?  Rx와 반응형 프로그래밍 은 어떠한 방식으로 이 비동기 문제를 접근하는지 한번 살펴보도록 하겠습니다.   3. 반응형 프로그래밍 Deep Dive! 반응형 프로그래밍은   변경을 감지하고 전파   하고   선언적  으로 프로그래밍을 작성한다는 패러다임을 구현하기 위해서 아래와 같은 구조를 가지고 있습니다.   응? 어디서 많이 본 구조인데... 아 뭐더라... 아! addEventlistener? 그렇습니다. DOM에서 쓰는 이벤트 리스너를 등록하고 전달하는 방식 역시 반응형 프로그래밍입니다. 이러한 방식으로 인해 웹 프레임워크는 자연스레 반응형 프로그래밍의 구조를 따르게 되었죠.  🔥 우리가 가고자 하는 방향은   모든 스크립트에서 이러한 Event Listener의 관점으로 프로그래밍을 하는 것입니다!   제가 이해를 돕기 위해서 계속 반응형 프로그래밍 패러다임 위에서 이러한 것들이 만들어졌다고 설명은 하고 있지만 사실은 반대입니다. 패러다임은 이미 만들어진 현상을 해석해서 하나로 정리한 관점이자 체계라는 점 다시 언급하고 넘어갑니다. 왜 Event 방식으로 개발을 하나요? - Reactive First!  출처: cycle.js https://cycle.js.org/streams.html#streams-reactive-programming 주의: 여기에서는 프로그래밍 패러다임과 관련된 용어들이 많이 등장하다보니 다소 어렵게 느껴질수도 있습니다. 잘 따라와주시길 바랍니다. 제어의 역전!   2개의 모듈이 있습니다. Foo모듈에서는 네트워크 요청을 받으면 Bar 모듈의 값을 증가하는 로직이 있다고 상상해보세요. Foo 모듈에서는 Bar 모듈에게 영향을 끼치므로 위와 같이 그림을 그려보았습니다. 코드로 표현하면 다음과 같습니다. 이 경우 상태를 변화하는 로직은 Bar에 존재하는데 동작은 Foo가 하도록 하고 있습니다. 더군다나 Bar에서는 Foo의 존재를 알 수가 없습니다. 이렇게하면 Bar가 수동적인 모듈이 되고 Foo 모듈과는 강결합되어 Bar에서는 자체 상태관리를 하지 못할 뿐더러 수정이 필요한 모든 로직을 Foo에 공개하는 형식으로 만들어야 합니다.   어떻게 하면 이러한 문제를 수정할 수 있을까요? 이 접근 방식의 대안은 화살표의 방향을 반전시키지 않고 화살표의 소유권을 반전시키는 것입니다.   이렇듯 모듈과 모듈간의 결합 시 참조의 주체를 바꾸어 사용하는 방법을   제어의 역전(Inversion of Control)   이라고 부릅니다. 이 접근 방식을 통해서 모듈의 상태를 변화하는 로직을 외부 모듈에 의존하지 않고 모듈 내부에서 처리함으로써 보다  캡슐화 와  느슨한 결합 을 하기 용이하도록 할 수 있습니다. 책임의 분리와 비동기 처리 반대로 Foo의 입장에서는 어떨까요? Foo 모듈에서도 로직을 수행하는 부분에 있어서 자유로워졌습니다.  이제 누구에게 어떻게 데이터를 전달해야할 지 몰라도 됩니다.  그저 데이터가 만들어지는 시점에 전달만 하면 됩니다. 클릭 이벤트라던가 Promise와 같은 경우가 그렇습니다. 처음에 배웠던  데이터의 흐름 ,  변경사항의 전파 ,  선언적 의 반응형 프로그래밍 패러다임이 기억이 나시나요? 복잡한 비동기 프로그래밍도 반응형 프로그래밍을 이용한다면 선언적으로 데이터의 흐름을 통해 간단하게 처리를 할 수 있게 됩니다. Reactive First! 이러한 제어의 역전 방식은 이미  DOM의 Event 나  Observer 패턴 ,  Pub/Sub 패턴 과 같이 오래전부터 사용해오던 방식이었습니다. 책임의 분리는  미들웨어 나  플러그인 과 같은 방식에서도 이미 자주 쓰이던 방식이었습니다. 반응형 프로그래밍은 이러한 관점을  일부가 아닌 모든 스크립트에 적용 을 해서 항상 Reactive를 먼저 고려하자는 패러다임입니다. 이러한 방식은 여러개의 모듈간의 결합이 많아질수록 더 유효합니다.    기존의 패러다임에서는 왼쪽의 그림처럼 하나의 모듈에서 여러가지 비동기 코드를 호출하는  pull  방식의 개념을 통해 호출 순서와 실행 순서와 데이터 처리를 한번에 하는 것이 관리를 어렵게 만들었다면,  반응형 프로그래밍에서는 오른쪽 그림과 같이  push 를 통해서 하나의 모듈(함수)에서 하나의 화살표만 처리하면 되는 단순한 형태로 생각을 할 수 있게 됩니다. 이 내용이 없어도 Rx로 빌드업을 하는데는 문제가 없을 것 같아 넣을까 말까 고민을 많이 했지만 이 글이 Rx가 아니라 반응형 프로그래밍에 관련된 글이기에 알고 있으면 좋을 것 같았습니다. 당장은 이해가 안되더라도 너무 깊게 고민하지는 않기를 바랍니다.    4. ReactiveX - 스트림을 이용한 개발! 그래서 우리는  Rx와 같은 반응형 프로그래밍 라이브러리 를 이용해서 이러한 구조를 만들게 되면 보다 프로그래밍을 단순한 관점으로 개발을 할 수 있게 됩니다.    반응형 프로그래밍은  어떠한 라이브러리나 구현체가 아니라  하나의 관점 일 뿐입니다. 하지만 구체적인 예시가 없는 설명은 이해를 어렵게 만들 뿐입니다. 이 글에서는 Rx를 통해서 반응형 프로그래밍을 설명할것이지만 정작 Rx를 어떻게 쓰느지에 대해서는 설명하지 않습니다. (마치 객체지향을 Java를 통해 설명하듯이 말입니다.)  Promise   라는 Library가 생겨났고 이것이 Javascript의 표준제안에 등록이 되면서 결국 Javascript의 Native한 기능이 되었습니다. 더 복잡한 비동기 프로그래밍을 해결하기 위한   Observable   이라는 API 역시 현재 ECMA의 기본 기능에 탑재 요청이 올라가 있는 상태입니다. 어떻게 될지는 모르겠지만 만약에 Native한 기능이 된다면 Javascript 비동기의 개발의 판도가 바뀔지도 모릅니다. 그 전신이 될 수 있는 Rx를 실무에 쓰지는 않더라도 개념은 한번 쯤 배워보는 것은 어떨까요?  https://www.google.com/search?q=tc39+observable&amp;oq=tc39+%E3%85%92&amp;aqs=chrome.1.69i57j0i512l2.3064j0j7&amp;sourceid=chrome&amp;ie=UTF-8 Rx가 무엇일까?  ReactiveX Rx를 알고나면 이 정의가 너무나 당연한 말인데 이해하는 과정이 좀 길고 복잡합니다.   비동기(asynchronous)  ,   옵저버블(observable)  ,   스트림(streams)   이라는 키워드만 일단 기억을 해둡시다.  Reactive Revolution 왜냐하면  Rx 는 단순한 API라기 보다는  새로운 패러다임에 가깝기 때문 입니다. 다시 한번 말하지만 이 글은 Rx가 아니라  반응형 프로그래밍 패러다임 에 대해서 설명하는 글입니다. 앞선 내용을 차근차근 복습을 한번 해봅시다.    비동기 프로그래밍  은 실행 순서와 데이터를 제어하기가 어렵습니다. 하지만 프론트엔드는  비동기 프로그래밍  덩어리입니다. 그렇기에 조금  더 간결하고 쉬운 개발을 하기 위한 관점과 체계 가 필요했고 그것이 바로  반응형 프로그래밍 입니다. 반응형 프로그래밍은   변경사항의 전파  와   데이터 흐름  을 중심으로   선언적   으로 작성하여 어려움을 해결합니다. 그러기 위해서는   Pull   →   Push   의 패러다임 전환이 필요하고 이를 구현하기 위해서는   Event   와 같은 방식을 통해   제어의 역전   을 만들어야 한다고 하였습니다. 여기서 우리는 다음과 같은 깨달음을 하나 얻을 수 있습니다. 아하!   변경사항의 전파   +   데이터 흐름   =   Event   였구나! 그래서 우리는 반응형 프로그래밍을 다음과 같이 확장을 할 수 있게 되니다.   변경사항의 전파  +  데이터 흐름     Event   +   선언적 Event를 넘어 Stream으로...! Rx에서는 이러한 이벤트의 종류를  Next ,  Error ,  Complete 의 3가지 type을 정의해서 조금 더 보편적인 상황을 처리할 수 있도록 정의하였습니다.  try   catch   finally 와 같은 맥락으로 일단은 생각해두시면 좋을 것 같아요.      변경사항의 전파  +  데이터 흐름   Event     스트림(Stream)   +   선언적 스트림을 선언적으로 작성하는 프로그래밍 패러다임 그렇습니다. 반응형 프로그래밍은 스트림을 선언적으로 작성하는 프로그래밍 방식이었습니다! ... 지금은 이해가 안가는게 당연합니다. 조금 더 빌드업과 예시를 통해 이해해봅시다. 선언적으로 작성한다는 것! 조금 더 돌아가겠지만  선언적 프로그래밍 에 대해서 한번 생각해봅시다. 여러분들이 제일 많이 알고 있는 것은 바로  for  와  Array Method  의 차이입니다. 일단 이 차이는 알고 있다고 하고 진행을 할게요.   우리는  for 가 아니라  .map ,  .reduce ,  .filter  를 사용하게 되면 Array를  선언적 으로 다룰 수 있다는 사실을 알고 있습니다. 그러면 이러한 방식처럼  Stream(or Event)  도  선언적 으로 다룰 수 있지 않을까요? 스트림을 선언적으로 작성한다는 것! =  Strem(or Event)를 Array Method처럼 만들어서 사용해보자! 조~금 억지스로운 예시를 하나 가져왔습니다.  다음 코드를 살펴봅시다.  랜덤한 숫자 5개에서 짝수만 2개를 골라 출력하는 프로그램  입니다. 일단 잘은 모르곘지만 Array의 값 대신 Stream을 다루는 객체의 이름을  Observable 이라고 지어봅시다. 그렇다면 다음과 같은 코드의 형태로 작성을 할 수 있을 것 같습니다.  Observable 는 Array가 아니라 Event라고 했으니  사용자가 클릭을 할때마다 랜덤한 숫자를 받아서 짝수를 2개 출력하기 는 어떨까요? 또는  1초마다 랜덤한 숫자를 받아서 짝수를 2개 출력하기 는 어떨까요? 🎉 축하합니다! 이제 우리는  비동기 프로그래밍 을  스트림(Stream) 을 통해  선언적  으로 프로그래밍을 할 수 있게 되었습니다! 이렇듯  이벤트를 하나의 값 으로 생각하고 이를 Array의 Method를 다루듯이 작성을 한다면 훨씬  더 직관적이고 간결하게 프로그래밍 을 할 수 있을 것 같습니다. (실제로 1초마다 숫자를 받아서 짝수를 2개 출력하기를 그냥 구현을 하면 어떻게 코딩을 할지 상상해 보세요.) 스트림을 여러개 연결을 해보면 어떨까?   우리가 알고 있는 일반적인 설계는 저렇게 화살표를 통해서 데이터가 전달되는 노드의 형태로 표현할 수 있습니다.  반응형 프로그래밍에서는 전체 프로그램의 복잡도를 고려하지 않고  각 노드를 하나의 스트림으로 정의하고 선언적으로 개발 을 할 수 있게 됩니다. Data-flow 프로그래밍   반응형 프로그래밍의 두번째 키워드인   데이터의 흐름(data-flow)   은 바로 이러한 구조를 의미합니다.  각자의  변경사항을 전파 를 하도록 설계를 하면 알아서 복잡한 데이터의 흐름이 만들어지지만 내부를 들여다보면 단순한 형태의 프로그래밍을 할 수 있게 합니다.  특히 이벤트를  값 으로 다룬다는 관점이 매우 중요합니다. 함수형 프로그래밍 반응형 프로그래밍에서는 이러한 data-flow를  함수형 프로그래밍 을 통해서 구현을 하고 있습니다.  함수형 프로그래밍이란  원본값을 함수를 통해서 전달을 하고 새로운 값을 만들어내는 조합이 다시 하나의 함수가 되는 형태의 구조 를 의미합니다.   그래서 아래와 같은 형태로 이벤트를 통해 데이터가 전달되는 흐름을 중첩된 Pipline을 통해서 전달을 할 수 있도록 도와줍니다.   Rx는 무엇인가요?   다시보는  ReactiveX API  for  asynchronous  programming with  observable   streams     변경사항의 전파  +  데이터 흐름   Event     스트림(Stream)   +   선언적 스트림을 선언적으로 작성하는 프로그래밍 패러다임 Everything is stream!   결국 반응형 프로그래밍의 최종적인 정리는 결국 이것입니다.  반응형 프로그래밍이란,   데이터의 흐름  과   변경사항의 전파  에 중점을 둔   선언적 프로그래밍  모든 것을 스트림  으로 간주하고   선언적  으로 개발하는 것 (... 결국 결론은 맨 처음 정의랑 똑같죠? ㅋㅋ 이번에는 이해가 된 채로 정의가 다시 읽혔으면 좋겠습니다.) Array도, Iterator도, Promise도, Callback, Event를 스트림이라고 하는 하나의 관점으로 간주하고 개발을 하는 패러다임이 바로 반응형 프로그래밍입니다.    Rx 맛보기  당신은 아래와 같은 자동완성을 구현해 달라는 요청을 받았습니다. 어떻게 코딩 할 지 상상해 봅시다. 타이핑 할때 마다 서버에서 데이터를 받아서 보여주세요. 너무 잦은 요청은 부하가 심하니 타이핑 간격이 좁으면 대기하다가 입력이 늦어지면 그때 서버에 요청하세요. 같은 내용일때는 요청하지 마세요. 일정 시간 동안 응답이 없으면 3회 재시도 하고 그래도 응답이 없으면 에러 메시지를 출력해 주세요 데이터는 캐시로 보관을 해서 먼저 보여주고 요청이 완료되면 새로 갱신된 데이터를 보여주세요. 엔터를 누르면 서버로 요청한 건 취소하고 검색 결과를 보여주세요.   끝으로... 객체지향 프로그래밍, 함수형 프로그래밍과 같이 프로그램 씬에는 여러가지 패러다임이 존재합니다. 이러한 패러다임을 이해하면 프로그램을 작성할 때 일관성있고 좋은 관점을 가질 수 있고 설계와 결정에 도움을 줍니다.  반응형 프로그래밍은 스프레드 시트와 같이 미리 선언된 방식에 데이터의 변경을 전파하여 프로그램이 동작하게 만드는 방식의 패러다임을 말합니다.  이러한 반응형 프로그래밍은 비동기 프로그래밍을 조금 더 간결하게 바라볼 수 있는 관점을 제공해줍니다.  프론트엔드는 특히 비동기 프로그래밍 덩어리이므로 반응형 프로그래밍 패러다임은 프론트엔드에서 중요한 패러다임이 되었습니다. 웹 프레임워크가 그러했고 이 후 만들어진 상태관리 역시 그러합니다. 패러다임이 먼저 생겨났고 그 패러다임에 맞춰 라이브러리나 프레임워크가 나오는 것은 아닙니다. 오히려 반대죠. 특별한 문제를 해결하기 위해서 만들어진 것들의 공통점들을 모아 하나의 관점으로 정리해서 바라보는 일종의 체계와 같은 것입니다. 그래서 반응형 프로그래밍의 관점에서 바라본다면 React도 React-Query도 Redux도 Recoil도 Svelte도 얼마든지  데이터의 흐름   변경의 전파   선언적 프로그래밍  이라는 관점에서 바라볼 수 있습니다.  또한  제어의 역전   책임의 분리   느슨한 결합   data-flow programming   함수형 프로그래밍   Event를 값으로 생각하기   Everythis is stream  과 같은 개념들은 Rx뿐만 아니라 다른 프론트엔드 라이브러리를 이해하고 프로그램을 이해하고 본인의 프로젝트의 설계 방향을 정하는데에도 큰 도움이 됩니다. 객체지향을 하나의 포스트로 끝낼수가 없듯이 반응형 프로그래밍에 대해서도 깊게 들어 갈 수 있는 부분들이 있겠지만 이 글이 반응형 프로그래밍의 소개가 아니라 프론트엔드 전반의 프로그램과 라이브러리의 방향성과 관점을 약간이나마 알 수 있게 되는 계기가 되었으면 좋겠습니다. 긴 글 읽어 주셔서 감사합니다. ❤️ 못다한 이야기 인터넷에서 반응형 프로그래밍을 검색을 하면 대부분 Rx를 설명하는 글이 대부분입니다. Rx는 좋은 라이브러리기는 하나 필수는 아니기에 자칫 반응형 프로그래밍 = Rx와 같은 생각으로 이어질 것 같아 Rx의 소개는 정말 최소한으로 하였습니다.   반응형 프로그래밍은 구현체나 라이브러리가 아니라 비동기를 잘 다루기 위한 프로그래밍 관점 및 체계라는 점을 다시 한번 알려드립니다. 그러면 반응형 프로그래밍과 Rx로는 어떻게 SPA를 설계하나요? 에 대한 질문에 대한 글은 따로 기회가 되면 작성을 해보도록 하겠습니다.   같이 읽어보면 좋은 글 https://subeen.io/blog/devs/2021-09-02-Reactive-Programming/ https://www.youtube.com/watch?v=alsCMx6vpG4 https://cycle.js.org/streams.html#streams-reactive-programming 이벤트를 한번 해볼까 합니다. 다같이 온라인으로 모여 1시간 정도 할 수 있는 것들로 생각해봅니다. 자유롭게 의견 주세요!   압도적(?)인 표차이로 구글 스프린트가 1위로 당첨이 되었습니다. 2위는 스터디였답니다. 프롤로그 1 주위에 개발자들끼리 함께 하는 이벤트나 커뮤니티가 부족한 것 같다는 성토로 시작하여 같이 해봄직한 것들을 논의해보았으나 역시 구관이 명관이기에  이미 시도된바 있는 구글 스프린트 가 가장 인기가 많았습니다. 사실 2기는 1기 이후 반응이 좋아서 다시 추진을 해보려다가 멤버 정족수가 모이지 않아 한번 부러졌지만 12명이라는 숫자를 보고 한번 시도를 하게 되었습니다. 참가자를 모집하고 날짜를 조율하는 일은 쉽지 않은 일이기에 호기롭게 날짜를 먼저 찍어두고 참가 신청을 받았는데 생각보다 저조한 참여율에 조마조마 매일 매일 주식 보듯 신청서를 봤던게 생각이 나네요. 다행히 마감 마지막 날에 딱 좋은 멤버 수인 6명이 참여를 해주셨답니다. 구글 스프린트 2기에 참여해준  알모, 단테, 홀리몰리, 설아아빠, 데비니, 이엘로  모두 너무너무 감사합니다. ❤️ 프롤로그 2 지난 1기에서는 구글 스프린트에 대한 프로세스  체험 과  &#39;스스로&#39;   함께  해보는  경험 에 조금 더 포커스를 뒀다면 2기에서는 어느 정도는 리딩을 통해서 조금 더  책에 있는 세부적인 방법들을 알려주고 적용 해보는 방식으로 진행을 해보았습니다. 그래서 지난번 글에서는 구글 스프린트가 무엇이고 어떤 식으로 흘러가는지를 설명했다면 이번 글에서는  조금더 세부적인 방법에 관한 이야기 를 함께 전달을 하게 될 것 같습니다.  (저도 실제로 제이크 냅과 스프린트를 해본 것은 아니므로 책의 내용과 여러가지를 바탕으로 시도해보고 있다는 점 알아주시면 좋을 것 같아요. 저도 이게 올바른 방법인지는 잘 모릅니다. 하지만 효과는 보고 있다고 생각해요. 더 좋은 방법이 있다면 공유해주세요.) 이 글은 대부분의 회고의 내용들로 채워져 있으며  학습적으로 도움이 될 법한 부분들은 ⭐️ 표시 를 해두었으니 참고 바랍니다.  구글 스프린트 1기? https://velog.io/@teo/google-sprint-1 첫째날 오늘 얘기를 나누고 생각을 주고받는 시간들이 값진 추억이 되었으면 좋겠습니다. 킥오프! 첫날에는 언제나 그랬듯 다들 어색어색하게 마이크만 켠 채로 모여있었습니다.    Team Canvas 지난 번에서도 했었던 팀 캠버스는 언제나 느끼는 거지만  처음 팀을 구성하는 OT용으로 참 좋은 것 같습니다.  구글 스프린트와는 관계가 없지만  맨 처음 팀을 이루거나 팀에 누군가가 새로 들어온다면  다같이 이러한 활동을 한번 해보는 것을 추천합니다. ⭐️  http://theteamcanvas.com/ https://www.figma.com/community/file/966990975393650677 https://brunch.co.kr/@hubertshin/54  - 어떻게 하는지 설명하고 있는 블로그 팀 캔버스 활동은 각자가 누구인지 소개하고, 우리 팀의 목표는 그리고 각자가 누구인지 그래서 우리의 최종 목표는 무엇이며, 우리가 함께 하기 위해서 어떤 가치를 중요하게 생각하고 서로의 강점과 약점을 공유하며 어떤 그라운드 룰로 함께 하면 좋을지를 생각해보는 여정으로 되어 있습니다.   저희가 어떠한 사람들인지 어떠한 생각을 가지고 스프린트에 임했으면 좋을지 본인을 돌이켜보고 팀을 생각해보고 미래를 생각해보는 시간이었습니다. 앞으로 5일동안 이 초심을 잊지 않았으면 좋겠습니다. :) 아이디어 회의 각자가 만들어보고 싶었던 아이디어를 공유해주세요. 모두가 만들어 보고 싶은 것을 하나 결정해 볼게요!   좋은 아이디어와 의견들이 많이 나왔던 1일차 과제였습니다.  원래 보통 회사의 스프린트라면 일단 목표는 대개 정해져 있기에  첫째날에는 취지나 방법, 방향, 목표등을 맞추는 과정 이나 저희는 함께할 아이디어를 논의를 하게 되었네요. ⭐️ 아이디어를 설득하고 브리핑을 하는 과정에서 제가 예전에  &quot;기획의 정석&quot; 이라는 책에서 배웠던 데로  why? -&gt; what? -&gt; how? -&gt; if?   라는 식으로 좀 말할 수 있기를 원해서 프로세스를 짜봤는데 제 설명이 부족해서 원하는 대로 잘 되지 않았답니다.  Tip?  그래도 뭔가 아이디어나 기획을 얘기를 할때에는 이런식으로 정리하고 말해보면 효과적이라고 합니다. 오랜 시간 동안 의견을 나눠봤고 좋은 의견들이 많아서 하나의 의견으로 좁혀지지는 않은 채로 각자의 의견과 다른 사람들의 의견들을 보면서 결정을 하고 설득을 할 수 있도록 구체적인 화면들을 추가로 가져와 달라는 과제를 전달하고 첫째날은 이렇게 마무리가 되었습니다. 오늘 자면서... 그리고 내일 출퇴근 하시면서 지금의 생각의 씨앗들로 피어난 재미난 아이디어나 생각으로 가득해 다시 모이기 전까지 즐겁고 행복한 날이 되기를 바랍니다. (이때 부터 스프린트의 체계대로 움직이지는 않았지만 뭐 어떻습니까? ㅋㅋ 적절히 순서는 맞게 진행을 해봤던 것 같아요) 둘째날   쟁쟁한 아이디어의 프로젝트들의 경쟁속에서 최종적으로  가제 &quot;국내판 stateofjs&quot; 가 결정이 되었습니다. 프로젝트 개요  who?  why?  what?  how?  if? 참여하신 분들이 전부 개발자이다 보니 변화해가는 기술 스택에 대해서 공유하고 집계하고 특히 국내 정서에 맞는 형태로 볼 수 있는 서비스가 있으면 좋겠다는 의견으로 취합이 되었답니다. ⭐️ 지도 그리기 아이디어가 정해졌기에 드디어  첫번째 프로세스인 MAP  을 진행할 수 있게 되었습니다. ⭐️ 지도를 그린다는 것은 아이디어를 중심으로 필요한  행위자를 왼쪽 에 두고  결말을 오른쪽 에 두어 각 과정을 그려보며  필요한 것들을 중간에 배치하며 화살표로 연결하는 과정 을 통해서 모든 팀이 만들어야 할 목표를 하나로 만들어 가는 과정을 의미합니다. 저희는 시간이 부족해서 화살표의 연결을 하지 못한채로 이러한 얘기들을 통해 ⭐️  핵심 목표 와  어떻게 하면 ~ 할 수 있을까?  질문을 완성을 해보고 둘째날을 마무리 할 수 있었습니다.       즐거운 하루 되세요 ❤️ 셋째날   ⭐️ 리서치 리뷰 실제 구글 스프린트라면 스케치전 리서치 전문가들이 우리가 만들고자 하는 목표와 관련 레퍼런스나 자료들 분석자료등을 가지고 한번 논의하는 자리가 있어야 합니다. 그래야만 뻔하거나 이미 누군가가 고민을 했던 것들을 다시 고민하는 비용이 줄어들게 됩니다.  저희는 그럴 여유는 없었으므로 약식으로 stackoverflow, stackshare 정도를 잠깐 살펴보는 식으로 마무리 하였습니다.  실제라면 스케치를 하기 전에 충분히 비슷한 사례, 비슷한 제품, 비슷한 아이디어들에 대해서 충분히 검토하고 찾아보는 시간이 필요합니다. 스케치 아이스 브레이킹 &quot;당신의 직업은 무엇입니까?&quot; &quot;오로지 그림으로만&quot;  한번 당신의 직업을 설명해보세요! ⭐️ 아이디어는 마감의 압박 속에서 피어 나기 때문에 이후 이어질 모든 스케치에서는 5분의 시간 타이머를 두고 진행을 해보았습니다.   그리고 각자의 그림이 뭘 의미하는지 설명해보는 시간을 가졌습니다. 여러분이 외계인이라면 이 그림들을 보고 개발자가 어떤 사람인지 짐작이 가시겠나요? 😆 ⭐️ 저희의 스케치를 소개합니다. 이 전날 MAP을 통해 획득한 목표를 이루기 위해 필요한 화면들을 스케치 해보기 시작했습니다. 이때는 스케치에 대한 별다른 설명 없이 아이디어를 모으는데 집중해야 하며 오롯이 각자의 시간을 통해서 작업을 하기 시작했습니다. 5분의 타이머와 함께 각 주제에 맞는 화면들을 그리기 시작했습니다.           ⭐️ 끈적 끈적 결정 스케치 이후 스프린트에서 중요한 과정 중 하나가 셋째날의 결정입니다. 이렇게 그려진 스케치에 대해서 펼쳐놓고 신중하게 마음에 드는 화면에 투표를 하게 됩니다. 투표권은 적절히 남발하지 않을 수 있게 정해진 1인당 2~3개의 정해진 개수만 부여하도록 합니다. 아직은 장면에 대해서 설명하지 않습니다. 원래 스프린트에서는  아이디어를 보다 객관적으로 바라보기 위해서 둘째날 스케치를 한 다음 논의없이 공유없이 하루가 지난 다음 날 후에 결정을 하라고 권하고 있습니다만  우리는 시간이 없어 스케치 이후 바로 결정을 하게 되었습니다. 어느 화면에 대해서 공감대가 형성되었는지를 알았다면 지금까지와는 다르게  비판적인 시각으로 다시 한번 장면들을 짧게 살펴보는 시간을 가집니다.  (중요!) 여기서는 실현가능성과 현실성 개발 공수 한계등의 걱정거리등을 포스트잇을 통해 각 장면에 붙여줍니다. 이후 참가자들은 각 장면에 대해서 설명을 하고 비판적인 걱정거리에 대해서 대답을 해주게 됩니다. 모든 화면에 대한 설명을 들었다면 신중하게 투표권을 행사하도록 합니다. 저희의 경우 1등과 2등을 선택하도록 하고 1등은 2점 2등은 1점을 통해서 최종 결정을 하도록 하였습니다. ⭐️ 실전에서는 이러한 다수결 결정은 의견일 뿐이며  담당 전문가와 의사 결정권자의 의사결정이 가장 중요 하다고 합니다. 그래서 의사결정권자의 선택을 통해 최종 결정이 난다고 하네요. 넷째날, 다섯째날 실제같은  프로토타입을 만들어 보는 것이 중요합니다. 못다한 결정에 앞서 넷째날 목표 리마인드! &quot;우리의 목적은 사용자에게 이 서비스를 느낄 수 있게 하는  진짜같은 프로토타이핑 을 만드는 것입니다.&quot; (물론 해보면 알겠지만 진짜같은 프로토타이핑을 만드는 것이 쉬운것은 아닙니다. 정말 리얼하지 않으면 사람들은 반응해주지 않아요ㅠㅠ) 프로로타이핑, 데모의 의미에서 부담감은 낮추더라도 완성도는 꼭 챙기셔야 합니다! PL을 뽑아봅시다! 코딩을 하고 프로젝트를 하는 것은 제가 중심이 아니라 스스로 함께 해보시길 바랬기에 자체적으로 PL을 뽑고 페어프로그래밍을 할 수 있기를 바랬습니다. 프로젝트 이름 정하기 이제 프로젝트의 아이덴티티를 분명하게 해줄 이름을 정하는 일을 하게 되었습니다. 프로젝트의 이름을 정하는 것도  점진적으로 주제를 정하고, 각자 말하고, 투표하고, 다시 논의하는  스프린트 프로세스를 통해서 일사천리로 진행이 될 수 있었습니다. 어떤 이름이었으면 하나요?   이름에 들어갈 단어를 골라주세요. 투표해주세요.   어떤 이름이었으면 하나요? 라는 룰에 부합하나요? (조금 개발스러운 느낌이 부족해요!)   로고도 만들어 봅시다.   프로젝트 시작과 페어 프로그래밍 그리고 새로운 PL &quot;단테&quot;를 중심으로 열심히 프로젝트를 진행해 주셨습니다. 여기서 부터는 저는 더 이상 관여하지 않았습니다. 해야할 목표가 있고 함께할 사람이 있고 열정이 있었기에 그 과정이 즐거울 수 있을 거라고 기대하며 테스트를 해보는 날을 기다렸습니다. 마지막날  pathfinder.dev 프로토타입 https://teo-sprint2nd-6327wqdmg-dante01yoon.vercel.app/  스프린트에서 설문 조사를 하고 있습니다. 소중한 의견은 스프린트 팀에게 큰 힘이 됩니다! https://docs.google.com/forms/d/e/1FAIpQLSdOHV4aO4AO6AwYYKQZ6KogwDxADC1lYN2Rsu__IbgCV3gJsQ/viewform           저는  스프린트의 최종 단계인 테스트 의 테스터가 되어 최대한 3자의 입장에서 느낀 점등을 말해보려고 했습니다. 실제 코딩을 할 수 있는 시간적 여유가 하루가 채 되지 않았을 텐데 이정도의 결과물을 만들어 준 참가자분들께 다시 한번 감사의 말을 전달드립니다. 마무리는 자축하며 앞으로 어떤 부분을 추가를 해야할 지 다음 스프린트를 고민을 해보는 시간을 통해 정해진 스프린트 2기 프로그램은 끝이 났습니다.     회고 4LS 회고를 통해서 스프린트를 한번 돌이켜 보았습니다.  타이머를 걸어도 하고픈 말들이 너무 많았던 우리 팀 여러분들은 이렇게 빼곡히 정성스레 작성을 해주셨네요!         끝으로...   5일간 함께 해준 알모, 단테, 홀리몰리, 설아아빠, 데비니, 이엘로 모두에게 다시 한번 감사의 인사를 전합니다. 이 글을 읽으신 분들도  구글 스프린트 나  팀 캔버스 에 대해서 간접적으로나마 어떤 활동인지를 이해하시고 한번쯤 팀에서 시도를 해보시면 좋겠습니다.  이 모든 것들이  하루 2시간씩 5일간  일어났던 일입니다. 실제 회사생활에서 보다 적게 시간을 썼는데 훨씬 더 많은 것들을 할 수 있었다고 하신 분도 있었어요. 이러한 프로세스를 잘 접목시켜서 실제 업무에서도 더 효율적인 프로세스로 일을 할 수 있는 인사이트가 되었으면 좋겠습니다. 긴글 함께 해주셔서 감사합니다 :) ps. 혹시 이 글을 보시는 디자이너 분들이 있다면 꼭 좀 함께 했으면 좋겠습니다. 3기는 어떻게 기약이 될런지는 모르겠습니다만 다음에 스프린트를 하고 싶으신 분들이 있다면 꼭 디자이너분과 함께 해보았으면 좋겠네요 :) 스프린트에서 설문 조사를 하고 있습니다. 소중한 의견은 스프린트 팀에게 큰 힘이 됩니다! https://docs.google.com/forms/d/e/1FAIpQLSdOHV4aO4AO6AwYYKQZ6KogwDxADC1lYN2Rsu__IbgCV3gJsQ/viewform 참가자 회고글 보러가기 이엘로 -  6일간의 여정 돌아보기 - 구글 스프린트 우리 프로젝트 같이 해보지 않을래요? (테오의 구글 스프린트 2기) ... 현재 특정게임을 만드는 방식의 강의를 듣고 있습니다. 강의내용중  DOM 에 대해 설명을 하는 데 강의에서는 필요한부분만 말해주니  DOM 이라는 큰 틀도 잘모르겠고 강의내용외에 어떤식으로 활용해야 할 지 모르겠더라구요. 따로 공부해보려고 mdn에서 찾아봤는데 특정개념을알려면 다른개념을알아야하고 또그 개념을알려면 다른개념을알아야하고... 해서 어디부터 어디까지  DOM 을 공부해야 할지 막막한데 혹시  DOM 은 다들 어떤식으로 공부하셨나요? 이번 글의 소재를 제공해주시고 허락해 주신 프론트준비생님께 감사의 인사를 전합니다. 😘 프롤로그 이번 글에서는  DOM(Document Object Model) 에 대해 얘기해 보려고 합니다.  웹 개발 초창기에는 DOM은 그렇게 썩 훌륭하지 않았습니다. 그러기에 javascript를 사용하다보면 자연스럽게(?) DOM에게 불만을 토하며 이걸 어떻게 쓰라는 거지? 하며 씩씩거리며 찾아 보게 되면서 이론보다는 몸으로(?) 익히게 되는 그러한 개념이었습니다.  이러한 불편함을 여러 개발자들이 개선을 해오며 jQuery가 나오고 또 React가 나오면서 이제 실전에서는 DOM API를 거의 쓰지 않는 추세가 되었습니다. 그랬더니 되려 현재에는 이러한 프레임워크나 라이브러리를 쓰지 않는 바닐라 스크립트라는 용어도 생기고 DOM과 같은 저수준 API를 공부하는 게 훨씬 더 어려운 일이 되어버린 현실을 알게되었습니다. &#39;지금은 DOM을 안쓰니까 지금부터 웹 배우는 친구들은 적게 배워도 할 수 있는게 많아서 좋겠다. 내가 예전에 배웠던걸 그냥 SKIP할 수 있겠네...&#39; 라고 잠시나마 꼰대같이 생각했던 저를 반성해봅니다. DOM을 깊게 파기 시작하면 엄청 양이 방대하니 간단하게 DOM에 대해서 입문을 하실때 도움이 될 수 있도록 언제나처럼 제 스타일대로 DOM을 설명해보려고 합니다. 이 글에서는 다음과 같은 내용을 다루려고 합니다. DOM이란 무엇인가? (MDN을 중심으로...) DOM이 생겨난 이유 DOM을 대하는 마음가짐 그밖에 DOM에서 꼭 알아야 하는 것 DOM API를 써야 하는 이유 DOM을 어떤식으로 공부하셨나요? DOM(Document Object Model) 문서 객체 모델(The Document Object Model, 이하 DOM) 은 HTML, XML  문서 의 프로그래밍  interface  이다. DOM은 문서의  구조화된 표현(structured representation)을 제공 하며 프로그래밍 언어가  DOM 구조에 접근할 수 있는 방법 을 제공하여 그들이  문서 구조, 스타일, 내용 등을 변경 할 수 있게 돕는다. DOM 은  구조화된 nodes 와  property  와  method  를 갖고 있는  objects 로 문서를 표현한다. 이들은 웹 페이지를 스크립트 또는 프로그래밍 언어들에서 사용될 수 있게 연결시켜주는 역할을 담당한다. 출처:  MDN ...그렇다고 합니다. 일단 중요한 키워드만 획득을 하고 천천히 풀어보도록 합시다. 문서, interface, 구조화된 표현, DOM 구조, 변경, Node, property, method, object. 여담이지만 처음에 개발을 공부하면 아무것도 모르는 상태에서는 이러한 정의와 설명이 참 개발공부를 어렵게 합니다. 그리고 나서 다 이해를 하고 난 뒤에  &quot;아! DOM을 이제 깨달았어!&quot;  상태가 되어 남에게 DOM을 최대한 간단하고 정확하게 설명을 하려고 하면  나 역시 이렇게 설명을 하고 있다 는 것을 알게됩니다. 그게 정답이니까요 😅. 공식문서에서의 정의는 굉장히 중요하고 최대한 정확하고 간결하게 알려줘야 하기 때문이죠.  물론 불친절하게요 ㅠㅠ 그러니 맨 처음에 내가 알아먹지 못한 정의가 나오는 것에 너무 막막해 하지 마시고  저 정의들을 내가 배워야 할 목차라고 생각해주세요. 우선  모든 개발은 필요에 의해 만들어졌다  라는 것과  기존 개념위에 올려진 개념  이라는 사실을 바탕으로 순서대로 익히고 난 뒤에 다시 정의를 한번 읽어보시는 것을 추천드립니다. DOM이 생겨난 이유 태초에 웹은 문서를 공유하기 위해 만들어졌다. 아마 &quot;이 편지는 영국에서...&quot; 와 같이 제가 글을 쓸때마다  웹은 문서를 공유하기 위해서 만들어졌다.  라고 쓰고 있네요. 근데 그만큼 중요한 의미이자 시작입니다. 웹은 문서를 공유하기 위해서 만들어졌고, 해당 문서를 만들기 위해서 HTML이라는 문서에 마크업이라는 언어를 만들고 문서를 만들 수 있게 되었습니다. 이후 서버에서 프로그래밍을 통해서 HTML을 제작할 수 있는 PHP와 같은 서버언어가 등장했고 이를 통해서 컨텐츠가 포함된 HTML을 동적으로 생성할 수 있게 되었습니다. 이 개념을  브라우저가 새로고침을 하지 않고 서버의 개입없이 브라우저 내부에서 동적으로 HTML을 변경 하고자 자바스크립트가 탄생을 했습니다. 여기서 알아두면 좋은 것은 브라우저가 먼저 만들어졌고 서버언어가 만들어졌고  자바스크립트가 더 나중에 만들어졌다는 점 입니다. HTML은 문자열이다 HTML이 좋은 점은 바로 문자열로 이루어져있다는 점입니다. 그렇기에 서버 언어에서는 별다른 HTML 전용 API없이도 문자열의 조작을 통해서 얼마든지 HTML을 만들어 낼 수 있었습니다.  PHP Code: HTML Result:  &lt;h1&gt;hello, teo.yu!&lt;/h1&gt; 그러면 javascript에서도? https://imyeonn.github.io/blog/web/86/ 서버에서 그랬던 것 처럼 화면에 그대로 문자열을 출력하듯이 HTML을 출력해버리면 어떨까요?  document.write()  라는 아주 간단한 API를 만들어서 서버에서 동작하듯이 만들어 보았습니다. 이 방식은 맨 처음 동적으로 문서를 만드는 것 까지는 좋았으나 이후 새롭게 문서를 변경하기 위해서  몇 가지 문제점 이 있다는 것을 알게됩니다. HTML 문서가 화면에 그려지기 까지... HTML은 결국 사람이 편리하게 다룰 수 있는 문자열이지 컴퓨터가 알아듣고 사용하기에 좋은 언어는 아닙니다. 컴퓨터가 이를 해석하고 그릴 수 있게 하기 위해서 HTML을 분석하고 정리해서 화면에 그릴 수 있는 구조를 만들어야 합니다.  이 과정은 확실히 적은 비용이 아닙니다.     https://yceffort.kr/2021/11/jorney-from-tags-to-dom 이렇게 화면에 그릴 수 있는  구조를 이미 만들어둔 상태에서 일부 변경 된 화면을 만들기 위해 처음부터 다시 변경된 HTML을 분석하여  다시 전부 구조를 만들어 적용하는 방식은 비효율적 이었습니다. 그래서 최초 HTML을 통해 한번 구조를 만들었다면 다음번 변경은 HTML의 조작이 아닌  이미 만들어진 구조에서 직접 일부 수정을 하는 방식 을 통해 훨씬 더 적은 비용으로 화면을 변경할 수 있을 것입니다. 그래서 DOM이 필요하다!   출처:  https://simplesnippets.tech/what-is-document-object-modeldom-how-js-interacts-with-dom/ HTML을 동적으로 보다 효율적으로 변경하기 위해서 HTML  문서(Docuemnt)  를 자바스크립트가 이해할 수 있는  객체(Object)  의 형태로  모델(Model)링  하여 자바스크립트에서 조작을 할 수 있도록 만든 ⭐️  interface 가 바로 이  DOM(Document Object Model) 인 것입니다. Interface? DOM과 Javascript의 관계 MDN 공식문서에 적혀 있는 다음 설명을 또 읽어 봅시다. DOM 과 자바스크립트 이 문서의 대부분의 예제와 같이, 위에서 사용된 예제는 JavaScript이다. 위의 예제는 자바스크립트로 작성되었지만 문서(document) 와 문서의 요소(element) 에  접근 하기 위해 DOM 이 사용되었다.  DOM 은 프로그래밍 언어는 아니지만  DOM 이 없다면 자바스크립트 언어는 웹 페이지 또는 XML 페이지 및 요소들과 관련된 모델이나 개념들에 대한 정보를 갖지 못하게 된다. 문서의 모든 element - 전체 문서, 헤드, 문서 안의 table, table header, table cell 안의 text - 는 문서를 위한 document object model 의 한 부분이다. 때문에, 이러한 요소들을  DOM 과 자바스크립트와 같은 스크립팅 언어 를 통해 접근하고 조작할 수 있는 것이다.   초창기에는 자바스크립트와 DOM 가 밀접하게 연결되어 있었지만,  나중에는 각각 분리되어 발전해왔다. 페이지 콘텐츠(the page content)는 DOM 에 저장되고 자바스크립트를 통해 접근하거나 조작할 수 있다. 이것을 방정식으로 표현하면 아래와 같다:  API (web or XML page) = DOM + JS (scripting language)  DOM 은 프로그래밍 언어와 독립적으로 디자인되었다.  때문에 문서의 구조적인 표현은 단일 API 를 통해 이용가능하다.  이 문서에서는 자바스크립트를 주로 사용하였지만, DOM 의 구현은 어떠한 언어에서도 가능하다. 아래는 파이썬을 사용한 예제이다: 출처:  MDN ... 그렇다고 합니다. 해당 내용을 이해하기 위해서 앞서 언급했던 내용을 다시 짚고 넘어가 봅시다. ... 여기서 알아두면 좋은 것은 브라우저가 먼저 만들어졌고 서버언어가 만들어졌고  자바스크립트가 더 나중에 만들어졌다는 점 입니다. 이미 브라우저는 자바스크립트가 만들어지기 전에 이미 HTML을 파싱하고 화면으로 표현을 할 수 있는 내부 구조를 이미 가지고 있었습니다. 그리고 나서 javascript가 만들어졌죠. 이 말은 이 내부 구조가 javascript로 만들어진것이 아니라는 말입니다. 그저 이러한 구조를 javascript를 통해서 조작을 할 수 있는  API 를 제공하는 형식으로 만들어지게 되었습니다. 이후 모든 브라우저에서의 동작은 같은 형태로 만들어야 한다는 웹표준이라는 것을 제정하게 되면서  어떠한 언어로든 이 구조에 접근을 할 수 있는 API 명세를 통일할 필요 가 생겼고 DOM을 정의하였습니다. 그래서 엄밀히 말하면  DOM은 API 중에서 공통 인터페이스 부분만을 의미 합니다.  API (web or XML page) = DOM + JS (scripting language) 하지만  실전에서는 이런 이론적인 내용 하나도 안중요하며  DOM = API로 이해하셔도 무방합니다. 지금 당장 무슨 말인지 이해가 안되도  &quot;아~ 완벽히 이해했어!&quot;  하면서 넘어가 줍시다.   DOM을 대하는 마음가짐 앞에서 DOM에 대한 이론으로 겁(?)을 줬지만 사실상 DOM의 본질은 다음과 같습니다. ✨  DOM = HTML을 수정하는 법을 컴퓨터가 알아듣게 작성하는 방법 HTML을 페어 프로그래밍을 한다고 상상을 해봅시다. 키보드를 담당하는 동료에게 원하는대로 지시를 하는 네비게이터의 입장이 되었습니다.  title  클래스를 추가하고 싶어서 우리는 아마 이렇게 말할겁니다. &quot;여기 h1 엘리먼트 옆에 class에 title 좀 넣어 주세요.&quot; 우리가 원하고자 행동을  정.확.하.게  알려줘야 될 것입니다. DOM을 공부하는 첫번째 방법은 변경하고자 HTML을 떠올리고 달라진 점을 어떤식으로 알려줘야 하는 지  컴퓨터가 알아들을 말(=API) 을 찾는 것입니다. 마치 외국으로 여행가서 주문할때 여행영어회화 책자를 뒤지듯이 말입니다.  DOM을 공부하기가 힘든 이유는 우리에게는 타이핑으로 쓰고 지우고 하면 되는 행동을 컴퓨터에게 시키기 위해서는  각각의 다 다른 방법(=API) 으로 알려줘야 하기 때문입니다. DOM은 어떻게 생겼을까? DOM은 일단 HTML을 표현하고 조작하는데 목적이 있기 때문에 HTML의 구조를 그대로 닮아있게 됩니다. HTML에는 Tag를 가지는 Element와 Text로 나뉘고 엘리먼트는 여러개의 Attribute를 가집니다. DOM에서는 이러한 각각의 요소를 Node라고 부르며 HTML과 마찬가지로 Element Node, Attribute Node, Text Node로 부르게 됩니다. 그밖에 주석이나 문서와 같은 Node도 존재합니다. 자세한 내용은 아래 링크를 참조해주세요. https://poiemaweb.com/js-dom https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType DOM Tree   HTML의 엘리먼트는 동일한 엘리먼트를 포함할 수 있는 구조가 됩니다. 이러한 구조를 Tree라 부르기에 HTML이 여러개의 Element와 Node로 구성되어 있는 것을  DOM Tree  라고 부릅니다.   트리 보다는 폴더 구조로 이해하고 Element는 폴더 Text는 파일로 생각을 하면 조금 더 이해하기 편합니다. DOM API 여기서 부터는 API의 학습의 영역이므로 제 글에서는 더 이상 기술하지는 않겠습니다. 나머지는 여러분들이 알고 있는 DOM을 검색하면 나오는 내용입니다. DOM API의 양은 방대합니다. 앞서 말한 본질을 기억하며 필요할때 찾아서 꺼내쓰시길 바랍니다. 그러나 학습의 길잡이가 되기 위해서 API 공부를 하실때 직관적인 분류 기준은 설명을 드리고자 합니다. HTML을 조작을 하기 위해서는 대략 다음과 같은 단계를 거치게 됩니다. DOM 기초 내가 수정을 하고자 하는 DOM을 선택하거나 생성 해당하는 요소에서 원하는 항목에 접근 해당 요소를 원하는 값으로 변경 선택된 노드 삭제 새로운 노드 추가 DOM 고급 내가 필요한 조건에 맞는 하위 요소들을 선택적으로 가져오기 알고있는 엘리먼트를 기준으로 상대적인 위치에 있는 항목에 접근 하기 여러 항목을 하나로 묶어서(=DocumentFragment) 배치 변경하기 DOM API는 막 공부를 한다기 보다는 대충 어떤게 있는지 알아두고 필요할때 꺼내쓰는 것이기에 레퍼런스를 외우고 있기 보다 실전 경험이 훨씬 더 중요합니다. 요새는 바닐라스크립트로 개발을 하는 것이 효율성이 떨어지기에 실습할 재료가 많이 없다는 것은 아쉬운 일이네요. 조금이나마 본인이 만들었던 것들 중에서 화면의 변화가 많은 작업들을 한번 바닐라로 한번 만들어 보기를 권해봅니다. 🔥 그밖에 DOM에서 꼭 알아야 하는 것 DOM은 HTML을 조작하기 위해서도 필요하지만 HTML뿐만 아니라  화면에 이미 출력이 된 요소의 속성에 접근 을 한다거나 사용자의 입력요소를 컨트롤하는  Event 조작  역시 DOM에 포함이 됩니다.  DOM은 HTML뿐만 아니라 이미 그려진 화면적 요소에도 접근할 수 있다. DOM은 HTML이 아닙니다. 이미 화면에 그려져서 반영된 요소에도 접근이 가능하다는 사실을 기억해주세요.  Element.offsetWidth  라던가  Element.getBoundingClientRect()  와 같이 HTML과 달리 이미 그려진 화면요소에 대한 속성을 조회할 수도 있다는 것을 기억해주시면 원하는 것을 만들때 찾기가 더 쉬워집니다. https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect DOM에는 Event도 포함된다. DOM에는 사용자의 클릭이나 터치, 키입력등의 이벤트 요소도 포함을 하고 있습니다. 이벤트 핸들러를 등록하고 취소하거나  이벤트 캡쳐   버블링 에 대한 부분도 꼭 알아 두시기 바랍니다.   https://ko.javascript.info/bubbling-and-capturing https://developer.mozilla.org/ko/docs/Learn/JavaScript/Building_blocks/Events   DOM를 써야 하는 이유 글 초반부에도 언급을 했지만 DOM API는 그렇게 훌륭하게 설계되지 않았습니다. 그저 안되는게 없도록 최소한의 방식으로 만들어졌죠. 이후 DOM API를 최대한 편하게 쓰기 위해서 노력했고 jQuery라는 선구자가 있어서 DX를 개선을 했기에  document.querySelectorAll 과 같은 API가 표준 API가 될 수 있었죠.  하지만 DOM API를 그냥 쓰는 것은 좋은 방법은 아닙니다. 지금도 마찬가지입니다. 가급적 DOM API를 사용하지 않고 다른 방식으로 개발을 하려고 하고 있죠. HTML은 사람이 읽기 편하고 생성하기 편한 문자열로 되어 있으나 DOM은 컴퓨터가 이해할 수 있도록 하나씩 조작을 해야하도록 만들어졌습니다. 그러니 현대의 프레임워크에서는  HTML을 조작하는 감각으로 DX를 제공 하고 내부에서는 VirtualDOM과 같은 방식을 이용해서  DOM API 사용을 최적화  하려고 하고 있죠. 그렇기에 현재는 DOM API의 기본적인 선택과 조작, 이벤트 연동, 노드의 추가 삭제등에 대해서 DOM를 다룰 일은 별로 없습니다. 프레임워크를 쓰고 있다면 주로  .getBoundingClientRect 와 같이 UI를 고도화하기 위한 UI속성들을 조회하거나  .scrollIntoView 나  animate 와 같은 UI를 다루는 방법들을 알아야 합니다. 프레임워크를 떠나 모두에게 배포를 하는 UI 컴포넌트를 만들어야 한다면 DOM API를 깊게 알아야 할 수도 있습니다. 특정 프레임워크에 종속이 되면 안될테니까요. 아니면 직접 프레임워크나 라이브러리를 만들어야 한다면 DOM API에 대한 깊은 이해가 필요하겠죠. DOM을 어떻게 공부 하셨나요? 시대가 다르다보니 이 방법이 지금은 통할지는 모르겠지만 저는 나만의 프레임워크와  라이브러리를 만들어보는 방식 으로 DOM API가 훈련이되고 단련이 되었습니다. jQuery mini를 만들어 본게 큰 도움이 되었다. 저는 특히 jQuery 라이브러리를 구현해본 것이 가장 큰 도움이 되었습니다. jQuery API는 DOM API보다 훨씬 더 직관적이고 깔끔한 네이밍과 기능을 가지고 있습니다. 우스갯소리로 jQuery가 DOM API의 표준이 되어야 한다는 얘기도 있었습니다. 그래서 차라리 DOM API를 달달 외우려고 드느니 깔끔한 문법의 라이브러리를 한번 만들어 보는 것이 API를 이해하는데 훨씬 더 도움이 되었습니다. http://asiamusicnetwork.kr/js/1px.js jQuery의 경우 github에 가면 테스트 코드가 존재합니다. 코딩 테스트 보는 것처럼 test를 통과하는지 확인하면서 작업을 했었던 기억이 나네요. https://umbrellajs.com/documentation https://github.com/franciscop/umbrella   🔥 [추천과제] Popover 만들기! 그리고 DOM과 같은 것들은 써보지 않고서는 학습이 되지 않기에 현대에도 DOM을 애써 써야할만한 과제들을 고민을 해봤습니다. 제 생각에는 일단 Popover를 한번 구현해보시는 것을 추천드립니다. 전부 바닐라로 만들지 않고 프레임워크를 써도 상관없습니다. 실전에서 상당히 자주 쓰이며 DOM API를 사용하지 않으면 구현하지 못하는 기능입니다.  요구사항 https://getbootstrap.com/docs/4.0/components/popovers/ 아래와 버튼을 눌렀을때 해당 하는 엘리먼트 근처로 새로운 팝오버 UI를 띄웁니다. 이때 위치는 자동으로 계산이 되어야 하며 4방향으로 옵션을 받을 수 있습니다. 이때 팝오버의 크기가 화면을 벗어나서 잘리지 않도록 적절한 위치에 표기를 할 수 있어야 하며 한번 팝오버가 뜬 상태에서 외부 영역을 클릭하면 닫혀야합니다.   뭐든 개발은 이론보다는 실전으로 해보는 것이 훨씬 더 중요합니다! 끝으로... 서버에서는 HTML은 문자열만 조작하면 되었지만 브라우저에서는 HTML을 변경하는 방식은 비효율을 불렀기에 변경된 위치만 세부적인 방법 하나 하나를 지시하는 방법이 필요했고 그러기 위해 HTML의 문자열을 컴퓨터가 이해할 수 있는 모델로 만드는 DOM이 탄생했습니다. 이러한 DOM을 조작해 HTML 문서를 브라우저에서 수정하기 위해 만들어진 인터페이스가 DOM API입니다. 이 DOM을 통해서 HTML을 조작하는 방식은 불편하기에 자연스레 조금더 편한 방식으로 진화를 하다보니 지금은 DOM API 자체를 거의 사용하지 않고 처음처럼 문자열을 조작하는 느낌으로 라이브러리나 프레임워크가 발전을 해오고 있습니다. 그래서 지금 웹을 배우시는 분들은 DOM을 배우고 라이브러리 프레임워크를 배워가는 자연스런 과정이 아니라 프레임워크를 중심으로 DOM API나 바닐라스크립트를 저수준 API의 개념으로 배우게 되어 더 어려움을 느낀다는 생각이 드네요. 본인이 프레임워크나 라이브러리를 만들지 않는다면 더더욱 사용할 일이 적다보니 학습이 어려울 거라는 생각이 듭니다. 그렇다면 프레임워크나 라이브러리를 하나 만들어 보시는 건 어떨까요? 대단한걸 만들라는 것은 아닙니다. 그냥 DOM API를 공부하는 것보다는 훨씬 더 나을 것 같다는 생각이 들어요. DOM API 역시 깊은 이해보다는 그냥 숙달이 되는게 맞는 방향이라고 생각합니다. Popover외에도 아래에 연습용으로 추천하는 캐로셀이나 컬러피커들도 한번씩 보시고 만들어 볼만하다면 시도 해보시는 걸 추천드립니다.  https://getbootstrap.com/docs/4.1/components/carousel/ https://ui.toast.com/tui-color-picker DOM API의 세부적인 내용들을 다루지는 못했지만 얼마든지 시중에 좋은 자료들이 많으므로 아래 참고 자료들을 공유드리며 이 글이 DOM을 공부하는데 막막함을 조금이나마 덜어 줄 수 있기를 바랍니다.  참고자료 https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction https://wit.nts-corp.com/2019/02/14/5522 https://ko.wikipedia.org/wiki/%EB%AC%B8%EC%84%9C_%EA%B0%9D%EC%B2%B4_%EB%AA%A8%EB%8D%B8 https://poiemaweb.com/js-dom https://kingofbackend.tistory.com/25  Good https://ko.javascript.info/dom-nodes https://ko.javascript.info/dom-navigation https://ko.javascript.info/bubbling-and-capturing  DOM1 core 살펴보기 https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html  https://developer.mozilla.org/ko/docs/Learn/JavaScript/Building_blocks/Events  최신 jQuery 대안 https://umbrellajs.com/documentation  만들어 볼만한 것들 https://getbootstrap.com/docs/4.1/components/carousel/ https://ui.toast.com/ 제가 며칠 전에 클린소프트웨어 책을 보니  SOLID 법칙 이 나오던데요, 자바나 C++ 같은 클래스 구조로 객체를 만드는 언어에서는 쉽게 따라해볼 수 있겠는데, 함수 위주로 작성하는 js, ts를 사용하는 프론트엔드에서도 사용이 가능한지, 현업에서 클린 소프트웨어를 만들기 위해 SOLID 법칙을 사용하고 계신 부분이 있는지 궁금합니다.  타입스크립트 클린코드 -  https://github.com/labs42io/clean-code-typescript   프롤로그 우선  SOLID 원칙 이 뭔지 알아야겠죠? 위키백과에 가서 검사를 한번 해봅시다.   컴퓨터 프로그래밍에서  SOLID 란 로버트 마틴이 2000년대 초반에 명명한  객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙 을 마이클 페더스가 두문자어 기억술로 소개한 것이다.  프로그래머가 시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 함께 적용할 수 있다.  SOLID 원칙들은 소프트웨어 작업에서 프로그래머가  소스 코드가 읽기 쉽고 확장하기 쉽게  될 때까지 소프트웨어 소스 코드를 리팩터링하여 코드 냄새를 제거하기 위해 적용할 수 있는  지침 이다. 이 원칙들은 애자일 소프트웨어 개발과 적응적 소프트웨어 개발의 전반적 전략의 일부다.  https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84) SOLID 원칙이란? 즉,  SOLID 란 똑똑한 선배님이 먼저 만들어 놓은  좋은 코드를 만들기 위한 원칙 이라고 하네요.  막연히 우리가 코드 리뷰를 하면서 &quot;이 코드는 좀 별로인것 같아요...&quot; 라고 할때 &quot;왜요?&quot; 라고 하면 &quot;...딱 보면 그렇잖아요!&quot; 라고 하기 보다는 이러한 좋은 원칙에 의거해서 &quot;이 코드는 SRP원칙에 좀 어긋난것 같아요. 일을 너무 많이 하는 것 같으니 좀 쪼개야 될것 같아요.&quot; 라고 한다면 훨씬 더 합의가 될 수 있으면서  우리의 코드가 좋은 방향으로 갈 수 있는 지침 이 되어줄 것입니다. 2000년대 초반에 만들어졌지만 아직도 우리가 배우고 있다는 것은 정말 이러한 원칙이 Bible이라는 얘기겠죠? 우선  SOLID 5가지의 기본 원칙 을 이해하기 전에 먼저  왜 이러한 원칙들이 필요한지  한번 생각을 해보도록 합시다. SOLID 원칙의 본질 왜 이러한 원칙이 만들어졌을까요? 소프트웨어는  변하기 때문에 &#39;소프트&#39;  라는 명칭이 붙었습니다. 소프트라는 어감 때문에 변경이 아주 쉬울 것 같지만 개발자인 우리는 이미 너무 잘 알고 있습니다.  코드 변경은 쉬운 작업이 아니라는 것을요. 코드를  끊임없는 변경 하는 작업은 개발자의 숙명과도 같은 것입니다.  요구사항과 환경이 매번 변화 하는 만큼  우리의 소프트웨어도 성장을 해야 합니다.  하지만 소프트웨어는 하나의 거대한 기계와도 같기 때문에 일부의 부품을 교체하는 것들이 기계 전체의 고장으로 이어지기도 합니다.   도미노를 한번 떠올려 봅시다. 잘 세워진 도미노의 일부분을 다른 색깔의 도미노로 바꿔야 한다고 했을때 자칫 실수라고 하게 되면 한번 쓰러진 도미노가 미치는 범위는 어마어마 할 수 있습니다. 이러한 문제를 방지하려면 어떻게 해야할까요?  도미노를 잘 세우는 팁은 중간의 일부를 비워두는 거라고 합니다.  그래서 혹여나 실수를 했을때  문제가 생기는 범위를 최소화 하고 국지화 할 수 있는 것이지요. 소프트웨어에서도 서로간의 종속성을 최소한으로 해둔다면 이렇듯 변경이 발생을 했을때  다른 영역에 영향을 주지 않고 변경을 할 수 있도록 하는 것 입니다. 도미노의 중간을 비워두면 좋다라는 원칙이 있듯이 변경에 유연할 수 있는 구조를 만들기 위한 원칙이 바로 이 SOLID 원칙이지요. 우리가 자바스크립트를 다루면서 이러한 원칙에 맞춰서 프로그래밍을 한다면  훨씬 더 좋은 구조를 가진 프로그램을 작성 을 할 수 있게 됩니다.   하지만 SOLID 원칙은 객체 지향 프로그래밍 원칙 아닌가요? 자바나 C++ 같은 클래스 구조로 객체를 만드는 언어에서는 쉽게 따라해볼 수 있겠는데, 함수 위주로 작성하는 js, ts를 사용하는 프론트엔드에서도 사용이 가능한가요? 그렇습니다. 애석하게도 이 훌륭한 SOLID 원칙들은  객체지향 프로그래밍의 설계  라는 패러다임 토대로 만들어졌습니다. 하지만 우리가 쓰는 자바스크립트는 완전한 객체지향 언어가 아니죠. 자바스크립트는 함수형 프로그래밍을 토대로 Java의 언어적 껍데기를 입힌 언어이기에  함수형이면서 동시에 객체지향의 성격을 동시에 지니고 있어  완벽한 객체지향 언어보다는 사실 함수형 언어에 가깝고 class라는 문법이 일반적인 객체지향과는 다르기에  SOLID라는 좋은 원칙 을 배워도 프론트엔드 개발자는  실전에 적용하기 힘들다 는 점이 있습니다. 확실히 최근 트렌드의 javascript 실전상황에서는 class 기반으로 작성하기보다는 함수를 주로 다루기는 합니다. 그렇다고 완전히 함수형 프로그래밍이라고 보기도 어렵지요. 그래서 주제의 의문인  SOLID 원칙을 javascript, typescript에서는 어떻게 적용을 해볼 수 있는 지  저 역시도 궁금해졌기에 한번 찾아보고 글을 작성 해보기로 하였습니다. 객체지향의 원칙을 함수형에 적용을 해본다면?   SOLID 원칙에 대한 자료를 찾다보니 객체지향을 기반으로 하지만  클래스는 곧 함수과 데이터 그리고 타입에 대한 이야기이니 SOLID가 꼭 객체지향만을 위한 원칙은 아니다  라는이야기를 발견 할 수 있었습니다. 하지만 SOLID가 객체지향을 바탕으로 설명하는 부분은 사실이기에  함수 위주로 작성하는 실전 코드에 대해서 원칙을 적용해 보는 예시를 찾거나 설명을 하는 자료는 매우 부족했습니다. 따라서 이 글에 대해서는 순전히  제 주관적인 관점 을 바탕으로 함수 위주의 js, ts를 기준으로 한번  SOLID 원칙을 재해석  해보고자 합니다.  그렇기에 객체 지향 관점으로 설명하는 SOLID 5가지 원칙에 대해서는 설명을 생략하겠습니다. 이미 인터넷에 좋은 자료가 너무 많아요! https://github.com/labs42io/clean-code-typescript#solid S.O.L.I.D 5가지 원칙 그렇다면 실제 5가지 원칙을 다시 짚어보면서 한번  함수형 프로그래머의 관점 으로 바라봅시다.   🔥 S - SRP / 단일 책임 원칙  단일 책임 원칙 (Single responsibility principle) 객체   함수 는 오직 하나의 책임을 가져야 한다. ( 객체   함수   1개의 함수는 1개의 역할만 수행하자! Functions should do one thing  Bad:  Good: 출처 -  https://github.com/labs42io/clean-code-typescript#functions-should-do-one-thing SOLID를 모른다고 해도 누구나 처음 배우는 클린코드의 첫 덕목입니다.  하나의 함수는 하나의 기능만 해야한다!  하나의 함수가 많은 일을 하고 있다면 함수를 쪼개야 한다. 함수를 잘게 쪼개고 명확하게 만들면  절대로 이 함수는 틀릴 수 없다!  라는 코드의 조각들이 많아지게 되며  문제가 발생했을때의 확인을 해야하는 코드의 양이 줄어 들게  됩니다. 도대체 어디까지 쪼개야 하는 건가요? 이 예시에서 굳이  isActiceClient(client) 를 쪼갤 필요가 있나요? 이 원칙을 헷갈려하는 주니어 개발자들이 있습니다. 예시에서도 보여주듯이 함수를 조립하기 위한 매개함수로 쓰일 수 있는 것들을 쪼개 주는게 좋습니다. .filter(...)에 들어갈 조건 판별 함수 .forEach(...)에 들어갈 동작을 하는 side-effect 함수 .map(...)에 들어가는 project 함수 .sort(...)에 들어가는 정렬을 나타내는 함수 가급적 데이터를 다룰때 for문보다는 함수형 method를 쓰려는 습관을 가진다면 훨씬 더 간결하면서 유연하고 좋은 코드를 가질 수 있게 됩니다. 하지만 너무 잘게만 쪼개는 것이 능사는 아닙니다. 가령  export const hasChildren = (item) =&gt; !!item.children  과 같은 코드에 대해서는 상황에 따라 다를 수 있습니다. 이 융통성이라는게 필요하다는게 소프트웨어 개발을 어렵게 하는 것 같아요.  정도로 결국  가독성과 응집도를 기준 으로 적절히 inline을 사용하시는 것도 필요합니다. 가독성의 기준은 본인이 아니라 이 코드를 읽는 다른 사람이므로 잘 모르겠다면 주위 동료에게 물어보시면 좋을 것 같아요. One more Thing! 순수함수로 작성해보자! 클래스를 쓰지 않고 함수만 사용한다고 함수 형  프로그래밍이라고 할 수는 없습니다. 함수형 프로그래밍이 되기 위해서는  순수함수와 부수효과를 분리하는 구조 가 되어야 합니다. https://maxkim-j.github.io/posts/js-pure-function  순수함수란? 1개의 반환값이 반드시 존재한다. 같은 인자를 넣었을때에는 항상 같은 값을 반환한다. 함수 외부의 어떠한 값을 변화시켜서는 안된다.  순수함수는 너무나도 SRP의 원칙에 들어맞는 모양 이 되게 됩니다. 그러니 함수형 프로그래밍의 핵심인 가급적 순수함수로 작성하는 원칙은 SOLID의 첫번째 원칙인 SRP와 함께 엮어서 생각을 해주시기 바랍니다. 🔥 O - OCP / 개방-폐쇄 원칙  개방-폐쇄 원칙 (Open/Closed Principle) 일단 OCP의 원칙을 그림을 통해 직관적으로 한번 이해해봅시다.  트럭이라는 운송수단과 뒤에 달리는 기구를 분리/결합 할 수 있는 구조 를 만들어 두면 새로운 목적이 필요한 도구를 만들어야 할때  트럭 전체를 다시 만들지 않고서  뒤에 달리는 장치만 새롭게 만들어서 붙일 수 있게 됩니다.   출처:  https://levelup.gitconnected.com/the-open-closed-principle-made-simple-cc3d0ed70553 OCP의 원칙의 의미는  새로운 기능의 추가가 일어 났을때에는 기존코드의 수정 없이 추가가 되어야 하고 ,  내부 매커니즘이 변경이 되어야 할때에는 외부의 코드 변화가 없어야 한다  라는 것입니다. 함수형 프로그래밍에서 이  OCP 를 가장 잘 느낄 수 있는 것은 바로 map, filter, reduce와 같은  Higer order Function(or Method) 와 webpack loader와 같은  플러그인 또는 middleware  개념입니다.  Bad:  Good: 하나의 함수의 기능이 여러가지 옵션들로 인해 내부에서 분기가 많이 발생하고 있다면 OCP와 SRP의 원칙에 맞게  함수를 매개 변수 로 받는 방법을 통해서  공통 매커니즘의 코드와 새로운 기능에 대한 코드를 분리 해서 다룰 수 있게 할 수 있습니다. 그러니 본인의 작성한 덩치가 큰 함수가 params에 option이나 flag가 많은 코드가 있다면 한번 SRP와 OCP 원칙을 기반으로 함수를 한번 점검 해보시기 바랍니다! 실전에서는 Redux의 middleware, Webpack의 loader, vite의 plugin과 같이 아주 많은 곳에서 이러한 원칙을 잘 지켜 유연한 확장과 견고한 매커니즘을 유지하는 좋은 설계를 가지고 있습니다. 🔥 이  OCP 원칙 은 함수형 개발의 설계에서 아주 아주 아주 x100 중요하기에 꼭 기억해서 좋은 설계를 만들 수 있도록 합시다.  버그 수정이 아닌 새로운 기능을 개발할때 기존에 개발된 함수를 수정하면서 코드를 개발하고 있다면 OCP 원칙을 위배한 코드를 작성하고 있을 확률이 엄청 높습니다! L - LSP / 리스코프 치환 원칙  리스코프 치환 원칙 (Liskov substitution principle) 많은 분이 SRP와 OCP는 쉽게 이해하다가 LSP부터 이게 무슨말이야? 하고 헷갈려합니다. 그래서 LSP는 객체 지향의 개념에서 조금 더 설명을 드리고자 합니다. LSP는 일단 정의가 헷갈리니 개념부터 먼저 잡고 갑시다. 리스코프 치환 원칙은 이해하면 어렵지 않은 개념인데 참 간단하게 설명이 안되기 때문에 객체지향에서의 원래 의미부터 찬찬히 한번 짚어 보도록 하겠습니다. 치환이라고 하면 상호변경을 의미합니다. 이 원칙에서는 뭘 치환하는 걸까요?  상속을 받은 하위 타입과 상위타입입니다. 이 둘을 치환을 해도 프로그램에서는 문제가 없어야 한다  라는 것이 이 원칙입니다.  일단, 예시를 통해 일단 한번 직관적으로 이해를 하는 것이 좋기 때문에 새와 앵무새와 펭귄의 이야기로 가봅시다.   출처:  https://www.cnblogs.com/charon922/p/8643454.html 새라는 객체를 만들고 &quot;앵무새는 새다.&quot;, &quot;펭귄은 새다&quot; 라는 정의에 따라 &quot;새&quot;를 상속을 받아서 앵무새와 펭귄을 만들었습니다. 객체지행에서 상속은 is-a 관계이므로 언뜻보면 맞는 것 같습니다. 하지만 이 경우  우리는 새를 정의하기 위해서 fly() 라는 method가 동작하는 것을 상정 했기 때문에 앵무새는 fly()하기에 새가 될 수 있지만  펭귄은 fly() 하지 못하기에 새가 될 수가 없습니다.  이렇게 설계가 된 경우 우리는 리스코프 치환 원칙을 위반했다라고 할 수 있습니다. (억지로 만든 예시입니다. 일단 느낌만 먼저 이해를 합시다.) 그리고 나서 가장 유명한 리스코프 치환 문제의 예시인  Rectanle -&gt; Squre 에 대해서 이해해봅시다. 전형적인 위반 LSP를 위반하는 전형적인 예로, 너비와 높이의 조회(getter) 및 할당(setter) 메서드를 가진 직사각형 클래스로부터 정사각형 클래스를 파생하는 경우를 들 수 있다. 정사각형 클래스는 항상 너비와 높이가 같다고 간주할 수 있다. 정사각형 객체가 직사각형을 다루는 문맥에서 사용되는 경우, 정사각형의 크기는 독립적으로 변경할 수 없기 때문에 (혹은 그래서는 안되기 때문에) 예기치 못한 행동을 하게 된다. 이 문제는 고치기 쉽지 않다. 정사각형 클래스의 할당 메서드를 수정하여 정사각형의 불변 조건(즉, 너비와 높이가 같음)을 유지하면, 이 메서드는 크기를 독립적으로 변경할 수 있다고 설명한 직사각형의 할당자의 사후 조건을 무력화(위반)한다. 이러한 LSP 위반은 실전에서는 LSP를 위반한 클래스를 사용하는 코드가 실제로 기대하는 사후 조건이나 불변 조건에 따라 문제가 될 수도 있고 아닐수도 있다. 여기서 중요한 사안은 가변성이다. 정사각형과 직사각형이 조회 메서드만 가진다면 (즉, 이들이 불변 객체라면), LSP 위반을 발생하지 않는다. https://github.com/labs42io/clean-code-typescript#liskov-substitution-principle-lsp 정리하자면, 리스코프 치환 원칙은 상속을 받아 만든 하위타입의 제약조건들이 상위 타입에서 먼저 선언한(fly나 setWidth) 조건들과 충돌이 날 경우 유지보수가 힘들어 진다는 문제점이 있기 때문에 만들어진 것입니다. 따라서  계층도간의 is-a 관계를 만족한다고 하더라도 (새-펭귄, 직사각형-정사각형) 하위 타입에서 가변성을 가지면서 상위 타입에서 정의한 조건과 일치하지 않는다면 상속을 받지 말아야 합니다. 함수형 프로그래밍에서는요? 이 원칙은 상속을 기반하므로 함수형 프로그래밍에게 바로 적용하기는 힘들것 같습니다. 하지만  먼저 선언된 조건들과 나중에 선언된 조건들이 서로 충돌이 나는 것을 방지해야한다는 원칙 으로 접근을 한다면  선언형 함수형 프로그래밍에서 발생하는 순환 종속성을 만들어내는 infinite Cycle을 만들지 않아야 한다 원칙 으로 대체를 할 수 있을 것 같습니다. 이와 같이 서로가 서로의 종속성과 순환참조를 만들어 무한루프에 빠지지 않을 수 있도록 하는 원칙을 기억하시고 프로그래밍을 하시면 좋을 것 같습니다. I - ISP / 인터페이스 분리 원칙  인터페이스 분리 원칙 (Interface segregation principle)   출처:  https://blog.ndepend.com/solid-design-the-interface-segregation-principle-isp/ 사진 속의 USB처럼 All-in-one 패키지가 편하지 않나? 라고 생각하실지 모를 것 같아, ISP를 위반한 댓가에 대한 정확한 비유는 다음과 같습니다.  모든 USB에 기기가 모두 꽃여있어야만  충전이 가능하세요~)   Bad: Good: 왜 예시를 객체지향으로 들고 왔을까요?  함수형에서는 사실 interface당 함수가 1:1의 관계이기에 ISP의 원칙을 위배하기란 쉽지 않습니다. (함수형 기반에서 ISP 위반에 대한 이야기를 전문적으로 하기가 참 어렵네요. 아래 이야기들은 일종의 썰 느낌으로 들어주세요.) ISP 위반인지는 확실치 않지만 interface를 보니 갑자기 생각나서 끄적이는 글 타입스크립트를 쓰다보면 백엔드의 스키마 정의를 interface를 정의해서 사용을 하게 되는데 백엔드 스키마 외에 클라이언트에서 필요한 필드들을 추가를 하고 스키마를 맞추기 위해서 ?를 통해서 optional한 필드로 만드는 경우가 있었습니다.  프롤로그 맞습니다. CSS는 배우기 어렵지 않으며 CSS를 작성하는 것 역시 어렵지 않습니다. 하지만 CSS 개발을 하다보면 CSS를 이렇게 쓰는게 맞는가? 하는 의문이 들때가 생깁니다.  처음 배울때와 달리 점점 CSS를 다루는 방법들이 복잡해지고 다양해지다 보니 이제는 무엇이 좋은 CSS인지를 몰라서 CSS가 어려워진다는 느낌을 받게 됩니다. 그래서 이번 글에서는 CSS의 역사를 짚어가면서 CSS의 발전방향을 짚어보고 가늠해보면서 앞으로 CSS를 어떻게 다루면 좋을지 생각해보고자 합니다. CSS가 어려워진 이유 웹은 문서를 공유하기 위해서 만들어졌습니다. 그리고 그 문서를 조금 더 잘 보여주기 위해서 서식이 만들어졌습니다. 이러한 서식과 데이터가 복잡하게 공존하게 되면서  서식과 컨텐츠를 분리해야겠다는 의도 에서 CSS가 탄생하게 되었습니다. 초기에는 문서와 서식을 잘 분리해서  보다 적은양의 코드를 통해서 같은 컨텐츠를 다양한 서식을 적용할 수 있도록 발전 을 하였습니다. 그러나 웹 산업이 급격히 발전을 하게 되면서 웹은 단순히  문서 의 역할을 너머  서비스와 어플리케이션 의 형태로 발전을 하게 되었습니다.  문서에서 어플리케이션까지 웹 서비스의 범위가 확장 이 됨에 따라 CSS에도 여러가지 요구사항들이 생겨났고 그에 맞는 여러 가지 좋은 스펙들이 발명이 되었습니다. 또한 그 과정에서 여러가지 시행착오를 겪기도 했었습니다. 특히 문서을 만들기 위해서 시작된 설계를 바탕으로 이후 어플리케이션을 위한 추가 방안을 마련하는 과정이 더욱 그랬습니다.  이렇게 이미 한번 만들어진 스펙은 되돌릴수가 없기에  좋았던 부분과 그렇지 못한 부분들을 우리는 함께 사용하고 있습니다. 또한 당시에는 시대에 맞게 의도대로 설계를 했지만 웹 산업이 급격하게 발전을 하면서 생겨난  새로운 요구사항을 이미 만들어진 스펙이나 설계가 못 따라오는 시기 가 존재했고, 그 안에서 어떻게든 방법을 찾다 보니  의도와는 다른 방식으로 CSS 스펙을 차용 해서 화면을 만들게 되었습니다.  또한 이렇게 우회해서 해결하는 방식들이 Tip에서 출발해 하나의 정석(?) 이 되어 공부를 해야하는 것이 되고 이런것들이 웹 문서로도 커리큘럼으로도 재생산이 되게 됩니다. 그리고 안타깝게도  최초 문서를 위해 설계된 방법들은 여전히 어플리케이션을 제작하기 위한 개념과는 충돌 하는 부분이 존재를 하고 있습니다. 이러한 부분들은 현대 산업에서 덩치가 큰 CSS를 이용한 프로젝트를 안정적으로 유지하게 어렵게 만드는 원인이 되고 있습니다. 그리고 이를 개선하기 위해서 CSS 스펙으로 해결하지 못하는 부분들은 여러가지 도구들을 발명해서 또 해결을 하고자 하게 됩니다. 그러면 또 우리는 이 새로운 도구를 배워야 하죠. 이후  이러한 문제를 해결할 수 있는 새로운 스펙이 출시가 되거나 더 나은 방법이 발견이 되면 기존에 찾아냈던 방식들은 전부 좋지 못한 방법 이 됩니다. 그렇지만 예전에 이미 생산된 커리큘럼이나 작성된 내용들은 남아있기에 뭐가 더 나은 방식인지 모른 채 학습을 하게 되죠.  그렇다고 무조건 최신을 따르자니  새로운 스펙이 모든 브라우저에 보편적으로 적용이 되기까지에는 또 시간이 필요합니다.  그러다 보니 특정 브라우저에는 제대로 보이지 않을수도 있기에 무조건 새로운 스펙을 바로 도입할수도 없죠.  그러니 기존의 방식 역시 알고는 있어야 하는 상황이 발생하게 됩니다. 당장의 최신 기술을 쓸 수 없으니 그렇다고 안정성만 추구해 계속 현재의 방법만 고수를 한다면 변화하는  웹 생태계에 따라가지 못한채 낡은 코드와 낡은 패러다임으로 인해 우리의 코드는 레거시가 되게 됩니다.  언제나 더 나은 방법을 찾아내고 개선을 하고자 하는 것이 개발자들이니까요.   (Can I use... 언제나 최신 기술을 바로 쓸 수 있는 것이 아니다.) 그러기에  언제 새로운 스펙으로 갈아탈지  어떤 기능이 나왔는지 어떠한 관점과 기술들이 나왔는지 우리는  꾸준히 관찰을 하고 학습 을 하여  적당한 시기에 더 나은 방법으로 꾸준히 업데이트 를 해나가야만 합니다. 종합하자면, 문서에서 어플리케이션으로 넘어오는 과도기적 시행착오로 인해  CSS 자체가 규모가 큰 서비스를 만들기에 이미 태생적인 문제가 있다는 것이 첫번째 어려움  입니다. 그리고  이를 극복하기 위해 새롭게 만들어지는 스펙들과 도구들이 범람 을 하는데 그 중에서 무엇이 좋은지 알기가 어렵고 무조건적으로 최신기술을 선택할 수는 없기에  적절한 기준점 을 가지고  적당히 좋은 도구 를  적당히 좋은 시기에 꾸준히 업데이트를 해야하는 것이 두번째 어려움 입니다. 나만의 Best Practice를 꾸준히 만들어보자! 웹 산업의 분야는 다양하기에  하나의 기술과 패러다임이 정답이 아닙니다.  CSS 기술은 항상 시대를 반영해서 발전을 해왔고 내가 홈페이지를 만들고 있는지 솔루션을 만들고 있는지 백엔드 입장인지 프론트엔드 입장인지에 따라서 좋은 방법과 나쁜 방법이 다 달라지게 됩니다.  CSS 역시 어디에서든 통하는 은빛총알 같은 것은 없습니다.  CSS에는 상황에 맞는 여러가지 도구들이 존재하고 있으며 어떠한 도구가 어디에 잘 어울리지는 지 역시 스스로 알아야 하겠지요. 그래서  CSS를 잘 하기 위해서는 본인만의 Best Practice를 가져야 된다 고 말입니다. CSS는 JS와는 달리 깊은 이해도 어느 정도 필요하겠지만  그것보다는 숙달 이 되어 있는 것이 훨씬 더 중요합니다. 왜냐하면 디자인을 내가 원하는 대로 만들 수 있고 요구하는 디자인을 정확하고 신속하게 만들어줘야 CSS를 잘 한다는 장점을 챙길 수 있기 때문에 CSS는 깊은 이해보다는 상대적으로 연습이 더 중요합니다. 그렇기에 내가 거대한 CSS와 디자인을 잘 다루기 위해서는 반복 숙달이 필요하고 그러다 보면 자기만의 루틴이 만들어지게 됩니다. 루틴이라는 것은 좋고 효율적인 걸 가지고 있어야겠죠.  CSS와 브라우저는 계속 성장을 하고 있기에 처음에 배웠던 그 방식이 지금은 최선이 아닐수도 있습니다.  그렇기에 내 도구들을 항상 점검하고 새로운 스펙들을 주시하고 있어야 합니다. 아쉽게도 무조건 최신을 택할 수도 없는 것이,  브라우저는 여러 종류 가 있고  데스크탑과 모바일  그리고  아직 업데이트를 하지 않은 유저 들도 있기 때문에 적절한 밸런스를 잡아야 합니다. 또한 그간 CSS 신문물의 척화비 역할을 하던  IE11의 퇴출이 확정 이 되었고,  CSS에도 JS의 영역이 가세 하면서 앞으로는 더 CSS의 도구와 패러다임이 업그레이드가 될 예정입니다. 최신 스펙뿐만이 아니라 CSS를 개발하기 위한 좋은 도구들을 꾸준히 바꿔가는 것 역시 우리가 낡은 개발자가 되지 않는 길이기도 합니다. 그러기 위해서 먼저 CSS 역사를 배워보자. 어느 분야든  역사를 공부한다는 것은 지금 이것이 왜 이렇게 만들어져있으며 앞으로는 어떻게 될지 방향성을 예측해 볼 수 있는 좋은 공부 가 됩니다. 특히 CSS의 경우 웹 문서로 출발해 홈페이지, 게시판 그리고 현재 웹 어플리케이션으로 넘어가는 과정에서 당시에는 CSS 스펙이 지원하지 않아서 만들어졌던 방법들이나 패러다임의 전환등이 많았기에 CSS를 지금 처음 배우는 사람들 입장에서는 예전과는 다른 환경에 쓰여진 말들이 어느 것이 맞는건지 잘 모르게 되는 경우가 생기게 됩니다. CSS뿐만 아니라 모든 개발의 내용은 필요에 의해 생기고 필요는 그때 당시의 상황을 반영하게 됩니다. CSS의 역사를 이해함으로써 앞으로 CSS 관련 글들을 읽었을때 어떠한 갈래와 패러다임에 해당하는 내용인지 알 수 있는 넓은 시야가 생기는데 도움이 되었으면 좋겠습니다. 또한 앞으로 새로운 스펙이나 도구 기술등이 나왔을 때에도 어떠한 맥락에서 이게 만들어졌는지 이해할 수 있는 단초가 되어 줄거라 생각합니다. CSS의 역사   출처:  https://github.com/ManzDev/frontend-evolution 문서를 공유하기 위해서 HTML이 만들어졌다. 1990 웹은 HyperText라는  문서를 공유하기 위해 서 만들어졌습니다. 그리고 이  문서를 만들기위해 HTML이라는 언어 가 만들어졌습니다. 미리 정의된 태그를 적절히 문서에 마크를 함으로써 적절한 서식이 입혀진 문서를 만들 수 있게 되었습니다. 이후 조금 더 커스텀한 서식을 입히고 싶은 요구로 인해  HTML에는 서식을 입힐 수 있는 기능 이 만들어지게 됩니다. 가령, 내가 강조하는 서식에 빨간색과 밑줄을 추가로 넣고 싶다라고 했을 경우에는 이런 식으로 스타일에 빨간색과 밑줄을 추가할 수 있습니다.  &lt;p&gt;안녕! &lt;strong style=&quot;color:red; text-decoration:underline&quot;&gt;여기를 빨간색과 밑줄표기로 강조&lt;/strong&gt;하고 싶어&lt;/p&gt; 이렇게  태그에 직접 스타일을 입력하는 방식을 inline-style 이라고 부릅니다. inline-style의 문제점 이렇게 inline-style을 사용하게 되면 원하는 커스텀한 스타일은 사용을 할 수 있었겠지만, 이러한 부분은 한군데가 아니겠죠. 이런 경우 작성했던 모든 strong 태그를 찾아서 빨간색과 밑줄을 추가를 해줘야 될 겁니다. 그래서 아래와 같이  매번 반복해서 작성 을 해야하는 복잡한 문서가 만들어지게 됩니다. 그런데 여기서 빨간색이 마음에 들지 않아서 파란색으로 바꾸고 싶다면 어떻게 해야 할까요? 이미 다 만들어 놓은 서식에서 색깔 부분만 찾아내 빨간색을 파란색으로 일일이 다 바꿔야 할 것입니다. 찾아 바꾸기를 한다고 해도 글자색이 아닌 다른 색을 수정할 수도 있고, 실수로 본문에 있는 글자가 바뀔 수도 있는 문제가 발생을 합니다. 이렇듯 사용자 스스로 반복을 하는 것은 개발자 세계에서는 아주 좋지 못한 것이죠. CSS가 만들어지다, 1996 그래서 HTML에서 스타일만 분리해내어 작성하여 반복적인 부분을 일괄적으로 적용을 해주는 방법을 생각해내게 됩니다. inline-style이 기록된 부분들을 하나로 묶어 별도의 스타일을  선언(declarations)  해두고, HTML에서 원하는 태그를 찾아서  선택(selector)  하여 스타일을 적용하는 언어인 CSS를 만들게 되었습니다.  선택자(selector)  와  선언(declarations)  이 둘을 합쳐  CSS Ruleset 이라고 부릅니다.  strong { color: red; text-decoration:underline } 이렇듯 CSS는  반복해서 입력을 해야 했던 귀찮은 행동들을 대신 해주는 일종의 매크로  와 같은 역할을 한다고 생각해주세요. 그러면 CSS의 작동원리에 대해서 더 이해하기 쉬울겁니다. Cascade와 Specificity - 희망편 앞서 설명드린 매크로와 같이 여러개의 서식을 일괄적으로 적용을 방식이다 보니  CSS의 Ruleset의 적용 대상과 서식이 겹칠 경우에는 어떤 서식을 더 우선을 해야할지 규칙이 필요 했습니다. 이러한 규칙을 CSS는  Cascade 라는 특징을 가지고 만들어졌습니다. ( C SS의 첫글자이기도 한 이 Cascade는 한국어로 명확하게 번역을 하기 애매해서 많이들 헷갈려 하는 개념입니다.)  Cascade란 서식을 겹겹이 덧칠해 나가되 단순한 걸 먼저 구체적인 것은 나중에 라는 방법입니다.  반복적인 작업을 줄이기 위해서 기초가 되는 서식을 먼저 전체에 적용을 하고 점점 더 구체적인 서식들을 적용을 해 나가는 식으로 만들면 좋을 거라고 생각을 했습니다.  기초 화장 먼저 칠하고 색조 화장을 하는 장면이나 &#39;그림을 그립시다&#39;의 밥 아저씨가 그림을 그릴때 처럼 밑칠을 먼저 하면서 장면을 만든 다음 그 위에 더 구체적인 것들을 덧칠하는 것들을 상상해 보세요. 그래서  CSS는 작성된 순서가 아니라 CSS Rule이 가지고 있는 고유의 명시도(Specificity)에 따라서 우선순위가 다르게 적용을 할 수 있도록 설계 가 되었습니다. 이 방법은 코드의 순서를 강제하지 않고 응집력이 높도록 코드를 작성할 수 있도록  도와줄 거라고 생각했습니다. 🔥 Cascade와 Specificity - 절망편   Specificity War!   하지만 이  Rule마다 고유한 명시도(Specificity)가 있다 는 결정은 결과적으로  아주 좋지못한 설계 가 되었습니다.  우리는 이 설계로 인해 기존의 CSS를 덮어쓰기를 하기 위해서 더 복잡한 Selector를 써야 하고 복잡한 Selector를 덮어 쓰기 위해서는 더 더 복잡한 Selector를 써야 하고 !important와 같은 우선순위를 변경하는 코드를 남발하도록 만들었습니다.  개인적으로는 CSS의 Global Scope 문제와 더불어 CSS의 가장 좋지 않은 설계가 바로 이 Specificity라고 생각합니다.  추후 설명할 CSS의 방법론이나 CSS in JS, Atomic CSS와 같은 기술들은 이러한 한계를 극복하기 위해서 만들어졌다고 생각합니다. https://css-tricks.com/a-specificity-battle/ 게시판과 같은 웹서비스가 보편화 이후 웹 산업이 단순히 문서를 데이터를 교환하는 Form이 중심이 되면서 우리가 알고 있는 게시판이나 쇼핑몰과 같은 데이터를 주고받고 저장을 하는 매체로 성장을 하게 됩니다. 그래서 단순히 정적으로 서식과 함께 생성하던 문서에서 데이터들이 결합하여 동적으로 생성을 해야 하다보니 HTML를 작성하는 주체가 백엔드 개발자가 됩니다. 그러면서 게시판, 포럼, 장바구니, 로그인과 같은 기능이 필요한 페이지들은  백엔드를 중심으로 하는 솔루션의 형태 로 발전하게 됩니다. 이러한 이유로 솔루션의 HTML을 CSS를 이용해서 디자인을 커스텀해야하는 요구사항이 높아지면서 HTML을 건들지 않고 CSS만으로 디자인을 할 수 있는 방법이 중요해지게 됩니다. CSS Zen Garden의 열풍, 2003 이러한 시멘틱한 HTMl를 이용해서 하나의 컨텐츠에서 여러가지 CSS의 서식을 입힐 수 있도록 작성하는 것은 HTML5와 CSS3를 제대로 사용하는 하나의 기준이 되었고 이를 제대로 보여주는 사이트인 CSS Zen Garden이 등장하였습니다. CSS Zen Garden은 시멘틱한 원본 HTML이 존재하고 디자이너가 CSS만으로 전혀 다른 스타일을 적용할 수 있다는 것을 보여줍니다.   (같은 컨텐츠로 전혀 다른 디자인을 만들 수 있다!) 아직까지도 시멘틱 웹과 CSS를 배우고 연습하기에는 이만한 자료도 없습니다. CSS를 연습해야할 자료가 없다면 지금과는 디자인 트렌드가 많이 다르긴 하지만 시멘틱웹과 CSS의 기초를 익히기에는 좋습니다. 이러한 컨셉을 바탕으로 추후 CSS를 커스텀 할 수 있는 블로그나 워드 프레스와 같은 CMS 서비스들이 인기를 끌게 됩니다. 다만, 이때까지는 HTML을 먼저 만들고 CSS를 나중에 디자인을 커스텀할 수 있도록 하는 방법이 유효했지만 점점 하나의 웹페이지가 거대해지면서 하나의 컨텐츠를 여러 디자인으로 커스텀 하는 방식보다는  하나의 디자인과 컴포넌트를 중심으로 서비스를 키워나가는 형식 으로 발전을 하게 됩니다. 그래서  하나의 HTML에 여러 서식을 넣도록 만드는 이러한 방식은 현대 웹 서비스개발과는 맞지 않습니다. 그렇지만 CSS Style을 override하여 커스텀한 테마를 이용하여 홈페이지를 만드는 워드프레스와 같은 방식은 당연히 유효하며  실제로도 웹 페이지의 대다수 를 차지하고 있습니다. 이것이 CSS를 어렵게 만드는 이유이기도 합니다.  시멘틱 패러다임 은 HTML과 CSS의 학습의 교과서와 같은 항목이자  현재 가장 많이 쓰이고 있으면서도 최신 프론트엔드 개발 서비스와는 맞지 않는 부분 이 있어 우리는 어떠한 부분이 필요하고 어떠한 부분이 이제는 필요없는지를 잘 구분 할 수 있어야 합니다. Selector가 점점 더 복잡해진다. HTML을 수정할 수 없으나 원하는 디자인을 만들기 위해서는 조금더 정교하고 고도화된 Selector가 필요하게 됩니다. 그래서 CSS는 점점 더 Selector가 복잡해지는 방향으로 발전을 하게 됩니다. 하지만 이렇게 Selector가 복잡해지면 Specificity가 높아지게 되고 새로운 스타일을 그 뒤에 덮기 위해서는 더 높은 Specificity의 Selector가 필요하고 그러지 못할 경우에는 !important를 사용하게 되는 부작용이 있어 CSS가 어렵고 복잡해진다는 것을 느껴갑니다. Sass의 등장, 2006 Selector를 복잡하게 사용해야 하고 CSS에서 반복해서 사용하는 글자 크기가 색상들을 작성을 하고 나서 수정이 용이하지 않다는 점을 해결하고 CSS를 확장하여 사용하고자 하는 시도가 만들어집니다. Nested한 Selector와 variable를 등록할 수 있는 * 추가적인 문법으로 작성하면 CSS로 변환을 시켜주는 pre-processor인 *  Sass가 만들어집니다.   이후 2009년 less, 2010년 stylus와 같은 새로운 pre-processor들을 만들어지게 되었으나 sass가 계속 점유율 1위를 이어갔습니다.    https://blog.logrocket.com/how-to-write-reusable-css-with-sass/ Pre-processor는 CSS를 로직이 있는 언어로 접근하고 재사용을 하기 위한 방법을 모색했다는 데에 의미가 있습니다. 물론 CSS는 구조상 재사용이 거의 힘들기 때문에 실제로는 재사용을 거의 하지 못했습니다. 이후 Atomic CSS라는 방식을 통해서야 CSS를 재사용하기 위한 방법들이 발견되게 됩니다. HTML5과 CSS3, 시멘틱이 중요해지다 하나의 변하지 않는 컨텐츠와 다양한 변경가능한 디자인이라는 컨셉을 통해 HTML과 CSS에는 시멘틱이라는 것이 중요해졌습니다. 시멘틱이란 시각적으로 어떻게 보일지가 아니라  의미에 중점 을 두는 것입니다. HTML이 어떻게 보여질지는 HTML이 결정하는 것이 아니라 CSS에 의해 커스텀될 수 있어야 재사용성이 커지기 때문입니다. HTML에서 시멘틱요소는 컨텐츠에 의미를 부여해서 보다 나은 검색결과를 얻고자하는 SEO와도 관련이 있지만 이 글은 CSS를 다루기에 해당 내용은 생략하도록 하겠습니다. 뭐가 더 시멘틱할까? 이해를 돕기 위해 예시를 들어보겠습니다.   여기에 동일한 서식을 가지는  .error ,  .red ,  .#f00  3가지 클래스 이름이 있습니다.   .error 라는 이름이 더 시멘틱하다고 생각할거라 생각합니다.  시멘틱해야 하는 이유 이 상황에서 에러 메시지의 색깔을  오렌지색 (단, HTML을 수정할 수가 없어요!)    .error { color: #f90 } .red .#ff0 은 이제 명백히 잘못된 디자인을 표기하게 될 겁니다. HTML을 수정할 수가 없다면 class의 이름이 시각적인 내용이기보다 의미를 나타내어야 디자인을 커스텀할 수 있는 영역이 다양해집니다. jQuery, Ajax의 보편화, 2008 프론트엔드 개발에서 Ajax라는 혁신과 jQuery의 등장으로 인해 백엔드에서 HTML이 아니라 JSON을 만들게 되었습니다. 이제는 HTML이 백엔드에 있는게 아니라 HTML과 CSS를 함께 작성을 하고 데이터를 연동해서 출력하는 작업을 JS로 하는 방식으로 개발을 하게 됩니다. 사실상 프론트엔드의 탄생입니다. 이때부터는 HTML와 CSS를 작업하는 주체가 백엔드와 프론트엔드가 나뉘지 않고 점점 프론트엔드로 옮겨지기 시작하면서 복잡한 Selector를 사용해야할 빈도가 줄어들기 시작했습니다. HTML의 편집권이 프론트엔드로 서서히 옮겨오기 시작하면서 Selector를 복잡하게 만들기 보다는 HTML에 class를 추가하는 등 의 HTML 수정을 통하여 단순한 Selector를 만드는 방식으로 발전을 하게 되었습니다. 웹 어플리케이션과 Framework, 2013 페이스북의 성장으로 인해 웹 어플리케이션이라는 영역이 확대되고 React를 비롯한 Web Framework가 만들어지면서  HTML를 작성하는 주체는 온전히 프론트엔드 의 영역이 되기 시작합니다. 그러면서 페이지단위로 문서 기반이 아니라  컴포넌트 기반의 개발 방식 이 자리를 잡게 됩니다. 이렇게 JS의 개념이 발전하게 되면서 프론트엔드는 계속 발전하게 되지만 CSS는 그만큼의 변화의 속도를 따라오기 못하게 됩니다. 문제의 비극은 여기서 출발을 합니다. 문서를 꾸미려고 만들었지, 앱을 꾸미려고 만든건 아니었어... 이미 웹 산업은 홈페이지를 넘어 웹 애플리케이션의 세상으로 넘어왔지만 CSS는 예전의 문서를 꾸미기 위한 스펙을 가지고 있었습니다. 그러다보니 문서를 꾸미기 위한 방법들로 애플리케이션을 만들게 되었습니다. 그러라고 만든 스펙이 아니다보니 온갖 방법을 동원해서 엘리먼트를 가운데 정렬을 하고자 합니다. 당시에는 &#39;엘리멘트는 가운데 정렬하는 7가지 방법&#39; 과 같은 컨텐츠들이 중요한 토픽이었습니다. 이것은 현재도 meme으로 쓰입니다.   이러한 문제로 인해서 문서를 편하게 꾸미를 수 있도록 설계된 CSS는 문서를 꾸미는데 있어서는 유용했을테지만 어플리케이션스러운 UI와 컴포넌트 방식의 개발과는 맞지 않는 설계가 되어버렸습니다. 모듈과 컴포넌트 방식으로 개발 CSS의 가장 큰 문제점은 CSS가 global scope를 가지고 있다는 점과 Cascade의 Specificity입니다. 모든 문서에 일괄적으로 적용되기 위해서 만들어졌던 기능은 다른 컴포넌트 영역의 스타일을 수정할수도 있다는 문제가 되었습니다. CSS는 외부 변화에 의해 너무나 부서지기 쉽습니다. HTML을 만들고 CSS를 만들어 두면 이미 만들어진 CSS가 새로운 컴포넌트를 만들기 위한 제약사항이 되어버립니다. 새로운 HTML과 CSS를 만들기 위해서는 기존에 만든 CSS를 피해서 작성이 되어야 했습니다. 때로는 반대로 기존에 만들어진 CSS를 새롭게 덮어써야만 했습니다. CSS의 Specificity관리와 모듈화가 중요해졌지만 CSS의 스펙은 변경할수가 없었기에 이러한 상황을 이해하고  어떻게 하면 CSS를 잘 작성할 수 있을지 체계적으로 그리고 규칙을 가지고 작성을 해야겠다는 방법론 이 논의되기 시작합니다. 방법을 찾아보자. CSS 방법론와 BEM, 2013 그러면서 여러 가지 방법론들이 등장을 하게 됩니다. 방법론의 본질은 다음과 같습니다.  여러명에서 함께 작업을 할때 공통적으로 사용할 수 있는 아키텍쳐 Cascade의 Specificity 관리  그러기 위한 이름짓기 컨벤션!   출처:  https://www.youtube.com/watch?v=1OKZOV-iLj4 지금 방법론의 최종승자는 BEM 이지만 ITCSS를 소개하는 이 동영상은  왜 방법론이 필요한가 에 대한 좋은 설명을 해주는 자료라고 생각해서 가져와봤습니다. BEM? .Block__Element--Modifier http://getbem.com/introduction/ 간단한 이름짓기 컨벤션을 통해서 협업할 때 같은 방식으로 이름을 작성할 수 있게 하면서 구조를 표현하고 Specificity를 하나로만 관리할 수 있게 해서 기존의 문제점을 해결하고자 하는 방식입니다. 처음에는 HTML이 복잡해지고 class이름이 너무 길다는 이유로 사람들에게 받아들여지지 않았지만 CSS의 구조적인 문제를 다 경험(?)하고서는  간결하고 직관적이며 배우기 쉬운 BEM이 대세 가 되었습니다. BEM이 최종 방법론의 승리자가 된 이유! 구조도 표현하면서도 종속 관계가 없다. Specificity가 하나로 관리된다.  그러면서 컨벤션이 단순해서 쉽게 기억할 수 있다. Flexbox의 등장, 2013   https://studiomeal.com/archives/197 https://d2.naver.com/helloworld/8540176 https://css-tricks.com/snippets/css/a-guide-to-flexbox/ 웹 문서가 아니라 웹 애플리케이션으로 발전을 하는 과정에서  레이아웃를 하기 위한 CSS 스펙에 대한 요구사항 은 꾸준히 있어왔습니다. 2008년부터 만들기 시작했던 레이아웃을 하기 위한 스펙은 여러번의 시행착오 끝에 드디어 2013년 정식 스펙으로 등장하게 됩니다. Flexbox가 나오기 전까지  🔥 float나 table, absolute와 margin등을 이용해서 억지로 레이아웃을 만들던 방법들 이 존재했고 이러한 방법들은 대체가능한 방법이 없었으므로 여러가지 Tip과 같은 방법들로 방법이 공유되고 문서가 만들어지게 됩니다. 출시 당시에는 IE10이하 브라우저나 크롬, 사파리의 경우에도 이전버전에서는 바로 호환되지 않았기에 당장에는 쓸 수가 없다보니 IE가 없는 모바일에서만 사용하고 크로스브라우징을 하는 등의 과도기가 있었지만 이제는  웹 레이아웃을 하기 위해서는 제일 먼저 알아야 하는 가장 중요한 스펙 이 되었습니다. flexbox의 의미는 문서를 위한 CSS와 어플리케이션 레이아웃을 하기 위한 방식이 분리되어 CSS 스펙으로 웹 애플리케이션 레이아웃을 할 수 있는 토대를 만들어 준 것입니다. 🎯 2022년  flexbox는 이제 웹의 모든 레이아웃의 표준 입니다. float, margin, table, inline-block 등  옛날 방식으로 뭔가 정렬을 하는 방식들은 이제 배우지 않으셔도 되고 헷갈려 하지도 마시기 바라며  CSS를 한다면 flexbox만큼은 꼭 master가 되시길 바랍니다! Handoff툴의 등장! Zeplin, 2014   기존에는  디자이너가 퍼블리싱까지 포함을 해서 웹 디자이너 라는 직군으로 일을 했다면 본격적으로 제플린이라는 핸드오프툴이 등장하면서 이쪽 씬의 판도가 변하게 됩니다. 제플린은 기존에 디자이너가 사용하던 도구의 내용들을 통해 그동안 웹 디자인을 하기 필요한 스타일가이드나 요소 간의 간격, 배치에 대해서 기존에는 이걸 다 문서로 만들어서 전달을 하거나 (배보다 배꼽이 더 크던 시절) 그게 아니면 직접 퍼블리싱까지 해서 전달을 했다면 이제는 툴에서 알아서 문서화와 소통 그리고 아카이브까지 해주니 본격적으로  디자이너와 프론트엔드 개발자의 영역이 분리 가 되어 더 각자의 영역에서 전문가가 될 수 있게 되었습니다. 이러한 핸드오프가 등장을 하고 나서부터는 CSS로 디자인을 잘하는 능력보다는 디자이너가 만들어 준 디자인을 flexbox등으로 적절한 구조를 만들어 나아가 컴포넌트의 구조를 잘 만들어내는 능력이 더 중요해지게 되었습니다. 제플린과 같은 Handoff툴의 등장의미는 기존의 디자이너가 퍼블리싱을 함께 하던 구조에서 보다 디자인에 집중을 하고 기존 퍼블리셔의 역할을 개발자가 대부분 가지고 와야 한다는 것을 의미합니다. IE11 (비공식) 업데이트 중단, 2015  IE는 2015년을 기점으로 현재 더이상의 업데이트가 없었습니다.  IE11은 윈도우에서 여전히 점유율이 높은 브라우저였기에 이 이후 새로운 CSS의 스펙이 나오더라도 개발자들은 사용을 하기 꺼려졌습니다. 이때부터 프론트엔드 개발자들이 CSS에 대한 관심이 예전보다 더 떨어지게 되는 원인이기도 했습니다. 무엇보다 이 이후 새로운 스펙이 발표가 되더라도 IE11에서는 지원을 할 수 없기 때문에 해당 스펙을 적극적으로 사용할 수가 없게 되었습니다. 예전부터도 그랬지만 이때부터는  IE11이 CSS의 신문물을 막아주는 방파제이자 척화비 가 되어 CSS의 발전역사가 여기서 멈추게 됩니다. 이러한 이유로 이후부터는 CSS의 스펙이나 CSS에서 문제를 해결하기 보다는  CSS를 문제점을 JS로 해결하려는 시도들 이 생겨나기 시작합니다. CSS 수고했어... 이제는 JS가 해결해볼게! CSS Modules, 2015  CSS의 Global Scope로 인해서 컴포넌트와 CSS간의 구조와 범위가 일치하지 않는 문제 를  JS를 통해서 해결 하고자 하는 움직임이 생겼습니다.  그중 첫번째 도구인 CSS Modules는 컴포넌트에서 CSS를 불러와서 컴포넌트에서만 적용이 될 수 있도록 컴파일을 해주는 도구였습니다.   이를 통해서 CSS는 태생적인 문제를 JS를 통해서 극복을 할 수 있게 되었고 본격적으로 JS와 CSS가 결합되어가는 시도가 이어졌습니다. CSS Modules를 통해서 CSS의 가장 고질적인 문제인 Global Scope에 대한 해결이 이루어졌습니다. 사실상 CSS Modules등을 쓴다면 기존의 BEM과 같은 방법론이 그렇게 필요하게 없게 되기도 하였습니다. 그래도 2019년 까지만 하더라도 방법론들을 학습하는 게 또 CSS의 학습의 중요한 역할이었어요. 하지만 또 지금은 그렇지 않습니다. 결국  CSS가 가지고 있는 문제점은 CSS만으로 극복을 하는데에는 한계가 있었기 때문 입니다. CSS in JS: Styled-Component, 2016 CSS는 다음과 같은 구조적인 문제를 지니고 있습니다.    Global namespace:  모든 스타일이 global에 선언되어 중복되지 않는 class 이름을 적용해야 하는 문제  Dependencies:  css와 JS간의 의존관계를 관리하기 힘든 문제  Dead Code Elimination:  기능 추가, 변경, 삭제 과정에서 불필요한 CSS를 제거하기 어려운 문제  Minification:  클래스 이름의 최소화 문제  Sharing Constants:  JS 코드와 상태 값을 공유할 수 없는 문제  Non-deterministic Resolution:  CSS 로드 순서에 따라 스타일 우선 순위가 달라지는 문제  Breaking Isolation:  CSS의 외부 수정을 관리하기 어려운 문제(캡슐화) CSS의 Global Scope와 Specificity문제는 CSS의 구조상 해결을 할 수 없는 문제였습니다. 그렇다면  CSS를 JS를 통해서 만들게 되면 이러한 문제를 해결한 새로운 CSS를 만들어낼수 있지 않을까?  하는 방법으로 CSS in JS가 탄생하였습니다.   이러한 방식을 통해서  Specificity문제의 원흉인 Selector는 사라지게 되고  Property와 Value를 컴포넌트 구조에 맞게 작성을 하면 되게 되었습니다. 🎯 현재에 와서 Selector의 의미가 많이 퇴색이 된 이유입니다. Selector를 복잡하게 쓰게 되면 Specificity관리가 힘들어지게 되고 BEM도 마찬가지 이지만  결국 하나의 Specificity를 갖는 방식 으로 진화를 하고 있습니다. 지금까지의 CSS는 틀렸다. TailwindCSS! 2017   JS가 아닌 CSS 생태계에서 이를 해결하고자 하는  새로운 패러다임을 얘기하는 CSS프레임워크 가 나타났습니다. 그것은  Utiliy-First 라고 불리는 방식의  TailwindCSS 였습니다. 사실 TailwindCSS는 새로운 개념은 아니었습니다. HTML과 CSS가 만들어졌을 초창기 부터 class에 유틸리한 이름을 붙여 개발하는 방식은 개발자들 사이에서 암암리에 행해지는 방식이었습니다. 하지만 시멘틱한 방식이 중요한 패러다임이 되면서 이러한 방식은 일종의 꼼수, 옳치않은 방식으로 여겨졌기에 가급적 이렇게 쓰지 말라고 하는 안티패턴이었습니다. https://mulder21c.github.io/2014/12/03/considerations-for-class-name/ https://cafe.naver.com/hacosa/184954 https://hyeonseok.com/blog/604 하지만 TailwindCSS는 이러한 방식을  오히려 일부차용이 아니라 전면적으로 이러한 방식을 사용을 하는 것을 권장하며 패러다임 쉬프트에 성공 하였습니다. 당연히 이러한 방식은 예시를 든 블로그의 내용을 보더라도 당시에는 받아들이기 아주 힘든 패러다임이었습니다. 그래서 tailwind의 경우에는 초반에 반대로 굉장히 많았습니다.  tailwindCSS가 받아들여지는데에는 예전과는 달리 다음과 같은 변화가 있었기 때문에 통용이 됩니다. 웹 개발은 이제 대부분 솔루션 방식이 아니라 프론트가 직접 HTML과 CSS를 수정한다. CSS로 개발하는 것보다 HTML을 다루는게 더 편하며 사이드-이펙트가 적다. 대부분 서비스들이 하나의 디자인 시스템을 가지고 여러개의 스타일시트를 이용해서 테마를 만들 이유가 없다.  Atomic한 CSS 는 모두 같은 Specificity한 class로 구성이 되었으며 개발을 할때에도  새롭게 CSS를 작성하지 않아도 되었기에 더 이상 추가적인 CSS의 관리가 필요하지 않다 는 큰 장점이 있습니다. 무엇보다  이름을 짓기 위한 고민을 하지 않아도 되며 (&lt;- 엄청 큰 장점입니다!!) 또한 이미 만들어진 CSS는  서비스가 커지더라도 CSS의 양이 변화가 없기 때문 에 대형 서비스 일 수록 CSS의 크기를 줄이는 이점이 존재합니다.  워드프레스와 같이 HTML이 미리 고정이 되어있고 테마를 제공해야하는 솔루션에서는 절대로 쓸 수 없는 기술이다보니 초창기 많은 사람들에게 좋지 않은 방식이라고 부정당했으나  지금은 당당히 CSS의 구조적인 문제를 다룰수 있는 방법으로 인정을 받고 가장 인기 있는 프레임워크 가 되었습니다. CSS Variables의 등장, 2017 Sass나 Less와 같은 PreProcessor의 등장이유기도 했던 CSS에 변수를 쓸 수 있는 기능이 IE11를 제외하고는 모든 브라우저에서 사용을 할 수 있게 되었습니다. IE11지원을 포기하고 새로운 CSS의 세상을 살기로 마음먹은 서비스들은 이제 더이상 Sass를 써야할 이유가 사라졌습니다.  복잡한 Selector는 CSS 구조상 이제 필요가 없어졌고, CSS Variable은 이제 CSS의 기본 기능이 되었습니다. autoPrefixer의 경우는 PostCSS가 대신할 수 있게 되었고 mixin과 같은 기능들은 CSS in JS에서 더욱 잘 지원을 할 수 있게 되었습니다. IE11을 쓰지 않을거라면 CSS in JS를 할꺼라면, Atomic CSS를 쓴다면 점점 Sass를 써야 하는 이유가 줄어들고 있습니다. 여전히 Sass는 CSS를 하나면 점유율이 높지만 서서히 대체 도구들이 등장하고 있는 중입니다. GridLayout의 등장, 2017 구상은 flexbox보다도 훨씬 전에 논의가 되었지만 여러가지 버전을 거쳐서 2017년 드디어 Grid Layout이 등장하게 됩니다. 하지만 IE의 시간은 2015년도에 머물러 있었기에 새롭게 만들어진 Grid Layout스펙과 IE에서 사용가능한 Grid Layout의 경우 미묘하게 스펙이 다르게 됩니다. 그래서 GridLayout은 흥행을 실패합니다. 사람들은 IE11에서 골치아프게 크로스브라우징을 해야하는 GridLayout에 비해 flexbox로 충분히 대부분의 레이아웃을 작업할 수 있었기에 Grid Layout은 실험적인 기능에 그치게 되었습니다. IE11안녕~ 함께해서 더러웠고 다신 만나지 말자, 2020 MS에서 공식적으로 IE11의 지원종료를 발표하였습니다. 사람들은 이제 확실하게 IE11을 지원하지 않아도 된다는 사실을 통해서 그동안 2015년에 묶여있었던 5년치의 CSS를 한꺼번에 배워야했습니다. 이제는 새로운 CSS의 스펙을 곧 마음대로 쓸 수 있게 되었습니다. 흥행에 실패했던 GridLayout의 사용점유율도 10%에서 50%로 올라왔습니다. 아직 사용할 수 없는 수많은 스펙들이 새로 만들어지고 있습니다. 이제는 새롭게 지원해줄 스펙을 통해서 CSS를 더 좋게 만들 수 있는 방법들을 고민해볼 차례입니다. 물론 아직 그런 시대는 오지 않았습니다. figma, sketch를 누르고 디자인툴 1위가 되다, 2020 디자인 툴에 대한 지각변동이 발생하게 됩니다. figma가 1위가 된것은 아주 중요한 사건입니다. figma는 디자이너뿐만 아니라 개발자와의 협업을 하기 위한 실시간 클라우드와 Zeplin과 같은 Handoff 기능을 함께 겸하고 있습니다. figma는 AutoLayout과 같은 개발자적인 관점에서의 도구를 가지고 있습니다. 점유율 1위가 되면서 디자이너들이 대부분 선택하는 도구가 되고 Zeplin대신 figma를 통해서 HandOff 및 디자인 리소스를 작업해야 하게 되었습니다. figma의 CSS Inspect는 아주 훌륭하며 디자이너와 함께 협업을 하기 위해서는 개발자들도 알아야 하는 도구입니다. CSS in JS의 대유행, 2021 Styled-Component의 흥행과 React의 압도적인 점유율로 인해 CSS in JS는 새로운 강자를 찾는 중입니다.  런타임에 CSS를 생성한다는 문제점을 극복하기 위해서  Zero-Time CSS, Near Zero CSS와 같은 컨셉을 들고 나오는 중입니다.   stateof2021 - 2021 새로운 기술들은 대부분 CSS in JS에 몰려있다.   오래된 기술의 사용율이 높긴 하지만   만족도의 순위는 엎치락 뒤치락 중이다! 아직까지 절대적인 강자는 Styled-Component가 자리를 지키고 있으며 어떠한 라이브러리가 최종승자가 될지는 좀 지켜보면서 천천히 갈아 타고 될 것 같다고 생각합니다. on-demand Atomic CSS! ... 2021? 2022? 2023? TailwindCSS는 미리 만들어둔 CSS만으로는 수치나 색상 입력에 한계가 있고 이러한 부분들을 미리 설정을 해두는 방식으로는 한계가 있다는 지적을 받아왔습니다. 그래서 CSS를 미리 만들어 두는 방식이 아니라 AtomicCSS에 필요한 수치를 입력을 해두면 필요한 CSS를 자동으로 생성을 해두는 주문형(on-demand) Atomic CSS 패러다임으로 발전하고 있습니다. 그중에서도 unocss가 단연 성장세가 무섭습니다. atomic-css 토픽에서 벌써 3위가 되었네요. 나머지 1위 2위는 모르셔도 됩니다. 정말 5~6년도 더된 아주 아주 오래된 것들이 떄문에 얻은 Star이구요    https://unocss.antfu.me/ 제가 만들고자 했던 것과 컨셉이 상당히 유사합니다. antfu는 개발을 참 잘하는 것 같습니다. vite를 함께 개발하는 코어 개발자인데 evan you와 함께 요새 안만드는게 없는거 같아요. 제가 보고 베낀것은 절대 아닌데 컨셉이 유사한데 더 인기가 많네요 ㅋㅋ star수를 보면 아직까지 atomic-css, functional-css, utility-first 라는 컨셉 그리고 on-demand라고 하는 컨셉자체가 아직은 희귀해서 인기자체가 좀 없는 느낌이기는 합니다.  https://github.com/topics/atomic-css atomic-css 토픽에서 조금만 더 스크롤 해보시면 제 라이브러리가 보입니다. 하하!!    https://developer-1px.github.io/adorable-css/ 주문형 Atomic-css라는 컨셉으로 현업에서 잘 활용하고 있고 몇몇 동료 개발자분들이 좋다고 인정을 해주고 실제 본인 현업에서도 써주시는 분들이 계십니다. (끝은 결국 홍보!! 많이 많이 이용해보고 의견 남겨주세요! +_+) 제 걸 쓰지 않더라도 컨셉은 같으며 저는 CSS의 한 축이 될거라고 믿고 있기에 꼭 알려드리고 싶었습니다.  끝내기 전에... 아... 뒤로 갈수록 좀 대충 쓰고 있는 기분입니다. PostCSS나 Bootstrap으로 부터 이어저 오는 프레임워크나 mui, ant design과 같은 컴포넌트 라이브러리와 디자인 시스템, Atomic Design Pattern과 같은 얘기들도 실었어야 했지만 일단 새로운 포스트를 작성하지 않은지 1주일이 되었기에 자신과의 약속을 지키고자 조금 성에 안 차는 완성도이지만 공개를 해봅니다. 완성도가 낮다기 보다는 1부라고 생각해주세요. 못다한 이야기들은 2부를 통해서 채워보도록 하곘습니다! :) 요약 너무 길었던 내용이라 중요한 내용만 복습해보곘습니다. CSS는 문서에서 서식과 컨텐츠를 분리하기 위해서 만들어졌다. 컨텐츠를 제공하는 솔루션을 기반으로 CSS를 커스텀하게 방식으로 발전했다. 그로인해 시멘틱 웹과 복잡한 Selector를 사용하는 방식으로 진화했다. CSS의 규모가 커져가는데 CSS의 발전은 늦어지자 CSS의 문법을 확장시키고자하는 방향으로 발전함. 프론트엔드는 백엔드는 데이터만 처리하는 웹 애플리케이션 방식으로 발전했다. 문서를 만드는 방법으로 애플리케이션을 만들어야 하는 과도기를 겪어갔다. Flexbox라는 애플리케이션을 위한 스펙들이 활성화되기 시작함. 컴포넌트를 기반으로 하는 프레임워크가 보편화되면서 CSS의 구조상의 문제가 드러남. Selector는 단순화되는 방향으로 진화하며 컴포넌트 개발방식에 맞는 CSS설계가 주요아젠다가됨. CSS 방법론은 BEM이 살아남았으나 CSS 구조의 한계를 느끼고 JS로 CSS의 부족함을 메꾸려는 방향으로 발전함. - PostCSS, CSSModules, CSS in JS CSS 자체적으로는 Utiliy-First라는 TailwindCSS가 새로운 대안으로 떠오름. IE11의 방파제가 무너지면서 Grid Layout이나 CSS Variable과 같은 CSS의 새로운 스펙들의 사용빈도가 높아지고 있음. 현재는 CSS in JS, Atomic CSS 2가지 갈래의 방향으로 프레임워크와 번들 생태계와 함께 진화중 끝으로... 분명 이번 글의 목적은  &quot;CSS의 역사를 이해해서 CSS 과도기 시기에 확대 재생산되었던 옛날 자료와 최신의 트렌드를 구분할 수 있고 본인의 상황에 맞는 도구를 찾기 위함&quot;  이라고 작성을 했지만 목적에 충실한 글이었나는 돌이켜 보게 되네요.  그러한 글을 쓰기 위해서 일단 역사자료를 찾아서 연대별로 정리해 봤는데 참고삼아 CSS에는 이런것들이 있구나 하고 아셨으면 좋겠습니다.  하는 정도의 포스팅이 된것 같네요. 중복된 내용이더라도 조금 더 빌드업이 될 수 있는 형태로 정리해서  CSS의 역사편  완결이 날 수 있도록 조금씩 더 정리해볼 생각입니다. 언제인지는 몰라도 일단 다른 포스팅을 좀 쓰면서 시간을 벌면서 차츰차츰 정리해보려고 합니다. [참고자료] 🎨 CSS Ecosystem CSS Language &amp; Interaction [1996] CSS1  https://www.w3.org/TR/REC-CSS1/ https://www.w3.org/TR/CSS/ CSS Preprocessors [2006] Sass  https://sass-lang.com/ http://lesscss.org/ https://sass-lang.com/ http://stylus-lang.com/ CSS Methodologies [2009] OOCSS  http://oocss.org/ http://smacss.com/ http://getbem.com/ https://acss.io/ https://itcss.io/ CSS Frameworks [2006] YUI  https://yui.github.io/yui2/ https://getbootstrap.com/ https://foundation.zurb.com/ https://purecss.io/ https://semantic-ui.com/ https://materializecss.com/ https://tachyons.io/ https://milligram.io/ https://bulma.io/ https://getuikit.com/ https://tailwindcss.com/ JS Tools &amp; CSS-in-JS [2013] PostCSS  https://postcss.org/ https://autoprefixer.github.io/ https://browserl.ist/ https://cssinjs.org/ https://github.com/css-modules/css-modules https://www.styled-components.com/ https://emotion.sh/ 나: &quot;Svelte로 오세요 +_+&quot; 나: &quot;...Svelte ㅠㅠ&quot;  나: &quot;여러분 혹시 vite는 쓰시나요?&quot; 나: &quot;rxjs 아시는분?&quot; 제가 쓰고 있는 아주 좋고 힙한 기술 스택 4가지  를 소개해보려고 합니다. 프롤로그 어짜다보니 주류 기술 스택을 안하고 있는 프론트엔드 개발자가 되었습니다. 좋은 말로는 선구자이고 나쁜 말로는 비주류일수 있겠네요. 아무도 묻지 않았지만 아무도 쓰고 있지 않길래 나온 지 좀 지났는데 왜 이걸 아무도 안 쓰고 있지? 왜 나만 쓰고 있지? 하는 마음에 글을 쓰게 됐습니다. 저는 정말 정말 좋다고 생각하기에 비주류 기술의 점유율을 조금 더 높여보고자 홍보 겸 소개를 합니다. 이 참에 이 기술과 저에 대한 아이덴티티를 확고히 가져가보려고 합니다. 이번 글은  아주아주 개인적이고 주관적인 입장에서 쓰는 글 이니 조금 더 편한 말투로 작성을 해볼까 합니다.   프로필도 바꿨습니다! 좋아하는 기술 스택이 바뀌면 어떡하지? (-_- 그땐 또 바꾸면 되지...) Svelte  https://svelte.dev/   첫 번째는 바로 Svelte입니다. 제가 프레임워크를 얘기할 때마다 뭐가 좋냐고 물어보면 항상 1번으로 대답하는 기술입니다.  Svelte 너무 좋습니다! 왜 Svelte가 좋은가? 일단 기본적으로 React나 Vue나 다른 프레임워크에 비해서  압도적인 성능 을 자랑합니다.     일단 방식이 다릅니다. 기존의 Framework는 다 라이브러리지만 Svelte는  컴파일러 입니다. 라이브러리와 컴파일러는 어떻게 다른거죠? 이거를 궁금해하시는 분이 있어서 좀 자세히 설명을 좀 드리자면 기존의 프레임워크들을 javascript의 라이브러리 형태를 하고 있기 때문에 javascript의 문법과 함수를 기본적으로 사용하고 있습니다. 그래서 hook이라던가 reactive나 class와 같은 javascript 체계안에서의 boilerplate가 존재하게 됩니다. 이러한 부분들이 프레임워크를 배우는데 러닝커브를 만드는 원인이 됩니다.  하지만 Svelte는 컴파일러입니다. 그래서 독자적인 언어를 가지고 있고 이 언어를 컴파일을 해서 최적화된 javascript의 결과물을 만들어냅니다. 그러면 Svelte도 새로운 문법을 배워야 하는거 아닌가요? 라고 반문할 수 있지만 그  새로운 문법은 바로 프론트엔드의 근본인 HTML, CSS, JS로 되어 있습니다.   Vue3입니다. Svelte에서는 이렇게만 작성을 하시면 됩니다. 단순한 코드라 큰 차이가 없어 보일 수 있지만  javascript만 알면 일단 바로 svelte를 해 볼 수 있다는 것 은 엄청 큰 장점입니다. 워낙에 직관적이고 러닝커브가 작고 코드 타이핑이 작다는 것도 장점입니다. HTML의 상위호환이기 때문에 퍼블리셔가 작업한 .html파일이나 .svg파일을 그냥 .svelte 확장자만 바꿔도 동작한다는 점에서도 아주 좋습니다. 처음 HTML+CSS만 배우신 분들도 svelte를 어느정도 할 수 있다(?)라는 말이 되기도 합니다. 그밖에 더 자세한 문법비교를 보고 싶다면 아래 링크를 확인해보세요 :)  React vs Vue vs Svelte 코드 비교 https://betterprogramming.pub/react-vue-and-svelte-templates-side-by-side-4aa52cf3cf2 이게 어떻게 돌아갈 수 있는거죠? 생각을 해봅시다. 위와 같은 counter를 만드는 코드가 가장 빠르기 위해서는 엘리먼트를 직접 선택해서 이벤트를 연결하고 값이 바뀌면 그부분만 다시 그려주는 바닐라스크립트가 가장 빠를겁니다. Svelte는 이렇게 필요한곳에 이벤트 핸들러와 값이 바뀌는 곳에만 적용되어 있는 $$invalidate의 처리로 인해서  모든 컴포넌트를 전부 가상으로 전부 렌더링해서 다른 점을 비교해서 업데이트하는 Virtual DOM 과는 다르게  특정 이벤트에만 특정한 값이 변경되었을때 특정한 엘리먼트만 변경될수 있도록 미리 계산된 바닐라 스크립트와 비슷한 최적화된 코드가 작성 이 됩니다.   그렇기 때문에 덩치가 크고 데이터 변경이 빈번할수록  전체를 다시 계산해야하는 React에 비해서 Svelte가 훨씬 빠릅니다. 이렇게 바꾸면 React보다 더 커지는 거 아닌가요? 이미 Svelte는 컴파일을 했기 때문에 라이브러리 코드가 거의 없습니다. 하지만 React와 Vue의 경우에는 기본적인 라이브러리가 있어야만 해당 코드를 실행할 수 있습니다. 프로그램의 크기가 작아도 최소한의 React(=140kb)혹은 Vue3(=45kb)의 코드가 올라가야 됨을 의미합니다.  Svelte는 고작 3kb입니다. Svelte는 라이브러리가 사라지는 프레임워크라는 말은 여기에서 나온것입니다. Svelte는 CSS in JS는 안되지 않나요? React가 쓰는 jsx의 경우 style태그를 지원하지 않습니다. 그러다보니 webpack 번들을 이용해서 CSS Module import라는 방식을 처음에는 사용했습니다. 이 방식에 대한 불편을 많이 얘기했죠. 컴포너트와 css가 항상 분리되어 작성을 해야 했으니까요. 그러한 단점을 극복하고자 나온것들이 CSS in JS입니다. 물론 스크립트로 동적으로 css를 짤 수 있다는 점은 CSS in JS의 장점이긴 합니다. 물론 러닝커브역시 존재하겠죠. 그리고 CSS in JS는 동적으로 생성하고 라이브러리가 필요하므로 번들이 커지고 초기 로딩이 필요하다는 단점 역시 존재합니다.  Svelte는  &lt;style&gt;  태그에서 배운대로 CSS만 입력을 하면 자동으로 CSS Module의 기능 을 해줍니다. CSS in JS와 같은 스크립트로 만드는 기능은 없지만 sass, less, stylus와 같은 pre-process를 빌드타임에 제공을 하고 있습니다. 그리고  JS와 css variable을 연동하는 기능 을 제공해주기때문에 CSS와 JS를 연동하기 위한 필요한 부분들  러닝커브 없이 바로 사용 할 수 있습니다. 그밖에... 일단 문서가 너무 잘 되어 있습니다. 러닝커브가 낮기 때문에 문서가 쉬울 수 있다고 생각합니다. 또한 기본적으로 recoil과 같은 상태관리를 제공합니다. 이 상태관리는 굉장히 유연하기 때문에 다른 상태관리 라이브러리를 연동하는 것이 어렵지 않습니다. Redux, Mobx, React-Query 모두 Svelte와 호환이 가능하며 특히  제가 이 글 후반부에 소개할 rxjs와 엄청 궁합이 좋습니다. 상태관리는 얘기가 길어지니까 Svelte를 깊게 파게 되면 설명을 또 드릴 수 있을 것 같아요. 입문도 쉽지만 깊게 파면 할 수 있는 것이 많은 프레임워크기 이기도 합니다. Easy to Learn Easy to Master! 단점을 말해주세요! 신생이고 아직 커뮤니티가 부족하다고 하죠. 결국 취업에는 아직 유리하지 않은 언어다... 입니다.  사실 이 점 때문에 다시 이 글을 쓰게 되었습니다. 여러분 우리 Svelte 좀 많이 써봐주세요.  정말 좋습니다. Svelte 정말 좋고요 제가 현업에서 아주 잘 사용하고 있습니다. 사내에서도 많은 전도를 하고 있습니다. 그래서 Svelte 정말 좋으니까 제가 좋다는 말만 계속 더 하면서 다른 걸로 좀 넘어가겠습니다. Vite  https://vitejs.dev/   힙하고 좋은 두 번째!  Vite 입니다. Svelte는 React를 대체하기 힘들기 때문에 그럴수 있다고 생각을 합니다. 하지만  Webpack대신 Vite 를 쓴다는 것은 어렵지도 않고 여러모로 이득이 많은데 생각보다 Vite의 인지도가 낮다는 점에서 놀라웠습니다. 원래 Vite는 제가 프론트엔드 역사 시리즈 형태를 쓰는 글이 인기가 좋아서 다음 시리즈인 번들러에 대한 얘기를 쓰면서 소개를 할 생각이었습니다만 번들러를 쓰려고 보니 자료 조사할게 너무 많아서 미리보기 차원에서 일단 vite만 먼저 소개를 드려봅니다.  미리보는 번들러의 역사 https://gruntjs.com/ https://webpack.js.org/ https://gulpjs.com/ https://rollupjs.org/ https://yarnpkg.com/ https://parceljs.org/ https://esbuild.github.io/ https://www.snowpack.dev/ https://swc.rs/ https://vitejs.dev/ Vite는 Vue용으로 쓰는거 아닌가요? 아닙니다. Vue용으로 만들려고 했지만 보편적인 빌드도구가 될 수 있다는 것을 알고서는 Vue뿐만 아니라 React, Svelte, Preact, Lit 등 여러방면으로 생태계를 확장하고 있는 도구입니다. 사실  Vite 는 엄밀히 말하면 webpack과는 조금 결이 드립니다.  일단 번들러가 아니에요.  Vite는  esbuild와 rollup을 메인번들러 로 쓰고 있고  HMR 과 DevServer, create-app, plugin등의 프로젝트  세팅과 빌드도구의 생태계 를 만들고 있는 도구입니다. 설명을 해야할게 너무 많은데... 짧게 요약을 하자면  번들러는 잘게 쪼개진 자바스크립트의 파일을 하나의 파일로 만드는 과정입니다. 자바스크립트는 원래 모듈이 없었습니다. 그래서 여러 파일로 하나의 프로그림을 만들기가 어려웠습니다. 그래서 덩치가 커지지 어려웠죠. 그래서 최근에 Native 모듈이 생겼습니다. 하지만 그럼에도 모듈방식으로 쓰지 않는 이유는 파일이 쪼개어져 있으면 서버에 요청을 여러번 해야 합니다. 브라우저와 서버의 통신은 데이터의 양을 제외하고 왔다 갔다의 최소한의 시간이라는게 존재하기 때문에 파일을 쪼개어서 내려받으면 하나의 파일을 받는것 보다 무조건 오래 걸립니다. 그러니 여전히 로컬에서 하나의 파일로 만들어줄 방법이 필요합니다. 이 과정을 해주는 것이 바로 번들러입니다.  최초로 가장 유명해진 번들러가 바로 웹팩입니다. 지금도 CRA로 React를 설치하면 웹팩으로 되어있죠. 웹팩의 config가 불편해서 no-config컨셉으로 parcel이 만들어졌고 쓰이지 않는 스크립트를 추려내서 더 적은 크기로 만드는 Tree-Shaking을 도입한 Rollup까지 여러 번들러들이 생겼습니다. 결정적으로 이 번들러들은 여러파일을 하나로 만들어줘야 하나보니 속도가 느려지게 됩니다. 덩치가 커질수록 내가 수정하는 양은 적은데 그 바뀔때마다 다시 번들링을 해서 파일을 만들어야 하니 답답해지는 거죠. 그래서 2가지의 해법이 등장합니다. 하나는 javascript가 아니라 더 빠른 언어를 이용해서 번들러를 만드는 방식입니다. 어차피 번들러는 로컬에서 돌리는 프로그램이니까 굳이 javascript일 필요가 없었습니다. 그래서 go로 만들어진 빌드 툴은 javascipt로 만들어진 webpack에 비해서 무려 100배나 빠릅니다.  두번째는 개발을 하다보면 분명히 일부만 수정을 할텐데 매번 번들링을 하는 것은 비효율적이니 한번에 전체를 번들링하는 것이 아니라 개발할때는 각 파일을 나눠서 빌드하고 파일이 수정되면 그 파일만 다시 컴파일을 해서 번들에 포함시키는 방식을 통해서 개발할때는 esbuild로 프로덕션으로 내보낼때에만 webpack으로 새로 빌드를 하자는 방식인 snowpack이 등장을 하게 됩니다. Vue를 만든 Evan you는 이 snowpack을 보고 이 방식으로 Vue를 컴파일하고 개발하는 도구를 만들어야 겠다고 생각을 하고 snowpack을 벤치마킹해서 자신만의 빌드도구를 만들게 됩니다. 메인 번들러는 webpack이 아니라 rollup을 택하고 snowpack이 가지고 있던 단점들을 극복하고 vite 생태계를 빨리 구축하면서 snowpack을 추월합니다. 그래서 vite로 React를 하시게 되면 개발할때는 빠른 속도로 수정된것만 반영해서 빌드나 개발속도가 엄청 올라간다는 것을 느낄 수가 있습니다. vite역시 webpack에서 말하는 코드 스플릿이나 청크같이 기능을 제공하며 rollup 기반이다 보니 필요한 플러그인들을 거의 다 있으며 webpack보다도 config하기가 쉽습니다. Vite써도 되는건가요? 어렵지는 않나요? 회사라면 아직 vite가 여물지 않다고 생각할수도 있고 안쓸 이유가 있습니다. 그런데 그냥 React를 배우시고 계시는 거라면 굳이 속도가 느린 webpack으로 쓸 이유가 없잖아요? 어차피 포트폴리오 인데... 터미널을 열고 다음과 같이 한번 쳐보세요.  npm init vite 그리고 더 배우는거 없습니다. (물론 있지만 일단은 없습니다. webpack config 안 건드시잖아요?)  진짜 cra대신 한번만 써보세요. 다른 세상을 만나게 될겁니다. 제가 좋아하는 Svelte는 rollup으로 그리고 Snowpack으로 그리고 지금은 vite가 메인 번들러가 되었습니다. Svelte와 vite의 궁합은 아주 좋습니다.! Rxjs  https://rxjs.dev/   세 번째는 바로 rxjs입니다! rxjs도 정말 좋습니다. Svelte의 경우는 Redux와 같이 메인 상태관리 라이브러리가 없습니다. 물론 요새는 Redux는 그렇게 인기가 많지는 않습니다만 그것은 Redux가 복잡한 문법체계를 가지고 있기 때문이지 상태관리가 필요없다는 얘기는 아닙니다. Svelte로 대형 프로젝트를 진행하기 위해서는 Svelte가 기본적으로 제공하는 Store만으로는 복잡한 상태관리를 하기 힘듭니다. Svelte의 Store는 상태관리와 Svelte를 연결해주는 징검다리이지 상태관리 라이브러리는 아니니까요. Redux는 별로인걸 알겠고 Vuex는 Redux를 따라한것이니 저 멀리 눈을 돌려 Angualr세상을 보니 Angaulr의 경우에는 rxjs를 이용한  NgRx  라는 상태관리 라이브러리를 가지고 있습니다. 여기서 상태관리와 반응형의 핵심이 바로 이 rxjs였죠. Svelte는 기본적으로 rxjs와 궁합이 좋습니다. rxjs를 만든 ben lesh가 svelte를 만든 rich harris에게 rxjs지원을 요청했고 성사가 되면서 프레임워크 레벨에서 rxjs를 지원합니다.  Rxjs와 Svelte의 아름다운 만남 https://twitter.com/benlesh/status/1179429245371719680 https://github.com/sveltejs/svelte/issues/2549 rxjs가 Svelte와 궁합이 좋은 것은 알겠는데 rxjs는 뭐하는거에요? rxjs는 함수형 프로그래밍의 끝판왕입니다. 혹시 지금 함수형 프로그래밍을 공부하고 있다면 도대체 함수형을 내가 뭐하려고 배우고 있지? 라고 생각이 드신다면 바로 rxjs를 하기위해서 함수형 프로그래밍을 배운다고해도 틀린 말이 아닙니다. javascript 함수형 프로그래밍의 끝에는 rxjs가 있습니다. 함수형 프로그래밍에 대한 여러 가지 개념들이 있고 여러 가지 방법들이 있는데 결국은 rxjs를 하기 위해서 함수형 프로그래밍을 한다고 보시면 될 것 같아요. 왜냐하면 조금 과장을 보태서 함수형 프로그램에서 나오는 모든 배우는 기술들의 최종적인 결과물이 rxjs입니다. 반응형 프로그래밍과 함수형 프로그래밍의 개념들이 다 섞여 있기 때문에 rxjs를 하시면 좋습니다. 물론 이렇게 단편적으로 설명을 드려도 와닿지 못할거 알고 있습니다. 그래서 제가 함수형 프로그래밍에 대한 어떤 시리즈를 준비를 했던 것이었고( 지금은 안쓰고 있지만 ) 간단한 예를 하나 들어보겠습니다. 요구사항: 이름으로 프로필을 검색하는 자동완성을 만들려고 합니다.  키 입력을 받을 때마다 프로필을 검색한다. 과도한 서버요청을 막기 위해서 0.3초내에 연속된 키입력은 skip하고 키입력 후 0.3초가 지나야 서버에 요청한다. 입력내용이 같으면 중복 요청을 하지 않는다. 서버에서 실패가 발생하면 같은 API로 재시도를 한다. 만약 재시도가 횟수가 3번을 넘어가면 에러 표기를 한다. 그 안에 성공하면 다시 초기화 한다. Rxjs로 작성을 하면 이런 코드형태가 만들어집니다. https://tech.kakao.com/2017/01/09/daummovie-rxjs/ NOTE: 일부러 옛날방식의 코드를 가지고 왔습니다.(rxjs 5이하) 지금(rxjs 7)은 문법이 pipe 방식으로 바뀌면서 훨씬 더 함수형 프로그래밍화 되었기 때문에 직관적으로 이해하기 어려울 수 있을거라 생각했습니다. 비동기계의 jQuery 라이브러리와 같습니다. 비동기를 마치 Array의 map, filter, reduce를 다루듯이 만질 수 있습니다. Promise나 async, await과는 전혀 다른 가치입니다.  핵심 20개 정도의 operator만 알고 있으면 비동기와 관련된 거의 대부분의 로직을 아주 쉽게 처리할 수 있는 기능을 제공합니다. 언젠가 이것도 시리즈 형태로 정리를 해볼 생각입니다. 그리고 제가 만든 rxjs기반으로 만든 Svelte 상태관리 역시 글로 소개시켜드릴 날이 왔으면 좋겠습니다.  https://github.com/developer-1px/adorable AdorableCSS  https://developer-1px.github.io/adorable-css/ 마지막으로 CSS를 다루는 기술! 바로 제가 팔고 있는 그거!  AdorableCSS 입니다.   R apid  O n- D emand  A  TailwindCSS 홍보글 를 보고선 설득당해서 한번 TailwindCSS를 시작했다가 느껴진 단점들로 인해서 유사 컨셉의 보다 좋은 방식으로 만든 것이 이 AdorableCSS입니다. 자세한 소개는 if(kakao)에서 제가 소개한 적이 있습니다. https://if.kakao.com/session/89 원래 이제 홈페이지를 리모델링을 하고 문서를 만들고 나서 본격적으로 블로그에 글을 쓰려고 했지만 일단 패키지로 먼저 소개를 올립니다. 문서를 빨리 만들어볼 생각입니다. 정말 좋은 기술입니다. 일단 css를 작성을 하는 것 자체가 엄청 피곤한 일이거든요. css를 사실 관리하기가 어렵습니다. 이것도 제가 반복해서 드리는 얘기중에 하나인데 요약을 하자면, 웹은 문서를 공유하기 위해서 만들어졌다.  CSS는 문서에서 서식와 컨텐츠를 분리하기 위해 만들어졌다. 웹이 발전에서 문서에서 어플리케이션이 되었다. CSS는 늦게 발전해서 그동안 문서 서식을 만드는 방식으로 어플리케이션 디자인을 만들어 내야 했다. CSS 2.1 나중에 어플리케이션을 만드는 CSS3가 나왔지만 CSS의 구조적인 부분은 수정하지 못했다. 그래서 지금의 CSS는 어플리케이션 만드는데는 썩 좋지 않다. 그 해법의 2가지 축이 Atomic CSS와 CSS in JS이다. CSS에서 가장 피곤한 부분은 이름짓기 입니다. 이름을 지어야만 서식을 적용할수가 있죠. 내가 bold 하나만 적용을 하고 싶어도  .nav__title { font-weight:bold} 와 같이 이름을 반드시 지어야 하는 문제가 생깁니다. inline으로 그냥 쓰면 편하겠지만 inline style은 굉장히 한계가 많습니다. 그래서 inline하게 쓰면서도 inline-style의 한계점을 극복하는 방식으로 만들어진 프레임워크입니다. ... 얘기가 길어질것 같아서 AdorableCSS는 제가 꼭 문서화를 마무리해서 좋은 설명으로 한번 더 찾아뵙겠습니다. 끝으로.. 제가 좋다고 생각하는 것들을 모아두고보니 세상 힙해졌네요. Svelte를 시작하고 나서 생태계를 맞추다보니 여기까지 오게 되었습니다. 제가 봤을 때는 정말 다 좋다고 생각하는 것들입니다. 뭐 아직은 주류는 아니다. 인정할 수 있습니다. 😢 그것은 최근에 나왔기 때문에 그렇겠죠. 아직 검증이 필요한 시간일 수도 있습니다. 이미 React와 Webpack, Sass, Styled-Component로 만들어진 것들이 더 많아서 주류를 택하는 개발자들이 더 많아질거라고 생각합니다.  그래서 추천하지만 추천을 못하는 이유도 있습니다. 그냥 제가 좋아하니까 한번 봐달라 그 애기 드리고 싶었습니다.  &quot;정말 그냥 한번 봐달라~ 너무 좋은 기술이니까&quot;  홍보를 하고 싶었어요. 이게 홍보를 해야 될 만큼 이렇게 뭔가 써봐주세요라고 해야 될 만한 기술들이 아닌 느낌인데 괜히 그렇게 되게 되네요. 😅 왜냐하면 사실 현업에서 이걸 쓰고 있으면서 후임 걱정이 솔직히 되긴 합니다. 그래서 조금 더 내가 쓰는 기술이 완전 주류까지는 안 바래도 3대장시절 angaulr나 vue정도급만 되어도 좋지 않을까 하는 생각에 이렇게 글을 한번 남겨 봅니다. 😚 혹시나 저와 비슷한 기술 스택을 가지고 계신분들 계시다면 댓글 달아주시면 감사하겠습니다. 혹시 해당 기술에 관심이 있으시다면 알려주세요. 최대한 알려드릴 수 있다면 알려드리고 싶습니다. 이번 글은 정말 주관적인 입장이 많이 들어간 글이기에 지금 대부분이 많이 사용하시는 React와 Webpack 그리고 Sass, Styled-Component를 말고도 이런 것들도 프론트엔드에 있구나... 정도로만 알게 되시는 걸로 도움이 되었으면 좋겠습니다. 많이 사랑해주세요(?) 감사합니다. ❤️ 오늘도 좋은 글 읽고 많이 배워갑니다!! 혹시 풀스택 개발자에 대해서 어떻게 생각하시나요?? 프론트도 재밌고 백엔드도 재밌는데 둘다 하려고 하니 T자형 개발자가 되기 힘들고, 또 &quot;풀스택개발자는 상상속 유니콘이다&quot; 라는 말도 있어서 어떻게 생각하시는지 궁금합니다!! 오늘도 좋은 소재를 공유해주신 분들께 너무 너무 감사하다는 인사를 먼저 드립니다. 프롤로그 이번에는 풀스택 개발자에 대해 한번 얘기를 해보려고 합니다. 명확한 실체없이 떠도는 용어인만큼 저마다의 해석이 다릅니다. 그러다 보니 상당히 많이 변질된 용어이기도하고 사람들이 환상을 가지고 있는 용어이기도 합니다. 이번 글에서는 현업의 프론트엔드 개발자의 시각에서  풀스택 개발자가 무엇인지  그리고  풀스택이 어떠한 의미를 가지는 지 에 대해 이야기를 드릴까 합니다. 이 글 또한 또하나의 풀스택 개발자에 대한 해석과 설명일테지만 프론트엔드 개발자이기 이전에 스스로를 풀 스택 개발자라고 생각했었기에 이 글이 풀스택 개발자에 대한 이해를 도울 수 있기를 바랍니다. 풀스택 개발자란 무엇일까요? 구글에게 물어봤습니다. 우선 풀스택 개발자에 대한 사전적인 의미를 생각해봅니다. 그러기 위해서는 구글에  &#39;full-stack developer&#39; 를 한번 검색해보았습니다. 클라이언트 및 서버 사이드 코드를 학습하고 웹 사이트가 작동하도록 해주는 모든 기술군에 대해 이해하고 있는 개발자입니다. 풀스택 개발자란 GUI 프론트엔드부터 데이터베이스 백엔드에 이르는 모든 소프트웨어 스택을 이해하는 개발자를 말한다. 풀스택 개발자는 데이터베이스, 서버, 시스템 엔지니어링 및 클라이언트의 모든 작업을 처리할 수 있는 엔지니어입니다. 풀스택 개발자, 폴리글랏 개발자 모두 하나의 범주를 넘어 다양한 환경 및 플랫폼을 이해하고 사용되는 대부분의 언어와 지식을 갖춘 인재를 얘기합니다. ... 점점 거대해져 가는 풀스택 개발자의 의미... 🤯 풀스택 개발자라는 말을 언제부터 쓰고 있었을까? 지금의 풀스택 개발자가 정의가 정확하게는 뭔지는 모르겠지만 이 말은 도체대 어디서 부터 생겨난 말일까요?    출처:  https://trends.google.co.kr/trends/explore?date=all&amp;q=%2Fg%2F11cn3vn3w2  🔥 2014년도를 기점으로 해서 풀스택 개발자의 용어가 크게 관심도가 증가 한다는 것을 알 수 있습니다. 왜 저 시기부터 일까요? (눈치 채신 분들도 있겠죠?) 사실 웹에 오랫동안 종사한 사람들은  풀스택의 의미 에 대해서 정확하게 알고 있습니다.   당신은 풀스택 개발자입니까?  라는 말은 사실 다음과 같습니다.  &quot;혼자서 ... 웹 사이트(서비스) 만들 줄 아세요? 😎&quot; 2014년의 이유, 그 이전의 웹의 역사 웹 개발자 웹은  문서를 가상의 공간에서 공유하기 위해서  태어났습니다. 오프라인에 있던 문서를 가상의 공간으로 링크로 연결이 되는 공간을 만들어냈습니다.  이후 사용자의 정보를 전달하고 그 내용에 따라 다른 형태의 페이지를 동적으로 만들어내는 방법이 개발이 됩니다. 예컨데 방문자수에 따라 다르게 표기가되는 카운터같은 것처럼 말이죠. 그 과정이 발전을 하게 되면서 사용자로부터 스스로 문서를 만들어내고 보관할 수 있게 됩니다. 방명록이라고 하는 것들이 추후 게시판, 포럼과 같은 형식으로 발전을 하게 되죠. 웹 개발자 라고 불렀습니다. 웹 디자이너 웹은 문서였기에 이러한 서비스가 발전하기 이전에  잘 읽히게 하기 위해서 잘 꾸며져 있을 필요 가 있었습니다. 문서이기도 했고 장식이기도 했고 카달로그의 역할도 복합적인 의미를 가지고 있었죠. 이러한 문서를 돋보이게 만들 수 있는 하는 사람들을 우리는  웹 디자이너 라고 불렀습니다. 웹문서가 홈페이지로 업데이트가 되면서 회사의 정보를 표현하거나 개인을 표현하는 수단으로 발전을 했죠. 하지만 게시판이나 포럼등 기능들과 디자인이 결합할 필요가 생기면서 둘다 어느정도 할 수 있는 역할이 필요했습니다. 때로은 웹 개발자가 웹 디자인을 적용해야 했고 웹 디자이너가 웹 개발을 하기도 했죠. 이제는  웹 사이트를 하나 만들기 위해서 는  화면을 다루는 웹 디자인 영역 과  데이터를 다루는 웹 개발  영역을 둘 다 할 줄 알아야 했습니다. 하지만 이때는  웹 사이트가 어느 정도 정형화 가 되어 있었기에  웹 디자이너는 솔루션을 이용해서 디자인만 적용  하거나  웹 개발자는 디자인 테마를 사서 적용 후 배포  하는 식으로도 가능했었기에  충분히 혼자서도 웹 사이트를 만드는 것은 어렵지 않았던 시기 입니다. 디자인도 할 수있고 웹 개발도 할 수 있었던 사람을 당시에는  웹 마스터 라고 부르던 시절이 있었습니다.  프론트엔드의 등장, 2014   출처:  https://github.com/ManzDev/frontend-evolution 하지만 2010년을 기점으로 구글을 앞세운 웹 서비스는 전혀 다른 방향으로 흘러갑니다. 웹은 이제  문서라는 개념을 완전히 탈피를 하고 하나의 어플리케이션과 같은 역할을 수행할 수 있게 됩니다.   그리고 페이스북의  2013년 React의 등장 으로 웹 개발은 기존과는 다른 새로운 국면으로 흘러가게 됩니다. 프론트엔드 역사와 미래, 업무 분야 ... 그리고 잘하는 프론트엔드 개발자란? https://velog.io/@teo/frontend 이렇게 웹 서비스의 개념이 커지고 프론트엔드라는 생태계와 분야가 만들어지면서  기존의 많은 웹 개발자에게 프론트엔드라는 역할을 같이하기를  원하게 됩니다. 그리고 기존의 웹 개발은 프론트엔드에 대치되는  백엔드 라고 불리게 됩니다.  이때부터 기존의 웹 개발자이면서 새로운 생태계인 프론트엔드를 같이 할 수 있는 개발자를 찾기 시작합니다! 이른바  백엔드와 프론트엔드를 모두 할 줄 아는 &#39;풀스택 개발자&#39; 를 말이죠. 지금이야 풀스택 개발자에게 자기멋대로 의미부여가 확장이 되고 있지만  풀스택 개발자의 시초는 이 변화된 웹 생태계를 다 이해하고 있는 사람 을 말하는 거였습니다. 왜 유독 웹에서 풀스택을 찾을까? 무릇 웹 개발자는 프론트엔드, 백엔드 가리지 않고 할 줄 알아야 되는거 아닐까요? 다른 분야에 비해 왜 유독 웹에서 풀 스택을 많이 찾을까요? 그것은 웹 서비스의 특성 때문입니다. 웹은  다른 UI 어플리케이션 분야와 달리 클라이언트만으로 무엇을 하기에는 부족 합니다. 일단 웹을 사용하기 위해서는  브라우저는 필수적인 요소 입니다. 브라우저를 통해서만 웹의 결과물들을 볼 수가 있죠. 그렇기에 브라우저를 잘 다룰줄 안다는 것은 웹 개발에서 아주 중요한 역할을 하고 있습니다. 이  브라우저를 중심으로 개발을 하는 분야가 바로 프론트엔드 이죠. 백엔드 개발자들이 웹 밖에서 데이터를 다루더라도 결국 웹 서비스가 제공이 되는 것은 브라우저 안이기 때문에 브라우저를 다루는 프론트엔드를 하지 않을 수가 업습니다. 프론트엔드만 있어서 브라우저만 잘 다룬다면 어떨까요?  브라우저는 여러가지 보안정책으로 인해서 컴퓨터의 OS리소스를 거의 사용할 수가 없습니다.  그러니 중간과정을 아무리 잘 만들어도 최종적으로 데이터를 보관을 할 수 없는 어플리케이션은 데모수준밖에 되지 않습니다. 그러기에 브라우저에서 없는 기능은 반드시  백엔드의 도움을 받아야만 서비스를 완성 할 수 있습니다. 그렇기 때문에 가치있는 서비스를 만들기 위해서는 반드시 백엔드를 통한 데이터 조작이 필요합니다. 웹은 초창기 시절부터  브라우저와 DB를 둘 다 다루는 것들이 당연 했으니 전통적인 시각에서  웹 개발자는 원래 풀스택 이었고 무릇  웹 개발자라면 둘다 할 줄 알아야 한다 고 했습니다. 초창기 페이스북의 모든 개발자들은 스스로들을 풀스택 개발자라고 말했지요. 하지만 과연 지금도 그럴 수 있을까요? https://www.meme-arsenal.com/en/create/meme/3395950 🦄 풀스택은 왜 유니콘이 되었을까? https://me.me/i/mirror-mirror-who-is-the-best-full-stack-web-developer-06a63f57eb1048ad85906a1d4c80d11d 웹 개발은 이제 더이상 1인 개발자의 세상이 아닙니다. 거대 웹 서비스들이 등장했고 세계 10권내의 서비스들이 존재합니다. 웹은 지난 10년동안 폭발적으로 성장을 하였습니다. 한 명이 분명 여러분야에 뛰어날 수 있습니다. 하지만 거대한 기업 세계에서는 1명의 개발자가 투자할 수 있는 시간은 동일합니다. 둘 분야 모두 뛰어난 인재라면 연봉이 높을텐데 2명의 풀 스택 개발자를 뽑아서 각각의 분야에서 0.5의 역할을 할거라면 그냥 프론트엔드, 백엔드 전문가 1명씩 뽑아서 일을 하는 면이 회사 입장에서 효율적이기 때문입니다. 이것은 서비스의 덩치가 커질수록 심화됩니다. 여러사람이 함께 일을 하게 되면 결국 특정 분야에 대해서는 누군가 보다 더 나은 전문가의 영역이 존재하게 됩니다. 할 줄 안다는 것과 그 분야의 전문가라는 것은 엄연히 다른 말입니다. 그러니 여러명의 유니콘으로 이루어진 팀을 만들려고 하는 것보다  좋은 협업능력을 가진 전문가집단 이 훨씬 더 훌륭할 수 있습니다.  하지만 여전히 높은 연봉을 주고서라도 풀 스택 개발자를 원하는 기업들이 존재합니다. 왜 그럴까요? 😎 왜 기업은 풀스택을 원할까? - 희망편 현대의 풀 스택 개발자는 최소한의 실행 가능한 제품, 즉 초기 고객을 만족시키고 지속적인 개발을 위한 피드백을 촉발할 수 있는 충분한 기능을 갖춘 애플리케이션을 스스로 구축할 수 있는 경험 많은  제너럴리스트 입니다.  여전히 몇몇 기업들은 고액의 연봉을 주고서라도 풀 스택 개발자를 희망하는 경우가 있습니다. 그들은 이 사람들이 프론트엔드와 백엔드의 두 분야 모두의 깊이있는 전문가는 아님을 알고 있습니다. 하지만  혼자서 초기 서비스를 만들어내고 협업을 해야하는 파이프라인을 이해하고 있는 전문가  입니다. 아직 서비스를 만들기도 전이라면  빠르게 아이디어를 검증해 볼 수 있는 전문가 가 필요합니다. 이들에게 깊은 전문성을 요구하는게 아닙니다.  협업에는 커뮤니케이션 비용이 발생합니다.  아이디어를 빠르게 검증해서 성공할 수 있는 방법을 찾기 위해  프로토타이핑을 빨리 해내는 것은 아주 중요한 스킬 입니다. 또한 스타트업에서는 초기 팀 빌딩이나 협업에 대한 경험이 부족합니다. 풀스택 개발자들은 여러 기술 전반에 걸친 폭넓은 경험적인 요소를 높이 평가받습니다.  풀스택 개발자는 백엔드, 프론트 엔드 및 디자인 팀과 협업할 수 있는 CTO와 같은 가장 좋은 위치를 차지합니다. 뿐만 아니라  IT기업이 아닌 곳에서는 풀스택 개발자가 더 유리할지도  모릅니다. 빅 테크기업과 같은 수준의 깊이를 요구하지 않더라도 기존의 아이디어를 적당히 서비스를 제공하는 것과  연결 만 시킬 수 있더라도 더 부가가치를 만들어 낼 수 있습니다. 이들에게 필요한 능력은 기술적인 깊이가 아니라  최소한의 애플리케이션을 만들어 내는 능력과 해당 비지니스 도메인에 대한 넓은 통찰력 입니다. 🤢 왜 기업은 풀스택을 원할까? - 절망편 &quot; 풀.스.택.  개발자시니까... 이것도 할 줄 아시죠? 이것도?&quot; 풀스택 개발자라는 용어가 주는 환상과 정해지지 않고 주관적인 해석으로 인해 이 글 초기에 봤듯이 이미 풀스택의 의미는 부풀려졌습니다. 그리고 이것을 악용하는 케이스도 늘어났습니다.  풀스택 개발자라는 직군이라는 핑계로 과도한 개발능력을 요구 합니다. 또한 풀스택의 기준이 주관적인 해석이 달려 있기 때문에 시각차도 존재합니다. 분명 풀스택이라고 해서 뽑았는데 분명 서비스를 만들어 낼 수는 있지만 할 줄 아는 분야가 너무 한정적일 수도 있습니다. 또는 인력이 없는 회사에서는  풀스택을 하면 좋지 않냐는 명목으로 한 개발자에게 여러가지 일을 시키기도  합니다. 그리고 여러가지 경험이 많고 이력이 많은 풀스택을 선호한다면서도 정작 풀스택 개발자에 대해서는 깊이가 없기 때문에 취업에서 불리해지는 경우도 생깁니다. 자칭 풀스택 개발자를 꺼리는 이유 https://twitter.com/ddialar/status/1396365919589441540 &quot;만능형이라는 말의 다른 이면은 어중간함입니다.&quot; 해본게 많지만 경험치가 낮은 풀스택 개발자들을 다른 실무에서 일을 하게 하려면 실제로 깊이가 모자란 경우가 많이 있습니다. 분명 한 것은 많은 것을 알겠는데 어느 하나 제대로 아는게 없는 경우가 생기게 됩니다. 앞서 말한 서비스의 규모가 이미 커져있고 전문가집단이 형성이 된 곳에 가면 이 현상은 더 두드러집니다.  이미 기준은 각 분야에서 잘하는 사람이 기준 이니까요. 경험치가 충분하지 못하다면 스스로를 풀스택이라고 칭하는 사람들은 신뢰하기가 어렵습니다. 대부분의 주니어 취업 상담의 얘기에서 공통적으로 하는 얘기가 있습니다. 이것도 해봤고 저것도 해봤고 해봤다고 전부 다 기록을 하게 되면 오히려 신뢰도를 잃게 된다고 말이죠. 분명 예전에는 웹 개발자는 풀스택 개발자를 지향을 했어야 했는데 이 산업이 커지다보니 풀스택을 담기에는 너무 커져버린게 아닌가 싶습니다. 마치 옛날에  레오나르도 다빈치 가 화가이자 조각가, 발명가, 건축가, 해부학자, 지리학자, 음악가였던 것 처럼요. 그때는 각 분야가 해놓은게 적었으니 한 사람이 수많은 역할을 수행할 수 있었지만 지금은 하나의 분야만 파고 들기에도 너무 알아야 할 것이 많아져버린 것이지요. 사실 잘하는 사람은 다 잘한다! &quot;저... 그게 아니라 레오나르도 다빈치는 진짜 천재 아닌가요? 2007년 네이처에서 선정한 인류역사를 바꾼 10인의 천재중 가장 창의성이 높은 사람인데요?&quot; 그렇습니다. 세상은 공평하지 않고  잘하는 사람은 사실 다 잘합니다. 풀스택이 유니콘이라고는 하지만 그것은 풀스택의 기준을 한없이 올려치기를 했기 때문이 아닐까요? 주변에 혼자서 웹 서비스를 만들어내고 DB를 다루고 화면을 다루고 디자인을 하면서  프론트와 백엔드의 지식을 넘나드는 사람들은 분명히 존재 합니다. 기술의 깊이가 전문가급은 아니더라도 비지니스에 대한 이해도가 높아서 스타트업을 성공시키기도 하고 프론트엔드에 전문가이면서도 필요한 백엔드 기술을 뚝딱뚝딱 잘 가져와서 스타트업에서 원하는 프로토타입을 만드는 경우도 있습니다. 백엔드의 전문가이지만 필요하면 UI를 가져와서 CMS나 백오피스를 만들어내는 개발자 역시 존재합니다. 회사에서는 분명 두 분야의 전문가가 아니라 하나의 직군과 전공을 택하고 한 분야의 전문가로 있지만  결국 개발의 본질은 같으니까요. 무엇을 풀스택이라고 부를 것인가? &quot;혼자서 웹서비스 만들 수 있습니다! 😎&quot; React를 이용해서 AWS를 통해 인프라 배포나 Auto Scale등의 구성은 하지 않고 express와 DB만 이용해서 서비스를 만들었다면 풀스택이라고 할 수 있을까?  React를 이용해서 React Native를 이용해서 앱 개발을 하면 앱 개발자라고 부를 수 있나? 이는 또하나의 풀스택일까? 워드프레스로 테마를 수정해서 웹사이트를 만들었다면 풀스택이라고 할 수 있을까? 혼자서 리눅스 서버를 이용해서 APM으로 게시판을 이용한 커뮤니티를 만들었다면 풀스택 개발자일까? Github의 pages를 이용해서 블로그를 만들었다면 풀스택이라고 할 수 있을까? DB없이 구글시트를 연동해서 설문결과를 저장하는 서비스를 만들었다면 풀스택이라고 할 수 있을까? 추상화된 좋은 서비스가 너무 많이 나오고 있다. 혼자서 웹 서비스를 만드는 방법은 너무나 다양합니다. 그리고 백엔드와 프론트엔드의 경계는 갈수록 희미해져가고 있습니다. 그러면서도 동시에 각 분야의 깊이는 점점 더 깊어지고 있습니다. 그런데 반대로 웹 서비스를 만드는 방법은 점점 더 쉬워지고 있습니다. 우리가 백엔드의 전문가가 아니더라도 클라우드 서비스를 이용해서 대용량 트래픽을 감당할 수 있는 서버를 쉽게 생성할 수 있습니다. javascript를 깊이 있게 몰라도 프레임워크를 통해서 복잡한 페이지도 쉽게 만들어 낼 수 있게 되었습니다. 디자인을 못해도 이미 잘 만들어진 UI Framework들이 존재합니다. 프론트엔드와 백엔드만이 아닙니다. 우리는 음성인식 기능과 같은 AI 기술도 얼마든지 사용할 수가 있습니다. 우리는 AI 전문가가 아니더라도 AI 서비스를 이용해서 서비스를 만들어내는 것은 어렵지 않은 일이 되었습니다. 하나의 전문성을 갖추는 것도 중요하지만  새로운 가치는 융합과 연결 에서 나옵니다. 프론트엔드와 백엔드가 하나라도 없으면 웹 서비스라고 할 수 없듯이 말입니다. 🔥 우리가 풀스택 개발자의 시각을 가져야 하는 이유 풀스택이 🦄유니콘이니 자칭 풀스택은 깊이가 없어서 꺼린다고는 하지만 어디까지나 그것은 회사나 특정 개인의 입장일뿐, 내가 어느 분야의  전문가가 되기 전까지는 웹 개발자라면 풀스택 개발자의 시각을 유지 하는 것은 충분히 필요한 일입니다. 웹 분야의 경우 산업이 발전하면서  경계가 희미해지고 프론트엔드와 백엔드의 스펙트럼이 계속 바뀌어 가고 있습니다.  특히  클라우드 서비스가 보편화 가 되면서 인프라나 스케일링 서버 운영에 대해서는 전혀 몰라도  React를 하면서 AWS를 이용해 Node로 express와 DB를 적당히 다루는 것  과 같은 프론트엔드 백엔드 기술을 같이 쓰는 것은 어렵지 않은 일이 되었습니다.  브라우저에서 다루지 못하는 데이터만 최소한으로 다루는 것 정도 는 이제 프론트엔드에서 하는 것으로 해서 인프라와 DB, 스켈일링을 클라우드화 해서 인프라 시스템만 백엔드가 하고  DB 스키마나 CRUD는 이제 프론트엔드에서  해야한다는 입장도 존재합니다.  Cloud Function와 Serverless 는 현재 진행형인 상태입니다. 웹 개발자라면 내가 한 분야의 전문가가 되거나 취향이 확고해 지기 전까지는 결국 다 해야 합니다. 어중간하게 둘 다 하는 것이 아니라  내 전문성을 살리되 적어도 관심사의 스펙트럼은 넓게 유지 를 해야 합니다. 일반적으로는 어느 한 분야의 전문가되는 식으로 커리어는 흘러가겠지만 결국  웹이라는 생태계 안에서 연결과 협업을 해야하는 일은 계속 해야하니까 요. 프론트엔드건 백엔드건 우리는  웹 개발자 잖아요. 끝으로...    당신은 어떤 풀스택 개발자인가요? https://www.pinterest.co.kr/pin/373728469062359052/ 풀스택의  Full 이 주는 어감 때문일까요? 언제부턴가 풀스택이라는 단어에 너무나 많은 의미를 투영하려고 하는 것 같습니다. 풀스택 개발자가 유니콘이 되어버린것은 개발자의 문제는 아닐지도 모르겠습니다. 하지만 사회는 점점 더  T자형 인재 를 원하고 있습니다.  하나의 전문성을 가지고 있으면서 또 넓게는 다양한 분야에 대한 지식을 아우르는  그러한 의미로 T라는 모양을 사용하고 있습니다.  우리는 어느 한분야의 전문가가 되어야겠지만 결국 웹 개발자라는 나아가 개발자라는 생태계안에서 계속 살아갈 것이고 누군가와 함께 일을 하게 될 것입니다.   &#39;풀스택이 고연봉을 주며 당연히 개발자가 지향해야 하는 곳이다.&#39; &#39;풀스택은 전문성이 없기 때문에 지향하면 안된다.&#39; &#39;풀스택이라는 것 자체가 잘못된것이다.&#39; 풀스택에 대한 얘기들은 많지만 대부분의 글들에는 풀스택에 대한 기준이 명확하지 않습니다. 제 역시 풀스택에 대해서 경계를 그을만한 명확한 정의를 내리기는 쉽지 않을것 같아요. 한가지 분명한 사실은 풀스택의 정의는 계속 변하고 있다는 사실입니다. 뿐만 아니라 웹도 변하고있고 개발 생태계도 계속 변하고 있습니다. 그렇기에 이 변화를 끊임없이 주시를 하면서  이 넓은 생태계가 어떻게 변하고 있는지 어떻게 이용하고 연결하고 협업할 수 있을지는 계속 확인하시기 바랍니다. 🔥 그리고 웹 개발자라면 아주 쉽고 간단한 방법이라도 본인만의 서비스를 완성 할 수 있는 방법을 공부해봅시다. 풀스택 개발자의 타이틀을 따기 위함이 아닙니다.  조그맣게 여러 서비스들을 연결하여 한 사이클을 완성을 할 수 있다는 것은 개발자의 시각을 굉장히 넓혀줍니다.  그리고 혹시 아나요? 작은 아이디어를 구현한 그 서비스가 대박을 칠런지도? 😘 끝으로 마지막에 보여드린 만화는 프로그래머 유머에 올라와있지만  풀스택을 지향한다는 것은 사실은 누구보다 열심히 개발하고 있는 인재들이 아닐까 하는 생각을 해봅니다. 내가 고액연봉을 받는 유니콘 풀스택 개발자가 못되더라도 우리는 다같은 개발자이기에 하나라도 더 많이 아는 것은 좋다고 생각합니다.  개발의 본질은 사실 크게 차이나지 않으니까요.  본인만의 기준에 맞는 전문성과 넓은 시각을 가진 풀스택 개발자 감사합니다. ❤️ 혹시 그럼 이런 글도 혹시 쓰실 생각 있으실까요? 제 질문이지만 아마 다른 분들도 궁금해할 질문같아서요 ㅎㅎ 프론트엔드 포지션이 생긴 이유, 앞으로 어떻게 될지  프론트엔드 개발자의 업무 범위 잘하는 프론트엔드 개발자란? ‘프론트엔드가 왜 생겼는지 모르겠다.’ , ‘퍼블리셔가 진화해서 프론트엔드 아니야?’ 라고 생각하시는 것같더라구요… 프론트엔드 개발자가 일을 해야하는 범위 잘하는 프론트엔드 개발자 란 어떤 개발자일까요? 이 것도 주니어, 중니어, 시니어별로 기대하는 바가 다르겠지만… 그래도 보편적으로 일 잘하는 프론트엔드 개발자에 대한 생각이 궁금합니다 너무나 좋은 소재를 제공해주신 분께 다시 한번 감사드리며 좋은 글로 보답하겠습니다. 프롤로그 질문에 대한 대답을 하기 위해서  웹의 역사 중 프론트엔드와 관련된 부분 을 중심으로 먼저 정리해보기로 했습니다. 적고나니 역사파트 분량이 많아져서 정작 질문의 핵심인  프론트엔드 개발범위 와  잘하는 프론트엔드 개발자 에 대한 분량조절을 실패한 것 같지만 재미로 읽어 주시길 바랍니다. 글을 나눌까도 했지만 그냥 보내주신 질문을 한번에 다 답변을 드리면 좋을 것 같아서 한 편에 정리했습니다. 한번에 쭉 다 읽어 주시면 좋을 것 같아요.  1. 프론트엔드 포지션이 생긴 이유, 그리고 미래 웹 프론트엔드는 웹 서비스 발전에서 막내격으로 생긴 포지션입니다. 프론트엔드라는 영역이 갑자기 뿅! 하고 생겨난것은 아니지만 지금처럼 이렇게 선명하게 프론트엔드와 백엔드가 세분화된 배경에 대해서  웹의 역사 중에서 프론트엔드를 중심으로 한번 알아보고  또 앞으로는 프론트엔드는 어떻게 될지 한번 생각해보도록 하겠습니다. WEB 1.0 문서를 공유하기 위해서 웹이 만들어졌다, 1990 아날로그의 책처럼 일련의 순서대로 된 것이 아닌 가상의 공간에서 텍스트에 새로운 문서에 대한 링크가 존재하는 개념의  하이퍼텍스트 가 태어났습니다. HTML의 첫글자인 H가 바로 이 Hypertext이죠.  웹은 인터넷을 통해서 이 하이퍼텍스트라는 문서를 모든 사람이 쉽게 만들고 또 공유하기 위해 태어났습니다. 이제 누구나 쉽게  HTML(Hypertext Markup Language)  을 이용하여 이 하이퍼텍스트를 쉽게 만들 수 있었고  HTTP(Hypertext Transfer Protocol)  를 통해서 누구나 이 문서에 접근해서 문서를 읽을 수 있게 되었습니다. CGI(Common Gate Interface) 통신이 가능해지다, 1994 정적인 정보만 담고 있는 문서에 사용자가 일정한 정보를 입력해서 전달하면 그 정보를 바탕으로  서버에서 동적으로 페이지를 생성 할 수 있게 되었습니다. PHP를 시작으로 여러가지 서버 스크립트 언어가 만들어지면서 본격적인 홈페이지 서비스들이 만들어지게 됩니다. 이때부터 사용자는 정보를 서버로 보내고 데이터를 보관할 수 있게 됩니다. 홈페이지에 카운터를 달거나 방명록 등을 달 수 있게 되었습니다. 이후 방명록은 게시판으로 발전했고 독자적인 컨텐츠를 수용할 수 있는 커뮤니티로 발전하게 됩니다. Javascript의 탄생, 1995 서버뿐만이 아니라 브라우저에서 실행이 가능한 스크립트 언어가 필요해졌고  자바스크립트 가 만들어졌습니다. 이제 서버와 통신을 하기 전에 화면을 조작하거나 서버에 데이터를 전달하기전에 검증을 하는 등의 기능을 할 수 있게 되었습니다. 문서를 예쁘게! 웹 디자인의 발전, 1996 HTML에 과도한 스타일이 작성되어 유지보수를 어렵게 하던 문제에서  컨텐츠와 서식을 분리하자는 CSS 가 탄생하였습니다. 그리고 브라우저의 성능상의 한계로 표현하지 못하던 애니메이션 등을 해결할 FLASH가 탄생했습니다. 검색 엔진과 포털, e-커머스 문서를 공유하고자 만들어진 웹에서 양질의 문서들을 찾아서 공유하는 것은 당연한 일이었습니다. 초창기 이러한 유용한 링크들을 아카이브 하는  웹 디렉토리 라는 서비스들이 생겨나고 이는, 사용자가 검색을 통해 양질의 정보를 찾아주는  검색엔진 이라는 서비스로. 사람들이 좋아할 정보들을 묶어두어 볼수 있게 하는  포털 서비스로 발전합니다. 또한 사용자가 언제 어디서든 정보를 전달할 수 있다는 장점은 어디서든 주문을 받을 수 있다는 것으로 연결해서 온라인으로 물건 주문을 할 수 있는  e-커머스로 발전 하기 시작합니다. 🔥 Internet Exploer의 대중화와 웹의 상업화, 1995-2004   Windows가 대중화되고 Internet Exploer가 기본 탑재가 되면서 웹은  기업이라면 당연히 가지고 있어야 하는 명함과 같은 존재 가 되었습니다. 이때 홈페이지를 만들기 위해서는  디자인을 HTML과 CSS로 만들 수 있는 웹 디자이너 가 필요했고  간단한 게시판이나 방명록 카운터등을 달 수 있는 서버 스크립트 기술 이 필요했습니다. 대형 엔터프라이즈급이 아니더라도 홈페이지는 필요해지게 되면서 간단한 게시판과 같은 기능을 직접 구현하기보다 솔루션을 이용하는  솔루션 기반의 홈페이지를 만드는 것이 일반적 인 방식이 되었습니다. 남들보다 주목을 끌기 위해서 기능보다는  디자인으로 이목을 끄는 편 이 더 쉬웠기에 화려한 배너와 디자인들의 수요가 생겼습니다. 이 때 정말  수많은 웹 디자이너 가 생겨났고  홈페이지를 개발하는 웹 개발자 가 생겼습니다. 이때는 대부분 솔루션을 기반으로 하다보니  HTML과 CSS를 주로 다루는 웹 개발자 는 실력없는 개발자라는 인식이 만들어진 시기이기도 합니다.  프론트엔드 관점에서 정리하자면,  웹페이지 개발의 수요는 올라갔으나  디자인과 데이터 솔루션을 제외한  로직의 영역이 중요하지 않았던 시기 였습니다. HTML와 CSS는 다른 개발에 비해 상대적으로 쉬웠고, Javascript나 Flash등의  동적 스크립트의 영역이 엔터프라이즈급 비지니스 모델과 거의 연관이 없던 시절 이었습니다. Web 2.0과 RIA(Rich Web Application) 여기서 부터는 웹의 역사를 다 이야기 했다가는 끝도 없으므로 프론트엔드의 발전에 영향을 끼쳤던  Flash , 그리고  구글 과  페이스북 을 중심으로만 이야기하려고 합니다. Flash와 RIA(Rich Web Application)   2000년대 초 닷컴 버블로 여러가지 웹 비지니스가 망하고 웹 생태계가 재편이 되면서  web 2.0 이라는 용어가 생겨 납니다. web 2.0에는 여러가지 개념들이 있지만 프론트엔드와 가장 밀접한 키워드는  RIA(Rich Web Application)  입니다. 기존의 정적인 문서 구조에서 벗어나  사용자와 적극적으로 인터렉션 을 하며  화면이 동적 으로 변하는 것들로 나아가야 한다고 했습니다. 당시에는 이와 가장 적합한 도구가 바로  Flash 였습니다. 당시 Internet Exploer의 동적 스크립트 능력을 한 없이 열악했으며 더 막강한 언어인 ActionScript로 되어 있는 Flash는 디자인, 에니메에션, 사용자 인터렉션 모두에서 월등했습니다. 대부분의 웹 디자이너들을 Flash를 배우기 시작했고 점차 화려한 웹 페이지들이 만들어지기 시작했습니다. 당시에는 이게 바로 웹사이트의 미래라고 생각하는 사람들이 많았습니다. 하지만 유려한 에니메이션과 화려한 이미지 그리고 사운드등으로 점철된 웹 사이트에서 사람들은 결국 피곤해했고, 많은 양의 리소스를 불러오기 위해서는 로딩이 필요했으며, 더군더나 Flash는 HTML이 아니므로 검색엔진에 포함되지 않았습니다. 문서라는 본질적인 측면에서는 Flash가 효과적이지 않다는 것을 알게 됩니다. 보안적인 문제도 있었습니다. 그러나 Flash만큼 디자인과 에니메이션과 코드를 연결하는 대안은 없었기에  Flash는 게임이라는 궁극적인 동적 스크립트의 끝판왕에서 계속 발전하게 됩니다.  물론 그들만의 세상으로 고립되어 가기도 했습니다. 결국 나중에는 Apple이 아이폰에서 Flash의 퇴출을 결정하고 Flash가 완전히 웹에서 사라지게 되지만  웹에서 이러한 동적 스크립트의 필요성 을 알게하고 웹에서  Flash의 대안 이 필요하다라는 것을 알게 해준 계기였습니다. 개인적으로는 참 안타깝다고 생각합니다. Flash가 마음에 들어서 배우는데 많은 시간을 할애했었는데... 정말 시대를 앞서갔고 좋은 개발환경을 갖추고 있었고 Adobe스럽게 잘 만들었지만 거대 IT 공룡들의 희생양이 되어버린것 같기도 합니다. (보안 문제 좀 잘 해결하고 독자적인 브라우저를 좀 만들지 그러셨나요. Flash 게임 시장을 스팀처럼 만들어 보지 그랬어요!! ㅠㅠ)  구글 - 마이크로소프트의 대항마로 웹을 선택하다! 검색엔진과 구글애드로 성공을 거둔 구글은 당시 IT의 1인자인 마이크로소프트를 넘어보고자 생각했습니다. 마이크로소프트의 가장 큰 원동력은 OS에 있었으나 OS를 새로 만든다고 이 점유율을 뺐을 수는 없는 노릇이었습니다. 자신들의 아이텐티티는 검색엔진이고 웹을 맨 처음 시작하면 구글로 시작을 한다면  &#39;웹이 하나의 OS가 되면 어떨까?&#39;  라는 생각으로 웹을 자신들의 OS로 만들려고 하는 프로젝트들을 시작하게 됩니다. 더 궁금하시면  크롬 OS 를 검색해보세요. https://www.flickr.com/photos/50114361@N00/3702942040 ) OS라면 어떠한 것들을 제공해야 할까요? OS만 있어서는 아무것도 할 수 없습니다. OS가 성공하기 위해서는  좋은 Software가 필요 합니다. 그래서 구글은 Microsoft에 있는  Office를 웹으로 옮겨오는 시도 를 하게 됩니다. 이 과정에서 Internet Explorer 보다 더 좋은 브라우저가 필요했고 웹 개발에 용이해야 했기에 디버그 기능에 엄청 공을 들였습니다. 뿐만 아니라 javascript 성능을 올리기 위해 자체적인  V8 자바스크립트 엔진 도 만들게 됩니다. 구글 뿐만 아니라 MS의 Internet Exploer의 독점적 위치가 대항하기 위한 여러가지 브라우저들이 이 시기에 만들어지기 시작했습니다. 이는 후술할  웹 표준 과  웹 접근성 의 토대가 됩니다. 🔥 프론트엔드의 토대가 된 Ajax   위와 같은 이유로 구글은  웹에서도 Application과 같은 소프트웨어 가 동작하기를 바랬습니다. 그전까지는 열악한 브라우저 컴퓨팅 환경에서 굳이 javascript로 이런 것들을 만들 이유가 없었습니다. 훨씬 더 나은(?) ActiceX와 Flash, Java Servlet과 같은 대체재가 얼마든지 있었습니다.(그래서 ActiceX로 떡칠이 되었죠;;). 굳이 웹으로 만들 필요도 없습니다. 하지만 구글은  다른 vendor에 의존하지 않는 방법이 필요 했습니다. 그래서  javascript를 통해서 비동기로 화면을 동적으로 구성하는 방법 을 통해서 Google Maps라는 서비스를 만들었고 이것은 웹 개발 생태계에 새로운 파장을 일으켰습니다. 대부분의 웹 페이지에서는 Flash와 같은 화려하지만 무거운 기능이 필요한 것들이 아니었습니다.  웹 생태계에 있는 자원을 그대로 활용해서 동적인 화면들을 만들 수 있다는 것 은 상당한 가치였으며 이를 통해서  javascript가 재평가 를 받게 됩니다. 웹 표준과 웹 접근성, 시맨틱.. 크로스 브라우징 Window, Internet Exploer, ActiveX등이 독점적 지위로 인해 자체 표준이 되어버린 상황에서 여러가지 브라우저 벤더를 포함 웹 종사자들이 다 같이 웹을 쓸 수 있도록 하는  웹 표준 을 만들게 됩니다. 웹은 모두의 것이고 특정 벤더에 의해 관리되지 않아야 하고 웹의 발전을 위해서는 최적의 것들을 표준으로 만들어야 한다는 취지로 만들어지게 됩니다. 웹 표준을 지켜서 html, css, javascript를 만들면  브라우저와 관계없이 동작 할 수 있다는 것을 의미합니다. 이를 기점으로 ActiceX나 Flash와 같은 비표준 기능 사용을 최소화하면서 표준은 아니지만 표준이 되어버린 IE에 맞춰주는  크로스 브라우징 을 통해 개발하는 직군이 확장되기 시작합니다. 이때부터 웹 디자이너, 웹 개발자들에게는  웹 표준 에 맞게 작성을 해야하고 Flash 대신  javascript나 css등을 이용해서 동적으로 화면을 만드는 능력을 요구 받게 됩니다. 또한 이때 웹표준과 함께 시맨틱 이라는 요소가 함께 강조되면서 검색에 유리한 구조와 의미를 부여하는 식으로 HTML과 CSS를 작성하고 시각장애인들과 같은 경우에도 웹을 사용할 수 있도록 하는  접근성에 대해서 강조 가 되면서 디자인보다 조금 더  전문성 을 요하는 구간이 생겨났습니다. 🔥 javascript 개발자를 찾습니다. jQuery의 등장!   javascript가 정식(?)으로 웹 개발 도구가 되면서 개발자들의 관심을 받게 됩니다. 열악했던 개발환경에서 대체재가 없는 이 javascript는 많은 사람들의 손을 거쳐가며 라이브러리가 발전하고 사용법이 발전을 하게 됩니다. 이러한 노력의 결과로 2008년  웹표준 API를 모두 포함 하면서  훨씬 더 쉬운 문법 과  IE 크로스브라우징 ,  Ajax 까지 해결해버린  jQuery 가 탄생을 하게 되면서 웹개발은 제2의 전성시대를 맞이하게 됩니다. 이때 만들어진 jQuery의 대부분의 문법들은 실제 웹 표준의 API 기능으로 대거 포함이 됩니다. 이 때부터 조금씩 프론트엔드에서 웹 디자이너와 웹 개발자의 영역이 조금 더 분리되게 됩니다.  크로스 브라우징 과 시멘틱, 접근성등의 영역은 웹 디자이너가 주로 다루는 영역들이 아니었습니다. Ajax를 다루는 작업들도 디자이너에게는 생소한 개념이었죠. 이때쯤해서  웹 디자인의 결과물을 시멘틱, 접근성을 고려하고 개발자가 사용할 수 있도록 HTML, CSS를 만들어 넘겨주는 일 이 새로운 프로세스가 되었고  Ajax를 할 줄 아는 웹 개발자 들의 몸값이 올라가게 되었습니다.  크롬브라우저와 V8엔진    웹을 통한 OS 와  웹 어플리케이션 을 다음 먹거리로 삼았던 구글은  javascript의 성능 개선 이 중요한 과제가 됩니다. 그래서 javascript의  성능을 개선한 V8엔진 을 만들어내게 되고  오픈소스 로 공유합니다. 그리고 V8와 당시 apple의 safari 오픈소스 웹브라우저 엔진인  webkit을 결합시킨 크롬 브라우저 가 탄생합니다. 크롬 브라우저는  매우 빠른 속도 와 함께 특히  풍부한 디버깅 환경을 제공 함으로써 웹 개발자들의 희망이 되어 주었습니다. (물론 ActiceX가 없었기 때문에 개발할때만 크롬을 쓰고 웹 서핑은 IE로 해야만 했던 시절이기는 합니다.) 크롬이 IE을 넘어서는데에는 한참의 시간이 걸렸지만 구글의 바램대로 웹은 하나의 OS가 되었고 크롬이 제공하는 디버깅 환경으로 인해서 웹 개발은 개발다운 개발을 할 수가 있었고 이것은 대형 서비스를 개발할 수 있는 단초가 됩니다. (정말이지 IE에서 디버깅 환경은 끔찍했습니다. 디버깅 패널을 열지 못한다고 생각해보세요! console.log도 없는 세상입니다.) 🔥 Node와 npm    V8의 오픈소스 는 새로운 국면을 맞이합니다.  javascript를 가지고 서버사이드 환경을 개발할 수 있는 Node 가 탄생합니다. 이는 javascript 성장에 박차를 가해줍니다. javascript만 할 줄 알던 사람도  새로운 언어의 학습없이 서버개발을 할 수가 있게  되었고 서버개발자 역시 javascript를 하면 겸사겸사 브라우저 개발도 할 수 있도록 영역을 넓혀주게 됩니다. 무엇보다 node에서  module 이라는 방법을 채택하게 되면서 javascript에도 module방식의 개념이 조금 더 보편화하게 됩니다. 이것은 나중에 브라우저에서의 번들러나 es module의 토대가 되어 줍니다. module 개념이 중요한 것은 파일을 쪼갬으로써 훨씬 더 덩치를 키울 수 있는 프로그램을 만들 수 있기 때문입니다. 자바스크립트는 모듈이 없다보니 한 파일에만 크게 작성을 해야했고 여러 파일들을 쪼개서 불러오면 성능상의 이슈가 발생했기 때문에 javascript 덩치를 키우는게 쉽지 않았기 때문입니다. 이후  npm 이라는  module을 패키징해서 등록하고 관리할 수 있는 도구 가 생겨나면서 javascript 생태계는 폭발적으로 성장하게 됩니다. node, browser 모두 javascript를 사용하므로 moment와 같은 날짜와 같은 유틸리티성 라이브러리는 공용으로 사용하면서 서버사이드에서 개발되는 많은 코드들이 browser에서도 사용할 수 있게 됩니다. 또한 이를 바탕으로 webpack, babel, rollup과 같은 node를 기반으로 하는 dev-ops 영역이 활발해지게 되면서 그간 javascript 개발에 불편했던 영역들이 하나 둘 씩 개선이 되기 시작합니다. 이러한 과정들을 통해 javascript로 엔터프라이즈급 개발하는 환경이 갖춰지면서 예전보다 더 가치를 창출 할 수 있는 웹 서비스들이 나올 수 있는 환경이 점차 마련이 되었습니다. 페이스북 - 연결의 가치, 1분에 3테라의 데이터가 쌓인다 페이스북은 SNS의 개념으로 성공한 거대 웹서비스입니다. SNS에 대한 얘기는 하지 않겠습니다. 페이스북은 1분에 3테라의 데이터를 쌓을 만큼 성장하게 됩니다. 이를 위해서는 기존과는 완전히 다른 체계의 서버 구상이 필요했습니다. 또한 페이스북은 유래없이 단일 웹 서비스로 거대한 성공을 이루었고 페이스북 역시 하나의 OS의 역할을 하고 싶어했고 앱, 게임, 연결, 채팅, 메신저등 온갖 기능들이 facebook에서 돌아가기를 바랬습니다. 페이스북은 웹 서비스 하나로 구글과 맞먹을 정도의 규모를 만들어냈고 이 어마어마하게 큰 웹 사이트 하나를 계속 유지 보수 하기위해서는 기존과 같은 방법과는 다른 방법이 필요했습니다. 🔥 백엔드와 프론트엔드의 각자의 전문성의 분리, React의 탄생 프론트엔드는 새로 생겼다기보다 거대 웹 서비스의 등장과 웹 산업이 발전하는 과정에서  자연스레 세분화  된 것입니다. 백엔드는 이제 거대 데이터를 처리하기 위한 도구와 자동배포와 스케일링등 새로운 도전과제를 맞이 하게 되었고 프론트엔드 역시 화면을 동적으로 다루는 역할이 중요해지면서 더 필요한 역할을 부여받게 되었습니다. 초창기 모바일 게임들은 1인 개발자들의 것들이 많았으나 지금은 혼자서 게임을 만든다는 것은 상상하기도 힘든 대형 규모가 된 것 처럼요. 특히  React를 기점으로 프론트엔드 개발의 체계 가 잡히면서 이러한 체계가 뚜렷해지기 시작합니다. 이후 프론트엔드의 폭발적인 성장    Frontend Evolution https://github.com/ManzDev/frontend-evolution 이러한 웹으로 큰 돈을 벌 수 있다는 인식의 변화와 웹 개발 환경의 급격한 개선을 통해서 브라우저의 javascript를 이용한 클라이언트 개발의 분야는 급속도로 성장을 하게 됩니다. HTML와 CSS javascript는 각각의 필요성에 의해 성장을 하게 되고 npm을 통해 계속 지속적으로 관리되고 배포될 수 있었습니다. module을 통해서 거대한 소스코드로 쉽게 관리될 수 있었고 크롬을 통해서 편안한 디버깅을 또 브라우저의 성능과 기능이 추가되면서 점점 더 브라우저 클라이언트 사이드 개발의 영역은 커져갑니다. [뇌피셜 주의] 기존에 Web Framework라고 하면 CI, Spring, Ruby on rails와 같은 Web Framwork를 말했지만 이와 구분지어 부르기 위해서 Front-end Web framework이라는 쓰이면서 Front-end 라는 용어가 쓰이게 되지 않았나 개인적인 추측입니다. (오피셜 아닙니다. 제가 언제부터 웹 개발을 프론트엔드로 부르게 되었는지를 생각해보면서 하는 추측입니다.) 현재 웹 프론트엔드의 입지 - 디지털 전환, 하이브리드 앱 웹 산업이 발전하고 브라우저와 웹 생태계가 발전하면서 그야말로 웹 전성시대가 되었습니다. 웹은 하나의 벤더에 속하지는 않았기 때문에 발전하는 속도가 훨씬 더 커졌습니다. javascript는 가장 많이 사용하는 언어 1위가 되었습니다. Google과 Facebook이라는 웹을 통한 거대 성공사례와 웹의 발전을 통해서 프론트엔드의 진화 속도는 엄청나게 가속도를 받게 됩니다. 특히 다른  앱들과 달리 설치가 필요없고 브라우저만 있으면 된다는 가벼운 접근과 개발환경 이라는 점은 엄청난 장점을 가지게 됩니다. 뿐만 아니라 거대해진 웹의 인프라가 곧 클라우드 서비스로 이어지고 디지털 전환의 시대를 맞이하면서 프론트엔드의 입지가 중요하게 되었습니다. 🔥 대 디지털 전환의 시대 이와 같은 IT의 성공적인 인프라가 만들어지면서 꼭 IT가 아니더라도 기존의 사업모델을 온라인으로 옮겨 놓고자하는 시도가 커졌습니다. SNS나 플랫폼 사업의 성공을 통해서  데이터를 유통하면 돈이 된다 는 사실을 알게 되어  오프라인의 서비스를 데이터로 보고 새로운 데이터 유통라인을 만들려는 시도 가 커지고 있습니다. 이러한 과정에서 이 중간의 데이터들을 눈으로 확인하고 조작하고 싶은 것들은 어찌보면 당연합니다. 사업이 온라인으로 옮겨지면서 이러한 데이터를 처리하는 중간 중간에 CMS와 같은 영역들이 크게 늘어났습니다. 쇼핑몰을 상상해보세요. 우리가 보는 쇼핑몰은 구매화면과 장바구니이겠지만 그 뒤로는 주문관리, 배송관리, 송장관리, 세금, 재고관리 등 마어마한 그 뒷단 데이터들이 존재합니다. 예시로 든 e-커머스에서는 이미 발전을 충분히 한 모델이지만 지금은  새로운 국면에서 새로운 다양한 서비스들이 만들어지면서  데이터의 유통과정에서 필요한 화면들이 다루는 작업들이 늘어나게 되었습니다. 그래서 프론트엔드에 너무 환상을 또 가져서는 안됩니다. 디지털 전환으로 인해 사업이 다양화되면서 정형화된 e-커머스와는 달리  새로운 서비스의 데이터들을 다루기 위한 도구 로 만들기 위해서  백오피스 영역이 발전함에 따라 관리자 도구로써의 웹의 가치가 더 높아지고 있고  이 영역에서의  프론트엔드 개발자 수요가 많습니다.  백오피스는 프론트엔드에서 정말 중요한 영역이기에 입문자들이 보통 상상하는 프론트엔드의 모양과는 달라서 이 부분을 많이 염두해 두고 있어야 합니다. 서비스 프로토타이핑의 최전선 이러한 디지털 전환을 통해서 새로운 사업들이 만들어지게 되면서  가볍게 개발 할 수 있다는 웹 환경과 디지털 전환은 아주 궁합이 좋습니다.  핵심은 필요의 연결과 데이터의 유통이기에 웹은 이러한 사업을 하기에 최적의 도구입니다. 인프라는 클라우드가 책임져주게 되면서 프론트엔드는 스타트업에서 사업을 검토하고 빠르게 만들어 볼 수 있는 영역에서 사업을 검증해볼 수 있는 아주 중요한 역할을 합니다. 데이터를 다루는 Application과 하이브리드 앱 전통적인 프론트엔드의 원래 주요 업무였던 로컬에서 데이터를 처리하는 기능은 앞으로도 더 발전을 할 것입니다. 구글 오피스, 구글 meet과 같은 전통적인 앱들도 있고, 최근 들어서 노션, 피그마, 슬랙과 같은 문서를 만들고 관리하는 서비스들은 Application에서 프론트엔드 임무는 무척이나 중요합니다. 게더타운과 같은 더 고도화한 Application을 지향하는 웹 서비스들도 나타나고 있습니다. 또한 앱 생태계가 발전하면서 ios, android 등으로 파편화된 환경에서 웹은 하나의 개발로 환경과 관계없이 사용할 수 있다는 점이 웹 프론트엔드를 더 중요하게 만들어주고 있습니다. 프론트엔드는 이제 완벽하게 새로운 하나의 생태계가 되었습니다. 구글의 생각대로 웹은 너무나 당연한 서비스의 출발지가 되었고 웹 문서에서 웹 어플리케이션으로 변모하였습니다. 이제는 문서가 아니라 데이터를 다루는 도구가 되면서 데이터를 시각화 하고 데이터를 다루는 영역이 점차 중요해져 가고 있습니다. 데이터 유통이라는 생태계가 커지고 산업 규모가 커져감에따라 점차 중간 단계에서 데이터를 확인하고 조작하는 역할이 커져가면서 관리자 형태의 데이터를 다루는 형태의 프론트엔드가 점점 커져가고 있습니다. 그리고 웹의 성능이 발전해감에 따라 엔터프라이즈급 웹 어플리케이션도 점차 늘어가는 추세입니다.  앞으로의 프론트엔드 방향성 보다 Serverless 하게... 클라우드 서비스   지금처럼 프론트엔드와 백엔드는 저마다의 영역으로 확장이 될 거라고 생각합니다. 백엔드의 로직의 영역은 점점 프론트로 내려오고 있고 백엔드는 데이터를 교환하고 저장하고 관리하는 인프라의 영역으로 확대되고 있습니다. 데이터를 다루는 로직은 점점 더 프론트엔드가 담당하게 되면서 클라우드를 통해 서버없이 작업을 하는 형태로 발전을 하고 있습니다.  (서버가 없다는 말은 실제 서버가 없는게 아니라 서버 개발없이 데이터 처리 로직만 개발해서 클라우드에 올리는 방법을 의미합니다.) 보다 Application 처럼...   VSCODE는 웹 기반으로 만들어진 어플리케이션입니다. 뿐만 아니라 기존의 구글 오피스 뿐만 아니라 MS의 Office 365역시 전통적인 어플리케이션의 영역이었지만 이제는 웹 기반에서 돌아가는 어플리케이션 서비스가 되었습니다. 뿐만 아니라 슬랙이나 피그마등 기존의 어플리케이션의 영역에 있는 것들이 웹으로 구현이 되고 있습니다.   초창기 문서 단위로 데이터를 보내고 새로고침이 되는 방식에서 새로고침이 아니라 일부 영역만 업데이트 되는 방식으로 데이터만 업데이트 되는 방식으로 바뀌어가면서 데이터를 수정하고 조작하고 저장하는 방식이 훨씬 더 정교해질 것입니다. 앱이 보편화 되면서 인터랙션에 대한 눈높이가 올라가면서 자연스럽게 페이지 단위가 아니라 요소별로 처리할 수 있는 UI의 고도화를 추구하고자 합니다. 그리고 게임과 같은 복잡한 인터랙션과 화면이나 3d와 같은 요소들을 웹에 넣으려는 시도들은 언제나 있어왔습니다. 언젠가는 킬러 어플리케이션이 나올 수 있겠죠! 보다 실시간으로...   게시판에서, SNS, 메신져, 방송등 점점 데이터의 교환속도가 빨라지는 방향으로 발전을 하고 있습니다. 메타버스에서는 완전히 실시간으로 연결된 것들을 상상하고 있죠. 조금 더 데이터를 실시간으로 다루는 형식의 서비스들로 발전을 하고 있습니다, 슬랙, 노션, 피그마, 게더타운등을 떠올려 보세요.   데이터를 유통하면 돈이 되는 세상에서  데이터를 시각화하고 컨트롤을 하려는 수요 는 계속 늘어날 것입니다. 이것은 프론트엔드의 성장을 말하지는 않습니다. 프론트엔드의 수요가 늘어난 것이죠. 지금의 프론트엔드 개발이 늘어난 것들은 이러한 현상 때문입니다. 하지만 노션, 슬랙, 피그마, 게더타운과 같이  데이터를 조작하고 실시간으로 연결을 하고자 하는 과정 에서 새로운 서비스들이 태어나고 있습니다. 프론트엔드의 성장은 새로운 킬러 서비스들로 인해 새로운 국면을 맞이 할테죠. 뭐가 될지는 모르겠지만 궁금하네요! 요약 웹이 발전하는 과정 중에서 프론트엔드가 성장하는 이정표를 따라와봤습니다. 제가 쓴 내용과는 조금 다르지만 핵심적인 결은 같은 이미지와 링크를 통해서 마무리를 하고자합니다. https://www.alibabacloud.com/blog/how-will-front-end-engineers-embrace-the-trend-of-serverless_594857 2. 프론트엔드 개발자의 업무 범위 웹 서비스란 사용자가 어떠한 입력을 하고 입력을 통해 더 가치있는 데이터를 만들어 사용자에게 잘 전달하는 것을 의미합니다. 이 과정에서  프론트엔드는 사용자와 서비스를 연결해주는 과정의 모든 것들을 구현하는 역할 을 하는 것이죠. 그래서 프론트 엔드 개발자의 업무 범위를 데이터와 서비스의 관점에서 그림으로 그려보면 다음과 같은 6가지의 범위가 존재합니다.   1. 데이터를 (예쁘게) 잘 보여주기 전통적인 웹 문서를 잘 만들어서 보여주는 영역입니다.  서버에서 내려오는 데이터 를 적절히  HTML, CSS를 통해서 요구하는 디자인의 형태 로 나타내야 하는 영역입니다. 최초의 문서는 HTML문서가 데이터이자 디자인이었고 데이터의 영역과 디자인의 영역이 세분화 되면서 발전해 왔다는 것을 알 수 있습니다. 조금더 세분화를 해보자면 디자인을 HTML + CSS 로 만들어내는 작업 적절히 재사용이 가능한 형태로 디자인을 컴포넌트화 하는 작업 기기, 브라우저, 화면등에 맞게 디자인이 제대로 보이기 위한 작업 시맨틱, 접근성, 검색엔진 최적화 등을 하기 위한 작업 초기 로딩을 속도를 개선하기 위한 최적화 작업 서버의 데이터를 적절히 디자인 컨텐츠에 연결하여 데이터와 함께 출력하는 작업 디자인을 코드로 바꾸는 작업과 서버 데이터를 코드로 바꾸는 작업이 적절히 혼재되어 있고 디자인을 코드로 바꾸는 작업을 국내에서는  퍼블리셔 라고 부르곤 합니다. 국내에만 있는 말인데 프론트엔드의 모든 영역에서 다소 로직이 차지하는 비중이 적은데 반해 작업량은 적지 않기 때문에 이부분의 스페셜리스트를 두어 효율을 높이는 방법을 선호합니다. 로직을 다루지 않다보니 퍼블리셔를 개발자로 보지 않는 인식이 있었으나, 최근의 경우  프레임워크에서 재사용이 가능한 형태로 디자인과 CSS를 같이 하면서 컴포넌트 로 만들어내는 과정들은 절대로 녹록치 않은 작업이기에 당당히 프론트엔드의 영역의 한 부분이 되고 있습니다. 2. 데이터(화면)을 조작하는 기능 전통 프론트엔드 개발자들의 영역이 되겠습니다. 이미 만들어진 데이터에서  사용자의 입력을 받아서 적절히 다른 데이터(화면)로 변경하는 역할 을 담당합니다. 대부분의 UI와 DOM, WEB API에 대한 이해와 View를 이루고 있는 데이터에 대한 깊은 이해를 요구합니다. javascript를 공부해야하는 이유이기도 합니다. 데이터의 관점으로 보았을때는 의미있는 데이터를 화면 내에서 만들려고 할 수록 어려워지고 복잡해지고 중요해지는 경향이 있습니다. 블로그의 글쓰기 에디터나 벨로그의 마크다운 글쓰기, 구글 시트의 셀, 피그마의 기능과 같은 부분들을 떠올려 보시면 좋을 것 같아요. 대부분의 개발자들이 프론트엔드를 하고 싶어 하는 이유이기도 합니다. 하지만 엔터프라이즈급에서 이러한 것들을 하는 회사가 그렇게 많지는 않아요. 프론트엔드 개발자 수요가 그렇게 많으면서도 내가 하고 싶은 일들은 별로 없는 이유이기도 합니다. 세분화해서 정리해보면, 현재의 화면을 데이터로 구성합니다. 사용자의 이벤트를 감지합니다. 해당 이벤트를 적절한 행동으로 분류합니다. 행동에 맞는 적절한 WEB API를 동작합니다. 해당 API의 결과를 통해 새로운 데이터를 생성합니다. 이 데이터를 기존의 데이터와 조립해서 원하는 데이터로 변경합니다. 해당 데이터를 화면에 출력합니다. Web Framework들이 대부분 이 작업들을 쉽게 작업하기 위해서 개발되고 있습니다. 3. 서버로 데이터 보내기 여기에서는 앞에서 만들어낸 중요한 데이터들을 서버로 보내는 역할을 하게 됩니다. 예전에는 백엔드를 개발하던 사람이 본인의 API를 테스트를 하면서 작업을 하던 영역이었지만 이제는 완전히 프론트엔드로 분리가 되어버린 영역입니다. 웹 디자인을 주로 하던 분들이 막히는 곳이기도 합니다. 혼자서만 공부를 하기 애매한 영역이기도 합니다. 웹의 가치는 데이터의 공유와 유통에 있기 때문에 데이터가 서버를 통해 공유가 되지 않는다면 의미가 퇴색이 되는 부분이기에 점점 더 중요해지고 있는 영역입니다. 백엔드와 적절히 협업을 할 수 있을 정도의 CS 능력 이 필요하기 때문입니다. 대표적으로  HTTP프로토콜 과  REST API 의 간단한 이해정도가 있겠네요. 특히 문제가 생겼을때 프론트엔드의 문제인지 백엔드의 문제인지 판단을 할 수도 있어야 대응이 가능하므로 협업의 경험치 축적이 필요한 영역입니다. 세부적인 내용은 다음과 같습니다. API 문서를 열심히 읽습니다(?) 서버에서 정의한 schema에 맞게 내부적으로 type을 설정합니다. 서버로 보내기전 데이터를 검증하는 작업을 합니다. 화면에 있는 데이터를 API에서 사용하는 구조에 맞게 변경합니다. 백엔드에 지정한 API의 양식에 맞춰 URL, Method, Header, Params, Body등을 만들어서 전달합니다. 이때 중복 전달 방지를 위한 distint, 쓰로틀링, 디바운싱을 사용하기도 합니다. 인증 및 보안은... 회사 내부 규정을 따릅니다. REST API이 대부분의 작업이나 GrpahQL이나 RPC, Web Socket, Web RTC 스트리밍 등 데이터 교환에는 여러 분야들이 존재하니 개발하는 영역에 따른 추가 공부가 필요합니다. 4. 서버에서 받은 데이터 다루기 서버에서 데이터를 전달받아서 화면에 필요한 데이터로 전환하는 변환하는 과정을 주로 다룹니다. 이 역시 백엔드와의 협업이 필요하며,  서버의 API가 비동기로 이루어진다는 점 ,  서버와의 스키마와 화면의 스키마나 일치하지 않는다는 점 , 내가 백엔드를 만들지 않았다는 점들이 여기 작업을 어렵게 만들어주는 이유입니다. 백엔드에서 만들어둔 스펙과 실제 화면에서 보여줘야 할 스펙이 일치하지 않기 때문에 이를 적절히 만들어 줄 수 있어야 합니다. 데이터의 응답속도가 느리기 때문에 실제 화면과 데이터간의 타이밍이 일치하지 않습니다. 이러한 비동기성 특징으로 인한 로딩, 중복 방지 등 중간 과정을 적절히 처리할 수 있어야 합니다. 서버 응답에 따른 문제원인 확인 및 문제해결 능력이 필요합니다.  최근에는 graphQL이나 react-Query등은 이러한 부분들을 좀 해결하자고 나온 라이브러리입니다. 일반적인 회사에서의 프론트 업무 범위 1 2 3~4 프론트엔드 개발의 영역은 사용자의 화면과 데이터를 백엔드로 전달하고 받는 모든 과정의 파이프라인을 담당하는 역할을 맡고 있습니다. 스펙트럼은 넓으나 회사나 프로젝트의 특성에 따라서 사용자에 가까운 쪽을 만드느냐 백엔드랑 가까운 쪽을 맡게 되느냐에 따라서 해야하는 주 업무의 모양새가 좀 달라지게 됩니다. 백엔드와 같이 데이터만 전문적으로 다루는 것은 아니나 데이터를 시각화하는 과정에서 기본적인 화면을 만들어내는 능력과 화면을 데이터로 이해하고 구성하는 2가지 능력을 동시에 요구합니다. 또한 디자이너, 기획자, UX, QA, 백엔드, 사업 까지 다양한 분야의 동료들과 적극적으로 협업을 해야하는 위치이기 때문에 다른 분야에 대한 이해도가 높아야 합니다. 일반적으로 웹 개발은 퍼블리셔, 프론트엔드, 백엔드 이런식으로 역할은 나눠져 있으나 명확한 업무 구분이 존재하지 않습니다. 협업의 관점에서 보았을때 서로의 영역이 겹치는 그레이영역은 존재하며 그라데이션과 같은 개념입니다.  퍼블리셔는 대개 1~2의 영역만 을 다루고  백엔드는 3~4의 영역만  다루는 것이 일반적인 견해입니다. 그렇다고  프론트엔드가 1 2 3~4를 혼자서 다하는가?  라고 하면 꼭 그렇지는 않고  자신의 주력 포지션이 1 2 3~4 어딘가에 있기 마련 입니다. 아니면 기능단위로 쪼개어져 넒은 영역을 커버하는 경우도 있지요.  역시 회사마다 사람마다 달라서 퍼블리셔가 컴포넌트와 화면 구성 데이터 연동까지 하는 경우가 있는가 하면 프론트엔드가  Serverless  혹은  *BFF 를 통해서 백엔드의 기능 구현을 하기도 하니 때문에 명확한 구분은 아니라는 점을 알아주세요!   어디가 빨간색이고 어디가 노란색인지 우리가 분명하게 선을 그을 수는 없지만 시점부터는 노란색이고 어느 시점부터는 초록색인 거니까 이 경계선은 회사마다 다르고 역할마다 다릅니다. 하지만 이 개념적인 부분을 이해를 돕는 적당한 마인드 셋 정도로 생각해주시면 좋을 것 같아요. 프론트엔드라는 영역은 원래 없던 영역이 아니라 웹이 거대해지면서 점점 영역이 넒어지고 있기 때문에 고정되어 있지 않고 점점 더 확장이 될것이기 때문입니다. 5. 개발환경 관리하기, 서버로 배포하기 프로젝트를 담당하게 되면서 초기 모든 사람들이 개발을 할 수 있도록 기술 스택을 정리하고 개발 환경을 설정하는 작업도 필요합니다. 그리고 이렇게 만들어진 프론트엔드의 결과물을 외부로 배포하기 위한 작업도 필요합니다. 소스코드를 관리하고 일정을 관리하는 일도 필요하게 됩니다. 보통 이런 역할을 하는 사람을 PL(Project Leader)라고 부릅니다. 프로젝트 개발 환경 설정 및 패키지 관리 프로젝트 컨벤션, 디자이너와의 컨벤션 조율 일정과 이슈관리 및 분배 배포 프로세스 및 릴리즈 관리 6. 개발자들을 위한 개발 우리가 흔히 쓰는 React와 같은 도구들을 개발하는 업무입니다. 거창하게 React가 아니더라도 사내에서 쓰는 공통 모듈이나 공통 라이브러리나 디자인 시스템의 컴포넌트와 같은 것을 만들 고 배포할 수 있습니다. 뿐만 아니라 git, jira, npm과 같은 도구들을 사내 환경에 맞게 설치를 하고 환경을 만들어주는 업무들도 여기에 속합니다. SDK나 OPEN API등 외부로 공개되는 모듈을 만드는 역할도 여기에 포함이 됩니다. 3. 잘하는 프론트엔드 개발자란?   일을 잘하는 거랑 개발을 잘하는 거는 다른거죠. 사람이 좋은거랑 소통을 잘하는 것도 다른거구요. 우리는 대부분 회사에서 함께 일하게 됩니다. 코딩을 잘한다는 것은 개발자에게 아주 중요한 기본적인 소양이나 우리가 코딩만 잘한다고 해서 그 사람이 잘하는 개발자라고 하지는 않습니다. 잘하는 프론트엔드 개발자란 어떤 개발자인지 한번 생각해봅시다. 회사의 입장에서 잘하는 개발자란...? 시간을 잘 맞추고 협업을 잘하는 사람 을 이야기합니다. 그러다보니 그냥 개발자의 가장 중요한 덕목인  일정을 잘 지키는  개발자가 좋은 개발자입니다.  오해를 하면 안되는 것은 일정을 잘 지킨다는 의미는 열정페이로 밤새가며 마감을 맞춰야 좋다는 의미가 절대 아닙니다! 프로젝트의 규모와 요구사항을 통해서 전체적인 일정을 스스로 컨트롤을 할 수 있고 그 일정을 내가 조율하고 예측가능한 작업을 할 수 있는 것이 회사에서 일을 잘 돌아갈 수 있도록 하는 능력입니다. 보통 주니어를 벗어났는가를 구분하는 요소로 이 일정을 컨트롤 할 수 있는지 여부를 중요하게 봅니다. 대부분의 주니어들은 일정산출을 어려워하고 일정을 조율하는 부분에서 어려움을 겪습니다. 얼마나 걸릴지 예측을 하기 어려운데 이는 프론트엔드의 작업 특성상 협업하는 라인이 많고 대부분의 작업의 마지막 파이프라인에 위치하기 때문입니다. 🔥 그러기 위해서 많이 알고 소통을 잘해야 한다. 기획, 디자인, 백엔드, QA, UX, 사업, 사용자까지 협업 라인이 다채로운 파트가 프론트엔드 분야입니다. 그렇기 때문에 프론트엔드의 기술 뿐만 아니라 다른 분야에 대한 지식이 충분히 있어야 합니다. 그래야 대화가 가능하고 소통이 되어야 일정에 대한 얘기도 할 수 있는 부분이지요. 이러한 부분들이 프론트엔드를 조금 어렵게 만드는 부분이기도 합니다. 사용자를 기준으로 하는 사고 방식과 백엔드의 데이터를 기준으로 하는 사고방식의 차이가 존재하기 때문이지요. 디자인의 사고방식과 구현의 사고방식 역시 다르기 때문에 이러한 조율 역시 프론트엔드 개발의 능력이기도 합니다. 소통의 방식중에는 말도 있지만 글도 있다. 회사의 규모가 커지면 커질수록 문서의 중요성이 높아집니다. 말은 보관되기 않기 때문에 시간이 지나버리고 담당자가 퇴사를 하고 나면 막막해지는 순간이 오기 마련입니다. 문서를 잘 쓴다는 것은 어마어마한 능력입니다. 취업에서 블로그를 중요하게 보는 이유는 그 사람이 어떠한 사람인가를 보여주는 역할도 하지만 기본적으로 글을.. 문서를 얼마나 잘 작성을 하는지를 보기위함도 있습니다. 본인이 작성한 소스코드 만큼이나 문서를 잘 작성하는 것도 잘하는 개발자의 능력입니다. 일하는 소통만 소통이 아니다. 회사는 사람과 사람이 살아가는 곳입니다. 기본적인 인성과 유머, 성실함, 공감능력, 긍정성, 주도성과 같은 인성적인 측면이 무엇보다 중요합니다. 면접에서도 그 사람의 능력도 중요하지만 무엇보다 먼저  함께 일하고 싶은 사람인가?  가 가장 중요합니다. 함께 하고 싶은 좋은 사람이 되는 것은 좋은 개발자의 덕목이기도 합니다. 빨리 할 줄 알아야한다. (프로토타입에 능해야 한다.) 특히 스타트업이나 초기 프로젝트에서 중요한 능력이기도 합니다. 웹 프론트엔드는 다른 앱과 달리 가볍고 빨리 만들 수 있다는 장점이 있습니다. 이러한 장점이 극대화가 되려면 정말로 요구사항을 빨리 이해해서 빠른 결과물을 만들어내는 능력이 필요합니다. 프론트엔드의 가치는 기술적인 부분이라기 보다 사업 그 자체에 있습니다. 그러다보니 이 아이디어가 정말로 괜찮은지는 여러가지를 구현해가며 피봇팅을 통해서 결정을 하게 되죠. 그러기 위해서는 빠른 구현이 중요합니다. 일정을 당기는 데 목적이 있는 것이 아니라 아이디어가 굳어가기전에 검증이 필요하기 때문이죠. 아이디어나 디자인들이 만들어지고 나서 구현에 까지 시간이 오래걸릴수록 매몰 비용으로 인해 포기하는 비용이 높아집니다. 이런 것들은 몇번 겪고 나면 안 좋은 아이디어나 디자인을 그냥 채택해버리기 때문이고 이는 나중에 사업자체의 가치를 떨어뜨리게 됩니다. 그래서 아이디어를 빨리 검증해줄수 있게 가볍게 빨리 프로토타입을 만들어내는 능력은 잘 하는 프론트엔드의 중요한 능력입니다. 프론트엔드는 잘하는 사람이 잘한다. 회사의 업무 특성상 프론트엔드의 기술을 깊게 활용하는 사업이라면 당연히 잘하는 것이 중요하겠죠. webRTC등을 이용한 화상이나 Socket을 이용한 실시간 처리 3d를 이용한 처리나 AI를 다루는 일들을 전문지식이 필요로 합니다. 이러한 분야에 있는 사람들은 자신의 주특기를 잘 하는 것이 무엇보다 잘하는 개발자이겠죠. 본인만이 가지고 있는 개발자적인 스킬이 비지니스적인 가치를 만들어 낼 수 있다면 그것만으로도 잘하는 개발자가 될 수 있습니다. 🔥🔥🔥 그러나 프론트엔드의 가치는 기술보다 본인이 만드는 서비스의 가치로 먼저 평가받는다! 안타까운 말이지만 프론트엔드의 가치는 먼저 내가 만드는 서비스의 가치입니다. 그렇기에 프론트엔드의 기술이 좋다고 해도 결과물이 형편이 없다면 가치를 인정 받을 수 없습니다. 아무리 실력이 있는 개발자라도 형편없는 디자인과 UX를 가진 서비스를 만들어낸다면 사람들은 구현해낸 능력을 보지 않습니다. 그보다 먼저 별점 테러를 받고 있겠죠. 그래서 일단 잘 만드는게 중요합니다. 디자인과 UX는 개발자가 관여하지 않는거 아닌가요? 라는 궁금증이 생기신다면 마인드를 고치시길 바랍니다. 개발자가 얼만큼 서포트를 해주느냐에 따라서 디자인과 UX는 얼마든지 더 좋아 질 수 있습니다. 좋은 디자이너와 UX를 선별하고 조율하는 것도 프론트엔드의 능력입니다. 좋은 서비스를 만드는 회사를 고르는 것도 본인의 능력입니다. 유명한 개발자들은 대부분 유명한 회사에 다니고 있는 사람들입니다. 그 사람을 유명하게 만들어주는 것은 당연히 그 사람의 실력이겠지만 그 전에는 자신이 관여한 성장시킨 좋은 서비스가 있습니다. 그러니 좋은 서비스가 무엇인지에 대한 철학, 좋은 서비스를 만들기 위해서라면 내가 한 것을 갈아 엎을 수도 있는 용기와 끈기, 좋은 서비스를 만들기 위해 협업하고 조율하는 과정, 좋은 서비스를 골라낼 수 있는 시각, 좋은 서비스를 만들기 위한 문제 인식 과정 등 좋은 서비스를 위한 모든 행동들이 잘하는 프론트엔드 개발자로 만들어 줄 수 있습니다. 같은 프론트엔드 동료의 입장에서는 트렌드 파악을 잘하는 사람이 좋다. 같은 개발자 입장에서는 트렌드를 잘 캐치하면서 좋은 소식들을 잘 공유해주는 개발자들이 좋은 개발자입니다. 특히 프론트엔드 분야는 지금 성장속도가 어마어마하기 때문에 이 트렌드를 놓치게 되면 금방 낡은 개발자가 되어 버립니다. 그렇다고 현업에서 쓰는 코드는 항상 머물러 있기 때문에 새로운 것들을 무조건 접하기도 쉽지 않은 상황이죠 나의 트렌드한 개발감각을 유지할 수 있게 새로운 정보를 계속 공유해 주면서 더 나은 Best Practice를 적립해 나갈 수 있도록 도와주는 동료는 참 좋은 존재입니다. 개발에 대한 철학이 뚜렷하고 함께 논의를 할 수 있다면 더더욱 좋겠지요. 프론트엔드의 성장세에 따라 Best Practice가 정립이 되기도 전에 새로운 것들이 나오는 형국입니다. 열린 마음으로 새로운 것들을 받아들이고 끊임없는 탐색을 통해서 최근의 트렌드를 쫒아가는 감각이 매우 중요합니다.  무엇보다 이러한 감각을 토대로 현재 프로젝트에 적절한 기술을 선택하는 밸런스를 갖추는 것이 중요합니다. 검증되지 않은 새로운 것을 잘 못 선택해서 해당 기술이 계속 업데이트가 되지 않거나 주류가 되지 못해서 인수인계를 해줄 사람을 찾지 못한다면 역시 그 프로젝트는 시대는 앞서갔지만 도태되는 프로젝트가 되어버립니다. 그렇다고 레거시를 계속 유지한다면 그런 레거시를 맡고 싶어 하는 개발자는 없기 때문에 어느 순간 회사가 낡아 버리는 현상이 발생합니다. 실제로 이러한 경우로 인해 프로젝트가 다시 새롭게 구성되는 경우를 빈번히 목격하게 됩니다. 트렌드와 현실감각을 유지하면서 적당히 프로젝트를 최신화 하려는 노력이 필요합니다. 🔥 정리: 정해진 리소스안에서 되게 해주는 것! 그리고 협업과 소통, 트렌드와 현실의 균형감각, 좋은 서비스를 만들고자 하는 노력  일정 과  인력 이라고 하는  정해진 리소스 안에서 어떻게든  최대한의 퍼포먼스 를 내어  요구하는 것을 구현 해주는 것이  개발자의 역할 입니다. 이것을 함께 하는 사람들과 원만하게 잘 해낼 수 있는 사람이 좋은 프론튼엔드 개발자겠죠.  그러기 위해서는 요구사항을 잘 이해해야 하고 잘 소통해야 하고  적극적으로 협업 을 해야합니다. 결과적으로  좋은 서비스를 만들어내야 좋은 개발자 가 되는 것이기에 최대한의 요구사항을 충족시키기 위해 노력을 하면서도 정해진 리소스가 부족할때에는 가능한 더 나은 방식을 찾아보고 대안을 제시 할 수도 있어야 합니다. 2인분 이상 하는 법 2인분 이상의 몫을 해내기 위해서는 내가 천재 개발자라서 2인분의 몫을 하는 것은 아닙니다. (물론 그런 사람도 있습니다!) 회사는 곧 집단이고 단체의 문화와 힘을 만들어내는 것은 또 다른 역할입니다. 개인의 일정을 조율하는 것에서 팀 단위의 일정을 조율하고 회사단위의 일정을 조율하는 것, 개인의 기술 스택에서 팀의 기술 스택과 회사의 기술 스택을 결정하는 일처럼 여러명의 개발자들의 능력을 더 끌어낼 수 있고 회사의 이익이 되는 방향으로 설정하는 일이 PM이고 CTO의 역할로 확장이 되는 거라고 할 수 있겠습니다. 궁극적으로 좋은철학을 가지고 회사의 문화를 만들고 그 문화에 어울리는 사람들을 모아서 키워나가는 역할을 한다면 2인분 이상의 역할을 할 수 있을거라고 생각합니다.   그러기 위해서는 좋은 문화와 아이디어의 가치를 탐구하고, 철학을 가지고 Best Practice를 단련하고 트렌드를 주시해서 내것으로 만들 수 있는 노력들이 뒷받침되어야 할 것 같아요. 그러기 위해서 자기를 알리기 위한 PR과 스토리텔링 역시 중요하겠지요. 끝으로... 프론트엔드는 웹 산업이 크게 발전을 하면서 세분화되는 과정에서 태어났습니다. 웹 개발자의 인식이 좋지 않았던 시절도 있었지만 특유의 가벼움으로 인해서 엄청난 성장을 하면서 프론트엔드 분야는 최근 몇년사이에 급격히 성장을 하였습니다. 그리고 앞으로가 훨씬 더 기대되는 분야이기도 합니다. 갑자기 성장을 하면서 생긴 수요로 인해 전통적인 개발자간의 시각차이도 존재하고 있고 프론트엔드의 몸값은 올라갔지만 프론트엔드의 일이 질적으로 달라지지 않은 분야들도 많이 존재해서 아직까지 프론트엔드에 대한 이해도가 많이 없기도 합니다. 더더욱 지금 프론트엔드가 좋아서 웹 개발에 입문을 한 사람들이 생각하는 가치와 실제 수요간의 차이로 인해서 혼란을 겪는 주니어 개발자들도 많은 것으로 알고 있습니다. 웹이 발전하는 지난 20년 그리고 프론트엔드의 체계가 잡히고 성숙해지는데에는 아직 10년도 되지 않았습니다. 그 과정이 시간적으로는 짧지만 그 안에 무수한 이야기들이 있었고 이 글에서 다 담아내지는 못했지만 그래도 지난 프론트엔드에 대해서 이해를 하는데 도움이 되었기를 바랍니다. 그리고 어떻게 프론트엔드가 확장이 되어갔는지 현대의 프론트엔드의 입지와 업무 분야에 대해서 파악을 하고 앞으로 어떻게 성장을 할지 어떤 트렌드로 발전해 나갈 수 있을지 가늠해 보는 시간이 되었기를 바랍니다. 끝으로 프론트엔드 기술과 무관하게 우리는 함께 일하는 개발자이자 동료이기에 좋은 사람이 되어 함께 개발을 하고 싶은 사람이 되고 또 그러한 사람들과 함께 개발을 할 수 있게 되기를 바랍니다. AdorableCSS에서 Reset이나 Normalize를 제공할 생각은 없나요? 프롤로그 현재 AdorableCSS에서 제공하는 Reset CSS는 다음과 같습니다.  *{margin:0;padding:0;box-sizing:border-box;font:inherit;color:inherit;flex-shrink:0;} 최대한 적은수의 양의 CSS를 제공하려고 단순하게 만들었지만, 점차 고민을 하다보니 와 같은 코드도 있으면 좋겠다 싶어서  문득 지금은 CSS Reset을 다들 어떻게 쓰고 있는지  궁금해졌습니다. 초창기에는 분명 IE와 같은 브라우저로 인해 크로스 브라우징이 주요한 아젠다이다 보니 CSS Reset에 대해 관심도가 높았었지만, 2022년을 앞두고 있는 지금은 크로스 브라우징의 원흉이었던 IE는 이제 퇴출길을 걷고 있으며 대부분의 후발부자 브라우저(엣지, 웨일, 브레이브등)은 이제 크로미움으로 통일이 되어가고 있는 상황에서  지금은 CSS Reset을 어떻게 만들어야 할까?  하는 생각이 들었습니다. 그래서 여러가지 관련자료와 애플, 네이버, 다음, 인프런, 오늘의 집, MS, 에어비엔비, 디스코드, 슬랙등의 CSS를 보면서 어떻게 사용을 하고 있는지 한번 확인을 해보았습니다. 그리고 알게된 내용들과 결론을 공유하고자 글을 쓰게 되었습니다. 이번 글의 목차는 다음과 같습니다. CSS Reset 이야기 실전에서는 어떻게 쓰고 있는가? 그래서 뭘 쓰면 좋을까? CSS Reset 이야기 왜 CSS Reset이 생겨났을까? 웹은 아시다시피 웹 문서를 공유 하기 위해서 시작이 되었습니다. CSS가 없이 HTML만 있던 시절 기본적인 태그에는 적당한 서식이 붙어 있었습니다. 이후 CSS가 생기면서 이 서식은  CSS의 기본 default서식 이 되었습니다. 우리는 이 스타일을  User-Agent StyleSheet 라고 부릅니다. 3대 브라우저별 UserAgent Style Chromium (Chrome):  https://chromium.googlesource.com/chromium/src/third_party/+/master/blink/renderer/core/html/resources/html.css https://searchfox.org/mozilla-central/source/layout/style/res/html.css https://trac.webkit.org/browser/trunk/Source/WebCore/css/html.css 안타깝게도 이 기본 서식들은 각 브라우저만의 개성이자 표준이 없던 관계로  브라우저마다 서로 다른 서식 을 가지게 됩니다. 특히 IE가 주류이던 그 시절은 더 심했습니다. 우리는 작업한 결과물이 어떠한 브라우저에서던 같은 모양을 보여주길 원했고 이러한 작업을  크로스 브라우징(Cross Browsing) 이라고 불렀습니다. 그리고 그러기 위해서는 우선 저마다 다른  브라우저의 스타일을 하나로 통일 해야 하는  선행작업 CSS Reset 과  Normalize  와 같은 것입니다. CSS Reset  * {margin: 0; padding: 0} 모든 태그에 적용된 서식에 margin과 padding을 제거하는 방식으로 시작된 이  CSS Reset 이라 방법은  브라우저의 기본요소의 디자인을 모두 없애자는 것 입니다. 이렇게  모두 0으로 만드는 방법을 통해서  브라우저들의 서식을 하나로 통일을 하려고 했습니다. 당시 브라우저에서  * {...}  Selector를 이용하여 CSS를 초기화를 하는 부분에는 성능과 출력의 이슈가 있어서 조금씩 정교하게 CSS를 만들어가면서 여러가지 버전의 Reset이 만들어졌는데 그중  에릭마이어의 CSS Reset 이 가장 유명한 CSS가 되었습니다. 10년도 넘은 지금도 CSS Reset를 검색하면 최상위로 나타나는 자료이며 아직도 쓰이고 있습니다.  가장 유명한 (그리고 오래된...) 에릭마이어의 CSS Reset https://meyerweb.com/eric/tools/css/reset/ CSS Reset은 브라우저의 모든 CSS를 제거하는 식으로 발전하는 과정에서 여러 비판도 있었습니다. Reset CSS를 하기 위해서 필요한 CSS가 점점 커지고 있는 문제. Reset CSS가 정말로 필요한가? 어차피 덮어질 CSS인데 왜 굳이 0으로 세팅을 하고 다시 지정을 하는가?  * {...}  Universal Selector은 성능상에 문제가 있다. :focus { outline: 0 } 과 같은 Reset은 브라우저의 기본 접근성을 해칠 수 있다. 등등 그래서 브라우저의 스타일을 통일하고자 하는 방법은  모든 스펙을 0으로 Hard Reset!  이라는 노선에서 다른 방향으로 진행이 됩니다. 재미로 읽는 그 시절 CSS Reset History https://www.webfx.com/blog/web-design/the-history-of-css-resets/ Normalize 표준이 없던 User-Agent StyleSheet에도 표준이 생겼습니다. 그렇다고 이미 만들어진 브라우저가 표준을 바로 따라 갈 수는 없었지만 새롭게 나오는 스펙들에 대해서는 다소 정리도 될 수 있었고 브라우저간 편차는 점점 줄 수 있었습니다. 여전히 크로스 브라우징의 브라우저의 모든 스타일을 통일을 하는 작업은 필요했으므로  브라우저간에 스타일이 표준 브라우저의 스타일과 동일하게 보일 수 있는 방식  이라는 정규화(Normalize)를 통해서 스타일을 통일하려는 방식이 만들어졌습니다.   이는 CSS Reset에서 보이는 거대 규칙 덩어리의 상속체인을 쓰지 않고서  일단 브라우저 스타일을 통일 했기 때문에  내가 개발할때 쓰던 브라우저(대부분 크롬이겠죠?)의 화면과 다른 브라우저와의 화면이 일치할거라고 생각할 수 있게 되었습니다.  Normalize.css https://github.com/necolas/normalize.css/blob/master/normalize.css Opinionated Normalize Normalize를 통해서 더 적은 코드로 개별 브라우저의 스타일을  표준 브라우저의 스타일 로 맞추는기는 했지만 다음과 같은 의문이 듭니다.  굳이 * {box-sizing: content-box}, html { line-height:1.15 }, sub {bottom:-.25em} 로 통일해야돼? 표준 스타일이 이미 오래된 스펙들로 만들어져있기에,  * {box-sizing: border-box} img { max-width: 100%; height: auto; } table { border-collapse: collapse; border-spacing: 0} 와 같이  표준은 아니지만 더 나은 Default값 들을 반복적으로 쓰게 되니, 아예  Normalize + New Default Style 등을 만들려는 방법들이 등장하게 됩니다.  sanitize.css https://csstools.github.io/sanitize.css/ @NOTE: :where(...) 문법은 css selector의 priority를 0으로 만드는 역할을 해서 css로딩 순서와 관계없이 사용할 수 있도록 하기 위함입니다.  Reboot.css https://github.com/twbs/bootstrap/blob/45eb70e03c1905d247c6e012fff9e263d1326066/scss/_reboot.scss Modern CSS Reset 프레임워크 기반의 개발방식과 시멘틱 태그의 중요성이 상대적으로 낮아진 요즘 normalize.css에 있는  &lt;sup&gt;   &lt;sub&gt;   &lt;details&gt;   &lt;summary&gt;  등 쓰이지 않는 태그들을 위해서 크로스브라우징을 해줄 필요가 있을까요? 라는 생각으로 최소한의 CSS Reset만 사용하면서  box-sizing: border-box ,   table { border-collapse: collapse; }  와 같은  기본보다 좋은 스펙들을 default로 만들어주는  형태의  최소한의 CSS Reset 형태 를 추구하고 있는 것 같습니다.  minireset.css https://github.com/jgthms/minireset.css 실전에서는 어떻게 쓰고 있나? 각 회사 홈페이지 대문을 기준으로 가져왔습니다. 이게 이 회사에서 공통적으로 쓰고 있는 그런거 아닙니다. 그냥 공통점이나 어떠한 흐름이 있을지 파악을 해보고자 가져온 자료이며 실제로 앞서 소개드린 오픈소스와 크게 더 나은 것은 같은 부분은 없고 대동소이한 형태를 이루고 있습니다.  결론부터 말하자면  minireset  과 유사한 형태로  Normalize보다는 Reset이지만 일부만 사용하고 있는 형태 이며 대부분 자기들의 CSS이며 라이브러리를 쓰는 곳은 인프런 정도가 minireset을 쓰고 있는 것을 확인했습니다. 좀 특이해 보이는 것들은 이유가 있어서 작성했을테니 골라 담으셔도 될 것 같아요! Apple.com Google.com Facebook CSS Reset이 없습니다. Github, Medium Normailze.scss 사용 Naver.com kakao.com 그래서 뭘 쓰면 좋을까? CSS는 이래서 참 어렵습니다. 맨날 정답이 없어요...;; 지금까지의 코드들을 통해서 파악한바로는, 앞으로는 reset CSS는 :where(...) 를 이용해서 작성이 되겠구나... normalize보다는 tiny reset이 좀 더 많이 보인다. 역시 정답은 없고 각자 필요한것만 골라 담아가는 형태가 되겠다. 이러한 방향성은 알겠지만 어떤식으로 최종적인 Reset 코드를 만들어야 할지 고민이 되었습니다. 아이러니하게도 제가 찾은 정답은 오픈소스도 현업의 코드도 아닌 개인의 블로그에서 발견한 글이었습니다.  My Custom CSS Reset https://www.joshwcomeau.com/css/custom-css-reset/ 저는 어떻게 만들었을까요? 그래서 지금까지 확인한 내용을 바탕으로 초안을 작성해보았습니다. 지금껏 살펴본 내용과 결이 다를 수 있지만,    AdorableCSS는 AtomicCSS를 더하면서 조립 하는 방식이기에 가급적  하드리셋을 추구하는 방향 으로 설계하는 편이 좋다고 생각했습니다.  table, a, button, img 역시 다루기 편하게 하드리셋을 택했습니다.  box-sizing:border-box, overflow-wrap, webkit-text-size-adjust와 같이 default보다 좋은 값이 있으면 설정해주고 싶었습니다.  IE11은 아직 지원해야 되기 때문에 😢 :where(...)나 all: unset과 같은 최신 스펙은 지양하기로 하였습니다. 자세한 내용은 항목별로 추가 설명을 적어보았습니다. *{margin:0; padding:0; font:inherit; color:inherit;} margin, padding, font, color를 초기화 시켜줍니다. 대부분의 Reset은 여기에 치중되어 있고 Reset의 크기가 커지는 것을 원하지 않아서 *을 사용하였습니다. 예전과 달리 최신 브라우저의 * 성능은 문제가 없는 수준이기에 조금 더 간결한 형태의 Reset을 원했습니다. font:inherit는 버튼이나 Input등의 글자가 고유의 시스템 글자로 되는 문제가 있어 현재 글자와 동일하게 보이기 위해서 추가하였습니다. color:inherit의 경우 a나 input, textarea의 글자색을 그대로 쓸 수 있게 하기 위해서 추가하였습니다. *, :after, :before {box-sizing:border-box; flex-shrink:0;} box-sizing을 border-box로 바꾸는것은 작업을 훨씬 더 편리하게 만들어 줍니다. 최초 박스 모델이었던 content-box는 paddig과 border가 정해진 content-width 바깥으로 만들어지는 구조였습니다. 하지만 width가 auto일 경우에는 부모의 크기를 따라가면서 안쪽으로 padding과 border가 만들어지는 방식이었습니다. 이 점도 충분히 혼란스러운데 대부분의 디자인 툴이 width에서 안쪽으로 padding을 잡는식으로 되다 보니 padding이나  border가 생기면 그에 맞게 계속 계산을 하는게 불편하기 때문에 🔥 최근에 나온 border-box가 default로 설정되는 것은 바람직하다고 생각합니다. 또한 flex-shrink:0 역시 default가 1이 아니라 0이 되어야 한다고 생각합니다. 가급적 원본의 컨텐츠가 잘리지 않고 크기대로 나와주는 것이 좋다고 생각합니다. :root {... overflow-wrap:break-word;word-break:break-word; ... } -webkit-tap-highlight-color: 모바일에 클릭시 검은색 영역이 사라집니다. -webkit-text-size-adjust: 모바일에서도 원래의 폰트 크기대로 출력됩니다. 👍 overflow-wrap:break-word;word-break:break-word;을 :root에 걸어두면 띄어쓰기가 없이 글자를 입력하면 wrap이 되지 않고 삐져나가는 일이 사라집니다.    이제 더이상 CSS는 AWESOME하지 않아도 됩니다! img, picture, video, canvas, svg {display: block; max-width:100%;} 이미지나 비디오가 글자 취급인 inline으로 되어 있어서 외부에서 엘리먼트를 감싸다 보면 꼭 하단에 4px씩의 여백이 생기곤 합니다. 대부분의 미디어 컨텐츠는 block 취급을 받는게 낫습니다. max-width:100%는 CSS가 AWESOME하지 않게 하도록 하기 위함입니다. (삐져나가는 거 금지) 끝으로... CSS는 공부하면 할수록 선택장애가 오는 것 같습니다. 🤔 어떠한 방법이든 화면만 잘 나오면 되는 것은 맞지만 &#39;이게 맞나?&#39;의 끊임없는 물음을 불러일으킵니다. 글을 쓰고 나면 최종 CSS Reset가 정해지지 않을까 하는 생각으로 글을 쓰기 시작했고 그게 한발자국 나아가는 효과를 줬네요. 조금이라도 발전을 할 수 있어서 기분이 좋습니다. 그래서 &quot;저는 뭐 써야 하는데요?&quot;라고 물어보신다면 &quot;CSS에 정답은 없습니다. 필요한것만 그때 그때 골라담으세요.&quot; 라는 답변을 드려야 될것 같아요.  하지만 &quot;그래도 하나를 추천한다면은요?&quot; 라고 물어본다면 하드리셋을 원하신다면 제 것을 추천합니다. 그냥 무난한 것을 택한다면 SPA를 하신다면 minireset을 홈페이지를 하신다면 sanitize를 추천드리고 싶네요. (그렇다고 하고 있던 프로젝트에 덮어씌우거나 하지는 마세요~ 엄청 귀찮아집니다! 사실 Reset이 그렇게 막 대단한 것은 아니잖아요.)  minireset.css https://github.com/jgthms/minireset.css  sanitize.css https://csstools.github.io/sanitize.css/ 끝으로 이거 하나는 확실하게 추천드릴 수 있을 것 같습니다. 제가 새롭게 알게된 이것은 Reset과 관련없이 추천드립니다.   띄어쓰기 안한 글자가 삐져나가는 현상을 막는 꿀팁! https://developer.mozilla.org/ko/docs/Web/CSS/overflow-wrap 아무쪼록 이 글이 도움이 되기를 바라면서 여기에 나와있지 않는데 * 본인이 쓰고 있는 좋은 Base CSS 라인 1줄이 있다면 공유 부탁드려요. *  😘  UPDATE 1/14: 사이트 전체 레이아웃 잡는 방법이 여러가지가 있을텐데 빨리빨리 되지가 않더라고요 많은 연습이 있어야겠지만 flex나 grid 사용해서 어떻게 전반적인 레이아웃 잡으시는지 궁금해요 css 각각의 속성 어떤건지는 대강 아는데 효과적으로 사이트 만드는 건 또 다른 이야기인거 같아서... 어떻게 보면  그리드 시스템?  에 대한 궁금증일 수도 있을거 같습니다만 너무 구체적인 활용예가 궁금한거 같기도 하네요...ㅎ 오늘 글을 쓸 수 있도록 질문은 주신 분께 감사의 말씀을 드립니다. :) 프롤로그 Flex와 Grid의 비교 및 Grid 스펙의 심층 분석 및 CSS Grid Good Parts는 아직도 갈길이 머네요. 그래서 미리 준비한 컨텐츠를 먼저 공개합니다. 질문의 내용에서 순서가 계속 뒤바뀌네요. 😅 이번 글에서는 질문의 주요 키워드 중 하나인  그리드 시스템 에 대해 다음과 같이 내용을 구성해보았습니다. Grid System(그리드 시스템)이란 무엇일까요? 웹에서 Grid System은 어떤식으로 발전을 했는가? CSS Grid로 Grid System 구현하기 개발자와 디자이너에게 Grid System의 의미 끝으로... 언제나 늘 제가 익힌 개념들을 주관적 해석을 더해서 쉽게 풀어내고자 하기에 실제와는 엄밀하게 따지만 맞지 않거나 비약이 있을 수 있다는 점 양해바랍니다. 1. Grid System(그리드 시스템)이란 무엇일까요?  중요! : 일단  Grid System 과  CSS의 Grid Layout 은  다른 겁 니다! 예쁜 디자인을 쉽고 빠르게 하는 방법이 없을까?   Grid System은 1970년대 편집디자인으로 부터 나온 용어입니다. 편집 디자인이란 구성요소들을 잘 배치해서 시각적으로 뛰어난 결과물을 만들어내는 것입니다. 즉 어떻게 배치를 하느냐에 따라서 디자인의 퀄리티가 달라지겠죠.  Grid System의 본질은 각 요소들의 오와 열을 맞추는 것 입니다. 사람들은 뭔가 안정되어 있고 정돈되어 있는 것을 보고 심리적으로 안정감을 느끼고 아름답다고 생각하기 때문에 이렇게 줄을 맞추기 위해서 영역을 만들어 놓고 디자인을 하는 방법을  Grid System 이라고 합니다. 디자이너의 감각에 의존해서 배치를 하는 것보다 미리 잘 짜여진 Frame을 만들어서 선을 그어두고 이를 바탕으로 배치하면 좋은 디자인을 만들 수 있는 것이며  어떻게 그리드를 만드느냐 하는 것 이 곧 좋은 디자인을 만들 수 있는 방법이었습니다. 웹에서도 Grid Sytem이 들어오다. 텍스트와 링크로 되어 있던  웹 에  디자인 이라는 개념이 발전하면서 자연스럽게 이러한  Grid System의 개념 이  웹 디자인 에도 자연스럽게 들어오게 됩니다. 웹은 다른 편집디자인과는 조금 다른 독특한 점들이 있습니다.  크기가 정해져 있는 오프라인 세계의 편집디자인 과는 달리  화면과 해상도가 달라지는 반응형 웹 의 성질을 가지고 있습니다. 디자인된 결과물을  개발자의 구현을 해야하며  디자인에 실제  데이터가 동적 으로 변하는 특징이 있습니다. 그래서 이러한 특성으로 인해 웹의 그리드 시스템은  디자이너와 개발자들 사이에서 함께  발전을 합니다. 웹 Grid System을 이루는 요소들   웹 그리드 시스템은 위와 같이 Column기반의 그리드 시스템을 일반적으로 사용하고 있습니다. 너비를 몇개의 구간으로 나누는지 그리고 사이의 간격과 좌우 간격에 따라 전체적인 디자인의 느낌이 달라집니다.   웹에서 Grid System의 의의 개발자들은 이와 같이 컬럼들의 화면을 만들 수 있는 CSS들을 만들어 둡니다.   디자이너 역시 그리드 시스템에 맞춰서 디자인을 한다면,     출처: 플러스엑스 -  모바일 디자인 할때 그리드 시스템을 사용해야 할까?   https://brunch.co.kr/@plusx/3 그리고 이러한  Grid System을 통해 서 디자인은  변화하는 컨텐츠와 해상도 환경에서도 예쁜 디자인 을 효율적으로 만들어 낼 수가 있고,  개발자 도 이러한 시스템에 맞춰서 디자인을 구현한다면  조금더 효율적으로 디자인을 구현 해 낼 수 있는 것입니다.   출처:  https://www.uiprep.com/blog/everything-you-need-to-know-about-spacing-layout-grids 뿐만 아니라  같은 Grid System 에 속해있다면  디바이스에 따라 컬럼의 수만 다르게 하여  적은 노력으로 적절한 방식으로 표현할 수도 있게 됩니다. 2. 웹에서 Grid System은 어떤식으로 발전을 했는가? 960 Grid System 이게 완전 시초인지는 모르겠지만 아무튼 제가 알고 있는 Grid System의 시초는  960 그리드 시스템 입니다.    https://960.gs/ 이 당시만 하더라도 이러한 Grid System 레이아웃을 그냥 CSS로 작업하기 굉장히 어려웠습니다.  🤔 일단 CSS 자체가 layout을 위해 float을 사용한것을 보면 아주 오래되었음을 알 수 있습니다. 물론 이렇게 만들어두면  정해진 가이드에 맞춰 디자인만 하면 레이아웃을 아주 쉽게 뽑아 낼 수 있기 때문에  대부분의 당시 960 스러운 디자인이 굉장히 유행을 했었습니다. 또한 11 of 12의 grid를 만들기 위해서 width와 margin-left, margin-right를 계산해서 입력을 해야 합니다. 왜 960으로 시작했을지 짐작이 가는 대목입니다. 다른 수치로 직접 만들어야 하는 경우에는 머리가 아플겁니다. 이러한 부분은 2가지 문제를 맞이 하게 됩니다. BootStrap 그 뒤 twiiter에 발표한 CSS Framework가 이 자리를 치고 들어옵니다. 본격적인 CSS Framework의 시대가 만들어지게 됩니다. BootStrap은 960과 달리 Grid System도 있으면서 기본적인 버튼과 다른 폼 요소까지 포함되어 있는 예쁜 CSS였습니다.  하지만 그 당시 BootStrap에서 가장 내세웠던것 역시 Grid System Layout이었습니다. 12개의 컬럼과 반응형으로 대응할 수 있도록 미리 정의된 CSS는 사람들을 혹하게 만들었습니다. 이후 원하는 수치를 마음대로 적용할 수 있도록  less 를 도입해서  Customize CSS 를 만들어주는가 하면  Fluid grid system 을 통해서 % 기반의 레이아웃을 제공하였습니다.  https://getbootstrap.com/2.3.2/scaffolding.html 그 당시에는  calc()  도 없었고 레이아웃도  float 을 이용하여 작업을 했습니다. 이런 Grid System 구현의 필요성에 비해 CSS 스펙이 너무 열악했기 때문에 이런거들을 해결하기 위한 논의가 되기 위한 발판이기도 합니다. 또한 column개수, gutter의 사이즈, container의 width 크기들을 Customize하게 만들기 위해서 CSS도 변수나 함수와 같은 것들이 필요하다보니 less나 sass등의 pre-processor의 필요성도 자연스럽게 연결이 되었습니다. (물론 Grid System때문만은 아니겠죠) https://getbootstrap.com/docs/3.4/css/ 이후 flex, grid라는 새로운 feature가 추가되면서 각각의 방식으로 Grid System Framework가 진화해 가고 있습니다. CSS가 발전하였다! 우리에게는 grid가 있다! 최초에 Grid System Framework가 발전한 이유는 float방식으로 레이아웃을 하는 방법이 직관적이지 않고 복잡했기 때문입니다. 하지만 이러한 과정으로 인해 CSS의 스펙은  flex ,  grid ,  calc  등 여러가지 방법이 만들어졌습니다. 최근의 Bootstrap이나 다른 Framework를 보더라도 이제 Grid System을 만드는 과정이 복잡하지 않습니다. 그러니 Framework의 비중이 예전같지 않게 되었습니다. 그러니 이제 우리는 Framework보다는 Flex Layout과 Grid Layout를 본질적으로 이해해야 가이드라인을 깨는 예외적인 디자인을 구현하거나 새로운 디자인 시스템에 맞는 구성을 만들 수 있기 때문입니다. 그래서  디자인 에서  Grid System을 쓴다면 , 우리도 그에 대응하는  CSS Grid Layout을 만들 수 있습니다 . 이것은 충분히  협의 가 되어야 하는 부분이겠죠. 3. CSS Grid로 Grid System 구현하기  https://css-tricks.com/snippets/css/complete-guide-grid/ https://learncssgrid.com/ Grid Sytem은 Flex말고 Grid로 만들자! 우리의 만능 Flexbox로 Grid System은 얼마든지 구현할 수 있습니다. (float로도 구현하는데요 ㅋㅋ)  하지만 flex로 grid system을 만드는 것은  직관성이란 없고  다소  복잡한 계산 을 해서 만들어야 하기 때문에  flexbox로 Grid System을 직접 만드시는 것은 비추 입니다.  하지만 CSS의 Grid 스펙은 보급률이 낮아서 대부분의 Grid Framework들이 Flex로 만들어져 있습니다. 이것을 가지고 착각을 하시면 안됩니다. 이제 CSS Grid의 사용률은 점차 올라고 오고 있는 추세입니다. 그래서 우리는  CSS Grid 를 이용해서 한번  Grid System 을 만들어 봅시다. 일단 그리드 시스템이 어떠한 요소로 되어있는지 살펴 보고 그에 맞는 코드를 적어 보겠습니다. (코드는 편의상 유틸리티 방식으로 만들고 있지만 스펙을 이해하고 실제 style에 적용을 하시면 됩니다.)   출처: 플러스엑스 -  모바일 디자인 할때 그리드 시스템을 사용해야 할까?   https://brunch.co.kr/@plusx/3   우리는 이와 같이 간단히 그리드 시스템을 만들 수 있었습니다. 단순히 6개의 분할을 하고 싶은게 아니라 여러가지 배치를 하고 싶었던 것이므로 몇가지를 추가해봅시다. 우리가 하고 싶은 것은 컨텐츠가 몇칸짜리인지를 만들고 싶습니다. 그래서 다음과 같은 코드를 생각할 수 있습니다.   참 쉽죠? 여기에 반응형을 첨가해봅시다. 예시로 적당히 썸네일 갤러리 같은 레이아웃을 만들어 보겠습니다. 1024이상에서는 6개, 1024 이하는 4개씩, 타블릿은 3개, 모바일은 2개씩 보여지는 형태로 만들어 보겠습니다.   사실 이것만 구현을 하는 거라면 flexbox로 % width로 할수 있는것 아니냐 하시겠지만,  Grid System의 강점은 디자인 전체가 그리드 기반인 경우에 빛을 발합니다! 예제가 좀 부실한건 인정합니다만 그리드 시스템이 다 적용이 된 반응형 디자인을 구할 수가 없었습니다. ㅠㅠ   이런 예제를 보여드리면 참 좋았을텐데 위와 같이 사이즈에 따라 컬럼의 개수가 달라지고 그에 맞게 크기가 달라지도록 만들기 위해서 위와 같은 반응형 쿼리에 적당히 숫자만 집어 넣으면  반응형 디자인을 아주 쉽게  구현을 할 수 있게 된답니다! 4. 개발자와 디자이너에게 Grid System의 의미 Grid System은 그냥 가이드 라인이다...?  그렇습니다. Grid System은 디자이너에게 좋은 디자인을 할 수 있는 일종의 가이드라인인 것입니다. 열심히 제가 Grid System에 대해서 좋은 점에 대해 설명하고 CSS Grid System Framework에 대해서도 설명을 했지만,  디자이너와 개발자가 완벽하게 약속하지 않는다면  나중에는 개발자의 방식을 디자이너에게 강요하게 되는 셈입니다. 왜냐하면 디자이너에게는 가이드라인이지만 개발자에 시스템이기에 디자인은 &#39;뭐 예외가 있을 수도 있지...&#39; 정도지면 개발자는 그 예외를 구현하기가 여간 귀찮은게 아니거든요.  Google Material Design 의 경우 8dp grid system을 사용합니다. 모든 요소들이 8px 단위로 만들어지죠. 이를 통해서 Grid System의 원래 목적인 줄을 잘 맞출 수 있는 시스템을 제공합니다.   하지만 모든 디자이너들이 이러한 8dp grid system을 좋아하는 것은 아닙니다. 디자인을 하기 위해서 원치 않는 제약은 싫어하는 법이죠. 글자 모양이나 내용에 따라서 조금 더 간격을 다르게 할때 훨씬 더 심미적으로 예쁠수도 있습니다. 물론 원칙을 정하는 것은 필요합니다. 흔히들 알고 있는  디자인 시스템 이라는 것도 Grid System과 같이  제약을 통해서 질서를 만드는  방법론의 총 집합이죠. 디자인 시스템내에 Grid System이 포함이 될테니까요. 그래서 개발자가 디자이너와 협의되지 않은 CSS Grid Framework을 쓰고 있거나 내가 특정 CSS Framework밖에 다룰 수 없다면 계속 디자이너와 부딫힐 수 밖에 없습니다. 언제나 디자인에 예외가 발생을 하는데 디자인의 시스템은 예외를 허용하지만 개발의 시스템은 허용하기 힘드니까요. 정답이 없는 문제이기도 합니다.  확실한 제약으로 인해 효율성을 높이느냐  약간의  예외를 허용함으로써 모든 예외에 대한 대응책을 열어두어야 하느냐 는 선택의 문제니까요. (저는 경험상 디자인 수정에 열려있는 쪽을 택하게 되는 것 같습니다.)  끝으로...  Grid sytem이란? Grid System은 일관성 있는 좋은 디자인을 효율적으로 만들기 위해 만들어진 격자 구조입니다 웹 디자인에서는 보편적으로 12 Column 기반의 Grid System을 사용합니다. 타블렛 8, 모바일 6  이렇게 반응형으로 Column의 개수를 조절하면서 만들어두면 디자인과 개발이 협업할 때 도움이 됩니다. 그래서 Grid System을 CSS에서 구현하기 위해서 많은 발전이 있었다.  현실에서 Grid sytem이란? Grid System은 가이드일뿐 실제로는 안 쓰거나 벗어나는 디자인이 많다. 그래서 grid보다 flexbox를 잘해야한다.  개발이 먼저 Grid System을 먼저 강요하면 나중에 예외의 디자인을 구현하기 어렵다는 것을 알고 있어라! 반드시 디자이너와 협의를 하세요 :) 하지만 디자이너와 합의한다면 넘나 좋은 것! 이번 글에서 우리는  Grid System 에 대해서 뭔지 이해하였고  Grid System을 디자인에서 사용한다면  그에 맞는  적절한 CSS Grid Layout 을 사용할 수 있다는 것도 알게 되었습니다. 하지만 개발은 절대적이나 디자인은 그저 가이드인 상태가 된다면 예외를 처리하기 위해서는  flexbox layout의 기초에 충실해야 한다 는 안타까운 결론도 같이 얻게 됩니다. 물론 합의를 하고 좋은 디자인을 멋진 반응형으로 간단하게 나타낸다면 너무 좋겠죠! 이 글이 웹과 디자인에서  Grid System에 대한 이해 와  CSS Grid 스펙을 이해하면 좋은 이유  중 하나가 되었으면 좋겠습니다.  사이트 전체 레이아웃 잡는 방법 이 여러가지가 있을텐데  빨리빨리  되지가 않더라고요 많은  연습 이 있어야겠지만  flex 나  grid  사용해서 어떻게 전반적인 레이아웃 잡으시는지 궁금해요 css 각각의 속성 어떤건지는 대강 아는데  효과적 으로 사이트 만드는 건 또 다른 이야기인거 같아서... 어떻게 보면  그리드 시스템?에 대한 궁금증 일 수도 있을거 같습니다만 너무 구체적인 활용예가 궁금한거 같기도 하네요...ㅎ 블로그에 글을 이어갈 수 있도록 좋은 질문을 해주신 분께 너무 감사드립니다.  프롤로그 글을 쓰다 보니 이 하나의 질문을 대답하기에 너무 많은 얘기들을 해야 했습니다. 특히  CSS Grid 에 대해서는 빌드업을 해야할 얘기가 워낙 많았기 때문에  Flex vs Grid 의 글을 쓰다가 멈칫해둔 상태입니다. 문의를 해주신 뒤로 시간이 계속 흘러가고 있고 블로그 글을 계속 미루는게 스스로에게 좀 불편했기에,  CSS Grid Layout 에 대한 이야기는 따로 크게 정리하는 시간을 가져보기로 했고, 그 글에서  Grid System 까지 같이 풀어보도록 하겠습니다. 그래서 이번 글의 목차는 다음과 같습니다.  1. 사이트 전체 레이아웃 잡는 방법 2. Grid Layout을 알아보고 Flex layout과 Grid Layout의 차이와 어떨때 어느 것을 쓰면 좋은지? 3. 그리드 시스템이란 무엇인가? 이며 CSS에서는 어떻게 사용하는가 나머지 파트는 다른 글로 찾아뵙겠습니다! 사이트  전체 레이아웃  잡는 방법 사이트 전체 레이아웃을 잡는 방법에 대한 방법과 빨리빨리 연습할 수 있는 방법 그리고 전반적인 레이아웃에 대한 개념에 알아보도록 하겠습니다.   여러가지 레이아웃들을 어떻게 만들까? 레이아웃의 기본은 분할! 선긋기, 자르기, 그리고 Flexbox! 그리고 다음과 같은 규칙을 머리속에 기억해두고 종이를 꺼내들고 네모를 그린뒤에 적당히 선을 한번 그어 보면서 이미지를 그려봅시다. 선은 처음부터 끝까지 그어야 합니다. 그래서 완전히 2개의 영역으로 구분이 되도록 하세요. 같은 방향의 선은 몇번이고 그을 수 있지만 다른 방향의 선은 안됩니다.   영역이 2개 이상으로 분리가 되면  진행방향  이라는 것이 생깁니다. 진행방향은 선의 방향과 반대의 방향입니다. 이렇게 분리된 영역을  컨텐트(Content)  그리고 이 컨텐츠를 묶어주는 것을  컨테이너(Container)  라고 부르며  진행방향은 컨테이너가 결정 하게 됩니다. 처음으로 익혀야할 부분은 이  이 분할과 HTML코드를 이미지로 비슷하게 생각 하는 일입니다. 세로로 선 긋기 = 가로 방향 HTML은 항상 세로로 작성되므로 가로형 컨텐츠에 대해서는 조금 더 생각이 필요합니다. 그리고 레이아웃에 원칙을 하나 더 추가를 하려고 합니다.  거의 대부분 컨텐츠 중  하나 는  Flexible 하다. 아닐경우도 있지만 레이아웃의 경우 반응형을 고려해야 하므로 거의 대부분  나머지 공간의 크기를 모두 받아줄 하나 이상의 메인컨텐츠가 가 있기 때문에, 컨텐츠의 크기가   1) 고정 크기 2) 컨텐츠를 따라가는지 3) 남는 공간을 모두 채우는 flex 인지를 생각해봅시다.   자르기 저도 그런것들은 기초시간에 이미 다 배웠어요. 그정도는 쉽죠! 저는 이런것들을 만들고 싶은거라구요.   두번째로 생각해야 할 것은 복합적인 컨텐츠가 만들어질때의 영역을 나누는 방법입니다. 방법은 간단합니다.   가위로 이 선을 자른다고 생각할때 둘로 반드시 나뉘는 것을 먼저 자르면 됩니다.   이 것들을 한데 모아 조립을 하기 위해서는  제일 큰데부터 안으로 들어가는 Top-Down 방식 과  제일 잘게 잘린 조각들로 부터 올라오는 Bottom-up  방식이 있습니다. 물론 중간부터 하셔도 아무 상관없고 레이아웃과 HTML의 형태를 같이 그릴 수 있는 본인만의 편한 방법을 찾아보세요. 어때요? 참 쉽죠? 죄송합니다... 😚 개념 설명을 위해서 align-items, justify-content, flex, padding, gap등 핵심요소는 포함시키지 못했습니다. 자료를 만들기가 너무 어렵네요ㅠㅠ  레이아웃 분할 에 대한  이미지만 명확히  가져가 주신다면 감사하겠습니다!  CSS 공부 어떻게 해야 하나요? - 이론편 (feat. figma)  을 보고서 flexbox의 나머지 역할들도 다시 한번 상기해주세요. 분할은 내가 해봐야 는다. 뭐 하지만 다들 이걸 모르시겠습니까? 정작 디자인으로 받고 나면 막막해지는 거죠. 특히 현대 웹 디자인의 정석인 Flat Design은 border등을 잘 안쓰는 편이라 어디를 잘라서 나눠야 가늠하기가 어렵습니다.    일부러 복잡한 예시를 좀 가져왔는데 처음에는 간단하게 늘려나가면 좋습니다. 레이아웃을 분할할 때에는 이러한 원칙이 있습니다. 선을 다른 영역을 침범하게 긋지 않는다! 의미론적으로 다른 성격의 것들이 섞이지 않게 잘라야 한다. 세로가 먼저일까? 가로가 먼저일까? 연습하는 법 연습할때는 유틸리티 클래스나 inline-style를 남발해도 좋으니  디자인을 보고 적절한 HTML의 구조를 바로 직관적으로 떠올릴수 있도록  연습해봅시다. 유틸리티 클래스는 홍보겸 제가 사용하는  AdorableCSS 의 문법에서 가져왔지만 본인이 직접 유틸리티 CSS를 만들어보시는 것이 더 좋아요!   Flex? Grid? 더 효과적인 방법은?  레이아웃의 대부분의 경우는 Flexbox가 더 좋습니다.  Grid의 경우 레이아웃이 확정이 되지 않으면 만들기가 어려워서 처음부터 Grid로 레이아웃을 잡고 가면 경직된 구조가 만들어지기 때문에 특히 수정이 잦은 경우에는 좋지 않습니다. 하지만 일단  Grid 세팅이 되고 난 다음의 반응형 처리 라던가  Grid로 했을때 훨씬 더 좋은 구조 들이 존재하니 Flexbox로 먼저 하고 Grid가 더 유리한 곳에는 Grid를 쓰면 좋을 것 같아요. 자세한 얘기는 꼭 다음번 포스트에 작성할 예정입니다! 다음번 포스트 예고:  Flex 와  Grid 를 언제 사용하면 좋은가? 각 레이아웃의 특징으로 알아보는 실전 레이아웃  Grid System 이란 무엇이고 CSS로는 어떻게 구현하는가? 끝으로... 아... 어느 정도의 수준인지를 모르니 강의나 연습용 컨텐츠를 만든다는 것이 정말 어렵네요. 😢 그리고 설명보다 자료를 만드는 게 정말 쉬운일이 아니라는 것을 깨닫습니다. 자자 그래도 확실히 할 것 해두겠습니다. 일단 이것은 강의도 아니고 검증된 효과적인 연습법도 아닙니다(!). CSS를 하다보면 분할이니 선긋기니 이런것들 없이 종국에는  바로바로 직관적으로  생각이 나게 됩니다. 이 글을 통해서 전달하고자 했던 바는,  디자인을 어떻게 레이아웃으로 분할을 하는지 (는 알려주지 않았지만 2번을 통해서 감각을 익히시길 바라며)  분할된 레이아웃과 HTML과 Flexbox 개념의 시각화 이 2번에 대한 것을 이해하는데 있어서 도움이 되기를 바랍니다. CSS Grid 나  Grid System 은 정보를 기반으로 하는 포스트가 될거라서 조금 더 잘 작성할 수 있을 것 같아요. 아무쪼록 이 글이 도움이 되었으면 좋겠습니다.   독학을 하다보니 부트캠프같은 곳에 가보면 어떨까 생각이 드는데... (중략) ... 가격이 너무 비싸서 엄두가 안나긴 해요. 도움이 될까요? 최초의 방아쇠가 된 이 질문이 우리가  5일간 의  스프린트 를 하게되고 이 글을 쓰고 있게 될 거라고 당시에는 생각하지 못했습니다... 그리고 이 말도 안되는 갑작스런 스프린트 체험에 기꺼이 응해주고 함께 해준  썰, 휴파, 감자, 펭귄, 빈츠, 꼬북, 트립, 하디  에게 다시 한번 감사의 말을 전합니다. ❤️ 프롤로그 부트캠프에 대한 이야기를 시작 된 이 주제는 점차... 독학을 하는 사람들은  특히 협업을 경험해보기 힘들고 장기적으로 사이드 프로젝트에 참여 하는 것 또한  부담 스럽기도 하다는 식의 이야기로 이어졌습니다.  협업 의 접점이 가장 많은  프론트엔드  직군이기에  협업을 배울 수 있는 장이 필요 한데 그럴 수단이  부족 하다는 부분은 정말로 공감이 갔습니다. 💨 구글 스프린트 해보실래요? 혹시 5일만 진행하면 해보고 싶으신분 계신가요? 원격으로? 하루 1시간?  그냥 구글 스프린트 5일만 돌려보는거에요!  잘 되든 말든. 개인적인 경험상 정말 좋다고 생각했던  5일간의 협업 프로세스 인  구글 스프린트 협업을 해보는 경험 과  특히 이 스프린트 프로세스가 가지고 있는 힘 을 알려주고 싶었습니다. 일요일 오후 4시에 시작한 이 대화는  월요일부터 금요일까지 5일을 해야하는 스프린트 일정  특성상 월요일 스프린트 시작하는 시간 전까지 참가모집을 하루만 받고 3~4명 정도만으로도 시작하려고 했던 이 스프린트는 무려 9명이나 지원을 해주셨습니다. 너무 감사드립니다. 🥰 😎 구글 스프린트(체험) 1기 모집 완료!  구글 스프린트 라는 프로세스를  경험하는데 목적 을 두었고 아무런 제약도 없고 코딩실력에 대한 제한도 두지 않았습니다.  (물론 사람이 안 모일까봐도 그렇기도 했어요. ^^;)  그래도 마지막으로 최소한의 동기 부여와 책임감을 위해서 이때까지  모든 과정과 만들어진 결과물은 제가 velog를 통해서 외부로 공개를 할 거라고  얘기를 했습니다. (이게 제가 주말에 지금 열심히 글을 쓰고 있는 이유기도 합니다. 저 역시 좋은 글을 남기기 위해서 최선을 다하기 위한  장치 이자  약속 이기도 했습니다.) 실제 구글 스프린트와 같이 할수는 없기에  5일 간  각자 1시간씩만  최소한의 부담으로  사이드 프로젝트 를 진행하듯이 진행을 하였습니다. 앞으로 이 글에서는 실제  구글 스프린트가 무엇 이고 어떻게 진행이 되는 것인지 그리고 우리는 어떤식으로  온라인 으로 그리고  사이드 프로젝트의 형태로  진행을 할 수 있었는지 이렇게 시작된  우리의 스프린트(체험) 과정을 공유하고자  합니다.  목차 구글 스프린트가 뭔가요? 전야제 - 참가 신청서 작성 🗺 DAY1 첫째날(월) - Team Canvas와 Map 🖼 DAY2. 둘째날(화) - SKETCH 🎯 DAY3. 셋째날(수) - DECIDE 🛠 DAY4. 넷째날(목) - PROTOTYPE 🤔😎 DAY5. 마지막날(금) - TEST 🎉 피날레~ 4Ls 회고 끝으로... 구글 스프린트가 뭔가요?   구글 수석디자이너 제이크 냅이 구글에 입사하고 팀 프로세스 개선을 위해 노력한 끝에 만들어낸  5일 만의 아이디어를 검증하는 획기적인 협업 프로세스 입니다. 대부분의 회의는 다른 회의를 부르고 그렇게 업무가 지지부진하게 흘러갑니다. 제이크 냅은 아이디어 회의의 대표적인 방법론으로 알려져 있는  브레인스토밍은 실제로 효과가 없다 는 것을 깨닫습니다. 그리고 대부분의 좋은 생각들은 단체에서 나오는게 아니라  개인이 몰입할때 만들어지고  개인의 몰입은  상황이 급박할수록 더 집중도가 높아지는 것 을 알게됩니다. 또한 이해관계자와 전문가가  처음부터 한데모여  발생하는 문제에 대한 해답을 바로 들을 수 있어서 소통의 속도를 높인다는 것이 중요하다는 것을 깨닫습니다. 이후 구글 벤처스에서 여러가지 프로세스를 실험해보고 검증해본 결과, 이러한 노하우를 한데 모아 이와 같은  5일간의 MAP - SKECTCH - DECIDE - PROTOTYPE - TEST  라는 프로세스를 만들어 냅니다. 구글 스프린트의 핵심 가치과 심리적 장치 ** 구글 스프린트의 핵심 가치는 다음과 같습니다. ** 개인 작업에 집중하기 프로토타입 제작 마감시간이 정해진 프로세스 이해당사자들이 전부 모여있는 워크샵  링겔만 효과 로 불리는 재미난 줄다리기 실험이 있습니다.  각자가 낼 수 있는 최대의 힘을 측정 한 다음 다같이 모여서 최대의 힘을 측정하면 분명 다 같이 최대한의 힘을 내고 있지만  단체의 힘은 개인의 합보다는 훨씬 못 미치는 결과 가 나옵니다. 이 실험은 누군가와 함께 할때 개인이 가진 최선을 다하지 않게 된다는 사회적 태만을 이야기합니다.   우리는 링겔만과 이 실험은 잘 몰라도  &quot;대학생 조별과제 효과&quot;  라고 하는 것은 다 알고 있습니다. 그렇지만 우리는 단체가 함께 하면 더 효과가 배가 되는 경험도 하게 됩니다. 다같이  단체로 영화관람 을 하게 되면 웃긴 장면에서 더 웃기다는 느낌을 받게 되고  단체로 도서관에 가면  더 공부가 잘되는 경험을 하곤 합니다.  같은 라이브 방송을 보더라도 채팅이 있고 함께 하는 시청자 수에 따라 몰입감 이 달라집니다. 실제로 공부를 할 때에도  혼자서 하는 것보다 같이 수업을 듣는 것이 더 효과적 이라는 연구 결과도 있습니다. 또한 우리는 시험기간이 되면 흔히 말하는  벼락치기 공부 를 하곤 합니다. 평소에 공부를 하라고 하지만 잘 안되던 것이  시험 전날은 평소와는 분명히 다른 마음가짐 을 가지게 됩니다. 적어도 시험 전날에 부여받는  그 압박 속의 동기부여 는 벼락치기 공부라는 것을 만들게 되며 이는 실제로 효과를 발휘합니다. 그리고 우리의  뇌는 목적이 있을때 다르게 동작합니다.  평소에 공부하는 코딩테스트 공부와  취업을 목전에 둔 코딩테스트 공부의 몰입도 는 질적으로 다르다는 것을 우리는 알고 있습니다. 그밖에도 우리는 사회적 동물이며 체면을 가지고 있습니다. 이는  사회적 약속과 결합이 되었을때  더 큰 힘을 발휘하게 됩니다. 혼자 있을때에는 무단횡단의 유혹에 쉽게 넘어가지만 여럿이 있을 경우에는 쉽게 그러지 못합니다. 헬스장에서 PT와 함께 하거나 군대에서처럼  다같이 활동을 하고 있을 때에는 평소에 할 수 없는 자신의 한계를 넘어갈 수 있기도 합니다. 끝으로  아이디어가 구현 이 되는데까지  시간이 오래걸린다면  확인 결과 아이디어가 별로더라도  매몰비용 으로 인해 버리기가 힘들어집니다. 이는 인지부조화를 일으켜  안 좋은 아이디어를 계속 고수하게 만드는 장애물 이 되기도 합니다. 구글 스프린트는 이러한 심리적인 장치들로 구성되어 아주  긍정적인 방법으로 사람에게 동기부여를 제공 하게 되고 이는 곧 효율적인 결과물로 이어지게 됩니다. 어떻게 보면  사람을 쥐어짜내는 프로세스 이기에  에너지 소모가 굉장히 많은 방법 이기도 합니다. 그래서 구글 스프린트는  좋은 프로세스 를 넘어  개인과 팀 단위의 동기부여를 일으킬 수 있는 좋은 장치 이므로 알아두시면 좋습니다. 그래서 어떻게 하는 건가요? 그저  5일동안 정해진 MAP - SKECTCH - DECIDE - PROTOTYPE - TEST 프로세스에 따라서 진행 하기만 하면 됩니다.  개인에 집중 ,  마감 ,  프로토타입 ,  모두가 함께 라는  핵심적인 가치 만 벗어나지 않는다면 세부사항은 자유롭게 하셔도 좋습니다. 상세 내용은 책으로 출판되어 있고 유투브 영상에도 있으니 따로 확인 하실 수 있습니다. 하지만 실제로는 하루 8시간씩 5일동안 스프린트에만 집중하는 것은 현업에서도 취준생끼리 혹은 대학생끼리도 쉽지 않습니다. 여기서는 아무런 연고가 없는 사람들끼리 코로나 시국에서 비대면을 통한  저희만의 방식으로 어떻게 스프린트를 했는지 공유 를 해볼까 합니다. 전야제 - 참가 신청서 작성 참가에 제한은 없습니다. 실력도 보지 않습니다. 새로운 사람들을 만나고 구글  스프린트를 체험 딱 5일간 하루에 1시간만!  그 이상의 열정을 다른 참여자에게 서로 요구하지 않습니다! 이러한 슬로건으로 참가자 신청을 받았으며, 아주 열정적인 분들이 신청을 해주었습니다. (고맙습니다! 😘)   우리는  하루에 1시간씩 만 시간을 함께하기로 했기 때문에 실제로 해야 하는 작업들은  개인 과제의 형식 으로 진행을 하기로 했고,  미리 필요한 내용 들과 첫째날 해야할 과제인  내가 만들어 보고 싶은 아이디어 를 미리 생각하고 오기로 하였습니다. 그리고 본인의  이름이 아닌 닉네임 을 받도록 하였습니다. 수평적인 문화는 자유로운 호칭에서 나온다. 이제는 많은 회사에서 많이들 사용하고 있는 닉네임을 호칭으로 하는 문화를 쓰고 싶었습니다. 서로에게 존대말을 쓰되 호칭에는 직책이나 ~님을 붙이지 않고 ~께서, ~시와 같은 높임법은 쓰지 않는 방식입니다. ex) 테오님은 어떻게 생각하세요? (X) 테오! 이거 어떻게 생각해요? (O) 이렇게 함으로써  서로를 존중하되 나이와 능력에 관계없이  너무 거리를 두지 않고 눈치 보지 않게 그리고  대립된 의견도 충분히 낼 수 있도록  하는  장치 가 되기를 바랬습니다. 또한 나머지 받은 내용들은 다음 소개할  Team Canvas 를 하기 위함이었습니다. 🗺 DAY1 첫째날(월) - Team Canvas와 Map 월요일날 해야하는 가장 중요한 일은 모두가 같은 곳을 바라볼 수 있도록  모두가 합의된 목표를 산출 하는 것입니다. 우리가 어떠한 물건을 함께 옮긴다고 생각해봅니다. 다같이 힘을  하나의 방향 으로 쏟지 않고 제각각의 힘을 쓴다면 실제로 들어간 힘에 반해서 이동한 거리를 얼마 되지 않을 것입니다. 서로 맞지 않는 방향으로 힘을 쓴다면 오히려 개인이 더 노력을 한 만큼 사실은 방해가 될 수도 있습니다. 인생을 살다보면  서로 열심히 하기 때문에 더 감정의 골이 깊어지는 경우 가 있습니다. 그렇기에 맨 처음  모두의 컨텍스트를 합의 하고  하나의 주파수로 맞추는 작업은 대단히 중요 하며 여기에는  하루를 전부 쏟을 만큼의 가치 가 있습니다. Team Canvas    http://theteamcanvas.com/ (Team Canvas는 구글 스프린트와는 아무런 관계는 없습니다.) 전혀 일면식도 없던 사람들끼리 무언가를 목표를 정하고 업무를 바로 시작하기는 힘들겠죠? 그래서 새로운 팀 문화를 만들어가는 오리엔테이션으로 사용되는  Team Canvas 를 작성해보는 시간을 가져보기로 했습니다. 실제로 프로젝트를 하면  팀이 추구하는 목표 와  개인이 개인적으로 추구하고자 하는 목표 가 다릅니다. 그러한 부분이 맞지 않다면 프로젝트에 주인정신을 가지기도 힘들고 업무가 재미가 없죠. 우리가 어떤 생각을 가지고 팀이 이루어지는 알고 있는 것은 중요합니다. 또한 각 개인의 성향과 개인의 어떤 강점이 서로 다르기 때문에 이것들을 미리 잘 있어야  좋은 팀 문화 가 만들어집니다. 그러기 위해서 새로운 팀이 구성되거나 이미 구성된 팀에 새로운 멤버가 합류한 경우 이러한  Team Canvas 를 작성하고 함께 가치를 논하는 일은 소중한 경험입니다. Team Canvas는 다음과 같은 항목으로 구성되어 있습니다.  (1) 이름과 역할(People &amp; Roles):  이름과 가진 자신이 맡은 혹은 맡을 수 있는 역할을 간단히 적는다. 서로 잘 모르던 구성원이 있으면 이를 통해 서로 소개한다.  (2) 공동의 목표(Common goal):  팀이 성취하기 원하는 공동의 목표를 각자 적는다. 공동의 목표에 대해 얼마나 동의가 되는지, 실행 가능한지 여부를 함께 토의할 수 있다.  (3) 개인의 목표(Personal goal):  공동의 목표와 연결된 개인의 목표를 적는다. 조직의 목표가 개인의 목표와 얼마나 연결되어 있는지 토의할 수 있다.  (4) 목적(Purpose):  공동의 목표에서 조금 벗어나, 팀으로서 궁극적으로 이루고 싶은 목적을 적는다.   (5) 가치 (Values):  팀이 생각하는 핵심 가치를 적는다. 가장 중요한 원칙을 말한다. 팀원 모두가 동의하고 이를 확정하면 팀원 모두가 이를 받아 들어야 한다. &#39;신뢰&#39;, &#39;창의력&#39;, &#39;품질&#39;, &#39;평등&#39;, &#39;존중&#39;  등의 단어들로 작성할 수 있다.  (6) 강점과 자산(Strength &amp; Assets):  개인이나 팀이 가진 역량과 재활용할 수 있는 자산을 적는다. 개인의 강점에 대해 적는 것도 좋다. 예를 들어, &#39;설득을 잘함&#39;, &#39;보드게임에 대해 많이 알고 있음&#39; 등도 강점이 될 수 있다. 이를 통해 팀원들에 대해 더 알게 되고 이를 존중하며 좋은 팀워크를 만들 수 있다.  (7) 약점과 위험(Weaknesses &amp; Risks):  개인이나 팀이 가진 부족한 점과 극복해야 할 부분에 대해 적는다. 예를 들어 &#39;쉽게 집중력이 흐트러짐&#39;, &#39;가끔 지나치게 토론에 몰입함&#39; 등은 서로 일하면서 존중해주고 도와줄 수 있는 공유를 가능하게 한다. 단, 다른 이의 부족한 점을 작성하는 것은 좋지 않다.  (8) 필요와 기대(Need &amp; Expectation):  팀의 공동의 목표를 이루기 위해 필요한 것들을 작성한다. 강점과 약점에 대해 공유 한 뒤 이 강점을 강화하고, 약점을 상쇄하기 위해 실질적으로 필요한 것들을 적을 수 있다.   (9) 규칙과 활동(Rules &amp; Activities):  팀이 지켜야 할 공동의 규칙들에 대해 이야기한다. 출처:  아이스브레이킹 - 팀 캔버스  :  https://brunch.co.kr/@hubertshin/54 원래는 각 항목과 관련해서 5분씩 작성하면서 포스트잇을 붙이고 발표하고 논의하면서  충분히 서로에 대해서 알아보는 시간 을 가져야 했지만 우리에게는 시간이 없어서 미리 작성해둔 내용을 바탕으로  figjam 이라는 공간에  Team Canvas 를 작성해 보았습니다.     대부분  열정이 가득한  주니어분들이 참여해주셨습니다. 감사합니다 👍   본격적인 스프린트의 시작! - 첫째날의 핵심 MAP 첫째날의 핵심은 모두가 같은 생각을 공유하는 것입니다. 우리에게는 큰 대의라는 것은 없었기에  각자 만들고 싶은 어떤 아이디어들 을 발표하고 합의하고 그 안에서 가장 마음에 드는 아이디어를 결정하는 시간을 가져보기로 하였습니다. 구글 스프린트에서 중요한 가치는  개인에 집중 ,  마감시간  이 있습니다. 이러한  발표 와  합의  그리고  결정 을 할때에는 반드시 시작과 끝, 그리고 명확한 목표 그리고 마감시간의 설정이 중요합니다. 마감시간! 타임타이머? 타임 타이머 입니다. 실제로 목표와 마감시간을 설정하고 행동하는 것에 대해서는 동기부여 효과가 상당하죠. 저희는 figjam에서 했기 때문에  figjam의 타이머 기능 을  매번  지속적으로 사용했습니다. 구글 스프린트에서는 무한정 기다려주지 않습니다. 대부분의 의사 결정이나 준비 시간을  미리 설정  하고 그 안에서 진행할 수 있도록 하였습니다. 이러한 장치는 지지부진한 회의를 막아줍니다.  시간이 적다구요? 절대로 그렇지 않습니다. 좋은 아이디어나 생각들은 시간이 길다고 만들어지는 것이 아닙니다.  원래 내 머리속에 있는 것들이 이 마감시간이라는 장치로 인해 꺼낼 수 있도록 도와줍니다. 각자 발표를 준비하는 시간  5분 이 주어졌습니다. 이미 과제로  내가 만들고 싶은 아이디어  에 대해서는 준비를 할 수 있도록 과제를 내주었기 때문에 5분이라는 시간은 준비한 과제를 figjam에 옮기는 시간일 뿐입니다. 그리고 각자 준비한 자료를 보면서 어떤 아이템인지 발표하기전에 서로의 아이디어를 검토해보며  미리 먼저 상상해보고(중요!)  궁금한 내용은 입력하거나 맘에 드는 내용들을 스티커를 붙일 수 있는 시간을  10분  동안 가졌습니다. 실제로 밖으로 꺼내기 전 보다 머리속에 있는 상상이 더 좋을때가 있습니다. 상대방의 생각이 구체화되어 발표하면  내가 더 상상해볼 여지 가 없어지기 전에 먼저 간단한 내용들을 통해서 나만의 더 좋은 상상을 할 수 있게 하고 실제 발표와 차이가 있을때에 그 갭을 메워가며 적극적으로 들을 수 있기 때문에 무언가 발표를 하기 전에  미리  발표자료에 대해서  적극적인 검토를 할 수 있는 시간을 갖는 것 은 중요합니다. 그리고 각자 돌아가면서 발표하는 시간을  2분씩  가졌습니다. 2분동안은 개인의 발표 내용으로 어떻게든 시간을 채워야 했습니다. :)   아이디어들의 경합! 그리고 최종 결정된 아이디어는....? 최종적으로 스티커나 공감을 많이 받았던 아이디어가 바로 이 두 가지 아이디어로 좁혀졌고요. 다시 각자의 시간을 선택할 수 있는 각자의 마음을 선택할 수 있는 시간을  5분  가지도록 했습니다. 그리고 본인이 결정한 거에 대해서  미리 쓰고(중요!)  각자 왜 그런 생각을 했는지 발표를 하도록 하겠습니다.   미리 본인의 의견을 쓰게 하는 이유는 대세에 휩쓸리지 않도록 본인의 의사를 확실히 할 수 있게 하기 위함입니다. 거수나 스티커 투표 과정을 중간에 대세감이 조성되지 않도록 했으며 발언 순서는 랜덤한 룰렛을 이용했습니다.  각자가 적어놨던 내용들을 바탕으로  내가 왜 이게 좋은지 얘기하는 시간을 가졌습니다. 그리 해서 최종적으로 저희는  감자의 아이디어 가 채택이 되었습니다. 🖼 DAY2. 둘째날(화) - SKETCH 화요일이 되었습니다. 화요일에서 가장 중요한 과제는 실제 모습을 상상하며 장면을 그려보는(스케치)가 중요합니다.  아이디어 스케치 단계 입니다. 메모장에 그려서 사진을 찍어서 figma에 올려주세요. 직접 그리셔도 좋고 &gt; 상상할 수 있을 만한 레퍼런스 이미지를 가져오셔도 좋습니다. 스프린트에 효율적인 멤버의 수는 몇명일까요? 저를 포함 9명이라는 참여자의 숫자는 스프린트에서 좋은 숫자가 아닙니다. 사람들은  몇 명이 모여 있느냐에 따라  말을 하는  화법이 달라지게 되며  특히 일정 수가 넘어가게 되면 대화가 아니라 발표의 양식이 됩니다. 이때에는 사회자가 없이는 진행이 불가능해지므로 적절히 대화가 가능한 인원수가 되는 것이 좋습니다. 구글 스프린트 책에서도 최대 7명 이상을 넘기지 않는 게 좋다고 합니다. 현재 멤버는 충분히 많기 때문에 이제 멤버의 수를 조절해서 회의를 할 필요가 있고  때로는 함께 하고  때로는 소그룹으로  회의를 진행하기에  화상회의보다 조금더 좋은 도구 를 사용하기로 하였습니다. 이것이 메타버스다! 게더타운으로 오세요~    https://www.gather.town/ 요즘 대세 키워드인 메타버스에 충실한 협업도구  게더타운 에  테오의 스프린트 1기  오피스가 만들어졌습니다. 다같이 얘기를 할때에는 회의실로 모이고 각자 팀별로 작업을 할 때에는 각자의 공간으로 가서 회의를 할 수 있게 되었습니다. 그리고 언제든 필요할때 이 가상 오피스에 모여서 각자 논의할 수 있는 시간을 가질 수 있게 되었습니다. 둘째날의 핵심 SKETCH! 랜덤 추첨을 통해서 조를 뽑았고요 이렇게 만들어진 두 개 조가 만들어져서 이제 각자의 조에 들어간 사람들끼리 아이디어를 발전하고 스케치하는 시간을 가졌습니다.   각자의 생각을 공개하는 시간을  또 타이머를 이용해서 발표를 하고  그 안에서  좋은 의견들을 또 투표를 하고  이때 둘째 날에 중요한 것들은 계속 의견을 발전시키고 계속적으로 발산하는 아이디어 회의라는 것을 계속 주지를 시켰습니다. 둘째날 부터는 어떻게 세부적인 이야기가 흘러갔는지 저는 모릅니다. 이렇게  잘만들어진 프로세스의 레일위로 올려놓기만 하는 것 으로 제 역할은 다했다고 생각했습니다. 피그마 위의 아이디어들이 점점 쌓여 가고 있었고 이 과정에서 충분히 각자 정말 친해졌을거라고 생각을 합니다. 어떤 내용들이 오갔는지  굉장히 궁금했지만 꼭 참고  셋째 날의 과제를 던져주는 식으로 마무리를 지었습니다.   아! 지금 무슨 이야기들을 하고 있었을까요? 🎯 DAY3. 셋째날(수) - DECIDE 오늘 미팅에서의 목표(DECIDE)  구현해야할 모든  스토리보드 를 확정 짓습니다. 시간관계상 figma에 잘 그릴 필요는 없고 손으로 그려도 좋으니 모든 스토리가 담겨있고 팀원들이 공유할 수 있는 그림이나 혹은 글로만 되어 있는 문서라도 좋습니다.  각자의 역할과 구현해야할 내용에 대해서 명확한 Role를 결정해 주세요. 수요일의 목표는 지금까지 만들었던 솔루션들 중에서 실제로 만들어 보고 검증하고픈 제일 좋은 것들을  결정하는 날 입니다. 또한 내일 해야할 프로토타입을 만들 수 있도록 하는 전체  스토리 보드를 확정(중요!) 해야 합니다. 사실상 이때 부터는 이미 각자의 팀이 스스로 잘 굴러가고 있었기 때문에 저는 특별히 관여하지도 않았고 어떤식으로 의사 결정이 되었는지 모릅니다. ㅋㅋ  스토리보드 에 대한 이야기를 하게 되면 길어지기 때문에 따로 한번 다루도록 하고,  DAY3가 참 중요한 날 인데 컨텐츠가 너무 비어있어 보여 제가 전달했던 전체 공지의 일부를 공유하며 넘어가도록 하겠습니다. -- 수요일 공지 메일 중에서... 🛠 DAY4. 넷째날(목) - PROTOTYPE 목요일이 되었습니다. 수요일날 만든  스토리보드 를 기반으로 하여 다음날 테스트가 가능하도록 실제로 구현을 하는 날입니다. 배포나 테스트를 할 수 환경을 갖추는 것이 가장 중요하기 때문에 배포나 서버 환경 세팅을 최우선적으로 해달라는 요구 사항을 드렸고 각각 각자의 역할에 충실하게 각자가 맡은 페이지를 만들고 통합하는 과정을 가졌습니다. 이 부분에 대해서는 제가 전혀 개입하지 않았습니다. 이제는 스스로 단톡방도 만들어지고 git을 통해서 소통을 하는 모습들을 보면서 뿌듯해졌습니다. 다들 현업이 있고 각자 생활이 있는 상태여서 실제 만큼의 투자를 할 만한 시간적 여유가 없기 때문에  우리의 목표는 완성도가 아니라 프로세스를 체험하는 것 이라는 것을 상기시기며 시간 투자를 많이 하지 못하는 부분에 대해서 아쉬워 하지 않기를 바랬습니다. -- 목요일 공지 메일 중에서... 🤔😎 DAY5. 마지막날(금) - TEST 드디어 마지막 날 금요일이 되었습니다. 지금까지 만들었던 것들에 대해서 실제 처음 생각했던 아이디어가 효과가 있는지  테스트 를 통해  최초의 아이디어를 검증 을 하는 날입니다. 원래는 전혀 이러한 것에 대해서 알지 못하는 사람들을  5명정도  테스트를 하라고 하지만 테스터를 모셔올 수는 없는 상황에서 구현 내용을 전혀 알지 못하는 제가 테스터가 되었습니다. Selector  https://d1eakt2myedioc.cloudfront.net/   &#39;룰렛을 선택하는 메뉴의 스크롤 영역이 좀 좁은거 같아요.&#39;, &#39;수정보다 돌리기 버튼이 더 위에 있으면 좋겠네요 :)&#39; 등과 같은 의견을 전달해보았습니다. Picker  https://www.picker.run/   &#39;룰렛을 돌려주세요에서 아래 버튼을 눌러야 하는 건지 몰랐어요.&#39;, &#39;룰렛이 변경될때 상호명 뿐만 아니라 메뉴판이나 사진등도 같이 나오면 좋겠어요 :)&#39; 과 같은 의견들을 전달해보았습니다. 각자 스스로도 알고 있는 문제도 있었고 시간 문제로 실제 만들고자 했던 것 만큼의 완성도를 못 낸 부분도 아쉽다고들 생각했지만, 각자 현생을 살고 있고 실제로  개발에 온전히 투자  할 수 있는 시간이  몇 시간도 채 안되는 시간 을 가지고  프로젝트 환경을 세팅 하고  백엔드 와  프론트엔드 를  구현 하고  배포 하고  테스트를 할 수 있을 만큼의 결과물 을 만든 점에 대해서 저는 너무 자랑스러웠습니다. 무엇보다 본래 우리의 목적은 완성된 훌륭한 결과물이 아닌  구글 스프린트 체험 과  좋은 사람들을 만나고 협업해보는 경험 이니까요! 🎉 피날레~ 4Ls 회고  Team Canvas  처럼 구글 스프린트에 없는 절차지만 그래도 뭔가 마무리로  의미 있는 시간들 을 좀 가지고 싶었기 때문에 일반적으로 프로젝트 진행 후 분기나 6개월 단위로 한번씩 진행하게 되는  회고 의 프로세스를 알려드리고 공유드리고 싶었습니다.  여러가지 회고 방식 이 있지만 저희는  4Ls 라는 회고를 진행해보았습니다. 4Ls란?  Liked: Learned: Lacked: Longed For:  스프린트 동안 할수는 없었지만 했으면 하고 바랬던 것이 무엇이 있을까요? 이것도 기술적인 것도 비기술적인것도 될수 있습니다. 출처 -  세가지 회고 도구   https://humbleagilecoach.tistory.com/5 이렇게 4가지의 L 주제를 바탕으로 각자 얘기를 해보고 특별히 같이 얘기를 해보고 싶은 주제를 투표하여 같이 이야기를 해보고 싶은 이야기를 해보았습니다.     펭귄님에게 스티커가 없는 것은 개인적인 사정으로 조금 늦게 참여하셨기 때문입니다! 오해 검지 검지! 각자  3장의 투표권 을 행사하여 공감가고 같이 이야기를 해보고 싶었던 키워드를 추출해보았습니다.   공통적으로  좋은 사람들과 함께 하는 경험 을 해서 좋았으며  강제로 진행이되는 구글 스프린트의 힘!  을 배웠다고 했습니다. 한편 하고나니  내가 낸 아이디어로 다시 해보고 싶다  라는 의견이 많았구요.  구글 스프린트에 대해 좀 더 알았다면 더 잘할 수 있지 않았을까?  하는 아쉬움등이 있었습니다. 끝으로... 구글 스프린트가 무엇인지 그리고  저희가 진행했던 5일간의 여정 의 간접 경험이  흥미 로웠기를 바랍니다.  책을 아무리 읽어봐도 사실 이것을 쉽게 느낄 수 없습니다.  쪼여 들어오는 마감과 압박 과 사람들로 인해서 만들어지는 이  프로세스의 힘 은 아무리 글로 설명을 해도  한 번 체험하는 이 효과 가 정말 크거든요. 실제 저희가 했던 것들은 구글 스프린트 책에 있는 정석과 같은 방법은 분명히 아닙니다. 하지만 그게 뭐가 중요합니까? ㅎ  개인에 집중 ,  마감 ,  프로토타입 ,  모두가 함께 라는  핵심적인 가치 만 지킨다면 얼마든지 간소화된 형태로 프로세스를 진행시켜 볼 수 있다고 생각합니다. 프로세스는 누군가 똑똑한 사람이 이끌지 않더라도 누구가 이러한 효과를 받을 수 있도록  잘 설계된 시스템 입니다. 그래서 꼭 협업을 어떻게 하면 좋을지 혹은 구글 스프린트 말로만 들어 봤지만 뭔지 궁금하셨던 부분들에 대해서 이 글이  조금이나마 가이드의 역할을 해줄 수 있기를  기대합니다. 좋은 결과물을 만들지 못하면 어떡하지? 나는 한번도 안 해봤는데 제대로 안되면 어떡하지? 라는 생각은 떨쳐보세요. 스프린트의 마지막은 실패하면 실패했던 거에 대한 회고를 하는 것으로  스프린트의 완성 입니다. 특히 스프린트는 개발자간의 협업이 아니라  기획 ,  디자인 ,  개발 ,  사업  과 같은  서로 다른 영역의 사람들 과 함께 할 수록 그 가치가 커집니다. 그런 의미에서 이번 스프린트에 디자이너가 포함이 되었다면 훨씬 더 완성도 있는 재밌는 결과가 나오지 않았을까 생각을 해보게 되네요. 끝으로 갑작스런 이벤트 - 그래서 더 재밌었던ㅋ - 에 참여해 준  썰, 휴파, 감자, 펭귄, 빈츠, 꼬북, 트립, 하디  에게 다시 한번 정말로 감사한 마음을 전합니다.   끝으로 이 글이 읽는 분들에게 동기부여가 되고 좋은 가이드가 되어 주변 사람들과 함께 구글 스프린트를 진행해보는데 도움이 되기를 바랍니다. :) [더보기!] 참여자 관점에서 느낀 후기도 궁금하시다면 다른 글도 한번 읽어 보세요! 트립:   구글 스프린트 체험 1기  5일간 야생에서 살아남기(feat. 테오의 스프린트 1기)  여태까지 내가 했던 회의는 모두 가짜였다!(feat. 테오의 스프린트 1기) https://velog.io/@devdynam0507 9,000명이 넘는 개발자가 State Of JavaScript 설문조사의 첫 번째 버전에 참여했습니다. ... 개발자가 다음에 가장 배우고 싶어하는 라이브러리와 만족도가 가장 높은 라이브러리를 찾을 수 있습니다. 그리고 이 데이터가 끊임없이 변화하는 JavaScript 생태계를 이해하는 데 도움이 되기를 바랍니다. - stateofjs 서문 중에서 발췌 프롤로그 프론트엔드 추천 사이트 좀 알려주세요! 이런 질문을 받을 때마다 추천 해주는 사이트에는 항상 빠지지 않는 statofJS, statofCSS 사이트입니다. The State of CSS 매해 새롭게 바뀌어가는 CSS, JS 생태계의 변화를 쫓아가기란 쉽지 않습니다. 늘 새로운 게 나오고  또 새로운 것은 항상 &#39;이게 정말 쓸만한가?&#39; 라는 물음이 동반됩니다.  그래서 수많은 개발자들에게 설문을 통해 올해 최신기술에 대한 동향과 선호도를 조사하는 프로젝트가 바로 stateofjs, stateofcss입니다. 최초 2016년 stateofjs로 시작한 이 프로젝트에서 오늘 도착한 가장 최신 소식인  &quot;statof of css 2021&quot;에 대한 소개와 주관적인 입장의 리뷰 를 진행해보고 자합니다.  https://2021.stateofcss.com/en-US/ statofjs, stateofcss의 뉴스레터에 가입을 하면 설문기간에도 메일이 옵니다. 이 설문을 통해서도 트렌드를 알기 쉬우니 같이 참여를 해보세요. 떴구나!   주목해서 봐야 할 부분 나마지도 모두 읽어보면 좋습니다. 그중에서도 주목해야 하고 학습에 도움이 되는 영역은  Features 와  Technologies 입니다. Features    Features 는  CSS에서 비교적 최근에 생긴 새로운 문법 에 대한  인지도 나  사용량 에 대한 설문 결과를 보여줍니다. CSS는 새로운 Spec이 나와도 브라우저에서 지원을 하지 않거나 Best Practice가 만들어지지 않으면 쉽게 사용하기가 힘듭니다. 하지만 대세가 되는 순간이 되었을때 어느샌가 다들 그것을 쓰고 있기 때문에 이제는 나도 써도 되겠구나 할 수 있습니다. CSS GRID   CSS  GRID 의 경우 사용하는 사람들이  2년전에는 절반 밖에 되지 않았지만  GRID는 점점 주류 가 되어가고 있는 것을 확인 할 수 있습니다. 저도 지금까지는 거의 Flex 레이아웃으로만 작업을 했지만 슬슬 Grid Layout을 연구해야겠다 생각 중이며 Best Practice를 찾아가는 중입니다.  FLEXBOX   이제  FLEXBOX 를 모르면 CSS를 할 줄 안다고 할 수 없겠네요! GAP PROPERTY FOR FLEXBOX   제가 CSS Practice에서 소개한  gap  속성입니다. 아직은 쓰고 있는 사람들이 절반정도 되고 있다는 것을 알수 있습니다. 이러한 속성들은 IE나 safari등에서 지원을 하지 않는 문제가 있어 당장은 polyfill사용법등으로 귀찮으나 나중에는 주류 기능이 되지 않을까 생각합니다. 그 밖에 눈여겨 볼만한 것들 기타 눈여겨 볼만한 Feature들을 추려봤습니다. 나머지도 꼭 직접 확인해보시고 저게 어떠한 스펙이며 어떤 브라우저가 지원 중인지를 알고 계시면 좋을 것 같아요.  https://2021.stateofcss.com/en-US/features CSS GRID Subgrid Flexbox CSS Multi-Column CSS Writing Modes position: sticky Logical Properties aspect-ratio content-visibility Gap property for flexbox Break rules Container Queries CSS Scroll Snap overscroll-behavior overflow-anchor touch-action pointer-events scroll-timeline 기술 면접에서도 가끔 새로운 CSS Feature에 대한 관심이나 소감, 내용을 묻는 경우가 있어요! 쓰지 않더라도 알아두시면 좋을 거에요 :) Technologies  Technologies 는 CSS 스펙이 아닌 Sass나 Styled-Component와 같이 CSS를 이용하는 라이브러리에 대한 동향을 소개합니다. 보통 이런 기술 스택은 배우는데도 시간이 걸리고 그런만큼 갈아타는 데 비용이 발생하므로 대중적이면서도 좋은 기술 스택을 가지고 있거나 배우기 위한 좋은 자료가 됩니다. 2020   2021    그래프의 의미 ASSESS ADOPT AVOID ANALYZE : 사용자는 많지만 만족도가 낮은 기술 (갈아탈지를 생각해봐야 하는 기술) 2021년 올해는  ASSESS  에 기술들이 대거 몰린 것이 특징이네요. 그리고 그 대부분이  React 계열에서만 사용이 가능한  CSS in JS  기술인 점도 흥미롭습니다.   Style을 컴포넌트와 같이 관리하지 못한다는 약점 을  CSS in JS 로 해결해주는 StyledComponent  등으로 보고나서 이후  CSS in JS 의 약점인  표현력 ,  Runtime Generate  등의 문제등을 해결하는  Zero-runtime  방식들이 많이 포진 했네요.  windiCSS ,  twin 과 같은 tailwindCSS를 React에 넣으려는 시도들도 주목을 받고 있는 것 같습니다. 그밖에 읽어볼 것들  https://2021.stateofcss.com/en-US/resources   CSS는 대부분 스스로 공부를 하네요. 다들 그런다고 합니다. 힘내십시오!!   양질의 자료를 얻고 싶다면 한번 여기 나와 있는 사이트에 한번 접속해서 읽어보세요!   https://css-tricks.com/snippets/css/a-guide-to-flexbox/ 끝으로... 충분히 제 개인적인 입장에서의 리뷰를 마지막으로 정리해봅니다.  React가 아니라 Svelte를 밀고있는 유저로써 CSS의 발전이 지금 React의 CSS in JS에 몰빵이 된 느낌의 2021년은 좀 씁쓸하네요. ㅠㅠ  CSS 신문물의 척화비이자 방파제였던 IE11의 퇴출이 기정사실이 되면서 IE를 고려하지 않아도 되니 쓸수 있는게 늘어나면서도 알아야할 것까지 늘어나서 빨리 다시 저만의  Best Practice 의 툴킷을 재정비해야 겠다 생각이 듭니다.  제가 밀고 있는  AdorableCSS 의  on-demand atomic css 방식은 아직은 주류가 아닌가 봅니다.   라이브러리를 선택할때 가장 중요한 factor는 결국 문서죠. 맞습니다. 저도 열심히 문서화를 해야하는데 문서화는 또 다른 재능인것 같아요. ㅠㅠ  https://developer-1px.github.io/adorable-css/ 새로운 시대를 미리 앞서가고 있다고 믿고 있지만 힙스터 감성일지 아니면 우물한 개구리의 공허한 외침이 될지는 모르겠지만 언젠가는 이런곳에 소개가 될 수 있기를 희망하면서 2022년 열심히 사이드 프로젝트로 발전시켜 볼 예정입니다.  Grid Layout 과 같은 기능도 연구를 해서  Best Practice Grid Layout 과 관련해서는 또  FlexBox과 같은 글 을 준비하고 있으니 기대해주세요.  다들 저마다  The State Of 2021 를 통해서 내가 모르고 있던 스펙이나 기술을 구경하고, 2022년 내가 배워야 할 기술 스택을 고르는데 있어서 이 글이 도움이 되었으면 좋겠습니다. :) 클래스와 인스턴스 개념 이해  클래스  : 어떤 사물의 공통 속성을 모아 정의한 것일 뿐 직접 만질 수도 볼 수도 없는 존재 여기서 상하관계가 존재하는데, 하위 개념은 상위 개념을 포함하면서 더 구체적인 개념이 추가됨.  인스턴스  : 어떤 클래스의 속성을 지니는 실존하는 개체 클래스를 바탕으로 인스턴스를 만들 때 비로소 어떤 개체가 클래스의 속성을 지님. 다중상속을 지원하는 언어든 아니든 인스턴스 생성시 호출 가능한 클래스는 하나뿐 자바스크립트 클래스 인스턴스에 상속되는지 여부에 따라  스태틱 멤버(static member) 와  프로토타입 메서드(prototype method) 로 나뉨. 스태틱 멤버 : 인스턴스에서 직접 접근할 수 없는 메서드 생성자 함수를 this로 해야만 호출 가능 프로토타입 메서드 : 인스턴스에서 직접 호출할 수 있는 메서드 클래스 상속 기본 구현 클래스가 구체적인 데이터를 지니지 않게 하는 방법 일단 만들고 프로퍼티들을 일일이 지우고 새로운 프로퍼티를 추가할 수 없게 하는 것. 인스턴스 생성 후 프로퍼티 제거 빈 함수를 활용 Object.create활용 세 코드의 공통점은 SubClass.prototype의  __proto__ constructor 복구하기 SubClass.prototype.constructor가 원래의 SubClass를 바라보도록 해주어야 함. 인스턴스 생성 후 프로퍼티 제거 빈 함수를 활용 Object.create활용 자바스크립트는  프로토타입 기반 언어 어떤 객체를 원형으로 삼고 이를 복제(참조)함 으로써 상속과 비슷한 효과를 냄. 프로토타입의 개념 이해 constructor, prototype, instance 어떤 생성자 함수(constructor)를 new 연산자와 함께 호출하면 constructor에서 정의된 내용을 바탕으로 새로운 인스턴스가 생성 이때 instance에서는  __proto__ 라는 프로퍼티가 자동으로 부여 이 프로퍼티는 constructor의 prototype이라는 프로퍼티를 참조 prototype와  __proto__ __proto__ Object.getPrototypeOf()  /  Object.create()  등을 대신 이용 만약 person이라는 생성자 함수의 prototype에 getName이라는 메서드를 지정시 Person의 인스턴스는  __proto__  Person.prototype === apple.__proto__ // true 인스턴스의 던더프로토는 생략 가능하기 때문에 다음과 같은 공식도 성립  Person.prototype === apple // true 따라서 정리해본다면, new 연산자로 Constructor를 호출하면 instance가 만들어지는데, 이 instance의 생략 가능한 프로퍼티인  __proto__ contructor 프로퍼티 인스턴스에서 contructor에 직접적인 접근이 가능 (읽기 속성이 부여된 예외적인 경우 : 기본형 리터럴 변수 - number, string, boolean) = 어떤 인스턴스의 생성자 정보를 알아내기 위해 constructor 프로퍼티에 의존하는 것이 항상 안전하진 않음. 다양한 constructor 접근 방법 모두 동일한 Constructor를 가리키는 코드 모두 동일한 객체를 가리키는 코드 프로토타입 체인 메서드 오버라이드 만약 인스턴스가 동일한 이름의 프로퍼티 또는 메서드를 가지고 있다면? 자바스크립트 엔진이 getName이라는 메서드를 찾는 방식은 가장 가까운 대상인 자신의 프로퍼티를 검색 후, 없으면 그 다음으로 가까운 대상인  __proto__ 를 검색하는 순서로 진행하기 때문에  인스턴스의 메서드 우선 실행 만약 메서드 오버라이딩이 이뤄진 상태에서 원본의 메서드에 접근하고 싶다면   apple.__proto__.getName() //원본의 getName 출력 프로토타입 체인 모든 객체의  __proto__ 에는 Object.prototype이 연결  프로토타입 체인  : 어떤 데이터의  __proto__  프로퍼티 내부에 다시  __proto__ 프로토타입 체이닝  : 이 체인을 따라가며 검색하는 것 메서드 오버라이딩과 동일한 동작방식으로, 어떤 메서드 호출 시 자바스크립트 엔진은 데이터 자신의 프로퍼티들을 검색해 찾던 메서드가 있으면 그 메서드를 실행하고 없으면  __proto__ 를 검색해 실행하는 방식 객체 전용 메서드의 예외 사항 어떤 생성자 함수든 prototype은 반드시 객체 Object.prototype이 언제나 프로토타입 체인의 최상단에 존재 객체에서만 사용할 메서드는 프로토타입 객체 안에 정의할 수 없음. 객체만을 대상으로 동작하는 객체 전용 메서드들은 부득이  Object.prototype 이 아닌 Object에  스태틱 메서드(static method) 로 부여 생성자 함수인 Object와 인스턴스인 객체 리터럴 사이에는 this를 통한 연결이 불가능해 대상 인스턴스를 인자로 직접 주입해야 함. 다중 프로토타입 체인 대각선의  __proto__ 를 연결해나가기만 하면 무한대로 체인 연결 가능 대각선의  __proto__ 를 연결하는 방법  __proto__ 가 가리키는 대상, 즉 생성자 함수의 prototype이 연결하고자 하는 상위 생성자 함수의 인스턴스를 바라보도록 useReducer   reducer  action   : 업데이트를 위한 정보. 주로 type값을 지닌 객체 형태로 사용 (ex  {type : &quot;INCREAMENT&quot;} )  const [state, dispatch] = useReducer(reducer, initialState);   state  dispatch   : 액션을 발생시키는 함수 실행 순서 useReducer vs useState 컴포넌트에서 관리하는 값이 하나고, 값이 기본형 데이터 -&gt;  useState useReducer 권장사항일뿐 이래야한다 하는 건 없음 클로저의 의미 및 원리 이해 특징 여러 함수형 프로그래밍에서 등장하는 보편적인 특성 예시     inner함수의 실행 컨텍스트  environmentRecord outerEnvironmentReference  : inner함수가 선언된 위치의 LexicalEnvironment가 참조복사됨 -&gt; outer함수의 lexicalEnvironment가 저장됨. inner함수의 실행 시점( let outer2=outer() 지역변수를 참조하는 내부 함수가 외부로 전달된 경우가 유일 스펙상으로는 선언 당시의 LexicalEnvironment를 전부 GC하지 않도록 되어있으나, 2019 기준 크롬이나 Node.js 등에서 사용중인 v8엔진의 경우 내부 함수에서 실제로 사용하는 변수만 남겨두고 나머지는 GC하도록 최적화돼 있음.  따라서 클로저란,  어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상 외부 함수의 LexicalEnvironment가 가비지 컬렉팅되지 않는 현상 ➤  어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상 클로저와 메모리 관리 필요성이 사라진 뒤에 메모리를 소모하지 않도록  식별자에 참조형이 아닌 기본형 데이터(null/ undefined)를 할당 해 참조카운트를 0으로 만들어주면 좋음! 클로저의 메모리 해제 예제 return setInterval   eventListener 클로저 활용 사례 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때 1 2 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점 함수 내부에서의 this가 원래와 달라지는 점 3 접근 권한 제어 (정보 은닉) 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 개념 외부에서는 오직 outer함수가 return한 정보에만 접근할 수 있음. return한 변수들은 public이 되고, 그렇지 않은 변수는 private이 됨.  부분 적용 함수 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가 나중에 (n-m)개의 인자를 넘기면 비로소 원래 함수의 실행 결과를 얻을 수 있는 함수 - 클로저를 핵심 기법으로 사용  부분 함수 사용의 적합한 예 - 디바운스 짧은 시간 동안 동일한 이벤트가 많이 발생할 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것. scroll, wheel, mousemove, resize 등에 적용해 프론트엔트 성능 최적화에 큰 도움을 주는 기능 커링 함수 여러개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 것. 당장 필요한 정보만 받아 전달하고 또 필요한 정보가 들어오면 전달하는 식으로 하면 결국 마지막 인자가 넘어갈 때까지 함수 실행을 미루는 셈 =  지연 실행  : 원하는 시점까지 지연시켰다가 실행해야하는 경우 사용 부분 적용 함수와 차이점 한 번에 하나의 인자만 전달 중간 과정상 함수를 실행한 결과는 그 다음 인자를 받기 위해 대기 마지막 인자가 전달되기 전까지는 원본 함수가 실행되지 않음 콜백 함수 다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수 콜백 함수의 넘겨지는 제어권 호출 시점 어떤 인자 값을 어떤 순서로 넘길 것인지 this가 될 대상 지정 콜백 함수는 함수다 콜백 함수 내부의 this에 다른 값 바인딩하기 콜백 함수 내부에서 this가 객체를 바라보게 만드는 방법 클로저로 만드는 방식 전통적인 방식으로 this를 다른 변수에 담아 콜백 함수로 활용할 함수에 this 대신 그 변수를 사용하는 방법이 있음. bind를 활용한 방식 콜백 지옥과 비동기 제어 콜백 지옥 ? 비동기 vs 동기  비동기 동기  : 현재 실행중인 코드가 완료된 후에야 다음 코드를 실행하는 방식 - 즉시 처리 콜백 지옥을 해결하는 방법   값이 전달되는 순서가 아래에서 위로 향하고 있어 코드를 자연스럽게 해석하기 어려운 문제가 있음. 기명함수로 변환   Promise   콜백 함수는 호출할 때 바로 실행되지만 그 내부에 resolve 또는 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지는 다음(then) 또는 catch 구문으로 넘어가지 않음.   Generator   Generator 함수를 실행하면 Iterator가 반환되는데, Iterator는 next라는 메서드를 가지고 있음. 이 next 메서드를 호출하면 가장 먼저 등장한 yield에서 함수의 실행을 멈춤. 비동기 작업을 순차적으로 진행되도록 할 수 있음. Promise + Async/await   상황에 따라 달라지는 this 전역 공간에서의 this window global 하지막 삭제 명령에서 차이를 보이는데, 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면 전역변수로 설정한 경우에는 삭제가 되지 않음. var로 선언한 전역 변수와 전역 객체의 프로퍼티는 호이스팅 여부 및 configurable(변경 및 삭제 가능성) 여부에서 차이를 보임 메서드로서 호출할 때 그 내부에서의 This 함수 vs 메서드 어떤 함수를 실행하는 방법 함수로서 호출 메서드로서 호출 이 둘을 구분하는 유일한 차이 :  독립성 함수 메서드  : 자신을 호출한 대상 객체에 관한 동작 수행 메서드 내부에서의 this this : 호출한 주체(함수명 앞의 객체)에 대한 정보가 담김 함수로서 호출할 때 그 함수 내부에서의 this 함수 내부에서의 this 함수의 this == 전역객체 메서드 내부 함수에서의 this 메서드의 내부 함수에서의 this를 우회하는 방법 현재 컨텍스트에 바인딩된 대상이 없으면 직전 컨텍스트의 this를 바라보도록 하는 방법 ES5 변수를 활용하는 방법   상위 스코프의 this를 저장해 내부 함수에서 활용하려는 수단으로 self를 사용 ES6 : this를 바인딩하지 않는 함수 ES6에서는 위와 같은 문제를 보완하고자  this를 바인딩하지 않는 화살표 함수 콜백 함수 호출 시 그 함수 내부에서의 this  콜백함수 this = 전역객체 생성자 함수 내부에서의 this  생성자 함수 자바스크립트에서는  함수에 생성자의 역할 부여 &lt;인스턴스 생성 과정&gt; __proto__ 명시적으로 this를 바인딩하는 방법 call() call(this로 바인딩 되는 인자, 호출할 함수의 매개변수)   함수를 그냥 실행 시, this는 전역 객체를 참조   apply()   call/ apply 메서드를 활용하는 방법 유사배열객체에 배열 메서드 적용 key가 0 또는 양의 정수인 프로퍼티가 존재하고, length 프로퍼티의 값이 0 또는 양의 정수 인 객체를 배열 메서드를 차용할 수 있음.    Array.prototype.slice.call(유사배열객체)  로 유사배열객체를 배열로  복사 Array.from(obj) 생성자 내부에서 다른 생성자 호출 클래스의 super와 같은 역할로 동작   여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply 활용 ES6에서는 스프래드 문법을 사용하여 표현할 수 있음 bind() 함수에 this를 미리 적용 부분 적용 함수 구현 name 프로퍼티 bind 메서드를 적용해 만들어진 함수는 name 프로퍼티에  bound bind 메서드에 의해 만들어진 함수 라는 것을 알 수있음.   상위 컨텍스트의 this를 내부 함수나 콜백 함수에 전달하기 화살표 함수의 예외사항  화살표 함수 별도의 인자로 this를 받는 경우 (콜백 함수 내에서의 this) (콜백함수, this)  형식의 매개변수를 가짐 forEach map filter some every find findIndex flatMap from Set.prototype.forEach Map.prototype.forEach 참고 블로그 :  https://www.nextree.co.kr/p7650/ 전역변수의 위험성 자바스크립트는 전역변수를 기반으로 하는 언어이기 때문에 변수 선언 키워드 없이 변수를 만들게 되면, 파일 전역에서 참조가 가능해지고, window의 프로퍼티로 설정되어  window.~ 변수 선언 키워드 사용하기 자바스크립트에는  암묵적 전역(implied globals)  라는 개념이 있다.  변수 선언 키워드(var, let, const) 를 사용하지 않고 변수를 선언하거나, 선언되지 않은 변수를 사용하면 암묵적으로 전역에 속하게 된다는 뜻이다. 전역에 속한다는 의미는 전역 변수가 된다는 의미 보다는  전역 객체의 프로퍼티로 생성된다 는 의미에 더 가까워 위에서 언급했던 대로  window.~ 로 접근 가능해진다는 뜻이 된다.  프로퍼티는 delete 연산자로 삭제 가능하지만 변수는 그렇지 않다. 즉시 실행 함수  즉시 실행 함수 이와 비슷하게  즉시 객체 초기화  패턴도 존재하는데, 즉시 실행 함수처럼 괄호로 묶어 바로 초기화해 사용하는 방식이다. 선언과 동시에 사용하는 방식은 소스코드의 신뢰성을 높여주지만 메모리 낭비로 이어질 수 있는 문제점이 있어 적절히 사용해주어야 한다. 네임스페이스 네임 스페이스 패턴 객체 리터럴 네임스페이싱 하나의 전역 객체를 만든 후, 모든 함수, 객체, 변수를 추가해 구현 장점 코드 내에서 뿐만 아니라 같은 페이지에 존재하는 JS라이브러리나 다른 외부 코드와의 이름 충돌 방지 단점 모든 변수와 함수에 상위 객체명을 붙여야하기 때문에 소스 코드 양 증가 -&gt; 다운로드 해야할 파일의 크기 증가 하나의 전역 인스턴스로 동작하기 때문에 한 부분이 수정되어도 전역 인스턴스를 수정 namespace로 사용되고 있는 객체는 this를 사용해 참조 불가능 함수 영역 안에 있는 this 키워드는 부모객체를 가리키고, 직접 호출시에는 전역객체를 가리키기 때문에 이 단점을 해결하기 위해선   샌드박스 패턴  을 사용해야 함. 범용 네임스페이스 함수 원하는 객체가 다른 곳에서 이미 선언되었는지 확인하기 위해 확인 작업을 해주어야 한다. 이를 위해 재사용 가능한 함수를 만들어 깊이 있는 객체도 확인이 가능하도록 만들어 주어야 한다. 샌드박스 패턴 전역 범위를 더럽히지 않고 맘껏 쓰일 수 있도록 유효 범위를 정해주는 패턴 장점 단 하나의 전역변수에 의존하는 네임스페이스 패턴의 단점을 여러개의 샌드박스 객체를 생성함으로서 극복 점으로 연결된 긴 이름을 쓸 필요가 없음 런타임에 탐색 작업을 거칠 필요가 없음 모듈 패턴 자바스크립트에서는 접근 제한자가 따로 없어  캡슐화 클로저 와  컨텍스트 의 개념을 이용하여 변수와 메소드에 접근 제한자를 구현 구현 방법 return 이하는 public처럼 외부에서 접근할 수 있는 부분을 구현하고, 내부에서는 private와 같이 외부에서 접근할 수 없는 영역을 구현한다 = 클로저 원래도 기억력이 좋은 편은 아니지만, 비밀번호를 모두 외우고 다닐 자신이 없어 자동로그인에 대한 의존도가 상당히 높은 편이다. 이 말은 즉슨 자동로그인에 정확한 아이디와 주소가 입력되어있지 않으면 혹은 어딘가에 적어두지 않으면 나는 로그인을 못한다는 말이다^^... Forgot your password?  구글링 결과  다행히 나와 같은 문제를 겪은 사람을 발견했다. 1. strapi 폴더에서 터미널을 킨다.   2. 다음 명령어로 새로운 비밀번호를 설정해준다.  yarn strapi admin:reset-user-password --email=이메일주소 --password=새 비밀번호 3. 적용완료!   이제 맘편히 사용할 수 있겠다^^ Window 함수 단순 페이지 이동 함수 앞뒤로 페이지 이동   window.history.back() 사이트 뒤로가기 버튼을 눌렀을 때 동작하는 함수. 이전에 방문했던 사이트로 이동시켜줌. window.history.forward() 사이트 앞으로 가기 버튼을 눌렀을 때 동작하는 함수. 특정 페이지로 이동 window.history.go()   window.history.go(-1) : 한 단계 뒤로 가기, window.history.back()과 같은 동작 -1 뿐만아니라 window.history.go(-2) (-3) ... 가능   window.history.go(1)  : 한 단계 앞으로 가기, window.history.forward()와 같은 동작  파라미터가 없이  window.history.go()  로 쓰이면 현재 페이지를 새로고침해줌 let pages = window.history.length  로 길이를 뽑아낼 수 있음.  이전 게시글 에서도 언급했었지만 History API는 보안상의 이유로 URL을 알려주지 않고 이동만 가능하도록한다.  다양한 동작을 하는 함수 window.history.pushState() history entry에 새로운 entry를 추가하는 메서드  화면을 새로 그리지 않고 state unused 현재는 사용하지 않지만, 빈 문자열로 넘겨주는 것이 좋음 url ❓ 같은 origin 같은 스키마, hostname (path는 달라도 됨) window.history.replaceState() 현재의 history.entry를 변경하는 함수 세션 History를 전부 지우거나 권한이 없는 코드로 이동하는 걸 막을 수는 없지만, location.replace()를 이용해 이전 페이지를 덮어씌워 숨기는 방법을 쓸 수 있음. 윈도우 이벤트 WindowEventHandlers.onpopstate = func pushState()나 replaceState()에 의해서는 popstate 이벤트가 감지되지 않는다. popstate이벤트는 같은 파일 내 두 history entries간 어디를 갈지 고를 때 동작함.  로그인 이후 routing 처리 유저가 사이트에 진입했을 때, 로그인 후 routing 처리하는 과정에서 문제가 생겼다. 기존 로직의 경우, 유저가 로그인을 한 뒤 이전 페이지로 이동되도록 만들어주었다. 만약 다른 사이트에서 바로 우리 사이트의 로그인 페이지로 이동되는 경우, 로그인 후 우리 사이트 밖으로 이동하게되는 문제점이 발생했다. document.referrer 이를 해결하기 위해선 로그인 페이지 이전 방문한 페이지의 주소를 구별하는 과정이 필요했다. 이전 페이지의 주소를 가져오기 위해선  document.referrer 를 주로 사용하는데, 유저의 유입 루트를 파악할 때 자주 쓰이는 코드라고 한다. window.history api 에서는  보안상의 이유 로 정확한 Url을 제공하지 않는다. 하지만 document.referrer에서도 단점이 존재한다. 우선 모든 document.referrer가 정확한 Url을 제공하진 않는다. 네이버 블로그를 운영해본 사람이라면, 구글에서 유입된 경우 정확히 어떤 루트로 이 블로그에 들어왔는지 알 수 없고 단순히 google이라고만 작성되는 걸 본 적이 있을 것이다.   이렇게 document.referrer이 항상 정확한 url을 리턴해주진 않는다. 또한 document 나 window의 경우, 브라우저 렌더링에서만 존재하기 때문에 서버사이드 렌더링에서 이용할 수 없다. 따라서  Next.js에서는 document.referrer을 사용할 수 없다  document.referrer는 빈 배열을 리턴한다.  next.js에서 이전 페이지의 path 가져오기  이 사이트 를 참조해서 코드를 작성했다. 코드에 대해 간략히 설명하자면, 현재 코드를 세션에 저장해 두었다가 다른 코드로 이동하면 저장되어있던 path를 prevPath로 저장해주고 현재 path를 currentPath에 덮어쓰기 해준다. 여기서 중요한 점은 세션에 저장되는 path는 내가 제작한 사이트에서만 동작하므로, 만약 이 사이트에 방문한 적이 없다면 세션에는 빈 데이터만 남게 된다. 빈 데이터인 경우 Home으로 넘어가도록 처리해주었다. 만약 밑미 페이지 - 네이버 - 밑미 로그인의 플로우로 진입하게 되면 네이버를 건너뛰고, 이전에 방문했던 밑미 페이지로 넘어가게 된다.  globalThis 이 문제를 해결하면서  globalThis  의 존재를 처음 알게 되었다. globalThis는 이름 그대로 전역 스코프의 this(전역 객체 X)를 의미한다. 환경에 관계없이 전역 객체를 가져오기 때문에 CSR과 SSR 어디서든 접근할 수 있다는 장점이 있다. 그래서 여기에서도 globalThis를 사용해 session에 접근할 수 있었다.   지난 2월 16일부터 약 6일간 테오의 구글 스프린트 4기에 참여했다! 참여 동기부터 스프린트 결과물까지 차근차근 설명해보도록 하겠다. ☻ 참여 동기 벨로그에 들어오면 항상 테오의 벨로그가 보였다. 가끔 클릭해서 글을 읽어보곤 했는데, 그 중 테오가 진행한 구글 스프린트 2기글을 보게되었다. 글을 읽으면서 재밌어보인다라는 생각과 함께 테오에게 다음 기수 모집하게 되면 알려 달라고 댓글을 달았는데, 테오에게 메일이 왔다!   사실 메일을 받고 바로 신청하고 싶었는데 이 때 이미 진행중이던 프로젝트가 있어서 뒤늦게 신청을 했더니 3기는 이미 모집인원이 다 차있었다. 다행히 4기도 함께 모집중이어서 4기에 신청을 했고, 스프린트에 참여할 수 있게되었다. 스프린트 진행 과정 수요일 게더타운에서 첫 만남을 가졌다. 다들 어색한 분위기 속에 테오가 준비한 피그잼으로 이동해 본인에 대해 소개하는 시간을 가졌다. 프로젝트를 시작하기 전, 서로에 대해 이해하는 과정을 거치고 나니 각자의 단점들을 서로가 보완할 수 있는 좋은 팀원들이 모였다는 생각이 들었다.    모임을 갖기 전, 테오가 프로젝트에 대한 아이디어를 생각오라고 과제를 줬고 피그잼에 각자의 아이디어에 대해 이야기를 나누고 우리가 진행할 프로젝트의 주제를 선정하는 시간을 가졌다. 이 때 굉장히 좋은 아이디어가 많아 아이디어를 선정하는데 꽤나 애를 먹었지만, 준의 아이디어인  npm 컴포넌트 배포 가 선정되었다. 여기에는 올리지 않겠지만, 다른 팀원들의 아이디어도 매우 창의적이고 재밌어 보였고, 전부 그냥 보내긴 아까운 아이디어들이라 언젠가 저 아이디어들을 꼭 실천해보고 싶다는 생각을 했다.  목요일   준의 아이디어를 구체화하는 작업을 했다. 그 전까지 프로젝트를 하면서 이렇게 다양한 관점에서 아이디어를 가공하는 경험을 겪어보지 못했는데, 이번 스프린트를 통해 어떻게 아이디어를 구체화하는지, 어떤 점들을 고려해야하는지 배울 수 있었다. 특히 내가 라이브러리에 생각했던 기능 중에 이스터에그가 있었는데,  &#39;서비스가 아닌 사용자가 원하는 기능만 꺼내 쓰는 npm에서 의미가 있을까요&#39;  라는 질문에  내가 프로덕트를 이해하는 부분이 부족했구나 하며 반성하는 시간을 가졌다. (((그 누구도 혼내지 않았음))) 금요일 그동안의 과정이 컴포넌트 개발 외적인 부분에 포커싱이 되었다면 이 날은 조사해온 레퍼런스를 바탕으로 어떤 컴포넌트를 만들 것인지 정하는 날이었다.    배경과 아이콘, 버튼 요소 등 최대한 많은 요소들을 다루고 싶었지만 전부 다 하기에 무리가 있다고 판단해 기존 아이디어에서 한번 더 필터링하는 과정이 필요했고, 이 과정에서 좋은 아이디어가 많을 수록 결단을 내리는 것이 더 힘들다는 것을 느낄 수 있었다.  토요일 / 일요일 npm 배포 주말 내내 개발에 착수했다. npm 배포에 시간이 많이 소요될 게 염려되어 npm 배포를 먼저 시작했는데, 배포 자체는 그렇게 어렵지 않았다. 그 때 참고했던 사이트들은 다음과 같다. typescript CRA npm 배포  NPM에 타입스크립트 및 자바스크립트 배포하기 react 컴포넌트 npm에 배포하기 [npm] Typescript 패키지 배포하기 배포 자체는 금방 끝났지만, 우리가 CRA로 작성해서 그런지 웹팩에서 문제가 발생했고 이 문제를 해결하는데 많은 시간이 소요됐다. 다음에 또 배포를 하게된다면 CRA를 사용하지 않는 방법으로 진행해야겠다.  Time 컴포넌트 배포를 성공적으로 마무리한 후, 각각의 컴포넌트로 팀을 나눠 진행했다. (Time, Weather, Season) 나는 준, 세인트와 함께 이 중 Time을 맡게 되었다.  Time 컴포넌트는 타입이  auto ,  morning ,  day ,  evening ,  night 로 이루어져 있다. 이 때  auto 는 현재 시간에 따라 컴포넌트의 스타일이 바뀌도록 만들어주었다. 배경과 아이콘을 분리한 뒤, 아이콘에 애니메이션을 넣어 Props로 애니메이션의 시간, 위치, 방향을 넘겨주도록 제작해 다양하게 표현이 가능하도록 만들었다. 다른 컴포넌트들과 달리 time 컴포넌트는 유저 자유도가 높아 구현에 크게 어려운 부분은 없었다. 다만 다른 사람들의 코드를 보면서 타입스크립트 코드를 짜는 법을 배울 수 있어 좋았다.  Documents npm 배포를 목표로 하다보니 단순히 서비스를 개발할 때와 다르게 신경써야할 부분이 많았다. 그 중에 하나가 Readme였는데, 이 부분은 다같이 hackmd를 이용해 작성하니 금방 끝났다. 또 다른 중요한 부분은 공식 홈페이지였다. 공식 홈페이지에서 사용자들이 npm에 대한 설명보다는, 직접 사용하며 변화하는 컴포넌트라는 점을 학습할 수 있기를 바랬고 이를 위해 사용자에게 값을 입력받아 화면상에서 컴포넌트가 변할 수 있도록 제작했다. 홈페이지 제작에 많은 시간을 쏟지 않기 위해 mui를 이용하기로 했으며, 갓뽀송이 만들어준 와이어프레임을 따라 홈페이지를 제작했다. 통일된 UI를 갖기 위해 공통된 부분을 컴포넌트로 추상화해 사용하였다.  결과물  ✨ 공식 홈페이지 ✨  npm 사이트에서 확인하기    react season component       모두의 주말이 모여 이렇게 멋진 컴포넌트가 탄생했다. 짧은 시간이었지만 이렇게 완성된 모습을 보니 굉장히 보람차고, 뿌듯하다. 2월 중 가장 알차게 보낸 나날이라고 확신할 수 있다. 준, 세인트, 데비니, 단테, 춘식, 이안, 아이뽀송 같이 좋은 팀원들을 만나 혼자라면 생각조차 하지 못했을 새로운 아이디어에 도전할 수 있었고, 함께 으쌰으쌰하며 마지막까지 신나서 개발 할 수 있었다.  아마 스프린트의 가장 큰 장점은 짧은 시간만으로 많은 것들을 얻어갈 수 있다는데 있지 않을까 싶다. 물론 체력을 바쳐야 하는 단점이 있지만, 막상 다시 돌아간다고 해도 다시 잠을 포기할 것 같다. 데비니가 쿨타임이 차면 다시 하고 싶다고 말했던 것처럼 나도 쿨타임이 차면 다시 스프린트에 도전해보고 싶다. 좋은 인연들을 많이 만나고, 기술적으로도 성장했으며, 나 자신에게도 자신감을 불어넣어주는 알찬 시간이었다. 마지막으로 이런 시간과 기회를 마련해준 테오에게도 고맙다는 말을 꼭 전하고 싶다.   https://nextjs.org/docs/advanced-features/custom-error-page 에러 페이지를 서버에서 매번 렌더링 하는 것은 Next.js 서버에 과부화를 줄 수 있다. 이를 방지하기 위해 별도의 파일을 생성하지 않아도 되도록, * 넥스트 Js에서는 커스텀 에러페이지를 만들 수 있는 기본 프레임을 제공한다. * 404에러(not found) 와  500에러(서버 에러) 를 가지고 있으며, 이외의 에러들은  _error.js  라는 파일명으로 커스텀 할 수 있다. 특정 에러 페이지 404 error page  pages/404.js  파일을 만들어 커스텀 할 수 있다. 이 파일은 빌드 타임에 정적으로 생성된다.  500 error page  pages/500.js  파일을 만들어 커스텀 할 수 있다. 이 파일은 빌드 타임에 정적으로 생성된다.  사실 둘이 파일 명의 숫자만 다르게 해주면 된다^^.. 📌 만약 빌드 타임에 데이터를 fetch 하고 싶다면 페이지 내에서   getStaticProps   사용이 가능하다. Next/Error 커스텀 pages/_error.js 넥스트에서 자체적으로 제공해주는 에러태그는 서버와 클라이언트 모두에서 동작한다. 이 에러태그를 커스텀하고 싶다면  pages/_error.js  파일을 생성해 다음과 같이 수정해주면 된다. 최근 Error가 Next.js의 데이터 패치 함수 ( getStaticProps ,  getServerSideProps  등) 사용을 지원하지 않는다고 한다. 참고해서 사용하기 new ✨ 쿠키 사용해 전역에 로그인한 유저 데이터 가져오기 로그인을 하게되면 로그인한 유저의 정보가 필요한 경우가 생긴다. 로그인 상태를 확인하기 위해 로그인한 유저에 따라 달라지는 기능 로그인한 유저의 데이터를 매번 받아오기 않기 위해 다음의 이유로 로그인한 유저의 정보를 저장해두어 여러곳에서 사용할 수 있도록 하였다. 처음에는 전역관리도구를 이용해 로그인한 데이터를 내려주려고 했으나, 전역도구(contextAPI)는  위에서 아래로 내려주는 편리함을 제공할 뿐, 밑에서 위로 데이터를 저장시키는데 한계가 있기 때문에  쿠키를 사용하기로 했다.  쿠키 vs 세션 vs 로컬스토리지  쿠키  세션  로컬스토리지  저장 용량 4KB 5MB 5MB/10MB  저장 기간 설정에 따라 만료, 탭 및 창별로 작동 브라우저가 닫힐 때까지 자바스크립트 혹은 수동으로 삭제하지 않는 이상 삭제되지 않음  읽기 권한 클라이언트 클라이언트 클라이언트 &amp; 서버  서버 데이터 전송 X X O  구형 브라우저 지원 적음 적음 모든 브라우저 가능 서버 데이터 전송이 불가능 하다는 말은 api에 데이터를 담을 수 없다는 의미 같은 주소의 URL 창을 여러개 열어도 각각의 창은 별도의 세션을 가짐 로컬 스토리지는 같은 URL창이면 같은 데이터를 유지한다. 우리가 사용하고 있는 프로그램은 NEXT.js이고 이는 서버 사이드 렌더링을 지원하기 때문에 로컬스토리지 사용이 불가능하다. 따라서 서버 친화적인 쿠키를 사용하기로 했다.  js-cookies   yarn add @type/js-cookies 해당 패키지를 이용해 쿠키에 저장하고 꺼내올 수 있다. 쿠키 패키지 가져오기  import Cookies from &quot;js-cookie&quot; 쿠키에 데이터 저장하기  Cookies.set(&quot;key&quot;,value)  💥  value에는 항상 string 형태로 저장 Cookies.set(&quot;user&quot;, JSON.stringify(res.data.data)) 쿠키에 저장된 데이터 가져오기  Cookies.get(&quot;key&quot;) JSON.parse(Cookies.get(&quot;user&quot;)) 쿠키에 저장한 데이터 삭제하기  Cookies.remove(&quot;key&quot;) 저장된 쿠키 데이터는 개발자도구 - Application - Storage - Cookies에서 확인 가능하다   데이터 업데이트 현재는 일단 user 데이터에 변동 사항이 생겨 put으로 변경사항을 업데이트 하는 경우, request를 보내고 받은 데이터 값을 쿠키에 저장하는 방식으로 로컬 데이터를 업데이트 해주고 있다. 이부분에 Mutate를 이용해 데이터가 반영되기 전 유저가 불편함이 없도록 수정하는 과정이 필요하다. (조만간,,) non-null assertion operator 위에서 가져온 쿠키를 사용하기 위해선 String 형식의 데이터를 JSON으로 바꾸는 과정이 필요하다고 했다. 하지만 JSON.parse를 이용하기 위해선, 타입스크립트의 strict null check 설정에 의해  항상 값이 Null이나 Undefined 값이 들어가지 않도록  해야해서 코드를 다음과 같이 수정하였다. 근데  유저가 로그인할 필요가 없는 페이지라면?  &#39;로그인시 유저 데이터를 받아야하지만 로그인하지 않아도 볼 수 있는 페이지라면 어떻게 해야할까&#39; 라는 질문을 받았고 이부분에 대해서 코드 수정이 필요하다고 느꼈다.  일단 로직을 바꾸지 않는 상태에서 데이터가 없는 경우 리턴되는 코드를 삭제하고  JSON.parse(userCookiesData)  를 바로 실행한다고 했을 때 Null cheker에 의해 에러가 발생하게 된다. 이 부분의 에러를 해결하기 위해 해당 변수 뒤에 느낌표를 추가하는 방법을 현호님이 알려주셨는데 찾아보니  non-null assertion operator 라고 불리는 타입스크립트 연산자였다. 적용하면 다음과 같다.  JSON.parse(userCookiesData!) 해당 연산자는 null checker에게  해당 변수는 null이나 undefined일리가 절대 없어!!  하고 단언해주는 역할을 한다. null checker의 의미가 없어지기 때문에 사용을 권장하지는 않는다고 한다. 위 코드의 경우 데이터가 없는 경우도 분명히 존재하므로 다른 방법을 찾아봐야겠지만, 이런게 있다는 사실을 처음 알게되었다! 다른 부분에서 유용하게 사용될 것 같다.  다음 글의 예시 를 참고해 작성되었습니다. Literal types string, number, boolean의 구체적인 하위 타입으로 예를 들어, 문자열 자체를 타입으로 지정하는 것을 의미한다. &#39;hello&#39;라는 문자열은 string 타입이지만 string은 &#39;hello&#39; 타입이 될 수 없다. &#39;hello&#39;만 &#39;hello&#39;타입에 부합하다고 볼 수 있다. 이 때 &#39;hello&#39; 타입을 literal type이라고 한다.  보통 단독으로 사용되진 않으며, Union 형태로 사용되면 강력한 타입으로 사용될 수 있다. 정해진 단어만 입력 가능하므로, 더욱 안전하게 데이터를 변수에 저장할 수 있다는 장점이 있다.  변수가 자동으로 데이터 타입을 지정할 때, const로 저장된 변수라면 (string, number, boolean타입) 컴파일러는 해당 변수의 타입이 변수의 값 자체 (리터럴 타입)이라고 저장됩니다. 이를  타입 좁히기(literal narrowing) 이라고 합니다. key of keyof로 타입의 이름을 뽑아낸 뒤, 이를 타입으로 지정할 수 있습니다. 이렇게 되면 Person 타입의 키에 해당하는 값만 사용할 수 있게 됩니다.  typeof keyof typeof 즉  keyof는 타입의 key를 뽑아내 literal type으로 만들어준다 고 볼 수 있다. 따라서 객체에서 사용하기 위해서는 객체의 타입을 뽑아 내고 ➡️ 타입에서 keyof를 이용해 key를 뽑아내는 과정을 거쳐야한다. 객체의 타입을 뽑아 내기 위해 사용되는 것이 바로 typeof이다.   type BookType = keyof typeof Book 이렇게 Book 객체의 타입을 가져와 key 값으로 literal type을 만들 수 있게 된다.  ♻️ 리팩토링 strapi relation 데이터 불러오기 왜 이런 결과값이 나왔을까 싶어 확인해본 결과,   relation된 데이터를 불러오기 위해선 쿼리를 수정 해주어야한다는 사실 을 알게되었다. 쿼리문 작성하기 릴레이션 된 데이터를 전체 가져오기 위해선  /api/articles?populate=%2A  쿼리를 주소에 입력해주면 된다. 여기서  %2A 는  * 을 나타내는 UTF-8 코드로,  * 는   모든 것  을 의미하는 와일드카드를 말한다. 이렇게 주소에 직접적으로 쿼리문을 넣을 수도 있지만, 해당 코드를 외워야한다던가 조건이 많아지면 복잡해진다는 단점이 있다. 이를 보완하기 위해 쿼리문을 객체로 만들어 주소로 전달해주는 방법도 있다. 위의 예시를 살펴보면,  와 같이 표현할 수 있다. populate를 위한 쿼리 외에도 페이지네이션 코드들 역시 쿼리문을 객체로 만들어 보낼 수 있어, 기존 useData 훅을 리팩토링 하기로 했다.  리팩토링 // useData 기존의 코드에서 query 부분을 수정해 request에 조건을 입력할 수 있도록 했다. 기존 코드를 사용한 부분에서 에러가 나지 않도록 default 파라미터 값으로 빈 문자열을 설정해주었다.  const qs = require(&quot;qs&quot;) 에러 메세지에서  npm i --save-dev @types/qs 삭제 후,  import qs from &quot;qs&quot;  로 불러오기가 가능해졌다.   &quot;esModuleInterop&quot;: true const example = require(&quot;Exam&quot;) ❌ * import * as example from &quot;Exam&quot; ⚠️ &quot;esModuleInterop&quot;: true  https://stackoverflow.com/questions/56238356/understanding-esmoduleinterop-in-tsconfig-file tag 데이터의 구조와 쿼리문 앞서 말한 것과 같이, hashtag의 데이터 중 다른 테이블과 relation 된 값이 존재한다. Hashtag에는 해당 태그를 갖고 있는 Post값과 relation을 맺고 있으며(n:m), Post는 작성자인 User 데이터와 relation을 맺고 있다(1:n). 따라서 user에 따른 태그값을 뽑아내기 위해 쿼리문을 다음과 같이 입력해주었다.  filter in filter? www.sdv.com/deli-ght  -&gt; deli-ght 유저가 작성한 포스트에 존재하는 tag 데이터를 뽑아내야함. 하지만 필터를 사용하면 다음과 같이 모든 태그 데이터들이 출력되어버리는 것을 확인할 수 있다. filter는 true false에 따라 값을 출력하기 때문에 리턴값이 존재해버리니 (필터링된 배열을 리턴) 빈 배열을 제외한 모든 배열을 true로 간주한다.   따라서 이를 해결하기 위해   filter in some   를 이용했다. some은 주어진 조건에 해당되는 값 즉, true가 나오면 순회를 곧장 종료하고 true를 리턴한다. 값이 true or false로 리턴되기 때문에 filter함수가 리턴된 값을 통해 필터링을 실행할 수 있다.    빈 배열 속 각기 다른 빈배열 만들기 예전에 코딩테스트 문제 풀 때, 꽤나 고생했던 부분이었는데 따로 정리해두면 좋을 것 같아 사진을 캡쳐해서 남겨두었다.    원래의 의도대로라면, 키가 해당되는 배열에만 값이 추가되어야 하는데, 왼쪽 디버깅창에 보이다싶이  모든 배열에 값이 추가 ❌ new Array(5).fill([])   [] 자체가 배열이 저장될 주소값을 가지고 있기 때문에 같은 주소값으로 배열을 채우게 된다. 따라서 같은 값이 입력되어버려 탈락 ❌ new Array(5).fill(new Array(0) ⭕️ Array.from(Array(5), () =&gt; new Array(0))    https://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript Array.from(arraylike, mapFunction) Array(5) () =&gt; new Array(0) strapi에서 api 확인하기 strapi에서 만들어둔 데이터에 접근하기 위해선, 해당 strapi 관리자 도메인에 /api/테이블명을 입력하면 된다. 예를 들어  post 라는 테이블을 만들었다면 해당 api를 확인하기 위해선  www.strapi어쩌구.com/api/posts 로 접속해주면 된다.  여기서 명심해야할 것은 작성한 테이블명 뒤에 s 가 붙는걸 원칙으로 하기 때문에 테이블 이름 명명시 s로 끝나는 이름을 붙일 수 없으며, 카멜케이스로 작성된 테이블의 경우, 예를 들어 seriesPost라면          www.strapi어쩌구.com/api/series-posts  로 접근하면 된다. 해당 api에 접근했을 때, 다음과 같은 에러가 뜨는 경우가 있다.   403에러는 접근 권한이 없는 이야기인데, setting - USERS &amp; PERMISSIONS PLUGIN - Roles - public에서 각각의 데이터 마다 접근 권한을 허락해주면 된다.     스켈레톤 로딩 스켈레톤 로딩이란 로딩화면동안 사용자에게 무언가 로딩된다는 암시를 주어 사용자 경험을 더욱 편리하게 하기 위해 사용되는 기법으로 데이터가 다운받아지는 동안 다운로드될 데이터와 비슷한 레이아웃을 가진 다음과 같은 화면이 나온다.      일단 그리드를 사용하지 않고 카드 자체에 넓이값을 지정하는 방식으로 수정해두었다.  flex overflow in grid라는 키워드로 검색해보니  다음 사이트 를 발견했고,  minmax를 정해주어야 원하는 대로 비율에 맞춰 내용물이 들어갈 수 있다는 것을 알게되었다.  ✨ 무한 스크롤 구현 마이 페이지의 데이터들을 useSWR로 받아 무한스크롤로 연결하는 작업을 진행했다. 목업데이터로 무한 스크롤을 팀원들이 Intersection observer API을 이용해 구현해주셨길래, Intersection Observer API를 공부하다가 뷰포트에 대한 이해가 부족해 뷰포트에 대한 공부를 먼저 하게 됐다.  브라우저 뷰포트 브라우저에서  뷰포트 == 화면 크기 visual viewport vs Layout Viewport &lt;meta&gt;  태그를 사용해야 한다.  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  width=device-width  : 기기의 넓이에 따라 넓이 설정  initial-scale=1.0  : 페이지가 처음 로드될 때의 초기 줌 레벨  minimum-scale  : 줄일 수 있는 최소 크기를 지정  maximum-scale  : 늘릴 수 있는 최대 크기를 지정  user-scalable  : 사용자가 화면을 축소 및 확대 가능하도록 지정 (yes / no)  뷰포트보다 웹 문서가 큰 경우, 스크롤이 생성 되며 스크롤을 이용해 뷰포트를 이동시킬 수 있다.  viewport 계산  document.documentElement.clientWidth / clientHeight window.innerWidth / innerHeight window.outerWidth / outerHeight document.documentElement.offsetWidth / offsetHeight   Layout viewport / visual viewport  Layout viewport Visual viewport  : 사용자의 액션에 영향을 받는 유동적인 화면 참고 :  브라우저 뷰포트 (layout 와 visual viewport) 간단 정리하기 Intersection Observer API intersection observer api는 타겟 요소와 함께 타겟 요소의 조상 요소나 최상위 document의 뷰포트가 상호작용을 일으키면 비동기적으로 변화를 관찰하는 기능이다. 페이지 스크롤 시 lazy-loading으로 이미지나 콘텐츠를 불러올 때 무한 스크롤 구현 시 (사용자가 스크롤 할 때마다 더욱 많은 데이터들을 불러올 때) 광고 수익을 계산하기 위해 광고의 가시성을 보고해야 할 때 유저가 결과 확인 여부에 따라 애니메이션의 실행이나 퍼포먼스가 결정될 때 호환성 scroll event 기존 scroll event를 사용하는 경우 단시간에 호출이 너무 많이 발생 동기적으로 실행되어 main thread에 영향 한 페이지 내에 여러 scroll 이벤트가 우르르 발생할 수 있음 디바운싱(Debouncing)과 쓰로틀링(Throttling)을 통해 개선 가능 특정 지점 관찰을 위해  getBoundingClientRect()  함수 사용 -&gt; reflow를 발생 다음과 같은 단점들을 보완하기 위해 intersetionObserver api 사용을 권장한다. 사용 방법   const io = new IntersectionObserver(callback, [options]) callback entries observer options root rootMargin threshold IntersectionObserverEntry의 속성 반환값 .boundingClientRect 타겟 엘리먼트의 정보 .rootBounds root 엘리먼트의 정보 반환 .intersectionRect 교차된 영역의 정보 반환 .intersectionRatio 교차영역에 타겟 엘리먼트가 얼마나 교차했는지 비율(0~ 1.0) 으로 반환) .isIntersecting 타겟 엘리먼트가 교차 영역에 있는지 boolean 반환 .target 타겟 엘리먼트 반환 .time 교차된 시간 반환 위의 성질들을 모두 알 필요는 없다.  제일 중요한 건 target에 도달했을 때, 정해진 함수가 실행된다  는 점이다. 자바스크립트에서는 돔 객체를 직접 observer에 다음과 같이 등록한다. 등록된 객체가 뷰포트에 threshold에 설정한 비율 이상 등장하게 되면, 지정했던 함수가 실행된다고 이해하면 된다. 리액트에서 사용하는 방법은 아래 실행착오와 함께 설명하도록 하겠다. useSWRInfinite 공식 문서 읽어보기 syntax SWR 0.x버전을 이용중이라면  import { useSWRInfinite } from &#39;swr&#39; 로 불러와야한다고 한다. data error isValidating size setSize  : 페이지 인덱스를 변경해주는 함수이다.  size 과  setSize 는 useState를 생각하면 쉽다. 페이지 인덱스 값을 이용하기 위해선 size를 이용하고, 페이지 인덱스를 변경하고 변경된 값을 data로 받기 위해선 setSize를 이용하면 된다. getKey는 api의 주소를 입력해주는 부분이고, fetcher는 request를 보내는 fetch 함수를 의미한다.   api별로 페이지 리밋과 페이지를 나누는 기준이 다르니 양식을 꼭 확인해보는 것이 좋다. strapi 의 경우, 페이지 인덱스를  pagination[page]  으로 페이지 별 데이터 수는  pagination[pageSize] ${API_ENDPOINT}/${path}?pagination[page]=${pageIndex}&amp;pagination[pageSize]=5 실행 착오 시도 11 기존에 만들어놓은 무한 스크롤에서 useSWR을 이용해 만들었던 무한스크롤. 게다가 useSWRInfinite를 사용하지 않아 일일히 데이터를 더해줘야하는 불편함도 있었다.  시도 22   엄청난 구글링 끝에 혹시 useSWR자체의 문제가 아닐까 싶어 이슈에 들어가보았다.  나와 비슷한 오류를 겪은 사람의 조언(?) 이 있길래 들어가봤더니, 다음과 같이 작성해보라는 충고가 있었다.  이렇게 실행하니 제대로 돌아갔다!!    그래서 어떻게 사용했는데? 왜 그동안 내가 실행했던 코드에서는 에러가 났으며, 왜 위의 코드는 돌아가는 걸까..  unobserve 코드가 위 코드에서는 작성되지 않았는데.. 그럼 설마..?  하는 생각과 함께 새벽 4시에 다시 컴퓨터를 켰고.. ✨ useSWRInfinite + IntersectionObserver + strapi ✨ onIntersect부분에 그냥 원하는 함수만 넣어주면 되는 것이었다.. observer는 어처피 변하지 않으니 굳이 지웠다가 재선언할 필요가 없었다.. 쏘 깔끔해진 코드.. ✍️ 오늘의 교훈 내 사라진 일주일 돌려내.. 부록 혹시 fetcher함수를 궁금해하실 분들이 있을까봐 axios를 사용한 fetcher를 놓고갑니다,, 혹시 코드에 대해 어려운 점이나 질문이 있으시면 언제든 댓글 남겨주세요! :)  Jest란? 제스트는 테스트 코드를 찾고, 테스트를 실행하고, 실패인지 성공인지를 판단하는 테스트 러너. facebook 에서 개발하고 관리( https://jestjs.io/ ) 접근성 마커  즉,  aria를 이용 해 TDD를 작성함으로서 자연스럽게 접근성을 향상시키는 장점이 있음. 제스트가 요소를 aria를 통해 찾을 수 있다 == 스크린 리더들도 찾을 수 있다 실습 리액트 앱 생성 jest가 기본적으로 함께 설치됨. test실행을 위해 watch mode  : 파일에 수정 사항이 감지될 경우 자동으로 테스트를 실행해주는 상태  npm i -D --exact jest-watch-typeahead@0.6.5   jest 명령어  a f p  - 정규표현식에 해당하는 파일이름만 필터링      t enter q  - 테스트 종료 시작부터 모든 테스트를 실행하도록 하고 싶다면 명령어 뒤에  --watchAll 을 붙여서 실행 샘플 코드 실행 코드는 파일이름.test.js 형식을 가진다.  Test 함수  : 글로벌 함수. 두 가지 인자를 가짐 첫번째 인자는 문자열로  테스트의 설명  (자스민에서는 describe) 두번째 인자는 테스트를 실행하는  테스트 함수  Render 함수  : 인자로 받는 JSX의 가상돔을 생성. 여기서는 app 컴포넌트를 전달받음  Screen  : 생성된 가상돔에 접근하기 위한 전역 객체 ( render(&lt;App /&gt; );에 접근)  getByText 함수  : 인자로 전달된 텍스트를 가지는 돔 안의 요소를 찾음. 정규표현식 사용 가능 ( /learn react/i  뒤에 붙은 i는  대소문자를 구분하지 않겠다 는 의미)  expect 함수  : 기대한 결과가 성공인지 실패인지 판단하는 함수  .toBeInTheDocument  :  matcher  함수 제스민의 ( == .toBe()  함수)  💡 matcher 함수 종류  fireEvent  : 가상돔과의 상호작용이 가능하도록 하는 객체 테스트 코드 getByRole  getByRole( role, 찾아야할 요소 안의 텍스트 )  role  :  aria에서 사용하는 요소의 역할을 의미하는 속성 https://www.w3.org/TR/html-aria/#docconformance role 값이 틀렸을 경우 친절하게 제스트에서 제안을 해주기도  암묵적인 role이 없는 요소의 경우, role 속성을 직접 명시  &lt;div role = &quot;wrapper&quot;/&gt; 되도록이면 정식으로 지원하는 role을 사용하는 것이 좋음. 💡  role의 종류 getByRole함수는 두번째 인자로,  찾아야할 요소 안의 텍스트 를 지정할 수 있습니다.  toHaveStyle 함수  : 요소가 특정한 CSS 스타일을 가지고 있는지 체크 App.test.js App.js 실행화면   테스트 결과   Transport layer OSI 7계층 중,  데이터를 무슨 프로세스에 전달해야할 지 결정 1024~65535  사이의 포트 번호를 할당함. port number 따라서 새로운 애플리케이션을 개발할 때, 반드시 포트 번호를 할당해주어야 함. 범위 포트 번호는  ‘0~65535’(16비트 분)  까지의 숫자로 되어 있으며, 범위에 따라 용도가 정해져 있음  ‘0~1023’  은  ‘잘 알려진 포트(well-known port)’  라고 해서 웹 서버나 메일 서버 등과 같이 일반적인 서버 소프트웨어가 클라이언트의 서비스 요청을 대기할 때 사용. 이 번호들은 잘 사용되기 때문에, 사용을 엄격히 제한.   ‘1024~49151’  은  ‘등록된 포트(registered port)’  로, 제조업체의 독자적인 서버 소프트웨어가 클라이언트의 서비스 요청을 대기할 때 사용.   ‘49152~65535’  는  ‘동적 포트(dynamic port)’  로, 수시로 변경되는 포트를 의미. 서버가 클라이언트를 식별하기 위해 사용. 알아서 할당되며, window에서 netstat 명령어를 통해 현재 사용되고 있는 동적 포트들을 확인 가능. 서버 소켓용 포트로는 사용하지 말기 (에러가 발생할 수 있음) 🙋  다른 프로세스간 PORT번호가 같을 수 있을까? 같은 프로세스 내에서 여러 포트번호를 사용할 수 있을까?  - 하나의 프로그램에서 여러 포트 사용 가능 ( 예시 데이터 베이스) 전송 방식 이 포트번호를 전달하는 프로토콜은  TCP 와  UDP 데이터가 잘 도착 했는지 확인할 수 있냐 없냐 의 차이 기존 세그먼트에는 보내는 프로세스의 포트 번호와 받은 프로세스의 포트번호가 있는데, TCP에서는 답장을 보내기 위해 두 주소를 모두 가진 채로 전송되지만, UDP의 경우 받는 주소만 가지고 있고 보내는 주소는 가지고 있지 않아 답장이 불가능하다. 🖌 글을 쓰게된 동기 이런 걱정들이 나도 모르는 사이에 내 스스로를 옥죄고 있었던 것이다.  나는 좋은 개발자가 되고 싶다.  하지만 왜 그런 개발자가 되고 싶은지, 그 이유를 분명하게 답할 수 없었다. 아무래도 뭔가 중요한 것을 놓치고 있는 것 같은 기분이 들었다. 그래서 나는 내가 개발자가 되기로 한 이유를 지금껏 살아온 내 짧은 인생 속에서 다시 한 번 찾아보기로 했다. 💬 어렸을 적 나는? 우선 어린 시절 나는 무엇을 좋아했는지, 무엇이 내 심장을 뛰게 했는지부터 생각해보았다. 그러자 초등학교 시절, PPT를 사용하여 마우스로 진행하는 간단한 미로 게임(소위 ‘마우스 피하기’)을 만들어보고 주위 사람들에게 플레이 해보도록 권하거나 온라인 커뮤니티에 올려 사람들에게 소소한 칭찬을 받고 기뻐했던 기억이 났다. 그리고 실생활에 도움이 될 만한 (예를 들면 타이머) 프로그램을 직접 만들어보고 내 생활에 이용해 본 기억도 났다.  어쩌면 나는 이미 그 때부터 개발의 재미를 알기 시작했던 것이 아니었을까. 하지만 어느 순간부터 공부에 대한 부모님의 기대와 압박이 커지면서 내 삶은 90퍼센트 이상을 학업에 쏟아야 하는 학생의 삶으로 변해있었고, 자연스럽게 나의 자유로운 창작 활동 또한 휴면 상태로 들어갔다. 모두 무언가를 만드는 활동 이란 공통점이 있었다. 아쉽게도 이런 활동들이 눈에 보이는 성과로 이어지진 않았지만, 그래도 적어도 이런 취미라도 가지고 있었던 것이 힘들었던 내 학창 시절의 버팀목이 되어주었던 것 같다.    💻 내가 컴퓨터공학과를 선택한 계기는? 고등학생이 된 이후로는,  진로를 선택하는 일 이 학교 성적 다음으로 내게 가장 큰 고민거리였다. 당시 나는 평소에 컴퓨터를 좋아하고, 프로그래밍에 대한 막연한 환상이 있어 컴퓨터공학과에 관심이 어느 정도 있었다. 하지만 컴퓨터공학과에 가서 뭘 배우는지, 졸업하면 무슨 일을 하는지 아는 정보가 하나도 없었을 뿐더러, 이 쪽 업계는 생각보다 근무 환경이 안 좋다는 얘기를 많이 들은 탓에 선뜻 고르기는 힘든 선택지였다. 그 다큐멘터리가 내 인생을 바꾸게 될 줄은 전혀 모른 채 말이다. 아직도 그 때의 기억이 생생한데, 당시에 난 어머니의 잔소리를 무릅 쓰고 마치 무엇에 홀린 것처럼 앉은 자리에서 그 다큐멘터리를 끝까지 시청했다. 그리고 무언가 말로 표현할 수 없는 깊은 감명을 받았다. 지금 생각해보면, 당시 TV 화면에 비친 IT 업계에 종사하는 사람들이 자신의 일을 좋아하며 즐겁게 일하는 모습과, 소프트웨어가 세상에 큰 영향을 미치는 모습이 나에게 깊은 인상으로 다가왔던 것 같다.  (몇 년 후  해당 다큐멘터리 영상 을 유튜브에서 발견할 수 있었다.)   이를 계기로 나는 전공을 소프트웨어 및 컴퓨터 공학 계열로 정했고 더 이상 다른 진로는 생각하지 않았다.   📘 대학생이 된 이후의 나는? 그러나, 대학교에 와서 처음 프로그래밍을 배운 나의 감상은,  어렵고 재미없었다. 수업 내용과 과제의 괴리감이 너무나 컸다.  (반복문을 처음 배웠는데 알고리즘 과제를 해야 했다..😂) 그래서 결국 나는 수업을 제대로 따라가지 못해 부끄럽게도 학점을 엉망으로 받았다. 사실 처음 대학교에 입학 후 방황하는 시기가 좀 있었다. 3번의 수능 끝에도 원하는 성적을 받지 못했고 어떻게 점수에 맞춰 온 학교도 내가 생각했던 대학의 모습과 거리가 멀었기 때문이다.  지금봐도 처참한 당시 전공 과목 성적들..   그렇게 첫 학기가 끝날 무렵, 나는 내가 컴퓨터공학과에 잘 온 건지, 프로그래밍이 내 적성에 맞는 건지 깊이 고민을 하게 되었다. 하지만 아직 내가 코딩을 제대로 해보지도 않았다는 생각이 들어, 방학 기간동안 한 번 제대로 프로그래밍을 공부해보자고 마음 먹었다. 하지만 막상 공부를 하려니 어떻게 해야 할 지 감이 잡히지 않았다. 그래서 우선 주위에 도움을 받을만한 곳이 있는지 알아보고, 마침 괜찮아 보이는 컴퓨터 학원을 발견해, 파이썬과 C를 기초부터 가르치는 단과 수업을 신청해서 들었다.  그리고 잘 해냈다. 당시 수업이 꽤 타이트했던 걸로 기억하는데, 학부 수업과 가장 달랐던 점은, 코드를 직접 손으로 계속 치면서 수업이 진행되었던 점이다. 그 때 ‘ 백문이 불어 일 타(打) ’라는 말이 무슨 의미인지 처음으로 깨달았다. 말로 아무리 설명을 들어도  손으로 쳐서 코드를 작성해보지 않으면 실력이 늘지 않는다 는 것을 직접 실감한 것이다. 그렇게 열심히 공부하고, 2학기를 맞이했다. 그리고  2학기는 1학기보다 훨씬 더 힘들었다. 그렇지만 나는 지난 학기와 달랐다. 이제는 프로그래밍 공부가 재밌어졌고 어떻게 공부해야 할 지도 알았다. 그래서 포기하지 않고 한 학기 내내 정말 열심히 수업을 따라갔다. 이 수업에 관해선 정말 인상 깊었던 경험이 하나 있다. 클래스를 활용하여 은행의 기능을 동작하도록 하는 프로그램을 작성하는 과제가 있었는데, 하다보니 자그마치 코드 길이가 400줄이 넘어갔다. 이 때 정말  밤을 새서 과제를 했다. 그 다음 날 아침 7시에, 수업 과제용으로 사용했던 IDE 창에 ‘맞았습니다’ 문구를 봤을 때의 그 희열감은 지금도 잊혀지지 않는다. 아쉽게도 나는 모든 과제를 100퍼센트 다 수행하진 못했다. 하지만 끝까지 포기하지 않고 공부한 결과, 많이 늘어난 프로그래밍 실력과 함께 A0라는 좋은 학점을 받을 수 있었다. (덤으로 다른 전공 과목에선 처음으로 A+ 학점을 받았다.)   좌절 로 시작했지만, 이를 극복하고 코딩의 재미를 찾아 스스로 공부하는 힘을 길러,  의미 있는 성과 를 얻는 데까지 나아갈 수 있었기 때문이다. 더불어 1학기 때, 이미 학창 시절부터 여러 공모전 및 대외 활동을 통해 수많은 스펙과 실력을 쌓아둔 소위 &#39;코딩 괴수&#39;들을 여럿 보며 스스로 많이 초조했는데, 오히려 이것이 긍정적인 자극이 되어 미리미리 내 미래를 향한 준비를 시작할 수 있는 계기가 됐다.   🎲 미궁 게임 플랫폼 사이트에서 게임 제작자로 활동했던 경험 프로그래밍이 적성에 잘 맞음을 깨닫고 재미를 붙이는 데까진 성공했지만, 아직 무언가를 직접 개발해 본 경험이 없었던 나로서 앞으로 어떤 분야의 개발자가 될 지 정하는 것은 또 하나의 큰 고민거리였다. 이러한 고민을 안은 채 나는 1학년을 마친 후 군대에 다녀왔고, 여전히 이에 대한 답을 찾지 못했다. 그러다가, 웹이든, 앱이든, 게임이든, 개발을 본인이 직접 해봐야 어떤 분야가 자신에게 가장 잘 맞는지 알 수 있다는 말을 듣고, 마침 전역하고 복학까지 시간이 꽤 남았기에, 새로 맞춘 전역컴으로 이런 저런 개발을 시도해보았다. 파이썬으로 기억력 게임을 클론 코딩하며 따라 만들어보는 것을 시작으로 안드로이드 스튜디오를 깔아서 모바일 앱 개발을 찍먹해보기도 했고 유니티로 게임 개발을 시도해보기도 했다. 이 때 우연한 계기로 &#39; 더 라비린스 &#39;라는 미궁 게임 플랫폼 사이트를 알게 되었는데, 이 곳에서 게임 제작자로 활동했던 것이 결국 내가  웹 프론트엔드 개발자 가 되기로 한 결정적인 계기로 작용했다.   그렇지만 이 활동을 통해 나는  플레이어와 직접 상호 작용 을 하며 여러 문제점을 개선해보았고, 이를 바탕으로 다음 작품은 어떻게 구상할 지, 또 화면 내 요소를 어떻게 배치하는 것이  사용자 입장에서 플레이하기 편할 지  깊이 있게 고민해보는 경험을 할 수 있었다. 그리고 이러한 고민을 거듭해 만들어 공개한 창작물을 사람들이 재밌게 즐겨주는 걸 볼 때, 정말 큰  성취감 과  뿌듯함 을 느꼈다. 더불어 웹 게임을 만드는 과정에서 나는  내 작업의 결과물이 눈에 바로바로 보인다는 것 이 때 처음으로 나는 내가 웹 프론트엔드 개발과 잘 어울리는 것이 아닐까하는 생각을 하게 되었다. 그리고 복학 후 웹 프로그래밍 수업을 들으면서 이러한 생각은 더욱 확실해졌다. 데이터나 서버 같은 벡엔드를 개발하는 것보단 눈에 보이는 프론트엔드 개발을 하는 것이 훨씬 더 재밌었고, 성적도 그 부분에서 더 잘 받았기 때문이다. 그래서 나는  프론트엔드 개발자 가 되기로 결정했다.   👉 그래서 개발자가 되고 싶은 이유는? 이렇게 쭉 글을 쓰다보니, 내가 개발자가 되고 싶은 이유에 대한 답이 어느 정도 정리되었다. 우선 나는  창작 활동 다른 사람들에게 좋은 영향을 주고 싶다. 그리고 나는 무언가를 학습하고, 그 원리를 파악하여  깊이 있게 이해하는 것 자기 성장   🖌 마치며.. 이렇게 개발자가 되고자 하는 이유가 다시 분명해지니, 글을 처음 작성하기 시작했을 때 느꼈던 초조함은 거의 사라졌다. 오히려 다시 즐기는 마음으로 개발 공부를 이어나갈 수 있을 것 같다. 앞으로도 내가 개발자가 되고자 했던 이 마음가짐을 잊지 않으며 지금처럼 계속 꾸준히 노력을 하다 보면, 나도 언젠가 더 멋진 사람들과 함께 일할 수 있는, 성장하는 개발자가 될 수 있지 않을까 싶다. 마지막으로 이 글을 보는 모든 개발자 분들도 본인이 개발자가 되고자 했던 이유를 다시금 생각해보고, 이를 바탕으로 나보다 더 멋있고 훌륭한 개발자로 성장했으면 좋겠다. 🙂 소개 💬 프론트엔드 개발자로 취업을 준비하는 모든 분들에게 도움이 될 만한 기술 블로그 포스트 및 여러 자료들을 모아 정리했습니다. 🙂 그 동안 저에게 유익했던 여러 포스트 및 자료들을 다시 볼 목적으로 제  깃허브 레포지토리 에 저장해 두었는데, 다른 분들에게도 공유하면 좋을 것 같아서 이렇게 정리하여 올립니다. 제가 프론트엔드 개발자를 준비하고 있어, 모은 자료가 주로 프론트엔드 관련이라는 점 참고 바랍니다. 📌 코딩테스트 대비   CodeUp 기초 100제 (문제 풀이 사이트) PS(Problem Solving)가 처음인 분들께 추천합니다. 기초 문법을 잘 모르셔도 괜찮을 정도로 설명이 자세합니다.   Code Tree - Novice Low (문제 풀이 사이트) PS 초심자에게 함께 추천하는 문제집입니다. 좀 더 코딩테스트 대비에 최적화되어 있습니다.   용감하게 시작하는 코딩테스트 1편 (By Covenant 님) 코딩테스트에서 코드를 간결하고 효율적으로 짤 수 있는 여러 팁이 잘 정리되어 있습니다.   개인이 생각하는 알고리즘(PS/CP) 공부 유형 및 보완법 (By 안수빈 님) PS를 어떻게 해야 할 지 막막하거나 자신이 지금 잘 하고 있는지 확신이 안 서는 분들께 추천하는 글입니다.   코딩테스트 준비 사이트 모음집(단순링크만) (By 태빵 님) 태빵님이 작성하신 velog 게시글로, PS 문제 풀이 사이트가 잘 정리되어 있습니다.   코딩테스트 대비를 위한 백준 문제 추천 (By Covenant 님) 작성자님께서 본인 경험을 바탕으로 코딩테스트 대비에 적합한 백준 문제를 대략 80개 골라 주제별로 정리해주신 글입니다. 📌 취업 및 포트폴리오 준비   주니어 프론트엔드 개발자의 채용 프로세스 참여 후기 (By 황준일 님) ZUM에서 진행했던 신입 프론트엔드 개발자의 채용 과정을 채용자의 시각에서 기록한 포스트입니다.   내 업의 본질은 무엇인가? (By 박재성 님) 우아한테크코스 이사님께서 우테코 2기 불합격자들의 불합격 이유를 피드백 해주시는 내용의 포스트입니다. 코딩테스트와 자소서를 어떻게 준비해야 할 지 감을 잡는데 도움이 됩니다.   신입 개발자가 포트폴리오를 준비할 때 알아두면 좋은 것들 (By 김태성 님) 스타트업 채용 담당자께서 그 동안 어떤 식으로 포트폴리오를 바라보고 평가했는 지에 대해 구체적으로 설명하십니다. 더불어 더 높은 점수를 받는 포트폴리오를 작성하는 방법도 실례를 들어 알려주십니다. 📌 FE 공부법 및 가이드   초보 웹 개발자를 위하여 (By 정호영 님) 웹 개발자 되고 싶은데 어떻게 시작해야 할 지 감이 안 잡히는 분들께 추천하는 포스트입니다. 앞으로의 대략적인 공부 방향을 잡는데 도움이 될 것입니다.   프론트엔드 개발, 뭐하는 직종이야? (By paul90 님) 프론트엔드 개발에 대한 대략적인 틀을 잡아주고, 프론트엔드 개발자가 되기 위해 어떤 역량이 필요한 지 알려주는 포스트입니다.   웹 프론트엔드 개발자, 어떻게 준비해야 할까? (By 윤지수 님) FE 개발자가 실제 업무에서 어떤 일을 하는 지 살펴보고, 이를 바탕으로 경력 같은 신입 FE 개발자가 되기 위해 어떤 경험을 해보면 좋을 지 안내해주는 포스트입니다.   2020 FrontEnd 개발자가 되기 위한 10가지 방법 (By Harang 님) 2020년 7월에 진행 된 우아한테크세미나(주니어개발자로 성장하는 우아한 방법들)를 작성자님이 듣고 요약한 포스트입니다.   비전공자 웹개발자로서 살아남는 법 정리본(출처:okky) (By 렛츠기릿 님) 웹 개발자에게 꼭 필요한 지식을 중요도 순으로 나열하고, 각 항목마다 중요한 이유 및 효과적인 공부법에 대해 정리한 포스트입니다.   프론트엔드 추천 자료 모음 (By 문건우 님) velog에서 엄청나게 많은 좋아요를 받은 포스트로, 프론트엔드 개발자에게 유익할만한 양질의 자료(사이트, 블로그, 깃허브, 유튜브 등등)들이 풍부합니다.   웹 프론트엔드 개발자 아무것도 모르는 상태에서 취업까지 하는 구체적인 준비방법 (By 라매 개발자 님) 노베이스 상태에서 프론트엔드 개발자가 되기 위해 무엇을 공부하고 준비해야 하는지 아주 구체적으로 알려주는 유튜브 영상입니다. 길이는 16분 정도 됩니다. 📌 FE 관련 학습 자료   모던 JavaScript 튜토리얼 (JavaScript 학습 사이트)   Web Development Tutorial (웹 개발 튜토리얼 사이트) (By 이웅모 님)   초보자를 위한 HTML &amp; CSS 동작과 원리 (edwith 강의) (By 윤지수 님) 📌 FE 면접 질문 및 필요한 지식 (이 카테고리의 자료들엔 따로 부가 설명을 달지 않겠습니다.)   신입 개발자 면접 준비 (1) : 일반 면접 관련 예상 질문(개발 외) (By 코딩맛집 님)   프론트엔드 개발자 면접 정리 (By suyeonme 님)   prepare_frontend_interview 레포지토리   취준생이 반드시 알아야 할 프론트엔드 지식들 레포지토리   프론트엔드 면접 질문 모음 (By honeysuckle 님)   프론트엔드 개발자 기술면접 인터뷰 질문 모음(업데이트) (답변 있음) (By 오렌지셔츠 님)   프론트엔드 개발자 면접 질문(기술면접) 정리 (By sunnykim91님)   프론트엔드 면접 문제 은행 질문 답변 (By wkahd01 님)   프론트엔드 인터뷰 핸드북 (번역) (By Yangshun Tay님)   안녕하세요, 프론트엔드 신입에 지원합니다. (By heyiminhye 님)   신입 개발자 전공 지식 &amp; 기술 면접 백과사전 (By Gyuseok Kim 님)   Brave Tech Interview 기술면접 문제 해설 레포지토리 📌 Etc.   성장의 조건 (By 제임스 님)   개발을 잘 하는 습관 (By Sungho Kim 님)   개발자가 되고픈 어린 친구들에게... (By 신현묵 님)   지원자도 회사를 평가합니다. 이렇게요. (By 유디v 님)   개발자들이 개발쪽으로 가려고 하는 비전공자들한테 가지 말라고 하는 이유 (By botho 님) 개발자의 현실 - 지옥편 느낌..👿   모두를 위한 컴퓨터 과학 (온라인 강의) 하버드 대학의 인기 강의로 뽑히는 데이비드 말란 교수님의 CS50 강의를 한글 자막과 함께 무료로 볼 수 있어 여기에도 소개합니다.   초등학생에게 Git을 설명해본다면? (Git 1편) (By Eddy 님)   초등학생에게 Git branch와 merge를 설명해본다면? (Git 2편) (By Eddy 님)   스타트업 신입 취업성공에 영향을 미치는 요소 (By 라매 개발자 님)   개발자 되는법 - 코딩 처음부터 배울때 뭐부터 해야해요? (By 테크보이 워니님)   개발자 되려면 어떻게 코딩 배워야 돼요? - 현직 개발자가 알려드립니다. (By 테크보이 워니님) 부디 많이들 도움을 얻으시기를 바랍니다. 😃    +)   엄청난 관심   감사드립니다..! 깃허브 레포지토리 (가능하면 이 포스트에도 업데이트한 내용을 계속 반영하겠습니다.)  최근 업데이트 날짜 : 2022-03-23 혹시 서비스에 유튜브 메일 번역이나   유튜브 댓글 번역 같은 만약 필요하시다면 이걸 이용해보세요!  https://github.com/KoreanThinker/react-native-translator 아래처럼 hook을 이용해서 간단하게 사용하실 수 있습니다! 이 라이브러리로 만든 예제 앱도 확인해보세요!  https://github.com/krtk-dev/translators  번역기를 사용할 때 정확한 표현을 찾기 위해 [구글, 카카오, 파파고] 번역기들을 하나씩 비교하곤 하였는데 이 과정이 너무 불편하다고 느껴 한 번에 비교할 수 있는 앱으로 출시하였습니다.   플레이스토어에서 20,000 다운로드를 기록중인 앱이지만 일이 바빠 관리를 못하고 있다가 최근 시간이 생겨 2.0.0 버전으로 버전업을 하며 오픈소스로 전환하였습니다.  기술스택 React Native @0.67 Context api Typescript 코드 전체코드 https://github.com/krtk-dev/translators 번역기능만 분리해 놓은 패키지 각 번역기들을 밑에 예제 처럼 자유롭게 사용하실 수 있습니다. github :  https://github.com/KoreanThinker/react-native-translator npm :  https://www.npmjs.com/package/react-native-translator   {result} ``` 다운로드 링크 appstore :  https://apps.apple.com/app/id1611097883 playstore :  https://play.google.com/store/apps/details?id=com.koreanthinker.translators CI/CD를 구현하여 프로젝트를 관리 할 것이다.  github action 을 통해 아래 두가지 기능을 자동화 시킬 것이다. PR 리뷰중에  yarn lint 와  yarn test  작동 메인 브렌치에 푸시 되면 배포 파일 구조 루트 폴더에서  .github 와 그 밑에  workflows CI code 결과 CD 파이어베이스 배포 권한 부여 파이어베이스에 배포하기 위해서는 권한이 필요하다. 터미널에  firebase login:ci 깃헙 레포에 시크릿 키로 저장 code 결과 해당커밋 :  https://github.com/KoreanThinker/music-shorts-velog/commit/b569209dc9e3e8062187f3c29d38b75d2e3faca2 전체코드 :  https://github.com/hardcore-study-group/music-shorts 실제 spotify계정으로 테스트를 여럿 진행하다보니 해당 계정이 정지 되었다... 따라서 목데이터를 이용해서 테스트하는 방식으로 변경할 것이다. 목표 SpotifyTestApi 모듈 생성 기능 API호출시 json으로 저장된 mock데이터를 반환해줌 파일 구조   코드 SpotifyWebApi를 상속받아 해당 메서드 호출시 그대로 목데이터를 리턴해줌 Mock data 수집 테스트 코드 변경 Tsconfig 수정 tsconfig.dev.json 개발환경에서 module폴더 안의 파일들이 typescript 문법을 사용할 수 있도록  module tsconfig.json 프로덕션 환경에서는 사용하지 않기 때문에 exclude에  module 테스트 실행  spotify-web-api-node 라이브러리에 필요한 기능이라고 판단해 PR작업 중이다.  링크 해당커밋 :  https://github.com/KoreanThinker/music-shorts-velog/commit/fcdd5958f6ad432c1dff39097eff58fd0361b443 전체코드 :  https://github.com/hardcore-study-group/music-shorts 코드 작성 기존코드에서  getSpotifyFirebaseCustomToken  함수의 반환값에 uid를 추가해주었고 accessToken, refreshToken을 firebase auth에 저장함. 테스트 코드 작성 트랙 리스트를 반환하는지 getSpotifyFirebaseCustomToken 에 반환값에 대한 테스트 코드를 변경해주었고 이과정에서 uid를 캐싱함 const testFunctions = firebaseFunctionsTest(); https://accounts.spotify.com/authorize&quot; musicshortsvelog@gmail.com   ``` 테스트 실행   이번 챕터 코드 :  https://github.com/KoreanThinker/music-shorts-velog/commit/a9ef7aa2f8b533d812769655250a36fcd76d627f 전체 코드 :  https://github.com/hardcore-study-group/music-shorts &quot;스포티파이로 로그인&quot; 기능을 구연하기 위해 두가지 API를 만들것이다. getSpotifyOAuthUrl // 스포티파이로 로그인 할 수 있는 URL을 제공한다. getSpotifyCustomToken // 로그인후 받는 Spotify토큰을 파이어베이스 토큰으로 변환 사전작업 Spotify developers dashboard에 접속하여 Redirect URIs에  http://localhost/callback /functions/testServiceAccountKey.json package.json 의  test getSpotifyOAuthUrl 기존의 코드를 삭제하고 index.ts에 코드를 작성하였다. 테스트 코드를 작성하여 테스트를 해보자.  getSpotifyOAuthUrl  함수의 반환값을 웹브라우저에서 열어보면 이러한 페이지로 연결된다.   getSpotifyFirebaseCustomToken 테스트 코드 작성 테스트를 하기 위해서는 유효한  spotifyCode 를 파라미터로 제공해야 하는데 이는  getSpotifyOAuthUrl spotifyCode 를 받아  getSpotifyFirebaseCustomToken 를 테스트 해보겠다. puppeteer설치  puppeteer 라는 라이브러리를 사용하여 웹뷰를 띄울 것이다.  yarn add -D puppeteer 명령어로 설치 할 수 있다. 실제 테스트코드 결과  yarn test 전체 코드 :  https://github.com/hardcore-study-group/music-shorts Spotify developer setup 우선  스포티파이 개발자 웹사이트 에 로그인하여 파이어베이스 처럼 프로젝트를 하나 만든다. 생성한 프로젝트는 기본적으로 개발모드이고 승인된 유저만 서비스에 로그인 할 수 있도록 되어있다. 따라서 개발중에 사용할 스포티파이 계정을 하나 추가해주면 된다. Spotify web api  https://developer.spotify.com/documentation/web-api/   설치 기본적으로 http호출로 사용할수 있지만  오픈소스로 제공된 훌륭한 라이브러리 yarn add spotify-web-api-node 사용법 Flutter playback sdk 스포티파이 api는 프리미엄 유저들에 한해서 음악 스트리밍 기능을 제공하지만  .mp3  같은 음악파일이나  https://spotify.com/music/straming/{random_id}.mp3 같은 주소를 제공해주지 않는다. 대신 sdk를 통해 플레이어 자체를 제공하고 play, pause, next, prev등의 함수를 호출하여 조작할 수 있다. spotify에서는 web, android, ios 용 sdk를 제공하고 있으며 우리 서비스는 이 3가지를 합친  flutter_spotify_sdk https://pub.dev/packages/spotify_sdk 전체코드 :  https://github.com/hardcore-study-group/music-shorts TDD를 하고 싶지만 우선은 임의로 테스트를 해볼 함수를 먼저 만들고 그 후에 테스트를 해보겠다. (DDT?) 이 함수에 대해서 4가지를 테스트 해볼 것이다. 결과의 타입이 string 인지 결과가 &quot;server is running&quot;인지 data가 없으면 오류를 던지는지 비 로그인시 오류를 던지는지 패키지 설치 mocha // 테스트 프레임워크  chai // assertion 라이브러리 ts-node // 빌드하지 않고 typescript를 바로 실행시킬수있는 라이브러리, 테스트코드를 빌드하지 않고 실행하기 위함 yarn add -D mocha chai @types/mocha @types/chai ts-node firebase-functions-test tsconfig.json 수정 tsconfig.dev.json tsconfig.json 테스트 코드 작성 실행 package.json에 scripts안에 다음과 같은 스크립트를 추가해준다.  &quot;test&quot;: &quot;mocha --reporter spec test/**/*.test.ts -r ts-node/register &quot;, 그후  yarn test 추가사항 전체코드 :  https://github.com/hardcore-study-group/music-shorts 동료 개발자와의 원할한 협업을 위해서  Eslint 와  Prettier 를 사용하여 포메팅을 할 것이다. Eslint eslint는 문법 linting과 코드 스타일 포메팅을 동시에 제공하는 라이브러리이다. Eslint는 functions를 설치하면서 같이 설치가 됬다.  Vscode 의  ESLint Prettier Prettier는 Eslint와 다르게 포메팅만 해준다. 줄바꿈이 되는 글자수같이 eslint보다 심화된 포메팅을 해주기 때문에 추가적으로 설치한다. Extention 패키지 설치 prettier eslint-config-prettier // eslint와 prettier의 포메팅이 겹치지 않게 도와줌 eslint-plugin-prettier // prettier오류를  yarn lint  yarn add -D prettier eslint-config-prettier eslint-plugin-prettier .prettierrc.js 파일 생성 .eslintrc.js 파일 수정 오류 해결 cmd + shift + p 키를 눌러 팔레트를 열어준뒤  format document 전체코드 :  https://github.com/hardcore-study-group/music-shorts 둘러보기  Firebase functions 시리즈에서 다룰 폴더는 오직  project/functions cd functions/ &amp;&amp; code . 패키지 설치 터미널을 열고  yarn 함수 작성 기본 제공 함수  src/index.ts  파일에 들어가서 주석을 풀어줍니다. 함수의 이름은 변수의 이름인  helloWorld 기본 제공함수 실행 저장후  yarn start 를 실행하여 서버를 가동시킵니다. 그러면 shell이 열리게 되는데  helloWorld() HTTP호출 HTTP호출을 하고 싶다면  yarn serve onCall HTTP 호출방식을 이용하면 모든서비스에서 쉽게 사용이 가능한 기본적인 방식이지만 보안문제와 인증문제등 여러가지로 복잡해진다.  따라서 우리는 onCall이라는 functions내장 기능을 사용하여 통신을 할것이다. onCall도 당연히 http 통신 방식이지만 인증, 보안을 파이어베이스에서 알아서 처리해준다.  onCall을 사용하면 호출을 하기 위해 호출을할 FE에 파이어베이스를 깔아야 한다는 번거로움이 있지만 인증과의 연동이 매우 훌륭하여 쓸만하다. 첫 onCall 함수 작성 yarn start 전체코드 :  https://github.com/hardcore-study-group/music-shorts 파이어베이스 프로젝트 생성  파이어베이스 콘솔 프로젝트 요금제 업그레이드 Functions를 사용하기위해서는  Blaze firestore 활성화 왼쪽 매뉴바에  Firestore Database Functions 를 통해서면  Firestore 에 접속할것이기 때문에  프로덕션 모드 nam5(us-central) 을 사용해주시면 되고 한국에서만 사용되는 서비스라면  asia-northease3(서울) 로 설정해주시면 됩니다. 이외의 위치들은  링크 firebase-tools 설치 firebase-tools? firebase-tools는 firebase 프로젝트를 테스트, 관리 및 배포할 수 CLI 입니다. 설치 명령어 npm install -g firebase-tools 설치 확인 fireabse --version 인증 firebase login 패키지 설치 프로젝트 Init firebase init Firestore, Functions, Hosting  이렇게 3개를 사용했습니다.  Hosting 은 두가지 옵션이 있는데   우선은 이걸로 설정하겠습니다. 엔터를 눌러 다음화면으로 넘어갈 수 있습니다. 원격 firebase 프로젝트와 연결 위에서 미리 프로젝트를 만들어 두었기에  Use an existing project 기타 프로세스 이후에 프로세스는 아래대로 진행해주시면 됩니다. What file should be used for Firestore Rules?  그냥 Enter What file should be used for Firestore indexes?   그냥 Enter What language would you like to use to write Cloud Functions?  Typescript Do you want to use ESLint to catch probable bugs and enforce style?  Yes Do you want to install dependencies with npm now?  n What do you want to use as your public directory?  그냥 Enter Configure as a single-page app (rewrite all urls to /index.html)?  N Set up automatic builds and deploys with GitHub?  N 결과 터미널에  code . 전체코드 :  https://github.com/hardcore-study-group/music-shorts 💡  들어가기 앞서  TypeScript 는  javascript  기반의 확장 슈퍼셋(Superset)언어로 기본  JS 에서 제공하는 타입에  TS  타입이 조금 더 추가되는 방식이다. 📌 The primitives : 기본 타입 ↪ Any Type  Any  : Dynamic Type 모든타입 허용, 타입에 제한이 없음.  Any  타입은 아무런 기능도 제공하지 못하므로 TS를 사용하는 의미가 없어진다.  잘못된 변수의 사용도 잡아주지 못하며 실행 중 에러가 발생할 수 있다. 💡  github readme 꾸미는 이유 무엇보다 자기만족이 매우 크다. 다른 게시물에 꾸미는 다양한 방법이 있으므로 해당 게시물은 내가 적용한 요소들만 정리하였습니다. 진행하면서 어려웠던 부분과 시간이 걸린 부분 중점으로 정리함. 0. Repo생성 및 README 생성   계정명과 같은 저장소를 생성한다.   리드미를 추가해서!! 자 이제 준비물은 준비가 다 되었다. 1. Header &amp;&amp; Footer   밋밋한 리드미에 생동감을 넣어주는 기특한 녀석이다. kyechan99님의 capshule render 프로젝트 2. 뱃지 추가하기   Shields / 리드미 뱃지 Simple Icon / 뱃지에 사용할 아이콘 리드미 뱃지에서 원하는 뱃지의 스타일을 고른 후 원하는 색상을 넣어 작성하면 된다. 나는 뱃지를 가운데 위치하기 위해 html방식으로 가져왔으며 &lt;p align=&quot;center&quot;&gt;&lt;/p&gt;  태그 사이에 위치했다. 3. 힙한 나의 깃 스텟 표시하기   간편하게 내가 자주 깃허브에 올리는 언어를 표시해 준다. 부끄럽지만 나의 깃허브 커밋수까지 표시해준다  뭔가 다 까발리는 느낌이 크다 아쉬운점은 나의 깃헙계정으로 집계하다보니 초대받아서 진행한 부분은 반영이 안된다.  열심히 안한거 같이 보인다. 4. velog 표시하기   은근슬쩍 나의 블로그를 홍보하며, 블로그도 작성한다는 이미지 주기에 아주 좋은 것 같아서 넣었다. eungyeole님의 Velog 포스트로 Github를 꾸며보자! 5. 페이지 조회수 뱃지   HITS 생성페이지 해당 페이지로 접속해 원하는 페이지의 URL을 넣고, 원하는 스타일로 꾸미면 아래에 원하는 형식으로 복사해 가져올 수 있다.  정확하진 않지만 그냥 이쁘다 6. 나의 커밋시간대 표시   productive-box / 나의 커밋시간대 표기하기 gist_id Fork한 저장소에서 설정  =&gt;  Secrets  =&gt; =&gt;  개발자설정  =&gt;  토큰생성  =&gt; 이제 레포의 Actions탭으로 이동하여 액션을 활성화 해준다. 바뀌길 기다리기 힘들다면 Fork한 레포의 리드미에 스페이스 하나 넣고 커밋하면 강제로 Action이 돌아간다 완성🥳[링크]   😊 📎 참고 링크  Shields / 리드미 뱃지  Simple Icon / 뱃지에 사용할 아이콘  Github ReadmeStats / 리드미에 스텟을 표시함  woo0_hooo님의 [Github] github profile 예쁘게 꾸미기  seondal님의 Github Readme 꾸미기 총정리  somjang님의 Tstory님 게시물  eungyeole님의 Velog 포스트로 Github를 꾸며보자!  HITS 생성페이지  productive-box / 나의 커밋시간대 표기하기 💡  들어가기 앞서 해당 내용은 코딩애플의  빠르게 마스터하는 타입스크립트 를 기반으로 작성하였습니다. 기반은 코딩애플의 강의지만 프론트 구현이 아닌 서버 구현을 위해 추가로 구글링 한 자료를 정리하였습니다. 📌설치 순서 NodeJS 설치하기 터미널에서 npm을 이용하여 글로벌로  typescipt 작업할 프로젝트 폴더 생성 후 작업폴더로 이동하기. tsconfig.json 파일 생성하고, 원하는 옵션 넣기. 작성한 코드(.ts)를 컴파일하기(.js) typescript로 작성한 코드는 결과적으로 js파일로 컴파일해야 실행시킬 수 있다.  tsw -w 를 사용하면 현재 폴더에 js파일로 컴파일하여 저장해 준다. 컴파일된 파일을  node file.js 로 실행할 수 있다. 📌TS 사용법 📌TS 사용예시 🎈이런 식으로 간편하게 사용할 수 있으며 변수를 선언할 때 JS의 편리함을 살짝 포기하고 코드의 직관성과 사전에 에러를 잡아준다는 큰 이점을 가져온다. &#39;작은것을 버리고 큰 것을 얻음&#39; 그리고 제일 큰 이점은 역시 내가아닌 다른 개발자가 나의 코드를 볼 때 코드를 파악하는데 들어가는 시간이 줄어든다 코드량이 커지면 커질수록 더욱 차이가 크다고 한다. 📌.ts 파일 실행하기 npm i -g ts-node npm init 으로 🗂 package.json 을 생성한 후 간편하게 실행시킬 수 있도록 정의해 보겠음. 이제 간편하게  npm start 📎 관련 링크  TYPE SCRIPT DOCS 📌 타입스크립트란? 마이크로소프트에서 구현한 JavaScript의 슈퍼셋 프로그래밍 언어로, 확장자는 .ts 이며, 컴파일의 결과물로는 JavaScript 코드로 출력한다.   최종적으로 JS 코드   로 구동된다. 정적 타입을 명시할 수 있는것이 순수 JS와의 가장 큰 차이점이다. 개발자의 의도한 변수나 함수 등의 목적을 더욱 명확하게 전달할 수 있고, 잘못된 사용으로 인한 피드백을 받을 수 있으므로 사용하기 전에 있을만한   타입 에러들을 미리 잡아   주어 생산성을 향상시킬 수 있다. 📌 내가 배우고 싶은 이유 내가 좋아하는 JS를 좀 더 배우고 싶은게 제일 큰 이유다. 실무를 진행하며 자주보는 런타임 오류를 조금이나마 줄이고 싶어서. 구인에 있어 우대사항에 자주 언급되므로 이직 시 우대를 받기 위해서. 스택 오버플로(Stack Overflow) 설문조사에서 개발자가 사랑하는 언어 2위에 올랐기에 나도 사랑하고 싶어서. 슈퍼셋(Superset) 즉 추가 문법이기 때문에 기존 코드에 적용이 쉽고 접근성이 좋아서. 📌예시  실행 전에는 에러인지 알려주지 않는 우리의 JS  코딩 중 잘못된 점을 짚어주는 친절한 우리의 TS 📎 관련 링크  SAMSUNG SDS  나무위키 안녕하세요. 데이터리안 윤선미입니다. 1월, 2월 세미나를 하면서 가장 많이 받은 질문 중에 하나가 &quot;데이터 분석가는 어떤 일을 하나요?&quot; 였습니다. 데이터 분석가, 요즘 채용도 많이 한다고 하고 앞으로 전망도 좋다는데 무슨 일을 하는지 궁금하신 분들이 많았던 것 같아요.  그래서 3월 세미나 주제를  &quot;데이터 분석가는 어떤 일을 하나요?&quot;  로 잡고 분석가들이 현업에서 밥 먹듯이 하는 퍼널 분석, 사용자 행동 데이터 분석을 주제로 강연을 합니다. 강연은 데이터리안 멤버 두 분(김민주, 이보민)이 해주실거예요. 데이터리안 월간 세미나는 총 2부로 진행됩니다. 1부는 강연, 2부는 Q&amp;A인데요. 매달 그렇듯이 이번 달에도 좋은 질문들을 많이 보내주셨어요.  1, 2월 세미나에는 주로 학생 취준생 분들이 질문을 많이 보내주셨다면, 이번에는 기획자, 마케터, 데이터 분석가 등 현업에서 데이터로 일을 하고 있는 분들의 질문도 학생, 취준생 분들 못지않게 많았다는 것이 큰 특징입니다. 질문에 대한 답변이 2부에 이어질 예정이니까 혹시 &#39;어! 저거 나도 평소에 궁금하던건데&#39;라고 생각되는 질문이 있다면 3월 세미나 신청해주세요. 일정  👉🏼 세미나 신청 링크! 일시: 3월 29일 오후 7시~9시 참가비: 10,000원 장소: Zoom 미팅룸 신청 기한: ~ 3월 29일 오전 10시 지금까지 들어온 질문들 ٩( ᐛ )و  &#39;이번 달 월간 핵심지표가 떨어졌다. 데이터보고 원인이 무엇인지 알아봐달라.&#39; 라고 얘기를 들으면 어느 단계까지 분석을 해서 전달해야할지 모르겠어요. - 마케터 A  분석은 하겠는데 전략 짜는게 어렵습니다. &#39;분석 결과 알겠고 이게 문제인거 알겠는데... 그래서 어떻게 해야해?&#39; 라는 질문엔 어떻게 대응하시나요. - 데이터 분석가 B  혹시 데이터 분석가로 일하는 현재로부터 몇 년 전 과거로 돌아갈 수 있다면 자신에게 해주고 싶은 조언이 있으신가요? - 학생 C  사용자 데이터 분석시 분석하는 방법 순서가 있나요? 아니면 이것저것 우선 전방위적으로 다 하면서 인사이트를 찾아가시나요? - 마케터 D  데이터 기반 의사결정의 경험이 거의 없는 조직에 퍼널분석이라는 개념을 도입하려고 합니다. 서비스가 발전하면서 고객분석의 중요성을 많이 느끼고 있는데, 설득하는게 쉽지 않네요ㅠㅠ 팀원들이 퍼널 분석을 경험해 볼 수 있는 가장 쉬운 방법에는 무엇이 있을까요? - 기획자 E  오늘날(아니면 앞으로) 데이터 의사결정이 미치게 될 범위와 가능성 - 학생 F  퍼널 분석의 평균치가 있는지 궁금합니다. - 취준생 G  대형 유통 기업의 데이터팀을 인터뷰 했을 때 주로 다른 팀(마케팅, 영업 등)의 의뢰를 처리한다고 답변을 받았어요. 기업의 규모에 따라 또 산업에 따라 분석가의 역할 붐위는 다 달라질 수 밖에 없는 걸까요? - 학생 H  Funnel, RFM 과 같은 방법론에 대해서 초보자가 공부할 수 있는 책이나 영상 추천해주세요! 개인적으로 공부하다보니 ML/DL과 같은 이론은 검색하면 쉽게 접근할 수 있는데 실무적으로 사용되는 분석 방법에 대해서 알려주는 강의나 책은 많이 없더라고요ㅜㅜ - 취준생 I 이 글은  데이터리안 웹사이트 에서도 읽으실 수 있습니다. 안녕하세요. 데이터리안 윤선미입니다.  Revenue, Profit, Paying User의 비율, ARPU(Average Revenue Per User), ARPPU(Average Revenue Per Paying User), Up-selling, Cross-selling, 객단가 등 매출과 관련한 전문용어는 왜 이렇게 많은 걸까요? 매출을 내는 일이 회사에서 가장 중요한 일이기 때문입니다. 물론 비즈니스가 성장 단계의 어디쯤에 있느냐에 따라 매출보다 더 중요한 것(서비스 이용자 수 등)이 있을 수는 있겠지만, 그런 비즈니스도 결국에는 돈을 벌어야 살아남을 수 있습니다. 10배 이상 뛰어난 데이터 분석가가 되는 법 혹시  How to Be a 10x Software Engineer 라는 글을 읽어보신 적 있나요?  이 글에서는 주니어 개발자가 자주 저지르는 3가지 실수를 소개하고, 같은 문제를 시니어 개발자가 어떻게 다르게 해결하는지를 보여주면서 &#39;10배 이상 뛰어난 개발자가 되는 법&#39;을 알려주는데요. 이 글에 따르면 주니어 개발자가 자주 저지르는 3가지 실수는 각각 이렇습니다. Not investigating tooling enough (도구에 대한 고민, 연구를 충분히 하지 않음) Not asking for help (도움을 요청하지 않음) Not delivering business value (비즈니스 가치를 제공하지 않음) 셋 다 고개가 절로 끄덕여지는 항목이지만, 저는 특히 세 번째 &#39;비즈니스 가치를 제공하지 않음&#39;이 10x 개발자와 그렇지 않은 개발자를 가르는 확실한 기준이라는 생각을 했습니다. 시니어 개발자들은 그들의 코드가 비즈니스 목표를 달성하기 위한 수단이라는 것을 이해하며, 비즈니스 목표를 달성하기 위한 방향으로 모든 의사결정을 한다는 이야기인데요(심지어 그것이 코딩을 1줄도 하지 않는다는 결론을 내더라도요). 이런 기준이 아직 없는 주니어 개발자들은 종종 &#39;멋진 신기술이 나왔으니까 써보자&#39;, &#39;코드 구조가 마음에 안드니까 리팩토링을 하자&#39;, &#39;구식 플랫폼을 버리고 새 플랫폼으로 마이그레이션하자&#39;는 식으로 비즈니스 목표와는 전혀 상관 없는 근거와 방향으로 의사결정을 한다는 겁니다. (더 궁금하신 분들은  번역본 도 있으니까 읽어보시면 좋을 것 같아요.) 데이터 분석가도 비슷합니다. 멋진 머신러닝 알고리즘이 나왔대요. 이번 프로젝트에 써봅시다. (이로 인해 확실히 좋아지는 것이 없는데도 불구하고요.) 제가 이렇게 분석을 해봤는데요. 이렇게 멋진 시각화가 나왔습니다! (비즈니스 목표 달성과 전혀 관련 없음) 분석 결과 E에서 비용을 절반이나(5천원) 절감할 수 있습니다. (너무 규모가 작아 하나마나한 개선) 주니어 데이터 분석가들이 수익 창출과는 무관한 이런 일들을 하는 동안, 10배 이상 뛰어난 데이터 분석가들은 뭘 하고 있을까요? 아마 저런 일을 하는 동안 쓴 시간의 반절도 안되는 시간에, 5배의 수익을 내는 분석을 하고있었을겁니다. 여기에서 10배의 생산성 차이가 발생합니다. 매출을 분석하자 좋은 소식을 알려드릴게요.  10배 이상 뛰어난 데이터 분석가가 되는 것이, 10배 이상 뛰어난 개발자가 되는 것보다는 쉬울 수도 있습니다. 왜냐하면 데이터 분석가는 매출 분석을 하니까요! (이 글을 읽는 개발자 선생님들이 화가 나지 않기를 바랍니다.) 회사의 비즈니스 목표는 결국 매출을 향합니다. 그것이 조금 더 먼 미래에 매출이냐, 가까운 미래의 매출이냐만 다를 뿐 겉으로 보기에는 돈과 전혀 상관 없는 것 같은 의사결정들도 결국에는 매출과 연결되어 있습니다. &#39;지금 우리의 목표는 단기적으로 돈을 버는게 아니라, 사용자 수를 늘리는거야!&#39; 같은 문장을 대충 읽으면 &#39;아 지금 우리 회사는 매출이 중요한게 아니구나&#39;로 결론을 내기 쉽지만, 사실은 &#39;아 나중에 더 큰 매출을 내기 위해서 일단 지금은 이 일에 집중해야 하는구나&#39;로 해석해야 합니다. 매출 분석 시리즈를 통해 &#39;회사의 매출이 성장하고 있는지&#39;, &#39;성장 또는 하락하고 있다면 그 원인은 무엇인지&#39;, &#39;어떤 사용자들로부터 이 매출이 나오고 있는지&#39; 현상 분석 뿐만 아니라 &#39;어떻게 하면 매출을 성장시킬 수 있을지&#39; 전략까지 일부 다뤄보려고 합니다. 단순히 숫자로서 매출을 분석하는 방법론만 배워가는 것이 아니라 여러분들의 회사에서 어떻게 돈이 흐르고 있는지, 나는 그 흐름에 어떤 기여를 할 수 있을지 함께 고민해보는 시간이 되기를 바랍니다. 시리즈를 쭉 따라오다보면 여러분들이 10배 이상 뛰어난 데이터 분석가가 되어있을지도 모르지요! 다음 글에서는 회사 전체 매출을 어떻게 구조적으로 쪼개어 볼 수 있는지 얘기하려고 합니다. 우리에게 친숙한 서비스들이 매출 최대화를 위해서 어떤 장치들을 전략적으로 배치해놨는지 사례도 몇 가지 같이 소개해보겠습니다. 이 글은  데이터리안 웹사이트 에서도 읽으실 수 있습니다. 안녕하세요. 데이터리안의 윤선미입니다.  지난 글에서 보민님이  RFM 분석 을 소개해주셨어요. 고객들을 Recency, Frequency, Monetary 라는 세 기준을 가지고 분류하고 이것을 어떻게 활용할 수 있을지에 대한 이야기를 해봤습니다. 이렇게 고객들을 공통의 특징을 기준으로 그룹화하는 작업을 &#39;고객 세분화(Customer Segmentation)&#39;라고 합니다. 고객 세분화 Customer Segmentation 공통의 특징을 공유하는 집단별로 고객을 세분화하면 다양한 일들을 할 수 있습니다. 『린 분석』 p59  이처럼 고객을 세분화하여 나누고 나면 개선이 필요한 고객군을 발견하기도 하고, 다른 고객군들과 현저하게 다른 성과를 내는 고객군을 발견하기도 합니다. 여러분들이 쇼핑몰을 운영하고 있다고 생각해봅시다. 그리고 쇼핑몰의 고객들을 최초 유입 경로에 따라 세분화 해봅시다. 페이스북에서 광고를 본 사람, 인스타그램에서 광고를 본 사람, 지인의 추천으로 알게 된 사람, 구글 검색으로 알게 된 사람 등 쇼핑몰의 고객들은 매우 다양한 경로를 통해 이 쇼핑몰에 가입했을겁니다.  이렇게 고객들의 집단을 세분화하면 아래 질문에 답할 수 있게 됩니다. 어떤 채널을 통해 가입한 고객들이 가장 많은가요?  유입 채널 별로 고객 1인당 결제 금액(ARPU, Average Revenue Per User)이 다른가요?  어떤 유입 채널을 통해 들어온 고객이 우리 서비스에 가장 많은 지출을 하고 있나요? 그 유입 채널의 광고를 늘려볼까요? 아니면, 그 유입 채널에서 하고 있는 광고 형식을 다른 채널에도 적용해볼까요? 만약 인스타그램 광고를 보고 최초 유입된 고객 그룹이 다른 그룹보다 서비스 참여도도 높고 지출도 많다면 &#39;오 그렇군😲&#39; 하고 넘어갈 것이 아니라  이 성공이 어떻게 발생했는지를 알아내고 그 성공 방정식을 확대 적용해야 합니다 . 만약 인스타그램이라는 채널 자체의 특성 덕분이었다면 인스타그램으로부터 고객 유입을 더 유도하기 위해 마케팅 예산을 확대해볼 수도 있습니다. 코호트 분석 Cohort Analysis 코호트 분석은 위에서 얘기한 고객 세분화를 &#39;시간의 흐름&#39;을 기준으로 하는 것을 말합니다. 사실 넓게 이야기 하는 사람들은 위의 고객 세분화와 코호트 분석을 따로 구분하지 않습니다. 저도 고객 세분화와 코호트 분석을 엄밀하게 구분하는건 크게 의미가 없다고 생각합니다만(이름이 뭐가 중요하겠어요. 분석으로 얻은게 있었나가 중요하지요.), 고객을 세분화하는데 시간 축을 이용해 분석하는 것이 꽤 유용한 분석 방법론이 되기 때문에 이 파트에서 따로 이야기를 해보겠습니다. 예를 들어, 여러분이 온라인 쇼핑몰의 분석가라고 생각해봅시다. 이 쇼핑몰에는 매달 천 명이 신규로 가입합니다. 사업을 시작한 후 첫 5개월 동안의 고객 당 평균 매출액을 표로 그렸을 때 아래와 같다고 가정합시다.  표 출처: 『린 분석』 p60 1월 2월 3월 4월 5월 전체 고객 (명) 1,000 2,000 3,000 4,000 5,000 고객 당 평균 매출 (달러) $5.00 $4.50 $4.33 $4.25 $4.50 우리 쇼핑몰, 잘 되고 있는걸까요?  이 표를 보고 상황이 좋아지고 있는지, 나빠지고 있는지 알기는 어렵습니다. 고객 당 평균 매출이 5달러면 잘 하고 있는걸까요? 5달러에서 4.25달러까지 감소했다가 5월에 4.5달러 수준으로 회복하고 있으니까 상황이 좋아지고 있다고 생각해도 되는걸까요? 이제 같은 데이터지만 고객군을 가입 시기에 따라 나누어서 표를 다시 그려보겠습니다.  표 출처: 『린 분석』 p61 코호트 볼륨 1개월 2개월 3개월 4개월 5개월 1월 가입자 1,000명 $5.00 $3.00 $2.00 $1.00 $0.50 2월 가입자 1,000명 $6.00 $4.00 $2.00 $1.00 3월 가입자 1,000명 $7.00 $6.00 $5.00 4월 가입자 1,000명 $8.00 $7.00 5월 가입자 1,000명 $9.00 평균 $7.00 $5.00 $3.00 $1.00 $0.50 위 표를 같이 읽어봅시다. 일단 매월 1,000명의 신규 가입자가 들어오고 있는 것을 알 수 있습니다. 그리고 매월 신규로 가입한 고객의 첫 달 평균 구매액이 1월 가입자는 $5에서 5월 가입자는 $9로 거의 두 배 가까이 증가하고 있습니다. 그리고 1월 가입자들의 평균 구매액이 $5에서 $3로 가입 이후 시간이 지날수록 가파르게 하락하고 있는데 반해 3월 가입자들은 첫 달 평균 구매액은 $7에서 다음달은 $6으로 그리고 그 다음달에는 $5로 완만하게 하락하고 있습니다. 고객들의 첫 달 구매액은 크게 증가하고 있고 구매액의 감소폭도 개선되고 있는 것을 알 수 있습니다. 이렇게 사용자들을 시간의 흐름에 따라 그룹으로 나누어 분석하는 방법은 매출을 분석할 때 뿐만 아니라 리텐션, 바이럴 효과, 이탈 등 여러분들이 분석하고 싶은 어떤 지표에도 적용해볼 수 있습니다. 아래에서는 Google Analytics 에서 기본 보고서로 제공하는 리텐션 차트를 같이 살펴보면서 코호트 분석을 리텐션에 응용한 사례를 설명하겠습니다. 코호트 분석 응용 - 리텐션 차트 리텐션을 처음 들어보셨다면  리텐션 (1) Classic Retention 을 먼저 읽어주세요. 아래 차트는 Google Analytics 콘솔에서 지원하는 데이터리안 웹사이트 사용자 유지율 차트입니다. 삼각형의 차트 형태가 익숙하시죠? 위에서 봤던 코호트 분석을 리텐션에 적용했기 때문입니다. 사용자를 첫 방문 시기별로 나누어 시간이 지남에 따라 각 그룹의 사용자들이 웹사이트에 재방문하는지를 볼 수 있습니다. 아래 표에서는 사용자 그룹을 일주일 단위로 나누었습니다. 표에서는 1월 30일 ~ 2월 5일 사이에 웹사이트에 첫 방문한 사용자 그룹 등 총 6개의 사용자 그룹을 볼 수 있습니다. 컬럼에는 각 사용자 그룹이 첫 방문 이후 얼마나 시간이 지났는지를 표시합니다. 첫 방문한 주차를 0주째, 그 다음 주차를 1주째라고 부르는 식입니다.   이 차트에서는 색이 진할수록 비율이 높음을 의미합니다.  코호트 분석을 배운 여러분들이 보시기에 데이터리안 웹사이트는 어떤가요? 잘 운영되고 있는 것 처럼 보이시나요? 여러분이 데이터리안의 데이터 분석가라면 이 리텐션 차트를 보고 어떤 분석을 추가적으로 해보시겠어요? 데이터 분석은 사용자를 이해하고 설득의 방법을 찾는 여정 데이터 분석은 결국 사용자를 이해하고, 설득의 방법을 찾는 여정이라는 생각이 듭니다. 데이터 없이 사용자들의 생각을 알 수 있을까요? 아니요. 우리는 사용자들을 오해만 할 수 있을 뿐입니다. 결제를 안 하는 사용자들이 밉죠. 우리 서비스 좋은데 왜 결제를 안해줄까. 광고는 잘 되고 있고 앱을 다운로드까지 했는데 하루 이틀만에 삭제해버리는 사용자들이 원망스럽습니다. 우리 앱 재밌는데 왜 안 써줄까? 데이터를 들여다보면 사용자를 이해할 수 있게 됩니다. &#39;아 결제 하는데 이런 어려움이 있었구나&#39;, &#39;앱 튜토리얼이 너무 어려웠구나&#39; 그리고 떠나간 사용자들 또는 미래에 다시 만나게 될 사용자들을 설득할 방법을 찾을 수 있게 됩니다. 이번 글에서는 한 발 더 나아가서 &#39;사용자&#39;라고 뭉뚱그려 생각했던 집단을 여러 그룹으로 나누어봤습니다. 특정 SNS 플랫폼에서 어떤 광고를 보고 들어온 사용자들과 다른 사용자들을 비교하면서 그 둘이 다른 사용자들임을 이해했습니다. 그리고 특정 세분화 그룹(Segmentation)의 성공을 보고 감탄만 할 것이 아니라, 적극적으로 확대 적용해야 한다는 것도 이야기했습니다. 그리고 시간의 흐름에 따라 사용자를 그룹화하는 분석 방법(코호트 분석)까지 살펴봤습니다. 혹시 이슬아 작가와 정세랑 작가를 아시나요? 제가 좋아하는 두 작가인데요. 이슬아 작가가 정세랑 작가의 소설 쓰는 수업에 들어가서 ‘소설이 너무 안써져요&#39; 라고 했더니 정세랑 작가가 ‘등장 인물이 몇 명이에요? 등장 인물을 추가하세요&#39; 라고 대답했다고 합니다. 이 얘기를 듣고 난 이후에 저도 수업에서 종종 농담조로 &quot;소설이 잘 안써지면 인물을 추가하면 된대요. 분석이 잘 안풀리면 코호트를 추가하세요.&quot; 라는 말을 합니다. 꼭 데이터 분석가가 아니더라도 데이터를 사용하려고 시도해본 사람이라면, 널려있는 데이터들 사이에서 길을 잃은 것 같은 느낌을 받은 적이 있었을거라고 생각합니다. 어떤 면에서 데이터 분석은 소설을 쓰는 것과도 비슷한 것 같아요. 백지를 이야기로 채워나가야 하니까요. 결국 그 백지를 사람에 대한 이야기로 채워야 한다는 점도 비슷합니다. 이번 글을 통해 사용자를, 유저를, 고객을 더 섬세하게 이해하는데 가장 좋은 도구를 여러분에게 쥐여드렸습니다. 데이터를 가지고 사용자에 대한 이야기를 써내려가봅시다.  여러분의 서비스를 사용하는 사람들은, 어떤 사람들인가요? (세미나 홍보) Q. 코호트 분석 하고싶은데, 어떤 데이터를 가지고 해야할까요?   이런 분들에게 3월 웨비나를 추천합니다. 업무에 데이터를 활용하고 싶은데... 데이터가 없다! 업무에 데이터를 활용하고 싶은데 어디에서부터 시작하면 좋을지 모르겠다. 데이터 분석가로 근무하고 있는데 나만의 무기가 없는 것처럼 느껴진다. 데이터 분석가로 취업, 이직하고 싶은데 도대체 이 직군이 무슨 일을 하는지 정확하게 알 수가 없다. 세미나 일정  세미나 신청링크 일시: 3월 29일 (화) 19:00~21:00 장소: 온라인 Zoom 미팅룸 참가비: 10,000원 신청 기한: 3월 29일 (화) 13:00 프로그램 소개 1부 (19:00~20:20) 강연 [민주]  &quot;알아두면 쓸데있는 Funnel 잡학사전&quot; : 사용자 획득부터 결제까지. 우리가 원하는 목적지까지 사용자가 도달하도록 만드는 전략적 접근법 [보민]  &quot;사용자 행동 데이터 분석의 기쁨과 슬픔&quot; : 페이지 조회, 클릭 등 사용자 행동 데이터 수집부터 분석까지 2부 (20:30~21:00) QnA 데이터 분석가 4인에게 묻는다 이 글은  데이터리안 웹사이트 에서도 읽으실 수 있습니다. 2022년 2월 22일,   월간 데이터리안 웨비나  에서 진행된 QnA의 일부 내용 입니다. 아래 내용은  유튜브에서 영상으로도  보실 수 있고, 2월 웨비나  풀버전은 인프런 에서 보실 수 있습니다. Q. 데이터 분석가로서의 경력이 없습니다. 파이썬 코딩테스트 통과 이력이나 이에 준하는 자격증이 도움이 되는지 궁금합니다.  보민 (3년차 데이터 분석가) 저는 경력이 없으니까 더더욱 프로젝트, 포트폴리오를 잘 만들어야 된다고 생각하는 사람이고요. 사실 말씀드렸던 것처럼 코딩 테스트 통과 이력을 말씀하시는 분 처음 보긴 했는데,  어쨌거나 자격증은 그렇게까지 도움이 되지 않는다고 생각을 하고요. 코딩 테스트 통과 이력은 사실 생각을 이번에 해봤거든요. 만약에 이 회사가 코딩 테스트가 필요하고, &#39;파이썬이라는 언어에 대한 코딩 실력을 확인해야겠다&#39; 라고 생각을 했었으면, 사실 그 회사에서 코딩 테스트를 줬을 것 같아요. 지금 말씀하시는 거는 다른 회사의 코딩 테스트인 것 같은데 그 코딩 테스트가 몇 문항으로 이루어졌는지, 난이도가 얼마나 되는지, 거기에서 쓰인 기술이 뭔지 이런 것들을 전혀 모르는 상태에서 그냥 코딩 테스트를 통과했었던 이력만 갖다 놓는다면, 제가 만약 면접관이라면 별로 신경을 안 쓸 것 같아요. 사실상 큰 쓸모가 없을 것 같거든요. 그래서 그 부분은 별로 의미가 없지 않을까 라는 생각이 조금 들고요.  저는 이제 실무에 바로 투입됐을 때  &#39;이 사람이 데이터 추출울 할 수 있는 사람이냐&#39; 이게 제일 중요하기 때문에  사실 코딩 테스트 통과 이력이나 자격증보다는,  SQL을 얼마나 잘 쓰는지, 어디까지 어떻게 추출할 수 있는지 , 이런 것들이나 아니면 데이터 분석 프로젝트를 했다 라고 치면  분석에서 어떤 인사이트를 얻었고, 그 과정에서 어떤 배움을 얻었는지 이런 것들이 더 중요할 것 같아요. 그리고 사실 이것도 신입 때 얘기고, 경력으로 가게 되면 프로젝트도 잘 안 물어보고요. 경력일 때는 본인이 회사에서 뭐 했는지 그런 것들을 더 많이 물어보게 되더라고요.  처음 취준하실 때는 이런 것들이 계속 신경이 쓰이시겠지만, 그런 것들은 생각보다 현업에서는 도움이 되지 않는다  라고 생각을 해주시면 될 것 같아요.  선미 (7년차 데이터 분석가) 저는 아까 질문 올라온 것 중에 답변하고 싶은 게 있었는데요. “ 어디 공모전 같은 데 내면 어차피 현업하는 사람들이 다 수상을 싹쓸이 해가서 도전 하고 싶은 생각이 안 든다 ”는 그런 질문이, 질문 아니고 약간 하소연..이 올라왔었거든요. 근데 그거 보면서 생각한 게,  공모전 참여해서 내가 수상을 못한다고 해가지고 내가 분석해 보고 고민한 내용이 어디 사라지는 게 아니잖아요.  그러니까 그거를 왜 수상에만 포커스를 맞추는지 잘 모르겠어요.  수상을 하는 사람은 그 프로젝트를 해본 사람 중에서 정말 정말 소수고, 사실 심사위원들의 입맛에 맞는 뭔가 결과를 낸 사람들이 수상을 하는 거잖아요.  나도 그 데이터에 대해서 분석을 해봤고, 내가 어떤 인사이트를 내봤고, 앞으로 이걸 가지고 어떤 것들을 해보고 싶다  그거를 남들한테 잘 설명할 수 있다고 하면 저는 그것도 다 포트폴리오에 써도 된다고 생각하거든요. 그래서 &#39;조금 어렵게 생각하는 것이 아닌가&#39; 이런 생각이 갑자기 들었어요.   민주 (3년차 데이터 분석가) 제 이력서 보시면 발표 자료에는 안 들어있었는데 원본에 보시면 프로젝트 중에, &#39;김해시 화재 발생 데이터&#39;를 분석한 프로젝트 내용이 들어가 있어요. 이게 공모전 데이터 가지고 한 거거든요. 공모전에 참가는 했는데 수상과는 거리가 정말 멀긴 했어요. 그래도 이제 분석한 내용을 선미님 말씀하신 대로  &#39;이런 식으로 분석을 해봤다&#39; 하는 거를 넣었거든요.  그러니까 충분히 그런 식으로 활용을 하실 수 있으니까  꼭 수상에만 의의를 두지 않으셔도, 편한 마음으로 해보셔도 좋을 것 같습니다.    선미 (7년차 데이터 분석가)  데이터를 가지고 완전히 다른 걸 해볼 수도 있는 거 거든요 . 심사위원들이 원하는 의도대로 할 필요는 없는 거잖아요. 분석 주제를 선정한다든지 이런 것도 사실 내가 그 데이터를 가지고 더 재밌는 주제를 뽑아낼 수도 있는 거고요. 그 공모전을 조금 활용해 보시면 좋을 것 같아요. &#39;내가 그 사람들한테 평가받는다&#39; 라는 프레임에서 벗어나서  &#39;내가 이 데이터와 플랫폼을 가지고 놀겠다&#39;, &#39;이용해 먹겠다&#39;  이런 느낌으로 해보셔도 괜찮을 것 같아요.   혜정 (3년차 데이터 분석가) 저도 선미님이랑 같은 얘기하려고 했는데요. 저도 공모전을 참여해봤는데 거기에서 수상을 한다는 것은 그 주최자들에게 맞춘다는 뜻이더라고요. 그래서 그 사람들이 원하는 분석, 혹은 원하는 결과를 내야 수상을 할 수 있는 건데  이 데이터로 특정한 결과만 낼 수 있는 것은 아니고 사실 다양한 접근을 해볼 수 있고 여러가지 개선 방안, 이런 게 나올 수 있어요 .  뒤의 질문에도 있긴 한데 데이터를 현업에 계시지 않으면 얻기가 되게 힘들잖아요. 취업 준비를 하는 입장에서는 데이터를 구하기가 되게 어려우니까 &#39;공모전에서 수상을 한다&#39; 이런 개념으로 접근 하시는 게 아니라  &#39;공모전에서 데이터를 얻는다&#39; 이런 개념으로 접근하시는 게 좋을 것 같아요 . 공모전에서 많은 데이터를 신청만 하면 얻을 수 있고 그거를 가지고 내 마음대로 뜯어보고 분석하고 잘하면 수상도 할 수 있고 이런 건데, 그 과정이 중요한거지 수상을 했다, 1등을 했다, 몇 등을 했다 이게 중요한 거는 결코 아니거든요. 설령 1등을 하셨어도, 대상을 탔어도 그 안에서, 프로젝트 과정에서 내가 기여한 게 없다거나 하면 취업 시에 좋게 작용하기는 어려운 부분이 있으니까 데이터를 얻는 통로로 공모전을 생각해주셔도 좋을 것 같아요.  특히나 데이터 분석 같은 경우에는 &#39;어떤 공모전이 제일 유명하다&#39; 뭐 이런 게 있는 것도 아니고, &#39;여기만 나가면 어느 회사 합격된다&#39; 이런 게 있는 것도 사실 아닌 것 같고,  데이터를 얻어서 내가 분석할 수 있는, 연습할 수 있는 툴을 가진다 데이터를 가진다 이런 생각으로 접근해 주시면 좋을 것 같아요.    보민 (3년차 데이터 분석가) 그리고 공모전 데이터도 어느 정도, 외부에 반출해야 되니까  가공이 된 데이터이기는 한데 그럼에도 불구하고 굉장히 이상한 데이터도 되게 많거든요.  그러니까 그런 것들도 경험을 해보시면 도움이 돼요. 실제 데이터들은 굉장히 이상하기도 하고, 데이터가 없을 때도 있고 이렇거든요. 그래서 되게 당황스러울 때가 있는데, 인프런에서 저희 강의 들어보신 분들은 아시겠지만 해커랭크, 이런 플랫폼에서는 진짜 정제돼서 정답만 나오는 그런 테이블들이 많이 있어요. 근데 실제 현업 데이터는 그렇지 않고, 분석가로서 일을 하게 되면 그것보다 더 카오스인 테이블들을 굉장히 많이 만나는데  &#39;실무 예습을 한다&#39;라고 생각해주셔도 좋을 것 같습니다. 🧐 실제 회사에서 데이터 분석가가 자주 하는 업무들이 궁금하시다면, 성과를 내는 데이터 분석에 대해 힌트를 얻고 싶다면, 3월 웨비나 [데이터 분석가는 어떤 일을 하나요?] 에서 만나요! 세미나 일정 👉  세미나 신청링크 일시: 3월 29일 (화) 19:00~21:00 장소: 온라인 Zoom 미팅룸 참가비: 10,000원 신청 기한: 3월 29일 (화) 13:00 프로그램 소개 1부 (19:00~20:20) 강연 [민주]  &quot;알아두면 쓸데있는 Funnel 잡학사전&quot; [보민]  &quot;사용자 행동 데이터 분석의 기쁨과 슬픔&quot; 2부 (20:30~21:00)  QnA  데이터 분석가 4인에게 묻는다 이 글은  데이터리안 웹사이트 에서도 읽으실 수 있습니다. &#39;데이터 분석 공부하는데 읽으면 좋은 책 추천해주세요&#39;, &#39;데이터 공부 어떻게 해야되는지 자료 추천 해주세요&#39;라는 말을 많이 듣습니다. 그때마다 yes24를 뒤적이며 링크를 보내드렸는데요. 뒤적이던 링크들 중 제 책장에 아직도 살아남아있는 책 몇 권을 소개해보려고 합니다. 책을 추천하는 대상은 &#39;데이터를 공부하는 사람들&#39;입니다. 데이터 분석가가 아니더라도 요즘엔 데이터 공부하는 사람들이 많습니다. 기획자도, 마케터도, 개발자도 데이터를 보면서 일하는 세상이잖아요. 그래서 추천 대상을 &#39;데이터 분석가가 되고 싶은 사람&#39;으로 좁히지 않았고, 추천하는 책들 또한 쉽고 재미있는 입문서를 위주로 담았습니다. 세상에서 가장 쉬운 통계학 입문 중학교 수준의 수학만 알면 쉽게 시작할 수 있고, 무엇보다 통계학 책처럼 안 생겨서 좋아합니다. 평균, 분산, 표준편차, 정규분포, 가설검정 등 데이터 분석을 하는데 필요한 통계 지식은 다 들어있습니다.    &quot;A/B 테스트에 대해서 이해하려면 어느정도 통계학 지식이 있으면 될까요?&quot; 라는 질문을 종종 받는데, 그 때마다 이 책을 추천하고 있습니다. 그리고 &#39;평균&#39;보다는 &#39;분산&#39;에 대해서 자세하게 설명해놓은 저자의 신념이 마음에 들었습니다. 건조하게 쓰여진 통계학 책 보다는 이렇게 저자의 스타일이 드러나는 책이 훨씬 재밌게 읽히는 것 같아요.  이 책을 읽어보고 &#39;뭐야 통계학 할 만 하잖아?&#39; 하신 분들에게는 서울대 경제학부 류근관 교수의  &lt;경제통계학 1부 : 그림과 수치를 이용한 자료의 정리&gt;  강의를 들어보시는 것을 추천합니다. K-MOOC에서 무료로 들으실 수 있고 1부 이후로 &lt;경제통계학 2부 - 통계적 추론을 위한 개념, 도구, 사례&gt;, &lt;경제통계학 3부 - 표본조사와 통계적 추론&gt; 까지 알차게 구성되어 있습니다. 개인적으로는 통계학과에서 가르치는 통계학보다 경제학과와 같이 응용 분야에서 가르치는 통계학이 더 재미있다고 생각합니다. 그로스 해킹 다음 책은 현재 마이리얼트립 그로스실 실장으로 있는 양승화님이 쓰신 『그로스 해킹: 데이터와 실험을 통해 성장하는 서비스를 만드는 방법』 입니다. 데이터를 통해 서비스를 어떻게 성장시킬 수 있는지 기본기를 다질 수 있는 책입니다.  브런치 를 운영하시니까 책 읽을 때 같이 둘러보시면 도움이 많이 될 것 같습니다.   AARRR, 리텐션, Stickiness, LTV 같은 그로스 분석 용어들에 익숙하지 않다면 꼭 첫 책으로 읽어보시길 추천합니다. 설명이 쉽고 자세해서 사전지식 없이도 이해할 수 있다는 것이 장점입니다. 개인적으로 처음 읽을 때 AARRR 파트 중에서 Acquisition 파트는 흐린 눈을 하고 대충 읽었었는데, 데이터리안 법인을 세우고 다시 한 번 읽으면서 많이 배웠습니다. 인프런에서  강의 로도 같은 내용을 보실 수 있습니다. 린 분석 세 번째 추천 책은 『린 분석: 성공을 예측하는 31가지 사례와 13가지 패턴』 입니다. 데이터 분석 공부하는 사람들이라면 한 번쯤은 꼭 들어봤을 책이지만, 막상 펼치려니 엄두가 안나서 미뤄두기도 많이 미뤄두기도 하는 것 같습니다. 그럴 때에는 스터디를 만들어보는건 어떨까요? 저는 스터디에서 일주일에 한 챕터씩 요약을 맡아 3~4명의 스터디원들과 함께 읽었을 때 이 책을 처음으로 끝까지 읽을 수 있었어요. 그리고 그런 노력을 한 보람이 있는 책이라는 생각을 했습니다.   OMTM(One Metric That Matters), 인게이지먼트(Engagement), 사용자 이탈(Churn), 인게이지먼트 퍼널(Engagement Funnel), 전환율(Conversion Rate), CTR(Click Through Rate), MVP(Minimum Viable Product) 등 전문용어의 홍수 속에서 살아남고 싶다면 또는 내가 분석하고 있는 이 서비스가 가장 효율적인 경로로 빠르게 성장하기를 바라고 있다면 꼭 읽어보길 바랍니다. 숫자가 비즈니스에서 얼마나 정확한 나침반 역할을 해 줄 수 있는지, 소모적인 논쟁 끝에 나오는 의사결정이 아니라 진짜 임팩트를 내는 의사결정은 어떤 분석 끝에 나오는지 힌트를 주는 책입니다. 데이터 분석가의 숫자유감   『데이터 분석가의 숫자유감』은 데이터 분석 업무 상식(?) 만화입니다. 업력이 긴  데이터 분석가 님이 쓰셔서 그런지 에피소드 하나하나 주옥같습니다. 만화로 그려서 술술 넘어가는 것이 장점입니다. 에피소드들도 회사에서 진짜 있을만한 이야기들로 꾸려져있어 데이터 분석가라면 과몰입에 주의하시길 바랍니다.  개인적으로는 사용자의 인구 통계에 기반한 데이터 분석과 의사결정이 왜 낡은 분석인지, 그렇다면 앞으로는 성연령이 아니라 어떤 데이터를 봐야하는지에 대해서 이야기하는 &lt;10화. 인구통계학 정보의 효용성: 이 광고는 30대의 여성을 대상으로 타기팅했습니다?&gt;를 재밌게 읽었습니다. 앞으로도 한국에 있는 데이터 분석가들이 책을 많이 내주면 좋겠어요. 데이터리안도 힘내보겠습니다(?) 헬로 데이터 과학 마지막으로 추천하는 책은 『헬로 데이터 과학』 입니다. &#39;MS 본사 데이터 과학자가 알려주는&#39;이라는 수식어가 붙어있는데 지금은 네이버 서치 데이터 과학 &amp; 분석팀 팀장으로 있는 김진영님이 쓰신 책입니다. 역시  개인 블로그 를 운영하고 있습니다. 최근에 저자가 데이터 분석 또는 데이터 분석 조직과 관련해 어떤 고민들을 하고 있는지 업데이트가 자주 올라오니 책 보다는 최신 소식이 궁금하신 분들은 블로그부터 둘러보셔도 좋을 것 같습니다.   엑셀로 예시를 적어놓아서 누구나 쉽게 따라할 수 있지만 내용은 가볍지 않습니다. 데이터 분석 포트폴리오를 만들고 싶은 학생분들에게도 좋은 아이디어 창고가 되어줄 것 같네요. 업무에서 사용하는 데이터 분석 뿐만 아니라, 생활에서도 데이터 분석을 녹여보고 싶은 분들에게도 추천합니다. (저는 업무로 데이터 분석을 하는 사람이라서 과연 생활에서까지 데이터 분석을 하고 싶은 사람이 정말로 있는가...! 커다란 의문이 있긴 하지만요.) 마무리 우리가 하는 데이터 분석은 실험실 데이터가 아닙니다. 사용자들은 통제된 실험실과는 달리 우리 마음처럼 움직여주지 않습니다.   이런 상황에서는 &#39;이 실험이 통계적으로 엄밀하게 설계되었냐?&#39;보다도 &#39;지금 이 실험을 하는게 맞냐?&#39;는 질문이 종종 훨씬 중요합니다. &#39;이 실험의 결과가 통계적으로 오차 범위 이내인가?&#39;보다 &#39;이 정도 차이면 감수하고 B로 결정할 수 있냐?&#39;라는 질문이 더 중요한 순간도 매일 찾아옵니다. 그렇기에 데이터를 공부하는 사람들에게 추천하는 책 목록은 기초 통계학 책 뿐만 아니라 이 숫자들을 비즈니스에 어떻게 활용할 것인지에 대한 책들을 아울러야겠다고 생각했습니다. &#39;데이터... 중요하다고는 하는데 어떻게 공부해야 할지 잘 모르겠다.&#39;고 생각하며 길을 잃은 것 같다고 느끼는 분들에게 도움이 됐기를 바랍니다. 그리고 제가 좋아하는 이 책들이 여러분들에게 어떻게 읽히고 있는지도 궁금합니다. 댓글이나  contact@datarian.io  계정으로 책 읽어본 후기 보내주시면 재밌게 읽어보겠습니다. 🤔 &#39;소비자들이 끊임없이 흘리고 있는 데이터&#39;라는 건 뭘까? 궁금하다면 이보민님의 강연  &quot;사용자 행동 데이터 분석의 기쁨과 슬픔&quot; 을 들으러 가봅시다. &#39;위에 글을 읽어보니 사용자 행동 데이터를 잘 쓰면 유용할 것 같고, 그러니까 기쁨이 있는건 알겠는데... 슬픔은 뭘까?&#39; 궁금하지 않으신가요. 데이터 적재부터 분석까지 모두 경험한 분석가가 사용자 행동 데이터 분석의 희노애락(喜怒哀樂)에 대하여 이야기합니다. 그 안의 노여움(怒)와 슬픔(哀)을 찾아보는 재미가 있을거예요.   세미나 일정  세미나 신청링크 일시: 3월 29일 (화) 19:00~21:00 장소: 온라인 Zoom 미팅룸 참가비: 10,000원 신청 기한: 3월 29일 (화) 13:00 프로그램 소개 1부 (19:00~20:20) 강연 [민주]  &quot;알아두면 쓸데있는 Funnel 잡학사전&quot; : 사용자 획득부터 결제까지. 우리가 원하는 목적지까지 사용자가 도달하도록 만드는 전략적 접근법 [보민]  &quot;사용자 행동 데이터 분석의 기쁨과 슬픔&quot; : 페이지 조회, 클릭 등 사용자 행동 데이터 수집부터 분석까지 2부 (20:30~21:00) QnA 데이터 분석가 4인에게 묻는다 이 글은  데이터리안 웹사이트 에서도 읽을 수 있습니다. 데이터리안 웹사이트 유입채널 알아보기 데이터리안 웹사이트를 방문하는 사람들은 어떤 채널을 통해 들어오게 될까요?   데이터리안 웹사이트 메인 화면 데이터리안에서 운영하는 공식 채널 우선, 데이터리안에서 운영하고 있는 유튜브 채널이 있어요. 보신 분들 혹시 계신가요? 강의 영상 중 일부를 공개하고 있고, 월간 데이터리안 클립이나 기획 영상들도 올리고 있습니다. 유튜브 외에도 브런치, velog, 커리어리, 오픈카톡방 등 여러가지 채널을 운영하고 있습니다. 보시면 입문반 실전반 링크를 넣어놨죠. 이런 채널을 통해서 유입되는 유저들이 있을거고요.  외부 채널을 통한 홍보 활동 그리고 데이터리안에서 운영하고 있는 SQL 캠프에 관심있을 것 같은 사람들이 있는 곳에 직접 홍보글을 올리기도 합니다. IT 관련 커뮤니티의 페이스북 그룹이나 오픈카톡방, 에브리타임, 링크드인 같은 곳들입니다. 여기서 홍보글을 보고 오시는 유저들도 있을거고요.  유료 광고 저희가 페이스북과 인스타그램에서 유료 광고를 하고 있어서 광고를 통해 들어오는 유저들도 있습니다. 검색을 통한 오가닉 유입 마지막으로 구글이나 네이버 검색으로 들어오는 유저들이 있을 거에요. 다른 유입과 다르게 자연적으로 발생한 유입이라고 해서 오가닉(organic) 유입이라고 말합니다.  유입채널 데이터는 어떻게 볼 수 있을까?: utm 파라미터 이렇게 여러 채널을 통해서 마케팅을 하고 있는데요, 이제 궁금해집니다. 그래서 어떤 채널이 가장 효과적인지. 적은 비용으로 많은 유저를 데리고 오는 채널이 가장 효과적인 걸텐데요. 각 유입채널의 성과를 알아내려면 어떤 유저가 어떤 채널로 유입되었는지 데이터를 쌓아놔야겠죠. 그 때 사용하는게 utm 파라미터입니다.    가끔 그런적 있으시죠? 친구한테 공유해주려고 url 을 복사했는데 말도 안되게 길어서 카톡창에 넘치는 경우... 보통 광고를 통해 접속한 경우에 이런 일이 자주 일어나는데요. utm 파라미터를 사용해서 그렇습니다. 링크 중간에 물음표가 있는데요. 물음표 앞까지가 원래 url 이에요. 저기까지만 입력해도 똑같은 페이지를 볼 수 있어요. 그럼 그 뒤에 달린 것들은 다 무엇이냐. 그게 바로 유입경로를 표시해주는 utm 파라미터입니다.  utm 파라미터에 대해 간단하게 설명을 드리자면, 아래의 다섯가지 파라미터가 있습니다. utm_source : 유입 채널 (e.g. youtube) utm_medium : 유입된 매체 (e.g. cpc, email) utm_campaign : 유입된 마케팅 캠페인 utm_term : (옵션) 검색 유입의 경우 검색하고 들어온 키워드 / 유료 광고의 경우 타겟 utm_content : (옵션) 유입된 콘텐츠 여기서 source, medium, campaign 은 필수값이고 term, content 는 옵션으로 사용할 수 있는 값들이에요. utm 파라미터가 달린 링크를 클릭해서 우리 웹사이트에 들어오면 로그에 저 긴 링크 그대로 남게 됩니다. 그렇기 때문에 어떤 채널에서 어떤 매체로 어떤 홍보 캠페인의 어떤 콘텐츠를 보고 유입되었는지 우리가 확인할 수 있게 됩니다. 예시를 하나 들어볼까요? 우리가 유튜브에 영상을 올릴거에요. 실전반 Day 1 오리엔테이션 영상을 올린다고 해봅시다. 그 영상 설명에 링크를 넣을 수 있겠죠. 실전반 오리엔테이션을 보고 관심이 있으면 클릭해볼 수 있을테니까요. 그 때 utm 파라미터를 붙이면 이 링크를 통해 우리 사이트에 접속한 사람이 얼만지 카운트할 수 있게 됩니다.  utm 예시 원문 링크:  https://datarian.io/bootcamp/sql-advanced https://datarian.io/bootcamp/sql-advanced?utm_source=youtube&amp;utm_medium=footer&amp;utm_campaign=sql_advanced_orientation 유입채널마다 utm 파라미터를 다르게 설정하면 어떤 채널로 들어온 사람이 어떤 액션을 했는지 데이터를 수집할 수 있게 되는거죠. utm 파라미터에 대해서 좀 이해가 되셨나요?  분석을 하기 위해서는 이런 사전 세팅이 정말 중요한데요. 저는 데이터 분석가 / 퍼포먼스 마케터 로 이전 회사에서 업무를 했어요. 그래서 이런 utm 파라미터 관리도 제가 직접 했는데요. 이걸 하나 놓치면 마케팅 예산은 실컷 썼는데 데이터는 쌓이지 않는다거나 세팅을 잘못하면 데이터도 잘못 쌓이게 되어서 제대로 된 분석을 하기 어려워집니다. 일일이 세팅하는 과정이 귀찮지만 정말 중요한 작업입니다. 저는 그래서 저런 기나긴 링크를 볼 때마다 아, 저기도 참 마케팅 성과 측정을 열심히 하는구나 하고 생각합니다. 참고 자료  https://ga-dev-tools.web.app/campaign-url-builder/ 👀 이런 인사이트 어디에서 더 볼 수 있지? 이 글을 쓴 데이터 분석가 김민주님의 강연  &quot;알아두면 쓸데있는 Funnel 잡학사전&quot;  들으러가자!   세미나 일정  세미나 신청링크 프로그램 소개 1부 (19:00~20:20) 강연 [민주] &quot;알아두면 쓸데있는 Funnel 잡학사전&quot;: 사용자 획득부터 결제까지. 우리가 원하는 목적지까지 사용자가 도달하도록 만드는 전략적 접근법 [보민] &quot;사용자 행동 데이터 분석의 기쁨과 슬픔&quot;: 페이지 조회, 클릭 등 사용자 행동 데이터 수집부터 분석까지 2부 (20:30~21:00) QnA 데이터 분석가 4인에게 묻는다 이 글은  데이터리안 웹사이트 에서도 보실 수 있습니다. 데이터리안 데이터 분석가로 근무를 시작한 여러분, 본격적으로 업무를 시작한 첫 날 대표님이 여러분에게 물어봅니다.  “다음달 SQL 캠프 입문반 참가자를 10배로 늘리고 싶은데, 어떻게 하면 될까요?” 업무를 받은 여러분은 어떤 방법을 떠올릴 수 있으신가요?  유료 광고 예산을 늘려볼까요?  웹사이트에 있는 SQL 캠프 입문반 소개 페이지에서 체류시간을 늘려야할까요?  지금은 웹사이트 외부에서 결제하도록 되어 있는데 결제 기능을 내재화해서 결제까지의 경험이 더 연결감있도록 만들어볼까요? 모두 다 가능한 방법이겠지만 각각 드는 비용과 실행하는데 걸리는 시간도 다 다르고, 무엇보다 그래서 입문반 참가자가 얼마나 늘어날지 예상하기 어렵습니다. 10배를 늘려야하는데 이 방법으로 그게 될까? 알 수 없죠. 이럴 때 퍼널 분석을 사용하면 문제를 조금 더 풀기 쉽게 만들어줄 수 있어요. 퍼널 분석 (Funnel Analysis) 퍼널 분석은 고객들이 우리가 설계한 유저 경험 루트를 따라 잘 도착하고 있는지 확인해보기 위해 최초 유입부터 최종 목적지까지 단계를 나누어서 살펴보는 분석 기법입니다. 얼마나 많은 사람들이 최종 단계까지 도착하는지, 또 어디에서 많이 이탈하는지 확인할 수 있습니다. 각 단계를 통과할 때마다 유저 수가 줄어들게 되는데 그림으로 그려보면 아래 그림처럼 점점 좁아지는 형태의 깔대기(Funnel) 모양이라 퍼널 분석이라고 말합니다. 각각의 단계를 넘어가는 것을 전환(Conversion)이라고 부르고 그 비율은 전환율(Conversion rate)이 됩니다. 예를 들어, 앱 서비스의 가입까지의 퍼널을 구성한다고 하면 아래 그림과 같이 그려볼 수 있습니다.  앱 서비스 가입까지 퍼널 예시   퍼널의 최종 단계에 도착하는 유저 수 늘리기 그러면 이제 퍼널을 보면서 퍼널 최종 단계의 유저를 늘리려면 어떻게 할 수 있을까요? 1. 앱 스토어 페이지 뷰를 늘린다 퍼널로 유입되는 고객 수를 늘리는 방법을 처음으로 생각해 볼 수 있을 것 같아요. 아래 테이블에서처럼 전환율이 같다고 가정하면 앱스토어 페이지 뷰를 본 사람 수를 늘리면 마지막 단계인 가입완료까지 도착하는 사람 수도 따라서 늘어납니다. 어찌보면 가장 쉬운 방법이에요. 유료 광고 예산을 늘리거나, 자극적인 문구나 이미지로 클릭을 유도해서 많이 들어와보게 할 수 있겠죠. 들어왔다 나가는 사람도 그만큼 많겠지만 일단 들어오는 사람을 10배 100배 늘려버리면 그 다음단계로 가는 사람들도 분명히 늘어날테니까요. 앱 스토어 페이지 뷰 전환율 가입 완료 100명 5% 5명 1000명 5% 50명 10,000명 5% 500명 2. 각 단계 사이의 전환율을 올린다 위에서 언급한 것처럼 많이 들어와도 그만큼 많이 나가버리면 효용이 없겠죠. 아까와 같이 기존 전환율이 5%라고 해봅시다. 5%면 100명 중에 5명이 전환되는 거죠. 우리가 전환율을 획기적으로 끌어올려서 30%가 됐다고 해봅시다. 그러면 유입을 전혀 늘리지 않고도 가입완료 수를 늘릴 수 있어요. 100명이 들어오면 30명이 전환되니까요.  앱 스토어 페이지 뷰 전환율 가입 완료 100명 5% 5명 100명 30% 30명 그러면 이 때 유입을 늘리면 어떻게 될까요? 500명이 들어오면 150명이 전환되겠죠. 처음보다 30배가 늘었어요. 처음에 입문반 참가자를 10배로 늘리는 게 가능해? 하고 생각한 분 계신가요? 쉽지는 않겠지만 전환율을 끌어올리면 가능할 수 있습니다. 그래서 전환율을 높이는 작업이 중요하고요.  앱 스토어 페이지 뷰 전환율 가입 완료 100명 30% 30명 500명 30% 150명 데이터리안에서도 실제로 얼마 전에 이 과정을 겪었어요.  월간 데이터리안 이라고 매월 마지막 주 화요일에 웨비나를 하는데요. 여기에 유료광고를 집행하고 있습니다. 이번에 광고 예산을 늘렸는데, 생각보다 신청이 늘지 않더라고요. 그래서 왜 그럴까 고민하던 와중에, 우연히 저희 광고를 직접 보고 웨비나 페이지에 들어갔는데 설명이 너무 없더라구요. 설명이 부족해서 전환이 되지 않는게 아닐까? 가정을 세우고 자세한 설명을 추가했습니다. 그리고 다음날부터 바로 신청이 막 들어오기 시작하더라고요. 유입은 그대로였지만 전환율을 높였더니 성과가 늘어난거죠.  왼쪽은 페이지 수정 전, 오른쪽은 수정 후   3. 퍼널의 단계를 줄인다 전환율을 올리고 유입 수를 늘려도 결국은 한 단계를 거칠 때마다 이탈하는 유저가 생길 수 밖에 없어요. 단계가 너무 많아서 귀찮아서든, 갑자기 와이파이 연결이 원활하지 않았든, 갑자기 실수로 창을 꺼버렸든, 뭐 상상할 수 없는 정말 다양한 일들이 현실 세계에서는 일어나니까요. 그래서 가장 효과적인 방법은 퍼널의 단계를 줄이는 거에요. 지금 위의 예시를 언뜻 보면 단계를 여기서 더 줄일 수 있을까? 싶지만, 각 단계를 쪼개서 보면 다르게 보일 수 있습니다.   일반적인 가입 절차    소셜 로그인 가입 절차 지금 퍼널에서는 가입하기 한 단계로 표현되어 있지만 사실은 이메일 입력, 이름 입력, 휴대폰 인증, 아이디 중복체크, 등등 여러 단계가 들어있습니다. 요즘 대부분의 서비스들이 구글 계정 로그인, 소셜 계정 로그인을 많이 쓰잖아요. 이렇게 가입 절차 자체를 최소화하는 것도 퍼널을 줄이고 전환율을 높이기 위한 장치로 이해하실 수 있을 것 같아요. 그러면 이제 무슨 생각이 드시나요? 퍼널의 단계를 최소한으로 줄이고, 각 단계 사이의 전환율을 끌어올린 다음에, 유입을 늘리면 되겠구나! 이런 생각을 들지 않으시나요? 이상적으로는 더없이 좋은 시나리오인데요. 하지만 현실에서는 그 작업들을 순서대로 하나씩 다 하기는 어려울거에요. 들일 수 있는 시간과 비용에는 언제나 한계가 있기 때문에. 회사에서는 비용 대비 효율을 생각해야하고 우리에게 시간이 무한정 있는 게 아니니까요. 우선순위를 정해서 가장 적은 비용으로 큰 효과를 볼 수 있는 전략을 선택해야겠죠.  그래서 퍼널에 불필요한 단계가 들어있지는 않은지, 전환율이 너무 떨어지는 구간이 있지는 않은지, 유입량 자체가 너무 적지는 않은지 살펴보면서 가장 쉽고 빠르게 가장 큰 효과를 가져다줄 부분이 어디인지 찾는 게 우리의 과제라고 할 수 있겠습니다.  좋은 분석이란 무엇일까 이 질문에 정답은 없지만, 제 생각을 이야기해보자면 단순히 숫자만 뽑아서 보여주는 게 아니라 의사결정에 도움이 되고 구체적인 액션 아이템이 나오는 분석이 좋은 분석이라고 생각합니다. 이게 말로는 쉽지만 사실 쉬운 일은 아닌데요. 그런 점에서 퍼널분석이 좋은 툴이에요. 퍼널을 쪼개보면 어디를 개선해야할지가 나오잖아요. 그러면 혼자서 액션 아이템까지 찾는 건 어렵더라도 마케터, 기획자, 개발자, 다른 파트들과 이야기를 나눠보면서 해결책을 찾아갈 수 있으니까요. 이제 어떠신가요? 처음에 퍼널분석을 배우기 전과 비교해서 이제 문제를 어떻게 해결할 수 있을지 좀 감이 오셨나요?  👀 Funnel 분석이 뭔지 더 알고싶어졌다면? 이 글을 쓴 데이터 분석가 김민주님의 강연  &quot;알아두면 쓸데있는 Funnel 잡학사전&quot;  들으러가자!   세미나 일정  세미나 신청링크 일시: 3월 29일 (화) 19:00~21:00 장소: 온라인 Zoom 미팅룸 참가비: 10,000원 신청 기한: 3월 29일 (화) 13:00 프로그램 소개 1부 (19:00~20:20) 강연 [민주]  &quot;알아두면 쓸데있는 Funnel 잡학사전&quot; : 사용자 획득부터 결제까지. 우리가 원하는 목적지까지 사용자가 도달하도록 만드는 전략적 접근법 [보민]  &quot;사용자 행동 데이터 분석의 기쁨과 슬픔&quot; : 페이지 조회, 클릭 등 사용자 행동 데이터 수집부터 분석까지 2부 (20:30~21:00)  QnA  데이터 분석가 4인에게 묻는다 이 글은  데이터리안 웹사이트 에서도 보실 수 있습니다. 안녕하세요! 데이터 분석가 이보민입니다. 인하우스 데이터 분석가로 일을 하다보면 프로덕트 분석이나 비즈니스 분석을 하는 시간 이외에 여러 부서에서 데이터 요청을 받는데 시간을 많이 쓰기도 합니다. 특히 마케팅 부서와는 긴밀하게 협업하여 일을 하는 경우가 꽤 있는데요. 제가 속한 회사의 경우 마케팅팀에서 푸시, 메일링을 위해 특정 조건의 유저 리스트를 요청하는 경우가 종종 있습니다. 오늘은 이런 CRM(Customer Relationship Management)을 할 때 사용하는 기법 중 하나인 RFM 분석에 대해 알아보도록 하겠습니다. 푸시를 보낼 유저 리스트를 추출하는 방식은 여러가지가 있을 수 있는데요. 대표적으로 이런 방식들을 사용할 수 있습니다. 유저들의 성별, 나이 등의 인구통계학적 정보로 리스트를 추출하는 방식 유저들의 행동 패턴을 통해 리스트를 추출하는 방식 서비스 내에 정해진 특정 조건에 의해 유저군을 나누어 리스트를 추출하는 방식 등 위에 나열한 방식 이외에도 산업군에 따라 비즈니스의 특성에 따라 또는 푸시, 메일링을 위해 사용하는 툴에 따라서 유저 타겟팅을 하는 방식은 천차만별일 수 있습니다. 정답이 따로 있는 것은 아니고요. 각각의 비즈니스에 알맞는 방법을 사용하면 되는데요. 오늘은 유저들의 행동 패턴을 통해 타겟팅을 하는 방식 중 가장 범용적으로 사용할 수 있고, 구매 유저 분류에 효과적인 RFM 분석 기법에 대해 알아보고 해당 기법을 이용한 유저군 분류(segmentation)를 어떻게 할 수 있는지 이야기 해보겠습니다. RFM 분석이란?  이미지 출처:  RFM analysis for Customer Segmentation RFM의 개념은 간단합니다. 아래 세가지 단어의 약자를 따서 RFM이라고 부르는데요. Recency : 얼마나 최근에 구매했는가 Frequency : 얼마나 자주 구매했는가 Monetary : 얼마나 많은 금액을 지출했는가 즉, 유저별로 얼마나 최근에, 얼마나 자주, 얼마나 많은 금액을 지출했는지에 따라 유저들의 분포를 확인 하거나 유저 그룹(또는 등급)을 나누어 분류 하는 분석 기법입니다. 구매 가능성이 높은 고객을 선정할 때 용이한 데이터 분석방법이라고 알려져 있고, 또 유저들의 평소 구매 패턴을 기준으로 분류를 진행하기 때문에 각 유저 그룹의 특성에 따라 차별화된 마케팅 메세지를 전달할 수 있는데요. 예를 들어 볼게요. 쿠팡과 같은 이커머스 플랫폼에서 RFM 분석을 해본다고 생각을 해보겠습니다. 유저 A와 B의 구매기록을 체크해보았을 때 아래와 같이 표현된다고 할때, A와 B 중에서 누가 더 해당 서비스에 충성 고객이라고 할 수 있을까요? 사용자 최근 구매일 총 구매 횟수 총 구매 금액 A 3개월 전 28 1,280,000 B 2년 전 1 50,000 Recency, Frequency, Monetary 중 어느 것을 보더라도 B보다는 A가 해당 서비스에 충성도가 높다고 생각할 수 있을 것 같습니다. 여러분은 RFM의 기본 개념을 완벽히 이해하셨습니다. 참 쉽죠? 유저들을 이런식으로 분류할 수 있게 되면 유저들마다 각각 다르게 리워드를 주면서 서비스를 더 잘 이용할 수 있게 도움을 줄 수가 있는데요. 예를 들어 A 고객은 이미 최근에도 잘 구매를 진행항 유저이기 때문에 A 유저는 그냥 두고 B 유저에게 할인 쿠폰을 보내줄 수도 있고요. 또는 반대로 이미 A 유저가 서비스를 잘 사용하고 있기 때문에 더 잘 사용하라는 의미에서 VIP 고객을 위한 할인 쿠폰을 보내줄 수도 있겠죠. 이런식으로 RFM을 사용하면 유저의 특성별로 각기 다른 정책을 적용하고 서비스를 더 잘 사용하게끔 유도하는 전략을 세워볼 수가 있습니다. RFM segmentation 직접 해봅시다 개념은 간단하게 알아봤으니 예시 데이터를 통해서 한번 직접 RFM을 통한 유저 분류를 해보도록 하겠습니다. 어느 서비스에서 유저 구매내역으로 RFM 수치를 확인해봤더니 아래와 같이 데이터를 확인할 수 있었다고 가정 해봅시다. 이때 구매내역은 기간 제한 없이 서비스가 시작된 이래로 전체 기간 동안의 데이터라고 생각해볼게요. 사용자 최근 구매일 총 구매 횟수 총 구매 금액(달러) 1 2020-12-28 12 903 2 2020-12-26 7 462 3 2020-12-14 1 943 4 2020-12-03 2 120 5 2020-11-17 6 623 6 2020-11-08 9 135 7 2020-10-21 2 801 8 2020-10-01 1 13 간단하게 유저군을 분류하기 위해 이렇게 기준을 세워볼게요. Recency : 2021-01-01일 기준으로 최근 한달 이내에 결제되었는가 Frequency : 5개 이상 주문하였는가 Monetary :  500달러 이상 주문하였는가 위 기준을 적용하여 각 항목의 기준에 적합한 데이터는 1으로 표시하고 맞지 않는 데이터는 0이라고 표시해보도록 하겠습니다. 사용자 최근 구매일 총 구매 횟수 총 구매 금액(달러) 1 1 1 1 2 1 1 0 3 1 0 1 4 1 0 0 5 0 1 1 6 0 1 0 7 0 0 1 8 0 0 0 이제 모든 사용자들의 RFM 수치가 간단한 등급 값으로 변환이 되었습니다. 변환된 데이터들을 기준으로 사용자군을 임의로 나눠보면 이런식으로 분류를 할 수 있겠네요. 사용자 최근 구매일 총 구매 횟수 총 구매 금액(달러) 사용자 분류 1 1 1 1 서비스 충성도가 높은 고객 2 1 1 0 3 1 0 1 4 1 0 0 최근까지 접속은 있었지만, 구매는 많이 없는 고객 5 0 1 1 떠나간 VIP 6 0 1 0 7 0 0 1 8 0 0 0 떠났지만 뼈아프진 않은 고객 지금은 이해가 쉽도록 몇몇 사용자군의 분류만 임의로 작성 해보았습니다만, 이렇게 변환 해놓은 RFM 리스트를 이용하면 다양한 시도를 해볼 수 있습니다. 예를 들어, 최근에 서비스에서 구매를 하지 않은 사용자들을 깨우기 위한 마케팅 캠페인을 기획하고 있다고 가정해볼게요. 최근에 서비스에서 구매를 진행하지 않은 사용자 중 구매 횟수가 높았거나 구매 금액이 높았던 사용자들을 하나의 그룹으로 묶어 할인 쿠폰을 보내고 싶다면 어떤 사용자들을 뽑아서 전달하면 될까요? 맞습니다. 5, 6, 7번 사용자들을 뽑아서 전달하면 되겠죠. 이런식으로 상황과 목적에 맞게 사용자군을 뽑아서 사용하면 되겠습니다. 실제 서비스에 적용해볼까요? 사용자 최근 구매일 총 구매 횟수 총 구매 금액 A 3개월 전 28 1,280,000 B 2년 전 1 50,000 위에서 이런 데이터를 보았죠. 실제 서비스의 데이터도 이렇게 명료하고 간단하면 좋을텐데 말이죠. 이렇게 사용자가 몇명 안되고 눈으로 명확하게 확인이 가능하다면 사용자군을 나누기가 정말 쉽겠습니다. 그럼 이번에는 이 데이터를 한번 함께 볼까요. 사용자 최근 구매일 총 구매 횟수 총 구매 금액 C 1개월 전 1 50,000 D 6개월 전 300 3,000,000 E 3년 전 2 5,000,000 C, D, E 사용자 중에서 서비스에 가장 충성도가 있는 사용자 또는 비즈니스 입장에서 가치가 있는 사용자는 누구일까요? 이제 조금 어려우실 수도 있을겁니다. C 사용자는 가장 최근에 구매가 일어났지만 구매 횟수는 1회 밖에 되지 않습니다. D 사용자는 최근 6개월 동안은 구매가 없었지만 그 전에 구매했던 내역을 보면 300회나 구매한 내역이 있습니다. 다만 전체 구매금액은 300만원으로 1회당 구매 금액으로는 그렇게 높지 않네요. 마지막으로 E 사용자는 3년 동안이나 구매가 없었고 구매 횟수도 2회밖에 되지 않지만 전체 구매액이 500만원으로 1회당 구매 금액이 매우 높았던 사용자라고 할 수 있겠습니다. 그렇다면 이 사용자들은 어떻게 분류하면 잘 분류했다고 말 할 수 있을까요? 실전에서 RFM 적용시 고려할 점 사실 RFM 분석에서 ‘반드시 이렇게 해야한다’고 정해진 것은 아무것도 없습니다. 비지니스의 성격에 따라, 상황에 따라 알맞은 기준을 세우면 됩니다. 대표적으로 서비스마다 다르게 적용이 가능한 요소들은 아래와 같습니다. Recency, Frequency, Monetary를 각각 몇 단계로 나눌 것인가 Frequency, Monetary를 집계하는 기간을 어떻게 설정할 것인가 Recency, Frequency, Monetary 데이터를 어떻게 조합하여 사용자군을 나눌 것인가 (몇 개의 사용자군으로 최종 분류를 할 것인가) 분석하는 서비스에 따라 위와 같은 항목에서 설정되는 값이 모두 다를 수 있기 때문에 똑같이 RFM 기법을 적용한다고 하더라도 어느 서비스에서는 사용자 그룹을 3개로, 어느 곳에서는 사용자 그룹을 5개로 분류 할 수가 있는 겁니다. 예를 들어, 쿠팡 같이 생필품을 판매하는 플랫폼의 경우 한 달 이내 구매가 없을 때 이미 Recency 가 떨어지는 고객으로 분류할 수 있지만 29cm 같이 고급화 전략을 쓰고 있는 플랫폼에서는 Recency 만점 기준을 한 달으로 세우면 너무 타이트한 기준이 될 수 있습니다. 더 생각해보기 RFM은 단순하게 생각하면 서비스 내에서 구매를 한 사용자들을 분류하는 기법이지만, 조금 더 넓게 생각해보면 사용자를 간편하게 분류하기 위한 대표적인 아이디어이기도 합니다. ‘Recency, Frequency, Monetary를 기준으로 분류한다’는 것 이외에는 정해진 것이 아무것도 없기 때문에 막상 실제 서비스에 적용하려고 하면 난감하기도 한데요. 거꾸로 생각해보면 그만큼 우리 마음대로 이런저런 분석을 해볼 수도 있는 기법이기도 합니다. 분석을 할 때 필요하다면 Recency, Frequency, Monetary를 기본으로 하고 회원가입 일시 데이터까지 추가로 함께 확인 할 수도 있고요. 컨텐츠 소비 데이터를 Recency(얼마나 최근에 컨텐츠를 봤는지), Frequency(얼마나 많이 봤는지), Duration(얼마나 오래 봤는지)으로 나누어 비슷하게 사용자들의 등급을 분류해볼 수도 있습니다. 이렇게 RFM 분석 기법은 그 요소와 방식을 자유롭게 변형하여 분석에 적용하는 것이 얼마든지 가능하며, 추가적으로 각각의 그룹에 해당하는 사용자들의 특성을 분석하여 서비스에 충성도가 높은 사용자와 낮은 사용자들의 특성을 찾아내어 부스팅 전략을 세우는 등의 작업을 해볼 수도 있겠습니다. 참고자료  Marketing RFM Analysis Simplified: 5 Step Approach Made Easy  RFM analysis for Customer Segmentation 안녕하세요, 데이터리안 혜정입니다. 지난 1월에는 데이터리안 유튜브를 통해 SQL 무료 강의를 공개했는데요, 오늘부터는 파이썬 강의 일부를 무료로 공개합니다. 파이썬은 데이터 분석에만 사용되는 프로그래밍 언어는 아니기 때문에 다양한 목적으로 파이썬을 배우실것 같아요. 저희는 데이터 분석에 필요한 파이썬 이론과 라이브러리를 위주로 알려드릴 예정이기 때문에, 데이터 분석에 파이썬을 활용하시는 분들께 추천드립니다. 👉 (인프런 강의) 데이터 분석을 위한 파이썬: 입문부터 꿀팁까지 그럼 매주 화, 목 20시 유튜브에서 만나요!  👉 파이썬 무료 강의 한번에 보기 이 글은  데이터리안 홈페이지 에서도 보실 수 있습니다. 리텐션 시리즈의 마지막으로 리텐션 차트와 리텐션 커브를 살펴보겠습니다. 클래식 리텐션, 범위 리텐션, 롤링 리텐션, 사용자 고착도 계산을 어떻게 하는지는 시리즈의 이전 글에서 다뤘으니 처음 보시는 분들은 시리즈 첫 글 부터 읽어주세요 :) 지금까지 얘기한 리텐션 모아보기 👇  클래식 리텐션 : Classic Retention / N-Day Retention  롤링 리텐션 : Rolling Retention / Unbounded Retention  범위 리텐션 : Range Retention / Bracket Retention  사용자 고착도 : Stickiness 어떤 분석이든 마찬가지지만 &quot;우리 서비스 전체 유저의 리텐션&quot;의 같이 큰 덩어리의 데이터에서 인사이트를 얻기는 어렵습니다. 저는 정세랑이라는 SF 소설을 쓰는 작가와 수필을 쓰는 이슬아 작가 두 분을 참 좋아하는데요. 정세랑 작가가 하는 소설 쓰기 수업에 이슬아 작가가 갔는데 영 소설이 안써지더랍니다. 그래서 정세랑 작가한테 질문을 했대요. &quot;소설이 잘 안써지는데요. 어떻게 하면 좋을까요?&quot; 정세랑 작가가 대충 이런 말을 했다고 합니다. &quot;지금 소설에 인물이 두 명인가요? 다섯 명으로 늘려보세요.&quot; 저는 &quot;이 데이터를 가지고 어떻게 인사이트를 발견할 수 있을까요?&quot;라고 물어보는 사람에게 이렇게 대답합니다. &quot;데이터가 지금 한 덩어린가요? 다섯 개로 쪼개보세요&quot; 전체 데이터를 쪼개어 특정 집단 안의 특징을 보고, 다른 집단과 비교하는 일을 코호트(Cohort) 분석이라고 합니다. 가장 흔하게 보이는 코호트의 예시는 아마 성연령일 것 같습니다.  카카오톡 선물하기 성연령 선물랭킹 화면 캡처 리텐션 분석을 할 때에도 코호트를 잘 정의하는 것이 중요합니다. 일반적으로 가입 시기별로 유저 그룹을 나누어 각 그룹별로 리텐션을 관찰합니다. 이렇게 하게 되면 시간 흐름에 따라 리텐션이 좋아지고 있는지 나빠지고 있는지 흐름을 판단할 수 있습니다. 리텐션 차트 (Retention Chart) 아래 리텐션 차트는 Google Analytics 콘솔에서 지원하는 데이터리안 블로그 사용자 유지율 차트입니다. 보통 유저를 첫 방문 시기별로 나누어 이렇게 삼각형 모양으로 그립니다. 차트의 왼쪽 위에 &quot;동질 집단별 사용자 활동&quot;에서 &quot;동질 집단별&quot;이라는 것은 유저를 첫 방문 시기별로 나누어서 표시했다는 뜻이고, 예를 들어 1월 9일부터 1월 15일 사이에 이 사이트에 첫 방문한 사람은 260명입니다.   데이터리안 블로그  Google Analytics 사용자 유지율 차트 1월 9일부터 1월 15일 사이에 이 사이트에 첫 방문한 사람은 260명이고, 여러분들은 보실 수 없지만 GA 콘솔에서 이 차트 위에 마우스를 호버해보면 첫 방문한 이후 1주째, 2주째, 3주째에도 방문한 사람이 260명 중 몇 명이었는지, 그 비율은 어떤지 알 수 있습니다. 이 차트에서는 옅은 하늘색은 대략 1 3%대, 그보다 진한 하늘색은 4 6%대, 그리고 7% 이상 정도로 생각하시면 될 것 같습니다. 자 그러면 시간 순으로 차트를 살펴볼까요. 12월 19일에서 12월 25일 사이에 첫 방문한 사람들은 총 73명이었는데요. 가로로 한 칸 이동해서 1주째칸의 색깔을 보면 아주 옅은 하늘색이죠. 리텐션은 1% 대 였습니다. 시간이 좀 지나서 1월 2일부터 8일 사이에 첫 방문한 사람들은 110명이었는데요. 1주째 리텐션은 4%대로 12월 19일~25일 사이에 첫 방문한 사용자 집단보다 1주째 리텐션이 3%나 더 높습니다. 1월 9일~15일 사이에 첫 방문한 사람들은 260명이었고 1주째 리텐션은 4%, 2주째 리텐션은 7% 대입니다. 이 사이트의 리텐션은 시간이 흐름에 따라 점점 개선되고 있나요? 그렇습니다. 사이트에 첫 방문한 사람들의 1주째 재방문율, 2주째 재방문율이 점점 높아지고 있고 아마 1월 초 사이트 개선 작업이 어느정도 성과를 거둔 것으로 보입니다. 아래는 구글 애널리틱스에서 데모 데이터로 제공하고 있는  Google Merchandise Store  사이트의 리텐션 차트입니다. 데이터리안 블로그 리텐션과 비교해서 어떤가요? 왜 이런 차이가 발생할까요?   구글 Merchandise Store  사용자 유지율 차트 Google Analytics 4에서 제공하는 유지율 보고서에 대해서 좀 더 알고싶으시다면  공식문서 를 참고해주세요. 리텐션 커브 (Retention Curve) 리텐션을 높이는 방법엔 크게 두 가지가 있습니다. 초기에 이탈하는 유저 줄이기 유저와 장기적인 관계 유지하기   1. 초기에 이탈하는 유저 줄이기 아래 영상을 보면 데브시스터즈 마케팅 총괄을 맡고 계시는 분이 &quot;마케팅은 고객과 처음 만나는 순간의 경험을 디자인하는 일이다&quot;라는 이야기를 하는데요. 이것을 NUX(New User Experience)라고도 합니다. 0일~1일 사이의 리텐션 차트는 이 경험과 관련이 있습니다. AARRR 단계에서는 Acquisition과 Activation 단계라고 생각하시면 될 것 같습니다. 데브시스터즈에서는 &#39;유저경험판&#39;이라는 것을 그려서 유저와 처음 만나는 모든 접점에 대해 다 그려놓고 &#39;내가 유저라면 어떤 장면을 만나면 멋지다고 느낄까&#39; 같은 질문들을 던진다고 합니다. 주로 유저의 가입 동선, 처음 받아보는 이메일, 처음 보는 화면, 처음 경험하는 서비스의 핵심 가치 개선을 통해 이 초기 이탈을 막을 수 있습니다. !youtube[4HWChI8Udeo?start=257] 2. 유저와 장기적인 관계 유지하기  이미지 출처:  유저 리텐션이 중요한 이유 유저가 우리 서비스와 처음 만났고 그 다음에도 우리 서비스에 접속했다면 일단 굉장한 산을 넘었습니다. 1번에서 봤듯이 초반 리텐션 커브는 굉장히 가파르기 때문입니다. 이렇게 가파르게 리텐션이 떨어지는 구간을 지난 후 안정화 되는 단계에서는 사용자와의 관계를 잘 유지하는 것이 중요합니다. 아래 영상에서 알토스 벤처스 박희은씨가 이런 이야기를 합니다. &quot;저희는 일단 빠르게 올라가는 숫자를 좋아하는데요. 그중에서도 제일 중요하게 생각하는 숫자는 얼마나 유저가 계속 이 플랫폼에 재방문하느냐를 가장 중요하게 보고요. 재방문 할때마다 체류 시간이 늘어난다고 하면 그 두 개의 지표가 어떻게 말하면 황금지표다라고 말할 수 있겠습니다. &quot;유저가 계속 이 플랫폼에 재방문하느냐&quot;는 장기 리텐션과 관련된 이야기입니다. 그리고 재방문 할 때마다 체류시간이 늘어나는지도 본다고 하네요. 유저와 장기적인 관계를 유지해야 한다고 할 때 흔히 사람들은 앱 푸시나, 휴면 고객 대상 마케팅을 생각하는데요. 유저와 장기적인 관계를 유지하는데 가장 중요한 것은 우리의 서비스의 핵심 가치를 고객들이 계속 경험하게 할 수 있느냐와 같이 좀 더 근본적인 곳에 있는 것 같습니다. !youtube[TDmzXuma4Lw?start=268] Smile Curve 좀 오래됐지만 전 세계적으로 화제가 됐던 에버노트의 Smile Curve 도 잠깐 소개해보겠습니다. 보통 리텐션 커브는 우하향하는 곡선을 그리는데, 에버노트와 같이 시간이 지날수록 유저에게 서비스의 가치가 높아지는 제품들은 이렇게 스마일 커브 리텐션 곡선을 그리는 수 있다는 겁니다. 차트를 보고만 있어도 배가 부를 것 같네요.  이미지 출처:  Should Your Startup Go Freemium? 정리 앞에서 네 개의 리텐션 시리즈를 통해 클래식 리텐션, 범위 리텐션, 롤링 리텐션, 그리고 사용자 고착도를 어떻게 계산하는지 알아봤고 이번 글에서는 리텐션을 어떻게 분석할 수 있는지 얘기했습니다.  리텐션은 가장 개선하기 어려운 지표로 꼽습니다. DAU, MAU 등 단순 접속 지표는 속된 말로 돈을 태워 늘릴 수 있지만(광고를 늘리면 Acquisition은 늘어납니다), 사용자의 재방문은 돈을 주고 살 수 없기 때문입니다. 푸시, 이메일 발송 등을 통해 일시적으로는 늘릴 수는 있으나 유저의 피로 관리를 생각하지 않은 캠페인은 장기적인 리텐션에 도움이 되지 않습니다. 조금 다른 얘기도 해보자면, 리텐션이라는 것이 중요하긴 하지만 언제나 최고의 우선 순위를 가지지는 않습니다. 여러분이 웨딩홀 사업을 한다고 생각해봅시다. 고객의 재방문이랄게 있을까요? 물론 이론상 있기야 있을 수 있지만 확률이 아주 낮습니다. 이런 성격의 사업을 한다면 리텐션(Retention)보다는 한 번의 기회에 최대의 매출을 내거나(Revenue), 주위에 입소문을 내주는(Referral) 것이 더 중요할겁니다. 가장 중요한 것은, 리텐션을 한 번 계산하고 &#39;우리 서비스의 리텐션은 이렇군!&#39;하고 만족하거나 실망하는데서 끝나면 안된다는 겁니다.   여러분이 분석하고 있는 서비스의 리텐션은 어떤가요? 좋아지고 있나요, 나빠지고 있나요. 만약 개선이 필요하다면, 특히 어느 구간을 개선해야 할까요. 구체적으로 어떤 액션을 해 볼 수 있을까요?  끊임없이 고민하고 실험하고 차트에서 실험의 결과를 발견해야 합니다. 참고자료  유저 리텐션이 중요한 이유  구글 애널리틱스 도움말 &gt; [GA4] 유지율 보고서 이 글은  데이터리안 홈페이지 에서도 보실 수 있습니다. 계속 리텐션 이야기를 해왔는데요. 지금까지 얘기한 리텐션 모아보기 👇  클래식 리텐션 : Classic Retention / N-Day Retention  롤링 리텐션 : Rolling Retention / Unbounded Retention  범위 리텐션 : Range Retention / Bracket Retention 이번 장에서는 조금 다른 이야기를 해보려고 합니다. 바로 사용자 고착도라고 부르는 Stickiness 라는 지표입니다. 이 지표는 DAU를 MAU 또는 WAU로 나누어 계산합니다.    먼저 DAU, WAU, MAU는 무엇인가? 부터 얘기를 시작해야겠네요. DAU, WAU, MAU 해당 기간 동안 활동한 사용자 수를 의미하는 지표로 각각 Daily Active User, Weekly Active User, Monthly Active User를 의미합니다. 일간, 주간, 월간 활성 사용자 수라고도 부릅니다. DAU(Daily Active User): 일간 활성 사용자 수 WAU(Weekly Active User): 주간 활성 사용자 수 MAU(Monthly Active User): 월간 활성 사용자 수 구글 애널리틱스에서도 활성 사용자 수 대시보드를 지원합니다. 아래는  데이터리안 블로그  구글 애널리틱스 데이터인데요. 지난 30일, 7일, 1일동안 활성 사용자수를 보여주죠. 각각 MAU, WAU, DAU라고 보시면 됩니다.   데이터리안 블로그  구글 애널리틱스 활성 사용자 수 DAU 138명 DAU는 맨 아래 보라색 라인 그래프이고 1월 28일 접속자는 138명입니다. 겉으로 보기에는 큰 변동이 없이 평평해보이지만, 지난 일주일간 방문자 수가 가장 적었던 1월 22일 DAU는 128명이고 방문자 수가 가장 많았던 1월 27일 DAU는 239명으로 날짜에 따라 확실한 변동이 있습니다.  대시보드에 y축 스케일이 큰 MAU, WAU와 함께 DAU를 표시할 때는 이런 점에 유의합시다. 특히 DAU 모니터링이 필요한 상황이라면 따로 대시보드를 만드는게 좋습니다. WAU 1100명 WAU는 중간에 있는 파란색 라인 그래프이고 지난 7일간 접속자는 약 1100명입니다. 대략 계산해보면 DAU의 합산이 WAU가 되었네요. 이런 경우 한 명의 유저가 일주일 동안 지속적으로 접속한 것이 아니라, 매일매일 새로운 유저가 들어왔다가 나간다는 것을 의미합니다.  이게 무슨 얘기일까요? 예시를 들어보겠습니다. 일곱 명의 유저(A, B, C, D, E, F, G)가 있다고 가정합시다. 그 유저들이 아래와 같이 접속할 때 각각 DAU와 1월 28일의 WAU를 계산해보세요.  WAU 예제 1 유저 1월 22일 1월 23일 1월 24일 1월 25일 1월 26일 1월 27일 1월 28일 A 접속 B 접속 C 접속 D 접속 E 접속 F 접속 G 접속  WAU 예제 2 유저 1월 22일 1월 23일 1월 24일 1월 25일 1월 26일 1월 27일 1월 28일 A 접속 접속 접속 접속 접속 접속 접속 B 접속 접속 접속 접속 접속 접속 접속 C 접속 접속 접속 접속 접속 접속 접속 D 접속 접속 접속 접속 접속 접속 접속 E 접속 접속 접속 접속 접속 접속 접속 F 접속 접속 접속 접속 접속 접속 접속 G 접속 접속 접속 접속 접속 접속 접속 예제 1번에서 DAU는 1월 22일부터 1월 28일까지 매일 1이고, WAU는 일주일 동안 유저 7명이 방문했으므로 7입니다. 예제 2번에서 DAU는 1월 22일부터 28일까지 매일 7이고, WAU는 일주일 동안 유저 7명이 방문했으므로 7입니다.   예제 1번에서는 매일매일 새로운 유저가 들어오고 기존 유저의 재방문이 없으므로 DAU의 합산이 곧 WAU가 됩니다.  하지만 예제 2번에서는 기존 유저들이 계속해서 재방문하고 있으므로 재방문은 DAU에 매일 집계되지만 WAU에서는 유저 1명으로 계산되므로 일주일 동안 DAU의 합산(=49)은 WAU(=7)보다 훨씬 큰 숫자가 됩니다.  데이터리안 블로그 의 WAU는 대략 일주일간 DAU의 합산과 비슷하니까, 아쉽지만 이 블로그는 예제 2번보다는 1번에 가까운 서비스 입니다. 기존 유저들이 재방문 하는 곳이라기 보다는 매일 새로운 유저들이 유입되는 곳이라고 볼 수 있겠지요. 이렇게 WAU와 DAU를 함께 본다면 WAU만 볼 때는 알 수 없었던 고객들의 방문 패턴을 알 수 있습니다. 이런 특성을 가지고 사용자들이 우리 서비스에 계속해서 방문하는지(&quot;딱 붙어있는지&quot;)를 측정하는 지표를 만들 수 있지 않을까요? 그게 바로  Stickiness(사용자 고착도)  입니다.  Engagement 지표 라고 하기도 하고,  WAU(또는 MAU) 대비 DAU의 비율  이라고 풀어서 말하기도 합니다. 이 지표에 대해서는 다음 섹션에 이어서 얘기하겠습니다. MAU 이번에는 다른 데이터도 봅시다. 페이스북 사용 디바이스별 MAU 변화 아래 그래프는 페이스북의 2012년 4분기부터 2015년 2분기까지 MAU를 사용 디바이스별로 보여줍니다. 2012년 2분기까지만 해도 컴퓨터와 모바일을 함께 사용하거나(Computer-Mobile), 컴퓨터로만 접속하는 사람들(Computer-only)이 전체 MAU에서 대부분을 차지했지만 시간이 지나면서 모바일로만 접속하는 사람들(Mobile-only)가 빠르게 늘어나고 있습니다.  이렇게 MAU를 특정 유저 그룹별로 나누어서 분석하기도 합니다. https://www.beyonddevic.es/2015/07/     페이스북 YoY MAU Growth 아래 차트는 페이스북의 분기별 YoY(Year on Year)* MAU 성장 그래프 입니다. 전년도 같은 쿼터의 MAU 대비 몇 퍼센트 성장했는지를 그렸다고 생각하시면 됩니다. 북미대륙, 유럽, 아시아, 나머지 국가들로 나누어 봤을 때 아시아 지역(노란색 그래프)의 MAU 성장세가 눈에 띕니다. 2015년도 2Q의 YoY MAU가 약 90% 이므로 2014년 2Q의 MAU 대비 약 90% 성장했다라고 해석할 수 있습니다. *YoY(Year on Year): 전년도 동기간 대비 https://www.beyonddevic.es/2015/07/     Stickiness Stickiness는 DAU와 MAU 또는 DAU와 WAU의 비율로 계산합니다. DAU와 MAU의 비율로 계산하는 것이 좀 더 보편적입니다. 월간 순수 사용자 중 특정 일자에 접속한 사람의 비율을 보는 것이지요.   우리는 계산의 편의상 DAU와 WAU의 비율을 보겠습니다. 아래의 수식을 기반으로 예제 1, 예제 2 각각의 데이터에 대해서 1월 28일의 Stickiness를 계산해보세요.   예제 1에서 1월 28일의 DAU는 1명, 그리고 WAU는 7명이므로 Stickiness는 약 14% 입니다. 주간 방문한 순수 사용자 중 14% 만이 1월 28일에 방문했다고 해석할 수 있습니다. 예제 2에서 1월 28일의 DAU는 7명, WAU도 7명이므로 Stickiness는 100% 입니다. 주간 방문한 순수 사용자 중 100%가 1월 28일에 방문했다고 해석할 수 있습니다.  유저가 더 자주 방문할수록 Stickiness는 100%에 가까워집니다. 페이스북의 Stickiness 지표 해석하기 아래 그래프는 2010년 2분기부터 2014년 4분기까지 페이스북의 DAU/MAU 비율입니다. 각 지역별로 차이는 있지만 시간이 지날수록 유저 고착도는 높아지고 있습니다. 페이스북을 유저들이 점점 더 페이스북에 자주 접속하고 있다는 뜻입니다.  https://www.beyonddevic.es/2015/07/     데이터를 조금만 더 자세하게 보면, 유저 고착도가 가장 낮은 지역은 아시아 지역입니다. 앞에서 본 데이터에 의하면 아시아 지역에 새로운 사용자가 유입되어 MAU 자체는 성장하고 있는 상황인데, 다른 지역에 비해서 유저의 서비스 고착도는 낮으니 저라면 신규 가입자와 기존 가입자들의 Stickiness를 분리하여 추가 분석을 진행해보겠습니다.  &quot;Thoughts On Facebook&#39;s Q2 2015 Earnings&quot;  를 읽어보면 당시 페이스북 전체 유저의 1/3이 아시아 지역에 있지만 전체 광고 매출의 16% 만이 아시아에서 발생하고 있다고 합니다. 페이스북의 광고 매출은 사람들이 더 많이 더 자주 접속하여 피드에 있는 광고에 노출되는 횟수가 늘어날수록(CPM, Cost Per 1000 Impression; 노출 당 과금) 그리고 광고를 클릭하는 횟수가 늘어날수록(CPC, Cost Per Click; 클릭 당 과금) 커지는 구조입니다. 때문에 아시아 사용자들이 아무리 많아도, Stickiness가 낮으면 매출로 연결되지 않죠. 이렇게 유저들이 더 자주 접속하고, 더 많이 접속하는 것이 중요한 페이스북, 인스타그램 같은 SNS 광고 비즈니스 또는 생필품을 판매하는 온라인 쇼핑몰 비즈니스에서 Stickiness 지표를 중요하게 봅니다. 데이터리안 블로그의 Stickiness 지금까지 Stickiness를 어떻게 계산하는지, 어떻게 분석하는지 이야기를 나눠봤습니다. 데이터리안 블로그의 Stickiness는 어떤가요? 여러분들이 보기에 현재 Stickiness 상황이 어떤지, 개선이 필요하다면 어떤 액션이 필요한지 의견을 남겨주세요.   데이터리안 블로그  구글 애널리틱스 활성 사용자 수 Stickiness를 쿼리로 뽑아보고 싶다면? 👉 데이터리안  SQL 데이터 분석 캠프 에 참여하세요. 이런 인사이트를 어떻게 내는건지 궁금하다면? 👉  월간 데이터리안 웹 세미나 를 신청하세요.  참고자료 &amp; 데이터 출처  데이터리안 블로그  Google Analytics 대시보드  Thoughts On Facebook&#39;s Q2 2015 Earnings 이 글은  데이터리안 웹사이트 에서도 보실 수 있습니다. 데이터리안 오픈카톡방에 질문이 도착했습니다! SQL 실습경험은 많지 않고, SQLD 공부하면서 필요한 예제정도만 실행해본 정도라면 실전반 바로 들어도 어렵지 않을까요? SQLD 취득은 했습니다.  SQL 데이터 분석 캠프 중  입문반을 들어야 하는지, 실전반을 들어야 하는지 궁금하신 분이 주신 질문이었는데요. 이 질문은 캠프 문의 질문이었지만, SQL 자격증은 있는데 내가 진짜 SQL 실력이 어떤지 잘 모르겠다 또는 학교에서 수업으로 들었는데 이 정도면 충분할까? 생각하시는 분들 많으시잖아요. 그래서 이 글에서는  SQL 실력을 점검해 볼 수 있는 네 가지 플랫폼 들을 소개해보려고 합니다.  HackerRank  (영어)  leetcode  (영어)  프로그래머스  (한국어)  solvesql  (한국어) 이 순서로 소개해볼게요 :D 1. HackerRank 첫 번째로 소개할 곳은  HackerRank 입니다. 프로그래밍 공부를 조금이라도 해봤다 하시는 분들에게는 너무 익숙한 플랫폼이죠. 약 60개의 SQL 문제를 무료로 풀어볼 수 있고, 난이도도 다양한 편입니다.   HackerRank 문제 목록 난이도는 Easy, Medium, Hard 세 단계로 되어있고 Medium 단계부터는 풀기 꽤 까다로운 문제들이 섞여 있습니다.  만약 다섯 문제 정도 출제되는 분석가 SQL 코딩테스트를 본다면 앞의 세 문제 정도는 Easy 난이도 문제가 들어가고 뒤에 두 문제 정도에 Medium 난이도 문제가 들어간다고 생각해도 될 것 같습니다. MySQL 이외에 DB2, MS SQL Server, Oracle 과 같은 다른 종류의 DBMS로도 문제를 풀어볼 수 있다는 점이 장점이고, 단점은 최근 문제 업데이트가 안되고 있다는 점인데 이미 올라와있는 문제의 종류가 충분히 다양해서 큰 단점으로 느껴지지는 않습니다. 2. leetcode 두 번째로 소개할 곳은  leetcode  입니다. 무료 문제와, 유료 구독을 해야 잠금해제 할 수 있는 문제가 섞여 있습니다. 무료로 풀어볼 수 있는 문제의 종류가 충분히 많고, 난이도도 다양한 편입니다.  leetcode 문제 목록 난이도는 해커랭크와 마찬가지로 Easy, Medium, Hard 세 단계로 구분되어 있습니다. 단계별 체감 난이도는 HackerRank와 비슷하고, Acceptance Rate를 제공하기 때문에 문제마다 상대적인 난이도를 조금 더 구체적으로 파악할 수 있습니다. MySQL 이외에 MS SQL Server, Oracle과 같은 여러 종류의 DBMS로 문제를 풀어볼 수 있도록 했고, 일부 문제는 솔루션을 제공합니다. 문제를 클릭하고 들어가면 Submissions 탭이 있는데 이 탭에서 나의 제출 쿼리마다 수행 시간이 얼마나 걸렸는지, 같은 문제를 푼 다른 사람들의 수행 시간과 대비해 얼마나 걸렸는지 자세한 정보를 제공합니다.  수행시간 분포 3. 프로그래머스 다음 플랫폼은  프로그래머스 입니다. 총 27개의 SQL 문제를 풀어볼 수 있습니다. 모든 문제의 난이도는 HackerRank, Leetcode 기준으로는 Easy 그리고 solvesql 기준으로는 쉬움 난이도의 문제들입니다.   프로그래머스 SQL 문제 목록 인프런  [백문이불여일타] 데이터 분석을 위한 중급 SQL  강의를 들으신 분들에게, 그리고  SQL 캠프 입문반 을 졸업한 분들에게 공부한 내용을 점검차 가볍게 풀어보라고 권하고 있습니다. SQL 문법 중에서 GROUP BY, JOIN을 사용하실 수 있다면 누구나 쉽게 풀 수 있는 문제 세트입니다. MySQL, Oracle 두 가지 DBMS로 문제를 풀어볼 수 있습니다. 4. solvesql  solvesql 은 데이터리안와 협업하고 있는 한국어 SQL 플랫폼입니다.  무료 연습문제를 10문제  제공하며, 연습문제 뿐만 아니라  플레이그라운드 에서 다양한 데이터를 다뤄볼 수 있다는 것이 가장 큰 장점입니다.  solvesql 문제 목록 난이도는 쉬움, 보통, 어려움 세 단계이고 보통 난이도부터는 풀기 까다로운 문제들이 들어있습니다. 단계 별 난이도는 HackerRank, Leetcode와 비슷하거나 약간 더 어려운 수준입니다. 무료 가입자는 SQLite 만 사용할 수 있습니다. Leetcode와 마찬가지로 문제마다 정답률을 제공하여 문제 별 상대적인 난이도를 좀 더 구체적으로 파악할 수 있습니다. HackerRank, Leetcode와 다르게 문제가 계속 업데이트 되고 있고, 분석적인 관점에서 볼 수 있는 문제들이 추가되고있어 알고리즘 성격의 SQL 문제 뿐만 아니라 데이터 분석 트레이닝을 하고 싶은 분들에게 유용한 플랫폼이 될 것 같습니다. 맨 처음에 질문에 대한 답변은 이렇게 드렸습니다.  혹시 여러분들도 궁금하시다면 한 번 풀어보세요! 안녕하세요. 코드 적는 경험이 많이 없으시다면 캠프에서 사용하는 solvesql.com 이라는 플랫폼에서 문제를 몇 개 풀어보고 감을 잡으시면 좋을 것 같아요.  네 가지 플랫폼 비교 플랫폼 언어 DBMS 유무료 장점 단점  HackerRank 영어 MySQL, MS SQL Server, Oracle, DB2 무료 다양한 문제 문제 업데이트 없음  leetcode 영어 MySQL, MS SQL Server, Oracle 부분 유료 수행시간 분포 언어가 영어라서 불편한 것 말고는 딱히 없음  solvesql 한국어 SQLite (데이터리안 캠프 수강생들에게는 MySQL) 부분 유료 다양한 데이터와 플레이그라운드 무료 사용자에게 제한적인 기능과 아직은 부족한 문제 갯수  프로그래머스 SQL 고득점 키트 한국어 MySQL, Oracle 무료 쉬운 난이도 쉬운 난이도 네 가지 플랫폼을 표로 정리해서 비교해보았습니다. SQL 공부하시는데 도움이 되었으면 좋겠어요. 어느 플랫폼에서 하든 코딩 연습은 코드를 많이 적어보는 것 이외에는 왕도가 없다는거 다들 아시죠? 이 글은  데이터리안 홈페이지 에서도 보실 수 있습니다.  월간 데이터리안 1월 웨비나 &quot;비전공자 4명, 어떻게 데이터 분석가 됐을까?&quot;  가 일주일만에 신청자 200명이 넘으면서 1월 25일 웨비나를 성황리에 마쳤습니다. 사전 질문들을 보니까 데이터 분석 교육으로 어떤 공부를 해야하는지, 포트폴리오는 어떻게 만들어야 하는지 고민이신 분들이 많더라구요. 100개가 넘는 질문 중에 거의 대부분이 이 고민이었던 것 같아요. 웨비나 질문 몇 개를 뽑아보겠습니다 비전공자가 데이터분석 직군이 되려면 전공자를 뛰어넘는 관련 경험이라던지 포트폴리오가 필요하다고생각합니다. 이런 경험이나 포트폴리오준비는 어떻게 하셨나요? 또 독학만으로 준비하셨나요 국비강의를 들으셨나요? 데이터분석가로 취업하기 위해 꼭 갖추어야 하는것은 무엇이며, 비전공자가 특히 고려해야 하는것은 무엇일까요? 데이터 분석가는 분석 포지션을 모두 수행하는 플레이어인가요? (데이터 분석가+비즈니스 분석가+프로덕트 분석가) 채용공고를 보면 데이터 분석가 업무를 모델링으로 쓴 곳도 있고, Funnel/AARRR 등 프로덕트 분석으로 쓴 곳도 있어서 기본적으로 역량을 어디서부터 어디까지 쌓아둬야 하는지 궁금합니다. 데이터분석 직무에 필요하다고 생각하시는 핵심역량 또는 채용시 중요하게 보시는 부분이 있다면 어떤것일지 궁금합니다. 사실 질문들을 읽으면서 우리끼리 얘기했어요.  &quot;이거 우리 캠프 들으면 다 할 수 있는데. 너무 캠프 말만 하면 쟤네 광고하나 할테고 이거 참 어렵네요...&quot; 데이터리안 SQL 과정은 단순히 SQL이라는 언어를 주입식 교육하는 과정이 아니라 데이터 분석가로 취업하기 위해 코딩테스트를 보려면 어떤 수준까지 언어를 알고 훈련해야 하는지, 실무에서 우리가 자주 썼던 문법은 뭔지 복기하며 기획한 과정이기 때문에 사실 이 질문들에 대한 저희의 최선의 답변은  &quot;저희를 믿고 캠프와 4주간 함께해주세요.&quot;  입니다. 이 과정을 기획한 분석가가 4명인데요. 이 4명이 지금까지 코딩 테스트를 본 회사를 세보면 몇 개일까요? 스무 군데가 넘습니다. 그 중에 실제로 근무한 회사는 여섯 곳이구요. 다양한 SQL 코딩 테스트 유형에 대해서, 분석가의 업무에 대해서 이보다 더 다양한 이야기를 해드릴 수 있는 곳은 없습니다. 실전반은 SQL의 문법을 어느 정도 아는 분들(그룹별로 집계하기, 조인까지는 할 수 있다!)을 대상으로 진행합니다. 코딩을 한 번도 해 본적이 없다 하시는 분들은 입문반부터 시작하시면 될 것 같구요.  실전반은 기본적인 문법을 아는 분들에게 좀 더 다양한 SQL의 함수와 기능에 대해서 얘기하고, 좀 더 고난이도의 문제를 함께 풀어보며, 리텐션 분석 퍼널분석 등 분석 프레임워크를 알려드리기 위한 과정 입니다. 현업과 비슷한 분석 경험을 해보고 싶거나, 나의 SQL 또는 분석 실력을 보여줄 수 있는 포트폴리오를 만들고 싶은 분들에게도 유용한 과정이 될거예요. 실전반 4주 목표 설정 데이터 분석가 채용에서 요구하는 SQL 코딩테스트에서 만점받을 수 있습니다 길고 복잡한 SQL 쿼리문을 뜯어보고 이해하며 수정할 수 있습니다 입문반보다 좀 더 다양한 함수와 기능을 배우고 익숙하게 사용할 수 있습니다 리텐션 분석 등 분석 프레임워크를 익히고 적용할 수 있습니다 분석 프레임워크가 뭐지? 요즘 분석가 채용공고들을 보면 AARRR, Cohort, Funnel 같은 단어가 많이 보이는데요. 처음 보시는 분들은 &#39;저게 뭐야...&#39; 하실 수 있을 것 같아요. 데이터 분석 하는데 많이 사용하는 용언데 알고보면 별게 아닙니다.   토스 데이터 분석가 채용공고 ( https://www.wanted.co.kr/wd/52315 )  AARRR 은 그로스해킹(Growth Hacking) 용어로 서비스를 성장시키기 위해서 어떤 분석을 해야하고, 어떤 지표들을 봐야하는지 정립된 분석 프레임워크입니다. 각각 Acquisition, Activation, Retention, Revenue, Referral을 의미하구요. 광고 등을 통해 사용자를 얻고(Acquisition), 그 사용자를 가입을 시킨다던지 튜토리얼을 마치게 하는 활성화 과정을 거쳐(Activation), 서비스를 지속적으로 사용하게 만들고(Retention), 결제를 하게 하고(Revenue), 다른 사용자에게 추천을하고(Referral), 또 그렇게 들어온 사용자를 활성화시키는(다시 Acquisition) 성장의 고리를 체계적으로 정리한 이론이라고 생각하시면 될 것 같습니다.  이 중 Revenue, 매출 분석은 입문반 4주차에 진행하구요. Retention, 사용자 유지 분석은 실전반에서 진행합니다.  Cohort 는 영어로는 &quot;a group of people banded together or treated as a group.&quot; 를 의미합니다. 데이터 분석에서 Cohort 분석이란 사용자를 여러 그룹으로 나누어서 그룹 별 특징을 분석해보는 일련의 과정을 말합니다. 예를 들어, 전체 매출을 봤을 때 매출에 변동이 없다고 해봅시다. 그런데 그 매출을 성연령별 유저 그룹으로 나누어 봤을 때에 특정 그룹에서는 매출이 하락하고, 다른 그룹에서는 매출이 상승하는 다른 패턴을 보여줄 수 있거든요.  이렇게 데이터를 쪼개서 분석을 하는 방법에 대해서는 입문반 4주차, 그리고 실전반 전반에서 얘기를 하게 될겁니다. 이외에도 다양한 분석 프레임워크들을 소개하고, 나아가 SQL로는 어떻게 구현할 수 있는지 알아볼거예요. 정말 알찬 한 달이 될 것 같지 않나요? 실제로 우리 캠프는 이런 내용들을 4주~8주 안에 압축해서 전달하기 위해 과제도 많이 내드리고, 일주일에 2시간 있는 라이브 수업 시간도 꽉꽉 채워서 사용하고 있습니다. 이런 것들이 실전반 코스에 포함되어 있어요 👩‍💻 주 1회 2시간, 4번의 줌(Zoom)  온라인 세션 💎 solvesql.com  연습 문제  쿠폰 4장 📽️ 인프런 고급 SQL  동영상 강의  수강권 (평생 무제한 수강) 👩‍🏫 완주할 수 있도록  조교의 진도 관리   🙋 비공개 슬랙(Slack) 채널  #실전반-질문답변  에서 강사, 조교와 빠른 질문 답변 ✨  월간 데이터리안 웨비나  앞으로도 쭉 무료 참석 ✔️ 수료증 발급 소위 말하는 &quot;나만 잘하면 되는&quot; 환경을 만들어 드립니다. 과제를 꼭 해오셔야 진도를 따라오실 수 있기 때문에 조교가 여러분들 온라인 강의 진도를 확인하고 리마인드를 드리구요. 처음 시작할 때의 패기와는 달리 마음이 느슨해져 숙제를 안해오실 수 있기 때문에 매주 랜덤으로 학생을 뽑아 강사와 문제풀이를 함께하는 시간을 가집니다.  일단 등록하면 여러분의 의지와는 상관없이 4주간 열심히 공부하게 되실거예요 . 입문반 1기를 마친 수강생 분은 4주차 설문에 이런 이야기를 남겨주셨어요 &quot;선생님들 덕분에 너무너무 즐겁고 유익한 한 달을 보낼 수 있었어요! 2022년이 다 지나고 나서 돌아봤을 때 올 해 가장 잘 한 일로 기억될 것 같습니다&quot; 데이터리안 강사에게 SQL을 배운, 지금은 배달앱 분석을 하고 계시는 수강생 J님의 인터뷰도 첨부합니다. 여러분들이 용기를 가지는데에 도움이 될거예요! !youtube[QnJaEPDAmhk?mute=1&amp;autoplay=1] 아직도 망설이고 계시는건 아니죠? 얼리버드 할인 기간 내에 신청하시면 25% 할인해드리고 있어요. 우리 줌 강의실에서 만나요! 👉🏼  실전반 신청하러 바로가기 이 글은  데이터리안 홈페이지 에서도 읽으실 수 있습니다. 띵동! 데이터리안 카카오톡 채널로 질문이 도착했습니다. 안녕하세요! 데이터 분석가 취업을 준비하고 있는데, 강의와 부트캠프 관련해 문의사항이 있어 연락드렸습니다.   답변 : 데이터 분석가에게 요구하는 기술과 역량은 회사마다 조직마다 다르지만, 데이터리안 강좌들 만으로 기술적인 내용은 충분히 익히실 수 있고 이후 면접 대비를 잘 하시면 좋을 것 같습니다.  데이터 분석가 채용은 대략 4가지 단계로 진행됩니다. 서류 전형 SQL 코딩테스트 면접  입사    마이리얼트립 데이터 분석가 공고 예시    토스 분석가 공고 예시 여기에서 우리가 도달하고자 하는 목표 지점은  &#39;4. 입사&#39;  이고, 4번에 도달할 수록 해당하는 사람들이 점점 적어지는 구조입니다. 데이터 분석을 할 때 이렇게 점점 좁아지는 깔때기 모양의 단계를 퍼널(Funnel)이라고 합니다. 퍼널의 간단한 예를 들면 이런거예요. 광고를 클릭해서 서비스 페이지에 랜딩함 서비스 페이지를 둘러보고 결제 버튼을 클릭함 결제에 필요한 정보를 입력하고 결제 완료 분석가들은 1번 스텝을 밟고, 2번 스텝으로 넘어가는 행동을  &#39;전환&#39;  이라고 부릅니다. 그렇다면 1번 스텝을 밟은 사람들 대비, 2번 스텝을 밟은 사람은 몇 % 인가? 그것을  &#39;전환율&#39;  이라고 하고요. 제품팀은 이 전환율을 높이기 위해서 어떤 액션이 필요한지  전략 을 세웁니다.  AARRR Funnel 이미지 예시 저는 채용 과정에서의 4가지 스텝도 이렇게 분석을 하고 전략을 세워야 하는 Funnel 이라고 봅니다. 여러분들도 이제 그렇게 보이시나요?  자 이제 제품팀의 분석가처럼 이 Funnel의 끝까지 가 닿기 위해서 어떤 일들을 해야할지 전략적으로 생각해봅시다. 서류 전형 SQL 코딩테스트 (가끔 파이썬과 SQL을 둘 다 보거나, 과제를 줍니다) 면접  입사 1. 서류 전형 코딩테스트를 보는 회사들은 어지간히 이상한 이력서가 아니라면 1번 단계에서 사람을 거의 걸러내지 않습니다. 코딩테스트로 대부분의 필터링이 되기 때문입니다.  코딩테스트는 대부분 해커랭크나 프로그래머스 같은 온라인 플랫폼을 이용해 진행하면 되기 때문에 채용하는 사람 입장에서는 거의 에너지가 들지 않는 일입니다.  일단 이력서를 냈다면, 코딩테스트를 못 보게 할 이유가 없습니다. 2. SQL 코딩 테스트 자, 1단계에서 2단계로 가는 첫 번째 전환은 쉽게 일어났네요. 이제 SQL 코딩테스트를 볼 차례입니다. 데이터리안의 현재 강의들은 주로 SQL과 파이썬이라는 도구 교육을 중심으로 합니다. 이 도구 교육은 2번에서 3번으로 가는 전환을 돕습니다. * 데이터리안의  인프런 SQL 로드맵 을 따라오시거나,  SQL 부트캠프 를 수강하시는 것으로 테스트 준비는 충분합니다. * 인프런 강의 후기를 보시면 가끔 &#39;코딩테스트 만점 받았어요!&#39;하고 써주시는 분들이 있습니다. 데이터리안 공식메일( datarian2020@gmail.com )으로도 테스트 잘 보게 해줘서 감사하다는 메일이 종종 도착하구요.   SQL 부트캠프  같은 경우에는 동영상 강의와 온라인 강의를 병행하기 때문에 풀어보는 문제의 양이 인프런 강의의 약 두 배에 가깝다고 생각하시면 될 것 같아요. 연습량이 두 배니까, 실력도 두 배로 늘겠죠? 3. 면접 코딩테스트만 통과한다면 여러분 앞에는 면접만 남아있게 됩니다.  사실 이력서가 가장 중요한 단계는 이 단계입니다.  면접관들이 지원자에게 이런저런 질문을 해야하는데, 앞에 있는 사람에 대해서 어느 정도 알아야 질문이나 대화가 되잖아요. 면접관들은 이력서를 읽으면서 질문을 합니다. 면접에 들어가기 전에 읽어보고 들어가라는 HR팀의 권유가 있지만, 다들 업무하느라 바쁘기 때문에 면접장에 도착해서나 이력서를 처음으로 훑어봅니다.   여러분들이 받을 수 있는 질문은 크게 네 가지입니다. 사전 테스트, 과제에 대한 질문 또는 SQL 추가 테스트  사전에 질문하기로 정해진 것들 이력서에 적힌 내용을 바탕으로 한 즉흥 질문 마지막으로 저희한테 혹시 하실 얘기나, 물어보고 싶은거 없으세요? 사전 테스트, 과제에 대한 질문 또는 SQL 추가 테스트 종종 온라인 SQL 테스트를 보고도 면접에서 추가 테스트를 보는 경우가 있습니다. 경험상 쿠팡, 카카오 등 많은 기업들이 그렇게 하고 있구요. 간단한 문제와 테이블 설명을 화면에 띄워주고 쿼리를 작성해보라는 식입니다.  팀에서 실제로 쓰고 있는 테이블과 구조가 비슷한 예시를 주는 것이 코딩테스트 플랫폼에서 보는 테스트와는 다른 점입니다.  대면으로 해야 한다는 것만 다르지, 난이도는 코딩 테스트 플랫폼에서 보는 것보다 쉬운 경우가 대부분인 것 같습니다. 사전에 질문하기로 정해진 것들 &#39;사전에 질문하기로 정해진 것들&#39;에 대한 대비는 인터넷에 &#39;데이터 분석가 면접 질문 모음&#39; 같은걸 보시면 대략 아실 수 있을 것 같아요. 제가 항상 하는 얘기지만,  모든 질문에 완벽하게 답할 필요는 없고 아는 것에 대해서 잘 대답하시면 됩니다.  저도 면접에서 질문받는거 다 모르구요. 그 회사 사람들도 면접 질문에 대해서 답하라면 100% 제대로 답변하는 사람은 아마 한 명도 없을겁니다.  &#39;A라고 답변하셨는데, 그러면 A에 대해서 좀 더 자세하게 설명해주실 수 있나요?&#39; 같이 답변에 대한 추가질문이 꼭 이어지니까, 엉성하게 아는 단어를 늘어놓는건 당장의 상황만 모면할 뿐 면접 전체에 도움을 주지는 않는다는 것을 기억합시다. 이력서에 적힌 내용을 바탕으로 한 즉흥 질문 &#39;이력서에 적힌 내용을 바탕으로 한 질문&#39;에 대비하기 위해서는 이력서를 전략적으로 잘 써야합니다. 포트폴리오를 준비할 생각이라면, 이 단계에서 자신있게 보여주고 얘기할 수 있는 것으로 구성하는게 좋습니다. 이력서를 쓰거나 포트폴리오를 준비하시는 분들 중에 &#39;서류합격&#39;을 목표로 하시는 분들이 있는데  사실 이력서가 가장 중요한 단계는 면접 이라는 말을 꼭 하고 싶었습니다.  SQL 부트캠프 입문반 에서는 이런 부분에서 분석 역량을 보여줄 수 있도록 RFM 분석, 매출 분석을 가르쳐드리고  SQL 부트캠프 심화반 에서는 리텐션 분석, 퍼널 분석 등 좀 더 다양한 분석 주제를 다룹니다. 부트캠프에서 가르쳐드린 내용을 바탕으로  새로운 데이터와 본인만의 관점을 담은 분석 프로젝트 를 해보시면 정말 매력적인 포트폴리오를 만들 수 있겠죠. 꼭 저희 부트캠프를 듣지 않으시더라도, 본인만의 관점과 분석 역량을 담은 프로젝트를 보여주는건 면접에서 플러스 요인입니다. 마지막으로 저희한테 혹시 하실 얘기나, 물어보고 싶은거 없으세요? 면접 끝날때쯤 꼭 하는 질문이 이겁니다. &#39;마지막으로 물어보고 싶은거 없으세요?&#39; 이 질문에 대한 대비는 저희 유튜브 채널에서 얘기를 많이 했기 때문에 영상으로 대신하겠습니다. !youtube[v1-h5bPCmUI] 데이터 분석가 면접에 대해서 더 궁금하신 분들은  1월 25일 저녁 7시에 여는 세미나 에 참석해주세요! &#39;마지막으로 물어보고 싶은거 없으세요?&#39;라는 질문에 대해 어떻게 답변하면 좋을지 멋진 이야기를 해주실 수 있는 분도 패널로 참석하신답니다. 재미있는 질문을 받은 김에 데이터 분석가 취업과, 데이터리안의 강의들에 대해 이런저런 이야기들을 해보았습니다. 아! 그리고 [비전공자 4명, 어떻게 데이터 분석가 됐을까?] 세미나 참석자가 100명이 넘었습니다! (박수) 많이 신청해주셔서 감사드리고, 더 재미있는 얘기 라이브로 많이 할 수 있었으면 좋겠습니다. 1월 25일에 만나요 :D     레퍼런스 마이리얼트립 데이터 분석가 공고:  https://www.wanted.co.kr/wd/33147 토스 데이터 분석가 공고:  https://www.wanted.co.kr/wd/52315 AARRR Funnel:  https://dwarves.foundation/playbook/aarrr-framework-zmjhde6izw/ 데이터 분야 중요하다는데, 정작 데이터 분야 취업을 위해서는 뭘 해야할지 모르는 경우가 많습니다. 데이터 분석 관련 커리어를 시작하고 싶은 취준생, 데이터 분석가로 직무 전환을 하고 싶은 직장인 여러분들을 위해 4인의 데이터 분석가가 뭉쳤습니다!  &#39;물류학, 기계공학, 경영학, 문예창작&#39; 각기 다른 전공으로 시작해 다양한 회사의 데이터 분석가로 커리어를 시작한 데이터 분석가들을 만나보세요. 행사 신청 바로가기 👉🏼  https://forms.gle/WqcFnRbjPedcHTNk9 ✔️  일시 참가비 : 10,000원 (학생 / 취업준비생: 5,000원) ✔️  프로그램 소개 1부 19:00 ~ 20:00 비전공자 데이터 분석가 취업기 + 채용공고 읽는 방법 2부 20:00 ~ 21:00 비전공자 데이터 분석가 4인 질의응답 ✔️  출연진 및 스태프 소개  연사 &lt;선미&gt; [물류학, 경영학 복수전공]  패널 &lt;민주&gt; [기계공학 전공]  패널 &lt;보민&gt; [문예창작 전공]  패널 &lt;혜정&gt; [경영학 전공]   참가 신청서 안에 사전 질문을 남길 수 있는 섹션이 준비되어있습니다. 평소 데이터 분야에 대해 궁금한 점이 있으셨다면 이번 기회에 질문 주세요! 지금까지 들어온 질문들 ٩( ᐛ )و 이력서 작성법(일반 회사 지원서 처럼 써야 할지, 아니면 노션 등 프로그래머들이 작성하는 방식으로 다양하게 작성해야 할지) 기획에서 데이터분석 직무 변경을 추천하시나요? 비전공자로 실무 첫단추를 어떻게 끼우게 되셨는지요. 그리고 기술창업을 하려고 하는데 창업 관련 얘기도 부탁드립니다.  데이터분석가 혹은 사이언티스트로 제대로 성장할 수 있는 회사의 구조나 분위기 등 어떻게 알 수 있을까요? 데이터분석가 현직자로 일하시다가 퇴사를 결심하게 된 이유가 있으신가요? 데이터분석가로 일하셨을 때, 하루 업무 일과가 궁금해요. 출근해서 퇴근까지 어떤 업무들을 하셨나요? 꾸준히 읽고 있는 데이터분석 관련된 컨텐츠들이 있으신가요? 책, 매거진, 뉴스기사 등 뭐든 좋아요! 분석하기 싫은 프로젝트를 만났을 때 어떻게 완수했는지?  1월 25일 저녁에 뵙겠습니다! 재미있는 얘기 함께 많이 나눠봅시다. 이 글은  데이터리안 홈페이지 에서도 보실 수 있습니다. 범위 리텐션(Range Retention)은  클래식 리텐션 을 유연하게 확장한 개념입니다. 클래식 리텐션에서는 분석을 특정 일/주/월 단위로(이 중에서도 일 단위의 분석을 지난 문서에서 살펴봤었죠) 한정짓는 느낌이라면 범위 리텐션은 구간을 유연하게 나눈다는 점만 다릅니다. 범위를 지정하는게 특징이기 때문에 Bracket Retention이라고도 합니다. 지금까지 얘기한 리텐션 모아보기 👇  클래식 리텐션 : Classic Retention / N-Day Retention  롤링 리텐션 : Rolling Retention / Unbounded Retention 범위 리텐션: Range Retention / Bracket Retention 범위 리텐션 계산하기 12월 1일에 서비스에 가입한 사용자 A, B, C, D, E의 방문로그를 아래와 같이 가정합시다. 이 데이터를 3일씩 묶어서 범위 리텐션을 계산해보겠습니다.  사용자 12-01   (Day 0) 12-02   (Day 1) 12-03   (Day 2) 12-04   (Day 3) 12-05   (Day 4) 12-06   (Day 5) 12-07   (Day 6) A 방문 방문 방문 방문 방문 방문 방문 B 방문 방문 방문 C 방문 방문 방문 D 방문 방문 E 방문 방문 아래의 기준으로 데이터를 묶어봅시다. Day 0: 12월 1일 (최초 접속일 또는 서비스 가입일) Day 1~3: 12월 2일부터 4일까지 Day 4~6: 12월 5일부터 7일까지 12-01   (Day 0) 12-02 ~ 12-04   (Day 1~3) 12-05 ~ 12-07   (Day 4~6) 기간 내 방문유저수 5 3 3 범위 리텐션 % 100% 60% 60% Day 1 3 구간 동안에는 사용자 A, B, C가 방문했고 Day 4 6 기간에는 사용자 A, D, E가 방문했습니다. Day 4 6 구간보다 Day 1 3 동안에 훨씬 많은 방문이 발생했지만 이러한 특성은 데이터를 요약하면서 사라지고 두 구간 모두 범위 리텐션은 60%로 계산됩니다. 이렇게 기간을 묶어서 계산하기 때문에 범위 리텐션 계산 방식은 노이즈에 강합니다. 우연히 하루정도 접속을 안 했다고 하더라도 리텐션에 영향을 주지 않기 때문입니다. 주로 서비스 사용주기가 길거나 주기적인 서비스에서 많이 사용합니다. 다양한 리텐션 계산 방법에 따른 차이 클래식 리텐션, 롤링 리텐션, 범위 리텐션 계산 결과를 하나의 차트로 그려보겠습니다. 같은 데이터를 이용하더라도 계산 방식에 따라서 이렇게 리텐션이 달라질 수 있습니다.    사용자의 이용 패턴이 바뀐 것도 아니고, 로그의 수집 형식이 달라진 것도 아니고 계산하는 하는 방법만 달라졌는데 리텐션 값이 이렇게 다른 것을 보면서 몇 가지 주의해야 할 점을 이야기하고 싶습니다.  남과 비교를 하려면 제대로 해야 합니다.  우리 서비스는 클래식 리텐션을 계산하고 있는데 옆 회사 롤링 리텐션을 가져다가 비교하는 일은 하지 말아야 합니다.  우리 서비스에 맞는 계산 방법을 사용해야 합니다.  사용 주기가 긴 서비스인데 일 단위 클래식 리텐션을 사용한다면 쓸데없는 일희일비를 하다가 잦은 푸시, 할인 등으로 사용자들을 지치게 할 수 있습니다. 사용주기가 짧은 서비스인데 너무 넓은 범위의 리텐션을 사용하면 계산하기까지 시간이 많이 소요되고(범위만큼 데이터가 모여야 계산할 수 있기 때문입니다), 지나치게 요약된 정보를 보느라 사용자들의 이탈시기를 놓칠 수 있습니다.  형식에 얽매이지 마세요.  우리는 지금까지 세 가지 리텐션 계산 방법을 살펴봤지만, 정해진 공식은 없습니다. 이 서비스와, 서비스를 사용하는 유저를 가장 잘 이해하는건 담당자입니다. (YOU!) 세 가지 리텐션 계산 방법을 기초로 서비스와 상황과 목표에 맞게 응용해보세요.  하나만 볼 필요는 없습니다.  어떤 것이 최선일까 고민하는데 너무 많은 시간을 쏟지 마세요. 일단 가장 쉬운 방법으로 계산하고 현상을 파악하는게 중요합니다. 그렇다고 너무 많이 보지도 마세요. 숫자가 너무 많으면 그것을 다 이해하기보다는 압도되어 버립니다. 데이터리안이 만든 SQL 캠프 ✨  막간을 이용한 광고 타임  ✨  데이터리안이 드디어 캠프를 만들었습니다! 2월 금요일 개강반: 2/4, 2/11, 2/18, 2/25 (총 4회) (매주 19:30 ~ 21:30, 2시간) 데이터 분석을 위한 SQL 캠프에서는 리텐션에 대해서 더 자세하게 이야기하고,  SQL 쿼리로 다양한 타입의 리텐션을 직접 계산하고 분석 해 볼 예정입니다. 클래식 리텐션, 롤링 리텐션, 범위 리텐션을 SQL로 한 번에 추출해보고 싶은 분들은 주목해주세요! 리텐션 계산을 위해 필요한 SQL 기능은 아래 세 가지인데요. 필요한 데이터만 필터링 테이블 피보팅 서브쿼리 이번에 여는  2022년 2월 SQL 입문 캠프 에서는 1번, 2번 기능을 배우고, 나중에 열릴 심화 캠프에서 3번 기능을 마저 배운 다음 리텐션 계산을 해 볼 예정입니다. 캠프 신청 방법은  여기 를 참고해주세요! 혹시 캠프 신청 기간이 지나서 이 글을 발견하셨다면  datarian2020@gmail.com 으로 문의메일 남겨주세요 :D !youtube[l4_axJ8KKos?autoplay=1&amp;mute=1] 참고자료  리텐션을 측정하는 세 가지 방법 이 글은  데이터리안 홈페이지 에서도 보실 수 있습니다.  리텐션 계산하기 (1) Classic Retention 에서는 이런 이야기들을 했습니다 :D 시리즈가 처음이신 분들은 앞 글을 먼저 봐주세요. 리텐션이 뭔지 왜 AARRR 중에 가장 중요하다고들 하는지 과연 &#39;방문&#39;만이 리텐션을 측정할 수 있는 기준일지 클래식 리텐션의 한계 롤링 리텐션을 계산해보기 전에, 클래식 리텐션의 한계에 대해서 짧게 복습해보겠습니다. 사용자 12-01   (Day 0) 12-02   (Day 1) 12-03   (Day 2) 12-04   (Day 3) 12-05   (Day 4) 12-06   (Day 5) A 방문 방문 방문 방문 방문 방문 B 방문 방문 방문 C 방문 방문 방문 D 방문 방문 E 방문 우리는 앞에서 202X년 12월 1일에 가입한 사용자 A, B, C, D, E가 있다고 가정했습니다. 그리고 위 표와 같이 사용자들이 접속했다고 가정할 때에, 클래식 리텐션은 아래와 같이 계산할 수 있습니다. 12-01   (Day 0) 12-02   (Day 1) 12-03   (Day 2) 12-04   (Day 3) 12-05   (Day 4) 12-06   (Day 5) 방문유저수 5 2 2 3 1 2 클래식 리텐션 % 100% 40% 40% 60% 20% 40% 이때 날아오는 날카로운 질문! *&quot;사용자 B를 Day 2 계산에서 빼도 되는건가요? Day 3에도 접속을 하고 있는데, 이 정도면 Day 2 시점에는 서비스를 계속 사용하고 있다고 봐도 되는게 아닐까요?&quot;* 우리가 고객을 얼마나 유지하고 있는지(Retain)의 관점에서 사용자 B는 Day2 시점에 여전히 서비스를 사용하고 있습니다. 클래식 리텐션에서는 놓칠 수 있는 이런 부분을 보완하기 위해 상황에 따라 롤링 리텐션(Rolling Retention)을 계산합니다. 롤링 리텐션은  &#39;사용자가 이탈하지 않고 남아있는가?&#39; 에 초점을 맞추기 때문에 Unbounded Retention이라고도 부릅니다. 롤링 리텐션 계산하기 롤링 리텐션은 기준일을 포함하여 그 이후에 한 번이라도 재방문한 유저의 비율을 나타냅니다. 좀 더 쉽게 이해하자면 &#39;마지막 방문일 이전은 방문한 것으로 간주한다&#39;로 생각하셔도 됩니다. 기준일 이후에 방문 기록이 있다면, 기준일 당시에는 이탈하지 않은 사용자로 계산하겠다는 뜻입니다. 사용자 12-01   (Day 0) 12-02   (Day 1) 12-03   (Day 2) 12-04   (Day 3) 12-05   (Day 4) 12-06   (Day 5) A 방문 방문 방문 방문 방문 방문 B 방문 방문 (방문으로 간주) 방문 C 방문 (방문으로 간주) 방문 방문 D 방문 (방문으로 간주) (방문으로 간주) (방문으로 간주) (방문으로 간주) 방문 E 방문 그러면 롤링 리텐션을 아래와 같이 계산할 수 있습니다. 12-01   (Day 0) 12-02   (Day 1) 12-03   (Day 2) 12-04   (Day 3) 12-05   (Day 4) 12-06   (Day 5) 이탈하지 않은 유저 수 5 4 4 4 2 2 롤링 리텐션 % 100% 80% 80% 80% 40% 40% 롤링 리텐션은 여행 서비스, 쇼핑몰, 부동산 서비스 등 사용 빈도가 높지 않은 서비스에서 유용하게 활용됩니다. 매일매일 이용하는 것이 중요하다기 보다는 사용자가 니즈를 가진 시점에(&#39;이사를 해야 되는데&#39;) 방문하면 되는 서비스(&#39;다방을 열어볼까?&#39;)의 경우에는 클래식 리텐션으로 사용자 유지 여부를 계산할 필요는 없는 것이죠. 오히려 클래식 리텐션으로 매일의 접속 여부를 확인하면서 이 지표를 높이기 위해 앱푸시를 보낸다던지, 과한 할인을 한다던지 하는 것은 장기적인 사용자 유지에 악영향을 미칠 수도 있습니다. 이렇게 다양한 리텐션 계산 방법들을 알고 있으면  상황에 맞게, 서비스에 맞게 사용자 유지율을 분석 할 수 있습니다. 보고용으로 쓸 수 있나? 하루가 더 지나서 12월 7일 데이터가 생겼습니다. 그런데 사용자 E가 지금까지 접속하지 않다가 12월 7일에 서비스에 방문했다고 가정해봅시다. 사용자 12-01   (Day 0) 12-02   (Day 1) 12-03   (Day 2) 12-04   (Day 3) 12-05   (Day 4) 12-06   (Day 5) 12-07   (Day 6) A 방문 방문 방문 방문 방문 방문 방문 B 방문 방문 방문 C 방문 방문 방문 D 방문 방문 E 방문 방문 이탈하지 않은 유저 수   (12월 6일 계산) 5 4 4 4 2 2 이탈하지 않은 유저 수   (12월 7일 계산) 5 5 5 5 3 3 2 롤링 리텐션 %   (12월 6일 계산) 100% 80% 80% 80% 40% 40% 롤링 리텐션 %   (12월 7일 계산) 100% 100% 100% 100% 60% 60% 40% 이탈했다고 생각한 사용자 E가 12월 7일에 돌아왔기 때문에 롤링 리텐션 값이 바뀌게 됩니다. 12월 6일에 계산한 리텐션과 12월 7일에 계산한 리텐션의 값이 다른 것을 표의 마지막 두 줄로 보실 수 있습니다. 이런 식으로 사용자들의 이후 접속에 따라 기존에 계산했던 리텐션 값이 얼마든지 달라질 수 있다는 점은 롤링 리텐션의 고유한 특징입니다. 그래서 절대적인 수치가 중요하다기 보다는 지표가 어떻게 움직이는지 트렌드를 보는 정도로 활용하시기를 권합니다. 이건 조금 사담이지만(원래 사담이 제일 재밌지 않나요), 제가 분석가로 있을 때 가장 어려움을 겪었던 부분 중 하나는 주변에 지표를 가지고 같이 일해야 하는 사람들이나, 보고를 받아보는 사람들이 &#39;숫자도 변할 수 있다&#39;는 점을 받아들이기 어려워한다는 점이었는데요.   &#39;어제 받아본 Day 1 리텐션은 80%였는데, 왜 오늘은 100% 입니까?&#39; 라는 질문이 충분히 나올 수 있다고 생각합니다. &#39;아! 이거 클래식 아니고 롤링 리텐션이에요&#39;라고 대답해서 해결할 수 있으면 참 좋을텐데 대부분의 경우에는 그렇지 못하구요. 조직의 분위기, 협업하는 사람들의 데이터에 대한 이해도가 어느 정도이냐에 따라 저는 롤링 리텐션을 아예 사용하지 않을 것 같기도 합니다.   이 글을 읽은 데이터리안 멤버(분석가)의 공감과 애환...👆 데이터리안이 만든 SQL 캠프 ✨  막간을 이용한 광고 타임  ✨  데이터리안이 드디어 캠프를 만들었습니다! 2월 금요일 개강반: 2/4, 2/11, 2/18, 2/25 (총 4회) (매주 19:30 ~ 21:30, 2시간) 데이터 분석을 위한 SQL 캠프에서는 리텐션에 대해서 더 자세하게 이야기하고,  SQL 쿼리로 다양한 타입의 리텐션을 직접 계산하고 분석 해 볼 예정입니다. 클래식 리텐션, 롤링 리텐션, 범위 리텐션을 SQL로 한 번에 추출해보고 싶은 분들은 주목해주세요! 리텐션 계산을 위해 필요한 SQL 기능은 아래 세 가지인데요. 필요한 데이터만 필터링 테이블 피보팅 서브쿼리 이번에 여는  2022년 2월 SQL 입문 캠프 에서는 1번, 2번 기능을 배우고, 나중에 열릴 심화 캠프에서 3번 기능을 마저 배운 다음 리텐션 계산을 해 볼 예정입니다. 캠프 신청 방법은  여기 를 참고해주세요! 혹시 캠프 신청 기간이 지나서 이 글을 발견하셨다면  datarian2020@gmail.com 으로 문의메일 남겨주세요 :D !youtube[l4_axJ8KKos?autoplay=1&amp;mute=1] 참고자료  리텐션을 측정하는 세 가지 방법 이 글은  데이터리안 홈페이지 에서도 보실 수 있습니다. 그로스해킹의 대표적인 분석 프레임워크로 AARRR을 많이 사용합니다.  AARRR은 사용자 획득 → 신규 사용자가 서비스를 사용하기 시작 (사용자 활성화)    → 지속적으로 서비스를 사용 (사용자 유지) → 구매 → 다른 사용자에게 추천 → 새로운 사용자 획득이라는 이제는 당연해보이는 유저의 서비스 이용 사이클을 체계화한 프레임워크입니다. A: Acquisition (사용자 획득) A: Activation (사용자 활성화) R: Retention (사용자 유지) R: Revenue (매출) R: Referral (전파)   흔히 이렇게 깔대기 모양으로 많이 그립니다. 위에 사용자 획득 구간에 유저가 가장 많고, 아래 단계로 내려갈수록 유저가 적어지는 구조를 (대체로) 가지기 때문입니다. 리텐션이 중요한 이유 오늘은 이 중에서도 가장 중요한 Retention, 사용자 유지와 관련한 지표 계산에 대해서 알아보려고 합니다. 다섯가지 단계 중 가장 먼저 개선을 해야하는 단계로도 알려져 있죠. 만약 사용자 유지가 되지 않는 서비스인데 광고를 늘려 Acquisition, Activation을 늘렸다고 생각해봅시다. 새로 들어온 사용자들은 몇 번 서비스를 써보고는 매력을 느끼지 못해 이탈합니다. 이건 밑빠진 독에 물을 붓는 것과 다름이 없습니다. 따라서 새로운 사용자를 받는 것보다 선결되어야 하는 것은 기존 사용자들이 서비스를 만족스럽게 사용하고 있는지, 지속적으로 사용하는지 보는 것이고 이것이 바로 Retention 입니다.   이 단계에서는 앞에서 얘기한 것처럼 사용자들이 우리 서비스를 1회성이 아니라  지속적으로 사용하는지, 핵심가치를 꾸준히 경험하는지를 측정 합니다. 측정 방법에 정해진 공식이 있는 것은 아니지만 몇 가지 자주 사용하는 방법들이 있습니다. 오늘은 그 중에서도 클래식 리텐션(Classic Retention)이라고 많이 부르는 계산 방법에 대해서 살펴보겠습니다. 클래식 리텐션은 N-Day Retention이라고도 합니다. &#39;지속적 사용&#39;은 어떻게 측정하나요? 일반적으로는 &#39;방문&#39;을 기준으로 측정합니다. 하지만 꼭 &#39;접속&#39;, &#39;방문&#39;으로 리텐션의 기준을 한정할 필요는 없습니다. &#39;사용자가 서비스를 지속적으로 사용하는지를 보려고 한다&#39;는 목표 아래 다양한 로그가 리텐션을 정의하는데 사용될 수 있습니다. 특정 페이지 방문 특정 페이지 N번 방문 결제 버튼 클릭 또는 결제 완료 특정 기능 사용 등등... 예를 들어 어떤 서비스의 경우 단순히 사용자가 서비스에 &#39;방문&#39;한 것으로 서비스를 사용했다고 보기는 어렵다고 판단하고 &#39;특정 기능을 사용&#39;한 유저만 리텐션 계산에 포함시킬 수 있습니다. 아래 서비스는 제가 잘 쓰고 있는  todo mate 라는 일정관리 앱 인데요. 제가 느끼는 이 서비스의 핵심 가치는 일정을 등록하고, 일정을 완료하면서 캘린더에 색색의 꽃을 피워내는 성취감에서 옵니다. 이런 경우 리텐션을 계산하는 서비스 담당자라면 &#39;방문&#39;보다는 &#39;일정 등록&#39; 또는 &#39;등록된 일정 완료&#39; 로그를 이용하여 리텐션을 계산해 볼 수 있을겁니다.   꼭 서비스 전체 레벨의 지표가 아니더라도, 특정 기능을 개발했을 때 또는 우리의 핵심 기능을 유저들이 잘 쓰고 있는지 살펴보기 위해 &#39;기능의 반복사용&#39;을 보는 기능 리텐션(Feature Retention)을 측정하기도 합니다. 클래식 리텐션 계산하기 자 우리는 일반적으로 많이 사용하는 &#39;방문&#39;을 기준으로 리텐션을 계산해보겠습니다. 서비스의 특성에 따라 다양한 방법으로 계산을 하는데 이번 장에서는 클래식 리텐션(Classic Retention)이라는 가장 널리 사용되는 간단한 계산 방법을 알아보겠습니다. 202X년 12월 1일에 사용자 A, B, C, D, E 5명이 처음 서비스를 이용하기 시작했다고 생각해봅시다. 그리고 아래 표와 같이 서비스에 방문했다고 합시다. 사용자 12-01   (Day 0) 12-02   (Day 1) 12-03   (Day 2) 12-04   (Day 3) 12-05   (Day 4) 12-06   (Day 5) A 방문 방문 방문 방문 방문 방문 B 방문 방문 방문 C 방문 방문 방문 D 방문 방문 E 방문 202X년 12월 1일에 가입한 사용자들의 접속을 요약해보면 아래 표와 같습니다. 12월 2일에 방문한 유저는 5명 중 2명으로 40%이고 이 비율을 리텐션이라고 합니다.  12-01   (Day 0) 12-02   (Day 1) 12-03   (Day 2) 12-04   (Day 3) 12-05   (Day 4) 12-06   (Day 5) 방문유저수 5 2 2 3 1 2 리텐션 % 100% 40% 40% 60% 20% 40% 클래식 리텐션의 한계 클래식 리텐션은 어떤 날(12월 2일)에, 특정 유저군(12월 1일에 가입한 유저 5명)의 몇 %가 접속(40%)했는지 계산합니다. 아마 조금 날카롭게 생각하시는 분들이라면 이런 질문을 할 수도 있을 것 같습니다.  *&quot;사용자 B를 Day 2 계산에서 빼도 되는건가요? Day 3에도 접속을 하고 있는데, 이 정도면 Day 2 시점에는 서비스를 계속 사용하고 있다고 봐도 되는게 아닐까요?&quot;* 사용자 B의 경우에 Day 0, Day 1, Day 3에 방문했으니까 사실 Day 2에도 관점에 따라 서비스 사용자로 볼 수 있습니다. 서비스 사용을 &#39;유지(Retain)&#39;하고 있느냐 물어봤을 때에 사용자 B는 Day 2 리텐션 계산에 포함되어도 괜찮은 것으로 보입니다. 이렇게 매일매일 사용하는게 아니라, 사용 주기가 길 경우 클래식 리텐션으로 사용자 유지 여부를 판단했을 때 실제보다 훨씬 과소계상하게 됩니다. 이렇기 때문에 리텐션 계산에는 다양한 방법이 있습니다. 클래식 리텐션은 사용자가 매일 접속해서 사용할 것으로 기대되는 서비스에 활용하기 적절한 지표입니다. 카카오톡 같은 메신저 앱이나, 트위터 같은 SNS 서비스가 여기에 해당합니다. 위와 같이 사용 주기가 긴 서비스들의 경우 롤링 리텐션(Rolling Retention)이라는 계산법을 많이 사용합니다. 롤링 리텐션은 이탈에 초점을 맞추기 때문에 언바운드 리텐션(Unbounded Retention)이라고 부르기도 합니다. 롤링 리텐션에 대해서는  리텐션 계산하기 (2) 에서 더 얘기해보겠습니다. 데이터리안이 만든 SQL 캠프 ✨  막간을 이용한 광고 타임  ✨  데이터리안이 드디어 캠프를 만들었습니다! 2월 금요일 개강반: 2/4, 2/11, 2/18, 2/25 (총 4회) (매주 19:30 ~ 21:30, 2시간) 데이터 분석을 위한 SQL 캠프에서는 리텐션에 대해서 더 자세하게 이야기하고,  SQL 쿼리로 다양한 타입의 리텐션을 직접 계산하고 분석 해 볼 예정입니다. 클래식 리텐션, 롤링 리텐션, 범위 리텐션을 SQL로 한 번에 추출해보고 싶은 분들은 주목해주세요! 리텐션 계산을 위해 필요한 SQL 기능은 아래 세 가지인데요. 필요한 데이터만 필터링 테이블 피보팅 서브쿼리 이번에 여는  2022년 2월 SQL 입문 캠프 에서는 1번, 2번 기능을 배우고, 나중에 열릴 심화 캠프에서 3번 기능을 마저 배운 다음 리텐션 계산을 해 볼 예정입니다. 캠프 신청 방법은  여기 를 참고해주세요! 혹시 캠프 신청 기간이 지나서 이 글을 발견하셨다면  datarian2020@gmail.com 으로 문의메일 남겨주세요 :D !youtube[l4_axJ8KKos?autoplay=1&amp;mute=1] 참고 이미지 출처  AARRR 퍼널  리텐션 커브  ✨ 데이터리안에서 분석가 로드맵이 나왔습니다 ✨ 그리고 인프런 대시보드가 리뉴얼 되었어요. 이제 학생들이 이 강의를 학습하는데 실제로 얼마나 시간을 소요하고 있는지 볼 수 있게 되었습니다! (예시. 기초 SQL강의의 런타임은 1시간 36분, 실질 수강 기간은 3일!)  로드맵을 소개하면서, 데이터리안 강의를 학습하는데 우리 수강생 분들이 어떻게 시간을 쓰고 계시는지 같이 얘기해보겠습니다.   1. SQL 실무 활용 트랙    기획자, 마케터  등 SQL을 실무에서 활용해야 하는 모든 직군이 공통으로 들을 수 있는 구성입니다. 간단한 데이터를 추출하거나, 기존 쿼리를 이해하는 등 라이트하게 활용할 사용자들을 위한 트랙입니다. 강의의 순수 플레이 타임은 기초 SQL 1시간 36분, 중급 SQL 4시간 19분으로  5시간 55분 이고, 중급 SQL 문제풀이 강의 2시간 12분을 포함해서 학습하신다면  8시간 7분 입니다.   실제 학습에 소요되는 시간은 어느정도 될까요?   강의를 90% 이상 수강한 학생들이 &#39;완강 수강생&#39;이라고 생각하고, 이 수강생들의 상위 50% 평균을 계산한 값은 다음과 같습니다. 기초 SQL은  3일 , 중급 SQL은  9일 , 중급 SQL 문제풀이는  4일 을 소요하여 강의를 완강합니다. 하루에 약 30분 정도 투자해서 공부를 하고 계시구요. 데이터리안의 모든 코스의 강의는 평균 10분 내외로 촬영하고 있으니까  하루에 약 3개 강의  정도 들으시는 것으로 예상해볼 수 있겠네요 😊 그런데 수강평을 보면 아시겠지만, 기초 SQL의 경우 런타임이 약 1시간 30분 정도라서 하루만에 몰아서 끝내시는 분들도 많아요. 이 강의를 활용해서 학생들을 가르쳐본 경험으로는 약 3시간, 길면 5시간 정도 집중하는 시간을 내면 기초 SQL 강의를 완강하실 수 있습니다. 본인 스타일에 맞게 하루에 몰아서 빡공! 또는 매일 30분씩 나누어서 공부하면 좋겠죠. 👉  데이터리안 수강평 모아보기 2. 데이터 분석가 트랙   현업에서  데이터 분석가 로 일하고 계시는 분 또는 데이터 분석가로 입사하기 위해  코딩 테스트 를 준비하는 분들을 위한 구성입니다. SQL로 데이터를 자유자재로 핸들링하고 분석에 활용할 분들을 위해 고급 SQL 강의가 들어가있고, 분석을 위한 추가 스킬로 파이썬이라는 프로그래밍 언어를 선택하신 분들을 위한 트랙입니다. 강의의 순수 플레이 타임은 SQL 실무 활용 트랙에 더해, 고급 SQL 5시간 16분 + 파이썬 입문 8시간 55분 + 판다스 6시간 30분으로 총 20시간 41분이 추가됩니다. 여기에 고급 SQL 문제풀이까지 학습하신다면 2시간 12분이 더해져 총 플레이타임은 22시간 53분이 됩니다. 실제로 수강하는데 걸리는 기간을 보면 고급 SQL은  16일 , 고급 SQL 문제풀이는  4일 , 파이썬 입문편은  4일 , 판다스는  22일 이 걸리고, 하루에 평균적으로 20분~30분 정도 투자하고 있어요.  파이썬 입문 강의는 특이하게 하루 평균 시청 시간이 2시간 30분이나 되는데요. 강의 러닝타임에 비해서 완강까지 걸리는 기간도 매우 짧구요.  아직 런칭한지 얼마 안 된 강의라서 그런 것인지... 정말 파이썬 입문 강의에는 🔥열혈 수강생🔥들만 있는 것인지 데이터 추이를 지켜보고 있습니다.  데잇걸즈 4기, 5기 분들도 데이터리안의 SQL 강의를 수강하셨었는데요. 적절한 코칭이 함께 들어갔을 때 또는 스스로 꾸준히 학습할 때 기초 SQL부터 고급 SQL까지 학습하는데 걸리는 시간은  약 4주에서 8주 정도 된다고 생각하시면 좋을 것 같아요. 개인차가 있지만 아무리 늦어도 8주안에 SQL 코딩테스트를 통과할 수 있는 정도의 실력은 길러진다고 보고 있습니다. 실제로 네이버, 리디 등의 데이터 분석가 코딩테스트에 합격하신 분들이 연락을 많이 주시구요. 데잇걸즈 같은 1년에 한 번 있는 프로그램이 아니더라도 함께 모여서 으쌰으쌰하며 공부할 수 있는 환경이 만들어지면 좋을 것 같다는 취지로 4주에서 8주짜리  SQL 캠프 도 기획하고 있으니까 기대 많이 해주세요. 👉  데잇걸즈 4기 수강생 분들의 기술 블로그 보러가기 &quot;SQL? 누구냐 너!!&quot; 3. 데이터 사이언티스트 트랙   이 트랙은 파이썬이라는 프로그래밍 언어와 머신러닝🤖을 공부하고 싶은 분들을 위해 구성했습니다. 강의 런타임과 실질 수강 기간은 아래와 같아요. 데이터 분석을 위한 파이썬: 러닝타임 8시간 55분 / 4일 / 매일 2시간 33분 학습 데이터 분석을 위한 판다스: 러닝타임 6시간 30분 / 22일 / 매일 21분 학습 추천 시스템 입문편: 러닝타임 7시간 49분 / 12일 / 매일 41분 학습 총 러닝타임은 23시간 14분, 학습 기간은 38일이네요. 앞에서도 말했지만 파이썬 입문 강의의 일일 학습 시간, 학습 완료까지 걸리는 기간 데이터가 참 특이합니다 🤔 &#39;데이터 분석을 위한 판다스&#39; 강의의 런타임이 6시간 30분으로 훨씬 짧은데도 실질 수강 기간은 훨씬 길죠. 판다스 강의에 분석 프로젝트가 많아서일까요. 데이터를 눈여겨 봐야겠습니다. 👉  데이터 분석을 위한 파이썬: 입문부터 꿀팁까지 보러가기 4. 수강 완료 기간 데이터 데이터리안 강의들의 런타임, 실질 수강 기간, 1일 평균 시청 기간 데이터를 정리해보면 아래와 같습니다. 이 데이터는 고정된 데이터가 아니라 여러분들의 강의 수강 패턴대로 계속 업데이트 될거예요. 강의 완료기간은 더 짧아지도록, 1일 평균 시청 시간은 더 길어지도록, 그리고 완강하는 사람들의 비율이 더 늘어나도록 저희도 노력하겠습니다. 👉  데이터리안 전체 강의 보러가기 데이터리안 서비스 페이지 바로가기 (2021년 11월 5일 기준) 강의명 러닝타임 완료기간 1일 평균 시청 시간 로드맵 [백문이불여일타] 데이터 분석을 위한 기초 SQL 1시간 36분 3일 32분 SQL 실무 활용, 데이터 분석가 [백문이불여일타] 데이터 분석을 위한 중급 SQL 4시간 19분 9일 29분 SQL 실무 활용, 데이터 분석가 [백문이불여일타] 데이터 분석을 위한 중급 SQL 문제풀이 2시간 12분 4일 33분 SQL 실무 활용, 데이터 분석가 [백문이불여일타] 데이터 분석을 위한 고급 SQL 5시간 16분 16일 20분 데이터 분석가 [백문이불여일타] 데이터 분석을 위한 고급 SQL 문제풀이 2시간 55분 4일 44분 데이터 분석가 데이터 분석을 위한 파이썬: 입문부터 꿀팁까지 8시간 55분 4일 2시간 33분 데이터 분석가, 데이터 사이언티스트 데이터 분석을 위한 판다스: 기초부터 블로그 GA 데이터 분석까지 7시간 47분 22일 21분 데이터 분석가, 데이터 사이언티스트 [개념부터 실습까지] 추천 시스템 입문편 7시간 47분 12일 41분 데이터 사이언티스트  또 만나요! 👋 드디어  &lt;데이터 분석을 위한 파이썬: 입문부터 꿀팁까지&gt;  강의가 완성되어 인프런에 올라갔다! 파이썬으로 프로그래밍 언어에 입문하는 분들이 많다는 것을 알기 때문에, 입문자들이 처음에 가장 어려워하는 설치, 패키지 관리 등의 단계를 과감하게 덜어냈다. 구글의 Colaboratory 라는 인터렉티브 파이썬 코딩 환경을 이용해  강의를 듣자마자 코드를 쓸 수 있도록  했다. 준비물은 10분 내외의 동영상을 집중해서 볼 수 있는 환경과 노트북이면 충분하다. 2020년부터 파이썬 입문 강의를 제작해달라는 요청을 꾸준히 받았다. 그럴 때마다 다른 분들의 책이나 강의를 추천해야 했는데 이제 &#39;우리 강의 보세요!&#39; 할 수 있어서 기쁘다.  2020년에도 파이썬 기초 강의 제작을 한 번 시도했었는데 이게 워낙 범용 언어이다보니 어디서부터 어디까지 가르쳐야하지? 하는 물음표에 갇혀 기획자들과 함께 뱅뱅 돌다가 한 번 포기했었다. 지금 생각해보면 아마 특정 용도로 파이썬 프로그래밍을 배우고 싶은 많은 분들이 느꼈을 어려움을 우리도 함께 경험한 것 같다. 데이터 분석을 하는데 파이썬이라는 언어가 많이 쓰인다고 해서 배우기 시작했는데 무작정 기초 수업을 듣다보니 &#39;이게 데이터 분석하고 무슨 상관인가&#39; 싶은 내용들이 나오기 시작하고, 흥미가 떨어지고, 흐지부지되고. 나중에 돌아보면 뭔가 배우긴 배웠는데 사용할 줄 안다고 어디에 말하기에는 어려운 딱 그 정도 지식만 있는 상태에서 공부를 멈췄을지도 모르겠다. 올해에는 그때를 반면교사삼아 &#39;데이터 분석&#39;을 하기 위해 파이썬 프로그래밍을 배우려고 하는 사람들에게 꼭 필요한 내용들이 뭘까 고민을 많이 하고 제작을 시작했다. 데이터 분석가로 일하면서 가장 많이 사용하게 되는 파이썬 기능을 위주로 가르친다. 함수, 클래스와 같은 어려울 수 있는 개념들도 입문자가 쉽게 이해할 수 있도록 최대한 풀어서 설명했다. 프로그래밍에 완전 입문자이거나, 비전공자이거나, 이전에 파이썬을 배워봤는데 반복문, 제어문, 함수 쯤에서 벽을 느끼고 포기했던 사람들에게 부담없는 난이도라고 자부한다. 많이 사랑해주셨으면 좋겠다. 강의의 마지막 섹션에서는 파이썬 기초를 닦은 사람들이 앞으로 어떤 공부를 하게 될지 상상할 수 있도록 테이블 데이터를 다루는 판다스(Pandas)라는 라이브러리와, 머신러닝 라이브러리 사이킷런(Scikit-learn) 튜토리얼을 담았다. 각각 20분~30분 정도의 튜토리얼을 통해 데이터를 가지고 간단한 시각화를 해볼수도 있고, 손으로 쓴 숫자 데이터를 분류하는 머신러닝 모델도 만들어볼 수 있다. 오타없이 코드를 친다는 전제하에(ㅎㅎ) 별도의 환경설정 전혀 없이 모든 코드를 직접 실행하고 결과를 볼 수 있다.   매번 강의를 만들 때 강조하는 부분이 &#39;연습문제&#39;다. 바로바로 풀어보는 적절한 난이도의 연습문제 만큼 학습에 효과적이고, 학습자의 집중력을 올릴 수 있는 방법은 또 없는 것 같다. 강의 기획자들이 한땀한땀 열심히 수업 예시와 연습문제를 설계했으니 아마 풀어보는 사람들도 재미있게 느낄 것 같다. 강의 호응이 좋으면 차차 연습문제도 업데이트 해 나가려고 한다. 혹시 아직 데이터리안 강의를 만나보지 않으셨다면!  데이터 분석을 위한 파이썬: 입문부터 꿀팁까지  데이터 분석을 위한 파이썬: 기초부터 블로그 GA 데이터 분석까지  [백문이불여일타] 데이터 분석을 위한 기초 SQL 데이터리안이 무슨 일을 하는지, 어떤 사람들이 모였는지 궁금하다면  데이터리안 서비스 페이지 혹시 학생인데 강의 가격이 부담스럽다면  datarian2020@gmail.com 으로 연락주세요. 파이썬 기초 강의에 한해 50% 할인 쿠폰을 이메일로 보내드릴게요. (~11월 13일 토요일까지) 